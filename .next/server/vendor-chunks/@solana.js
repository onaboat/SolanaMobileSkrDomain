"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@solana";
exports.ids = ["vendor-chunks/@solana"];
exports.modules = {

/***/ "(rsc)/./node_modules/@solana/buffer-layout/lib/Layout.js":
/*!**********************************************************!*\
  !*** ./node_modules/@solana/buffer-layout/lib/Layout.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* The MIT License (MIT)\n *\n * Copyright 2015-2018 Peter A. Bigot\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */ /**\n * Support for translating between Uint8Array instances and JavaScript\n * native types.\n *\n * {@link module:Layout~Layout|Layout} is the basis of a class\n * hierarchy that associates property names with sequences of encoded\n * bytes.\n *\n * Layouts are supported for these scalar (numeric) types:\n * * {@link module:Layout~UInt|Unsigned integers in little-endian\n *   format} with {@link module:Layout.u8|8-bit}, {@link\n *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},\n *   {@link module:Layout.u32|32-bit}, {@link\n *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}\n *   representation ranges;\n * * {@link module:Layout~UIntBE|Unsigned integers in big-endian\n *   format} with {@link module:Layout.u16be|16-bit}, {@link\n *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},\n *   {@link module:Layout.u40be|40-bit}, and {@link\n *   module:Layout.u48be|48-bit} representation ranges;\n * * {@link module:Layout~Int|Signed integers in little-endian\n *   format} with {@link module:Layout.s8|8-bit}, {@link\n *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},\n *   {@link module:Layout.s32|32-bit}, {@link\n *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}\n *   representation ranges;\n * * {@link module:Layout~IntBE|Signed integers in big-endian format}\n *   with {@link module:Layout.s16be|16-bit}, {@link\n *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},\n *   {@link module:Layout.s40be|40-bit}, and {@link\n *   module:Layout.s48be|48-bit} representation ranges;\n * * 64-bit integral values that decode to an exact (if magnitude is\n *   less than 2^53) or nearby integral Number in {@link\n *   module:Layout.nu64|unsigned little-endian}, {@link\n *   module:Layout.nu64be|unsigned big-endian}, {@link\n *   module:Layout.ns64|signed little-endian}, and {@link\n *   module:Layout.ns64be|unsigned big-endian} encodings;\n * * 32-bit floating point values with {@link\n *   module:Layout.f32|little-endian} and {@link\n *   module:Layout.f32be|big-endian} representations;\n * * 64-bit floating point values with {@link\n *   module:Layout.f64|little-endian} and {@link\n *   module:Layout.f64be|big-endian} representations;\n * * {@link module:Layout.const|Constants} that take no space in the\n *   encoded expression.\n *\n * and for these aggregate types:\n * * {@link module:Layout.seq|Sequence}s of instances of a {@link\n *   module:Layout~Layout|Layout}, with JavaScript representation as\n *   an Array and constant or data-dependent {@link\n *   module:Layout~Sequence#count|length};\n * * {@link module:Layout.struct|Structure}s that aggregate a\n *   heterogeneous sequence of {@link module:Layout~Layout|Layout}\n *   instances, with JavaScript representation as an Object;\n * * {@link module:Layout.union|Union}s that support multiple {@link\n *   module:Layout~VariantLayout|variant layouts} over a fixed\n *   (padded) or variable (not padded) span of bytes, using an\n *   unsigned integer at the start of the data or a separate {@link\n *   module:Layout.unionLayoutDiscriminator|layout element} to\n *   determine which layout to use when interpreting the buffer\n *   contents;\n * * {@link module:Layout.bits|BitStructure}s that contain a sequence\n *   of individual {@link\n *   module:Layout~BitStructure#addField|BitField}s packed into an 8,\n *   16, 24, or 32-bit unsigned integer starting at the least- or\n *   most-significant bit;\n * * {@link module:Layout.cstr|C strings} of varying length;\n * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link\n *   module:Layout~Blob#length|length} raw data.\n *\n * All {@link module:Layout~Layout|Layout} instances are immutable\n * after construction, to prevent internal state from becoming\n * inconsistent.\n *\n * @local Layout\n * @local ExternalLayout\n * @local GreedyCount\n * @local OffsetLayout\n * @local UInt\n * @local UIntBE\n * @local Int\n * @local IntBE\n * @local NearUInt64\n * @local NearUInt64BE\n * @local NearInt64\n * @local NearInt64BE\n * @local Float\n * @local FloatBE\n * @local Double\n * @local DoubleBE\n * @local Sequence\n * @local Structure\n * @local UnionDiscriminator\n * @local UnionLayoutDiscriminator\n * @local Union\n * @local VariantLayout\n * @local BitStructure\n * @local BitField\n * @local Boolean\n * @local Blob\n * @local CString\n * @local Constant\n * @local bindConstructorLayout\n * @module Layout\n * @license MIT\n * @author Peter A. Bigot\n * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.s16 = exports.s8 = exports.nu64be = exports.u48be = exports.u40be = exports.u32be = exports.u24be = exports.u16be = exports.nu64 = exports.u48 = exports.u40 = exports.u32 = exports.u24 = exports.u16 = exports.u8 = exports.offset = exports.greedy = exports.Constant = exports.UTF8 = exports.CString = exports.Blob = exports.Boolean = exports.BitField = exports.BitStructure = exports.VariantLayout = exports.Union = exports.UnionLayoutDiscriminator = exports.UnionDiscriminator = exports.Structure = exports.Sequence = exports.DoubleBE = exports.Double = exports.FloatBE = exports.Float = exports.NearInt64BE = exports.NearInt64 = exports.NearUInt64BE = exports.NearUInt64 = exports.IntBE = exports.Int = exports.UIntBE = exports.UInt = exports.OffsetLayout = exports.GreedyCount = exports.ExternalLayout = exports.bindConstructorLayout = exports.nameWithProperty = exports.Layout = exports.uint8ArrayToBuffer = exports.checkUint8Array = void 0;\nexports.constant = exports.utf8 = exports.cstr = exports.blob = exports.unionLayoutDiscriminator = exports.union = exports.seq = exports.bits = exports.struct = exports.f64be = exports.f64 = exports.f32be = exports.f32 = exports.ns64be = exports.s48be = exports.s40be = exports.s32be = exports.s24be = exports.s16be = exports.ns64 = exports.s48 = exports.s40 = exports.s32 = exports.s24 = void 0;\nconst buffer_1 = __webpack_require__(/*! buffer */ \"buffer\");\n/* Check if a value is a Uint8Array.\n *\n * @ignore */ function checkUint8Array(b) {\n    if (!(b instanceof Uint8Array)) {\n        throw new TypeError(\"b must be a Uint8Array\");\n    }\n}\nexports.checkUint8Array = checkUint8Array;\n/* Create a Buffer instance from a Uint8Array.\n *\n * @ignore */ function uint8ArrayToBuffer(b) {\n    checkUint8Array(b);\n    return buffer_1.Buffer.from(b.buffer, b.byteOffset, b.length);\n}\nexports.uint8ArrayToBuffer = uint8ArrayToBuffer;\n/**\n * Base class for layout objects.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support the {@link\n * Layout#encode|encode} or {@link Layout#decode|decode} functions.\n *\n * @param {Number} span - Initializer for {@link Layout#span|span}.  The\n * parameter must be an integer; a negative value signifies that the\n * span is {@link Layout#getSpan|value-specific}.\n *\n * @param {string} [property] - Initializer for {@link\n * Layout#property|property}.\n *\n * @abstract\n */ class Layout {\n    constructor(span, property){\n        if (!Number.isInteger(span)) {\n            throw new TypeError(\"span must be an integer\");\n        }\n        /** The span of the layout in bytes.\n         *\n         * Positive values are generally expected.\n         *\n         * Zero will only appear in {@link Constant}s and in {@link\n         * Sequence}s where the {@link Sequence#count|count} is zero.\n         *\n         * A negative value indicates that the span is value-specific, and\n         * must be obtained using {@link Layout#getSpan|getSpan}. */ this.span = span;\n        /** The property name used when this layout is represented in an\n         * Object.\n         *\n         * Used only for layouts that {@link Layout#decode|decode} to Object\n         * instances.  If left undefined the span of the unnamed layout will\n         * be treated as padding: it will not be mutated by {@link\n         * Layout#encode|encode} nor represented as a property in the\n         * decoded Object. */ this.property = property;\n    }\n    /** Function to create an Object into which decoded properties will\n     * be written.\n     *\n     * Used only for layouts that {@link Layout#decode|decode} to Object\n     * instances, which means:\n     * * {@link Structure}\n     * * {@link Union}\n     * * {@link VariantLayout}\n     * * {@link BitStructure}\n     *\n     * If left undefined the JavaScript representation of these layouts\n     * will be Object instances.\n     *\n     * See {@link bindConstructorLayout}.\n     */ makeDestinationObject() {\n        return {};\n    }\n    /**\n     * Calculate the span of a specific instance of a layout.\n     *\n     * @param {Uint8Array} b - the buffer that contains an encoded instance.\n     *\n     * @param {Number} [offset] - the offset at which the encoded instance\n     * starts.  If absent a zero offset is inferred.\n     *\n     * @return {Number} - the number of bytes covered by the layout\n     * instance.  If this method is not overridden in a subclass the\n     * definition-time constant {@link Layout#span|span} will be\n     * returned.\n     *\n     * @throws {RangeError} - if the length of the value cannot be\n     * determined.\n     */ getSpan(b, offset) {\n        if (0 > this.span) {\n            throw new RangeError(\"indeterminate span\");\n        }\n        return this.span;\n    }\n    /**\n     * Replicate the layout using a new property.\n     *\n     * This function must be used to get a structurally-equivalent layout\n     * with a different name since all {@link Layout} instances are\n     * immutable.\n     *\n     * **NOTE** This is a shallow copy.  All fields except {@link\n     * Layout#property|property} are strictly equal to the origin layout.\n     *\n     * @param {String} property - the value for {@link\n     * Layout#property|property} in the replica.\n     *\n     * @returns {Layout} - the copy with {@link Layout#property|property}\n     * set to `property`.\n     */ replicate(property) {\n        const rv = Object.create(this.constructor.prototype);\n        Object.assign(rv, this);\n        rv.property = property;\n        return rv;\n    }\n    /**\n     * Create an object from layout properties and an array of values.\n     *\n     * **NOTE** This function returns `undefined` if invoked on a layout\n     * that does not return its value as an Object.  Objects are\n     * returned for things that are a {@link Structure}, which includes\n     * {@link VariantLayout|variant layouts} if they are structures, and\n     * excludes {@link Union}s.  If you want this feature for a union\n     * you must use {@link Union.getVariant|getVariant} to select the\n     * desired layout.\n     *\n     * @param {Array} values - an array of values that correspond to the\n     * default order for properties.  As with {@link Layout#decode|decode}\n     * layout elements that have no property name are skipped when\n     * iterating over the array values.  Only the top-level properties are\n     * assigned; arguments are not assigned to properties of contained\n     * layouts.  Any unused values are ignored.\n     *\n     * @return {(Object|undefined)}\n     */ fromArray(values) {\n        return undefined;\n    }\n}\nexports.Layout = Layout;\n/* Provide text that carries a name (such as for a function that will\n * be throwing an error) annotated with the property of a given layout\n * (such as one for which the value was unacceptable).\n *\n * @ignore */ function nameWithProperty(name, lo) {\n    if (lo.property) {\n        return name + \"[\" + lo.property + \"]\";\n    }\n    return name;\n}\nexports.nameWithProperty = nameWithProperty;\n/**\n * Augment a class so that instances can be encoded/decoded using a\n * given layout.\n *\n * Calling this function couples `Class` with `layout` in several ways:\n *\n * * `Class.layout_` becomes a static member property equal to `layout`;\n * * `layout.boundConstructor_` becomes a static member property equal\n *    to `Class`;\n * * The {@link Layout#makeDestinationObject|makeDestinationObject()}\n *   property of `layout` is set to a function that returns a `new\n *   Class()`;\n * * `Class.decode(b, offset)` becomes a static member function that\n *   delegates to {@link Layout#decode|layout.decode}.  The\n *   synthesized function may be captured and extended.\n * * `Class.prototype.encode(b, offset)` provides an instance member\n *   function that delegates to {@link Layout#encode|layout.encode}\n *   with `src` set to `this`.  The synthesized function may be\n *   captured and extended, but when the extension is invoked `this`\n *   must be explicitly bound to the instance.\n *\n * @param {class} Class - a JavaScript class with a nullary\n * constructor.\n *\n * @param {Layout} layout - the {@link Layout} instance used to encode\n * instances of `Class`.\n */ // `Class` must be a constructor Function, but the assignment of a `layout_` property to it makes it difficult to type\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction bindConstructorLayout(Class, layout) {\n    if (\"function\" !== typeof Class) {\n        throw new TypeError(\"Class must be constructor\");\n    }\n    if (Object.prototype.hasOwnProperty.call(Class, \"layout_\")) {\n        throw new Error(\"Class is already bound to a layout\");\n    }\n    if (!(layout && layout instanceof Layout)) {\n        throw new TypeError(\"layout must be a Layout\");\n    }\n    if (Object.prototype.hasOwnProperty.call(layout, \"boundConstructor_\")) {\n        throw new Error(\"layout is already bound to a constructor\");\n    }\n    Class.layout_ = layout;\n    layout.boundConstructor_ = Class;\n    layout.makeDestinationObject = ()=>new Class();\n    Object.defineProperty(Class.prototype, \"encode\", {\n        value (b, offset) {\n            return layout.encode(this, b, offset);\n        },\n        writable: true\n    });\n    Object.defineProperty(Class, \"decode\", {\n        value (b, offset) {\n            return layout.decode(b, offset);\n        },\n        writable: true\n    });\n}\nexports.bindConstructorLayout = bindConstructorLayout;\n/**\n * An object that behaves like a layout but does not consume space\n * within its containing layout.\n *\n * This is primarily used to obtain metadata about a member, such as a\n * {@link OffsetLayout} that can provide data about a {@link\n * Layout#getSpan|value-specific span}.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support {@link\n * ExternalLayout#isCount|isCount} or other {@link Layout} functions.\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @abstract\n * @augments {Layout}\n */ class ExternalLayout extends Layout {\n    /**\n     * Return `true` iff the external layout decodes to an unsigned\n     * integer layout.\n     *\n     * In that case it can be used as the source of {@link\n     * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},\n     * or as {@link UnionLayoutDiscriminator#layout|external union\n     * discriminators}.\n     *\n     * @abstract\n     */ isCount() {\n        throw new Error(\"ExternalLayout is abstract\");\n    }\n}\nexports.ExternalLayout = ExternalLayout;\n/**\n * An {@link ExternalLayout} that determines its {@link\n * Layout#decode|value} based on offset into and length of the buffer\n * on which it is invoked.\n *\n * *Factory*: {@link module:Layout.greedy|greedy}\n *\n * @param {Number} [elementSpan] - initializer for {@link\n * GreedyCount#elementSpan|elementSpan}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {ExternalLayout}\n */ class GreedyCount extends ExternalLayout {\n    constructor(elementSpan = 1, property){\n        if (!Number.isInteger(elementSpan) || 0 >= elementSpan) {\n            throw new TypeError(\"elementSpan must be a (positive) integer\");\n        }\n        super(-1, property);\n        /** The layout for individual elements of the sequence.  The value\n         * must be a positive integer.  If not provided, the value will be\n         * 1. */ this.elementSpan = elementSpan;\n    }\n    /** @override */ isCount() {\n        return true;\n    }\n    /** @override */ decode(b, offset = 0) {\n        checkUint8Array(b);\n        const rem = b.length - offset;\n        return Math.floor(rem / this.elementSpan);\n    }\n    /** @override */ encode(src, b, offset) {\n        return 0;\n    }\n}\nexports.GreedyCount = GreedyCount;\n/**\n * An {@link ExternalLayout} that supports accessing a {@link Layout}\n * at a fixed offset from the start of another Layout.  The offset may\n * be before, within, or after the base layout.\n *\n * *Factory*: {@link module:Layout.offset|offset}\n *\n * @param {Layout} layout - initializer for {@link\n * OffsetLayout#layout|layout}, modulo `property`.\n *\n * @param {Number} [offset] - Initializes {@link\n * OffsetLayout#offset|offset}.  Defaults to zero.\n *\n * @param {string} [property] - Optional new property name for a\n * {@link Layout#replicate| replica} of `layout` to be used as {@link\n * OffsetLayout#layout|layout}.  If not provided the `layout` is used\n * unchanged.\n *\n * @augments {Layout}\n */ class OffsetLayout extends ExternalLayout {\n    constructor(layout, offset = 0, property){\n        if (!(layout instanceof Layout)) {\n            throw new TypeError(\"layout must be a Layout\");\n        }\n        if (!Number.isInteger(offset)) {\n            throw new TypeError(\"offset must be integer or undefined\");\n        }\n        super(layout.span, property || layout.property);\n        /** The subordinated layout. */ this.layout = layout;\n        /** The location of {@link OffsetLayout#layout} relative to the\n         * start of another layout.\n         *\n         * The value may be positive or negative, but an error will thrown\n         * if at the point of use it goes outside the span of the Uint8Array\n         * being accessed.  */ this.offset = offset;\n    }\n    /** @override */ isCount() {\n        return this.layout instanceof UInt || this.layout instanceof UIntBE;\n    }\n    /** @override */ decode(b, offset = 0) {\n        return this.layout.decode(b, offset + this.offset);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        return this.layout.encode(src, b, offset + this.offset);\n    }\n}\nexports.OffsetLayout = OffsetLayout;\n/**\n * Represent an unsigned integer in little-endian format.\n *\n * *Factory*: {@link module:Layout.u8|u8}, {@link\n *  module:Layout.u16|u16}, {@link module:Layout.u24|u24}, {@link\n *  module:Layout.u32|u32}, {@link module:Layout.u40|u40}, {@link\n *  module:Layout.u48|u48}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class UInt extends Layout {\n    constructor(span, property){\n        super(span, property);\n        if (6 < this.span) {\n            throw new RangeError(\"span must not exceed 6 bytes\");\n        }\n    }\n    /** @override */ decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readUIntLE(offset, this.span);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeUIntLE(src, offset, this.span);\n        return this.span;\n    }\n}\nexports.UInt = UInt;\n/**\n * Represent an unsigned integer in big-endian format.\n *\n * *Factory*: {@link module:Layout.u8be|u8be}, {@link\n * module:Layout.u16be|u16be}, {@link module:Layout.u24be|u24be},\n * {@link module:Layout.u32be|u32be}, {@link\n * module:Layout.u40be|u40be}, {@link module:Layout.u48be|u48be}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class UIntBE extends Layout {\n    constructor(span, property){\n        super(span, property);\n        if (6 < this.span) {\n            throw new RangeError(\"span must not exceed 6 bytes\");\n        }\n    }\n    /** @override */ decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readUIntBE(offset, this.span);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeUIntBE(src, offset, this.span);\n        return this.span;\n    }\n}\nexports.UIntBE = UIntBE;\n/**\n * Represent a signed integer in little-endian format.\n *\n * *Factory*: {@link module:Layout.s8|s8}, {@link\n *  module:Layout.s16|s16}, {@link module:Layout.s24|s24}, {@link\n *  module:Layout.s32|s32}, {@link module:Layout.s40|s40}, {@link\n *  module:Layout.s48|s48}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Int extends Layout {\n    constructor(span, property){\n        super(span, property);\n        if (6 < this.span) {\n            throw new RangeError(\"span must not exceed 6 bytes\");\n        }\n    }\n    /** @override */ decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readIntLE(offset, this.span);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeIntLE(src, offset, this.span);\n        return this.span;\n    }\n}\nexports.Int = Int;\n/**\n * Represent a signed integer in big-endian format.\n *\n * *Factory*: {@link module:Layout.s8be|s8be}, {@link\n * module:Layout.s16be|s16be}, {@link module:Layout.s24be|s24be},\n * {@link module:Layout.s32be|s32be}, {@link\n * module:Layout.s40be|s40be}, {@link module:Layout.s48be|s48be}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class IntBE extends Layout {\n    constructor(span, property){\n        super(span, property);\n        if (6 < this.span) {\n            throw new RangeError(\"span must not exceed 6 bytes\");\n        }\n    }\n    /** @override */ decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readIntBE(offset, this.span);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeIntBE(src, offset, this.span);\n        return this.span;\n    }\n}\nexports.IntBE = IntBE;\nconst V2E32 = Math.pow(2, 32);\n/* True modulus high and low 32-bit words, where low word is always\n * non-negative. */ function divmodInt64(src) {\n    const hi32 = Math.floor(src / V2E32);\n    const lo32 = src - hi32 * V2E32;\n    return {\n        hi32,\n        lo32\n    };\n}\n/* Reconstruct Number from quotient and non-negative remainder */ function roundedInt64(hi32, lo32) {\n    return hi32 * V2E32 + lo32;\n}\n/**\n * Represent an unsigned 64-bit integer in little-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.nu64|nu64}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */ class NearUInt64 extends Layout {\n    constructor(property){\n        super(8, property);\n    }\n    /** @override */ decode(b, offset = 0) {\n        const buffer = uint8ArrayToBuffer(b);\n        const lo32 = buffer.readUInt32LE(offset);\n        const hi32 = buffer.readUInt32LE(offset + 4);\n        return roundedInt64(hi32, lo32);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        const split = divmodInt64(src);\n        const buffer = uint8ArrayToBuffer(b);\n        buffer.writeUInt32LE(split.lo32, offset);\n        buffer.writeUInt32LE(split.hi32, offset + 4);\n        return 8;\n    }\n}\nexports.NearUInt64 = NearUInt64;\n/**\n * Represent an unsigned 64-bit integer in big-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.nu64be|nu64be}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */ class NearUInt64BE extends Layout {\n    constructor(property){\n        super(8, property);\n    }\n    /** @override */ decode(b, offset = 0) {\n        const buffer = uint8ArrayToBuffer(b);\n        const hi32 = buffer.readUInt32BE(offset);\n        const lo32 = buffer.readUInt32BE(offset + 4);\n        return roundedInt64(hi32, lo32);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        const split = divmodInt64(src);\n        const buffer = uint8ArrayToBuffer(b);\n        buffer.writeUInt32BE(split.hi32, offset);\n        buffer.writeUInt32BE(split.lo32, offset + 4);\n        return 8;\n    }\n}\nexports.NearUInt64BE = NearUInt64BE;\n/**\n * Represent a signed 64-bit integer in little-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.ns64|ns64}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */ class NearInt64 extends Layout {\n    constructor(property){\n        super(8, property);\n    }\n    /** @override */ decode(b, offset = 0) {\n        const buffer = uint8ArrayToBuffer(b);\n        const lo32 = buffer.readUInt32LE(offset);\n        const hi32 = buffer.readInt32LE(offset + 4);\n        return roundedInt64(hi32, lo32);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        const split = divmodInt64(src);\n        const buffer = uint8ArrayToBuffer(b);\n        buffer.writeUInt32LE(split.lo32, offset);\n        buffer.writeInt32LE(split.hi32, offset + 4);\n        return 8;\n    }\n}\nexports.NearInt64 = NearInt64;\n/**\n * Represent a signed 64-bit integer in big-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.ns64be|ns64be}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */ class NearInt64BE extends Layout {\n    constructor(property){\n        super(8, property);\n    }\n    /** @override */ decode(b, offset = 0) {\n        const buffer = uint8ArrayToBuffer(b);\n        const hi32 = buffer.readInt32BE(offset);\n        const lo32 = buffer.readUInt32BE(offset + 4);\n        return roundedInt64(hi32, lo32);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        const split = divmodInt64(src);\n        const buffer = uint8ArrayToBuffer(b);\n        buffer.writeInt32BE(split.hi32, offset);\n        buffer.writeUInt32BE(split.lo32, offset + 4);\n        return 8;\n    }\n}\nexports.NearInt64BE = NearInt64BE;\n/**\n * Represent a 32-bit floating point number in little-endian format.\n *\n * *Factory*: {@link module:Layout.f32|f32}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Float extends Layout {\n    constructor(property){\n        super(4, property);\n    }\n    /** @override */ decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readFloatLE(offset);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeFloatLE(src, offset);\n        return 4;\n    }\n}\nexports.Float = Float;\n/**\n * Represent a 32-bit floating point number in big-endian format.\n *\n * *Factory*: {@link module:Layout.f32be|f32be}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class FloatBE extends Layout {\n    constructor(property){\n        super(4, property);\n    }\n    /** @override */ decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readFloatBE(offset);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeFloatBE(src, offset);\n        return 4;\n    }\n}\nexports.FloatBE = FloatBE;\n/**\n * Represent a 64-bit floating point number in little-endian format.\n *\n * *Factory*: {@link module:Layout.f64|f64}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Double extends Layout {\n    constructor(property){\n        super(8, property);\n    }\n    /** @override */ decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readDoubleLE(offset);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeDoubleLE(src, offset);\n        return 8;\n    }\n}\nexports.Double = Double;\n/**\n * Represent a 64-bit floating point number in big-endian format.\n *\n * *Factory*: {@link module:Layout.f64be|f64be}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class DoubleBE extends Layout {\n    constructor(property){\n        super(8, property);\n    }\n    /** @override */ decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readDoubleBE(offset);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeDoubleBE(src, offset);\n        return 8;\n    }\n}\nexports.DoubleBE = DoubleBE;\n/**\n * Represent a contiguous sequence of a specific layout as an Array.\n *\n * *Factory*: {@link module:Layout.seq|seq}\n *\n * @param {Layout} elementLayout - initializer for {@link\n * Sequence#elementLayout|elementLayout}.\n *\n * @param {(Number|ExternalLayout)} count - initializer for {@link\n * Sequence#count|count}.  The parameter must be either a positive\n * integer or an instance of {@link ExternalLayout}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Sequence extends Layout {\n    constructor(elementLayout, count, property){\n        if (!(elementLayout instanceof Layout)) {\n            throw new TypeError(\"elementLayout must be a Layout\");\n        }\n        if (!(count instanceof ExternalLayout && count.isCount() || Number.isInteger(count) && 0 <= count)) {\n            throw new TypeError(\"count must be non-negative integer \" + \"or an unsigned integer ExternalLayout\");\n        }\n        let span = -1;\n        if (!(count instanceof ExternalLayout) && 0 < elementLayout.span) {\n            span = count * elementLayout.span;\n        }\n        super(span, property);\n        /** The layout for individual elements of the sequence. */ this.elementLayout = elementLayout;\n        /** The number of elements in the sequence.\n         *\n         * This will be either a non-negative integer or an instance of\n         * {@link ExternalLayout} for which {@link\n         * ExternalLayout#isCount|isCount()} is `true`. */ this.count = count;\n    }\n    /** @override */ getSpan(b, offset = 0) {\n        if (0 <= this.span) {\n            return this.span;\n        }\n        let span = 0;\n        let count = this.count;\n        if (count instanceof ExternalLayout) {\n            count = count.decode(b, offset);\n        }\n        if (0 < this.elementLayout.span) {\n            span = count * this.elementLayout.span;\n        } else {\n            let idx = 0;\n            while(idx < count){\n                span += this.elementLayout.getSpan(b, offset + span);\n                ++idx;\n            }\n        }\n        return span;\n    }\n    /** @override */ decode(b, offset = 0) {\n        const rv = [];\n        let i = 0;\n        let count = this.count;\n        if (count instanceof ExternalLayout) {\n            count = count.decode(b, offset);\n        }\n        while(i < count){\n            rv.push(this.elementLayout.decode(b, offset));\n            offset += this.elementLayout.getSpan(b, offset);\n            i += 1;\n        }\n        return rv;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Sequence}.\n     *\n     * **NOTE** If `src` is shorter than {@link Sequence#count|count} then\n     * the unused space in the buffer is left unchanged.  If `src` is\n     * longer than {@link Sequence#count|count} the unneeded elements are\n     * ignored.\n     *\n     * **NOTE** If {@link Layout#count|count} is an instance of {@link\n     * ExternalLayout} then the length of `src` will be encoded as the\n     * count after `src` is encoded. */ encode(src, b, offset = 0) {\n        const elo = this.elementLayout;\n        const span = src.reduce((span, v)=>{\n            return span + elo.encode(v, b, offset + span);\n        }, 0);\n        if (this.count instanceof ExternalLayout) {\n            this.count.encode(src.length, b, offset);\n        }\n        return span;\n    }\n}\nexports.Sequence = Sequence;\n/**\n * Represent a contiguous sequence of arbitrary layout elements as an\n * Object.\n *\n * *Factory*: {@link module:Layout.struct|struct}\n *\n * **NOTE** The {@link Layout#span|span} of the structure is variable\n * if any layout in {@link Structure#fields|fields} has a variable\n * span.  When {@link Layout#encode|encoding} we must have a value for\n * all variable-length fields, or we wouldn't be able to figure out\n * how much space to use for storage.  We can only identify the value\n * for a field when it has a {@link Layout#property|property}.  As\n * such, although a structure may contain both unnamed fields and\n * variable-length fields, it cannot contain an unnamed\n * variable-length field.\n *\n * @param {Layout[]} fields - initializer for {@link\n * Structure#fields|fields}.  An error is raised if this contains a\n * variable-length field for which a {@link Layout#property|property}\n * is not defined.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @param {Boolean} [decodePrefixes] - initializer for {@link\n * Structure#decodePrefixes|property}.\n *\n * @throws {Error} - if `fields` contains an unnamed variable-length\n * layout.\n *\n * @augments {Layout}\n */ class Structure extends Layout {\n    constructor(fields, property, decodePrefixes){\n        if (!(Array.isArray(fields) && fields.reduce((acc, v)=>acc && v instanceof Layout, true))) {\n            throw new TypeError(\"fields must be array of Layout instances\");\n        }\n        if (\"boolean\" === typeof property && undefined === decodePrefixes) {\n            decodePrefixes = property;\n            property = undefined;\n        }\n        /* Verify absence of unnamed variable-length fields. */ for (const fd of fields){\n            if (0 > fd.span && undefined === fd.property) {\n                throw new Error(\"fields cannot contain unnamed variable-length layout\");\n            }\n        }\n        let span = -1;\n        try {\n            span = fields.reduce((span, fd)=>span + fd.getSpan(), 0);\n        } catch (e) {\n        // ignore error\n        }\n        super(span, property);\n        /** The sequence of {@link Layout} values that comprise the\n         * structure.\n         *\n         * The individual elements need not be the same type, and may be\n         * either scalar or aggregate layouts.  If a member layout leaves\n         * its {@link Layout#property|property} undefined the\n         * corresponding region of the buffer associated with the element\n         * will not be mutated.\n         *\n         * @type {Layout[]} */ this.fields = fields;\n        /** Control behavior of {@link Layout#decode|decode()} given short\n         * buffers.\n         *\n         * In some situations a structure many be extended with additional\n         * fields over time, with older installations providing only a\n         * prefix of the full structure.  If this property is `true`\n         * decoding will accept those buffers and leave subsequent fields\n         * undefined, as long as the buffer ends at a field boundary.\n         * Defaults to `false`. */ this.decodePrefixes = !!decodePrefixes;\n    }\n    /** @override */ getSpan(b, offset = 0) {\n        if (0 <= this.span) {\n            return this.span;\n        }\n        let span = 0;\n        try {\n            span = this.fields.reduce((span, fd)=>{\n                const fsp = fd.getSpan(b, offset);\n                offset += fsp;\n                return span + fsp;\n            }, 0);\n        } catch (e) {\n            throw new RangeError(\"indeterminate span\");\n        }\n        return span;\n    }\n    /** @override */ decode(b, offset = 0) {\n        checkUint8Array(b);\n        const dest = this.makeDestinationObject();\n        for (const fd of this.fields){\n            if (undefined !== fd.property) {\n                dest[fd.property] = fd.decode(b, offset);\n            }\n            offset += fd.getSpan(b, offset);\n            if (this.decodePrefixes && b.length === offset) {\n                break;\n            }\n        }\n        return dest;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Structure}.\n     *\n     * If `src` is missing a property for a member with a defined {@link\n     * Layout#property|property} the corresponding region of the buffer is\n     * left unmodified. */ encode(src, b, offset = 0) {\n        const firstOffset = offset;\n        let lastOffset = 0;\n        let lastWrote = 0;\n        for (const fd of this.fields){\n            let span = fd.span;\n            lastWrote = 0 < span ? span : 0;\n            if (undefined !== fd.property) {\n                const fv = src[fd.property];\n                if (undefined !== fv) {\n                    lastWrote = fd.encode(fv, b, offset);\n                    if (0 > span) {\n                        /* Read the as-encoded span, which is not necessarily the\n                         * same as what we wrote. */ span = fd.getSpan(b, offset);\n                    }\n                }\n            }\n            lastOffset = offset;\n            offset += span;\n        }\n        /* Use (lastOffset + lastWrote) instead of offset because the last\n         * item may have had a dynamic length and we don't want to include\n         * the padding between it and the end of the space reserved for\n         * it. */ return lastOffset + lastWrote - firstOffset;\n    }\n    /** @override */ fromArray(values) {\n        const dest = this.makeDestinationObject();\n        for (const fd of this.fields){\n            if (undefined !== fd.property && 0 < values.length) {\n                dest[fd.property] = values.shift();\n            }\n        }\n        return dest;\n    }\n    /**\n     * Get access to the layout of a given property.\n     *\n     * @param {String} property - the structure member of interest.\n     *\n     * @return {Layout} - the layout associated with `property`, or\n     * undefined if there is no such property.\n     */ layoutFor(property) {\n        if (\"string\" !== typeof property) {\n            throw new TypeError(\"property must be string\");\n        }\n        for (const fd of this.fields){\n            if (fd.property === property) {\n                return fd;\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Get the offset of a structure member.\n     *\n     * @param {String} property - the structure member of interest.\n     *\n     * @return {Number} - the offset in bytes to the start of `property`\n     * within the structure, or undefined if `property` is not a field\n     * within the structure.  If the property is a member but follows a\n     * variable-length structure member a negative number will be\n     * returned.\n     */ offsetOf(property) {\n        if (\"string\" !== typeof property) {\n            throw new TypeError(\"property must be string\");\n        }\n        let offset = 0;\n        for (const fd of this.fields){\n            if (fd.property === property) {\n                return offset;\n            }\n            if (0 > fd.span) {\n                offset = -1;\n            } else if (0 <= offset) {\n                offset += fd.span;\n            }\n        }\n        return undefined;\n    }\n}\nexports.Structure = Structure;\n/**\n * An object that can provide a {@link\n * Union#discriminator|discriminator} API for {@link Union}.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support the {@link\n * UnionDiscriminator#encode|encode} or {@link\n * UnionDiscriminator#decode|decode} functions.\n *\n * @param {string} [property] - Default for {@link\n * UnionDiscriminator#property|property}.\n *\n * @abstract\n */ class UnionDiscriminator {\n    constructor(property){\n        /** The {@link Layout#property|property} to be used when the\n         * discriminator is referenced in isolation (generally when {@link\n         * Union#decode|Union decode} cannot delegate to a specific\n         * variant). */ this.property = property;\n    }\n    /** Analog to {@link Layout#decode|Layout decode} for union discriminators.\n     *\n     * The implementation of this method need not reference the buffer if\n     * variant information is available through other means. */ decode(b, offset) {\n        throw new Error(\"UnionDiscriminator is abstract\");\n    }\n    /** Analog to {@link Layout#decode|Layout encode} for union discriminators.\n     *\n     * The implementation of this method need not store the value if\n     * variant information is maintained through other means. */ encode(src, b, offset) {\n        throw new Error(\"UnionDiscriminator is abstract\");\n    }\n}\nexports.UnionDiscriminator = UnionDiscriminator;\n/**\n * An object that can provide a {@link\n * UnionDiscriminator|discriminator API} for {@link Union} using an\n * unsigned integral {@link Layout} instance located either inside or\n * outside the union.\n *\n * @param {ExternalLayout} layout - initializes {@link\n * UnionLayoutDiscriminator#layout|layout}.  Must satisfy {@link\n * ExternalLayout#isCount|isCount()}.\n *\n * @param {string} [property] - Default for {@link\n * UnionDiscriminator#property|property}, superseding the property\n * from `layout`, but defaulting to `variant` if neither `property`\n * nor layout provide a property name.\n *\n * @augments {UnionDiscriminator}\n */ class UnionLayoutDiscriminator extends UnionDiscriminator {\n    constructor(layout, property){\n        if (!(layout instanceof ExternalLayout && layout.isCount())) {\n            throw new TypeError(\"layout must be an unsigned integer ExternalLayout\");\n        }\n        super(property || layout.property || \"variant\");\n        /** The {@link ExternalLayout} used to access the discriminator\n         * value. */ this.layout = layout;\n    }\n    /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */ decode(b, offset) {\n        return this.layout.decode(b, offset);\n    }\n    /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */ encode(src, b, offset) {\n        return this.layout.encode(src, b, offset);\n    }\n}\nexports.UnionLayoutDiscriminator = UnionLayoutDiscriminator;\n/**\n * Represent any number of span-compatible layouts.\n *\n * *Factory*: {@link module:Layout.union|union}\n *\n * If the union has a {@link Union#defaultLayout|default layout} that\n * layout must have a non-negative {@link Layout#span|span}.  The span\n * of a fixed-span union includes its {@link\n * Union#discriminator|discriminator} if the variant is a {@link\n * Union#usesPrefixDiscriminator|prefix of the union}, plus the span\n * of its {@link Union#defaultLayout|default layout}.\n *\n * If the union does not have a default layout then the encoded span\n * of the union depends on the encoded span of its variant (which may\n * be fixed or variable).\n *\n * {@link VariantLayout#layout|Variant layout}s are added through\n * {@link Union#addVariant|addVariant}.  If the union has a default\n * layout, the span of the {@link VariantLayout#layout|layout\n * contained by the variant} must not exceed the span of the {@link\n * Union#defaultLayout|default layout} (minus the span of a {@link\n * Union#usesPrefixDiscriminator|prefix disriminator}, if used).  The\n * span of the variant will equal the span of the union itself.\n *\n * The variant for a buffer can only be identified from the {@link\n * Union#discriminator|discriminator} {@link\n * UnionDiscriminator#property|property} (in the case of the {@link\n * Union#defaultLayout|default layout}), or by using {@link\n * Union#getVariant|getVariant} and examining the resulting {@link\n * VariantLayout} instance.\n *\n * A variant compatible with a JavaScript object can be identified\n * using {@link Union#getSourceVariant|getSourceVariant}.\n *\n * @param {(UnionDiscriminator|ExternalLayout|Layout)} discr - How to\n * identify the layout used to interpret the union contents.  The\n * parameter must be an instance of {@link UnionDiscriminator}, an\n * {@link ExternalLayout} that satisfies {@link\n * ExternalLayout#isCount|isCount()}, or {@link UInt} (or {@link\n * UIntBE}).  When a non-external layout element is passed the layout\n * appears at the start of the union.  In all cases the (synthesized)\n * {@link UnionDiscriminator} instance is recorded as {@link\n * Union#discriminator|discriminator}.\n *\n * @param {(Layout|null)} defaultLayout - initializer for {@link\n * Union#defaultLayout|defaultLayout}.  If absent defaults to `null`.\n * If `null` there is no default layout: the union has data-dependent\n * length and attempts to decode or encode unrecognized variants will\n * throw an exception.  A {@link Layout} instance must have a\n * non-negative {@link Layout#span|span}, and if it lacks a {@link\n * Layout#property|property} the {@link\n * Union#defaultLayout|defaultLayout} will be a {@link\n * Layout#replicate|replica} with property `content`.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Union extends Layout {\n    constructor(discr, defaultLayout, property){\n        let discriminator;\n        if (discr instanceof UInt || discr instanceof UIntBE) {\n            discriminator = new UnionLayoutDiscriminator(new OffsetLayout(discr));\n        } else if (discr instanceof ExternalLayout && discr.isCount()) {\n            discriminator = new UnionLayoutDiscriminator(discr);\n        } else if (!(discr instanceof UnionDiscriminator)) {\n            throw new TypeError(\"discr must be a UnionDiscriminator \" + \"or an unsigned integer layout\");\n        } else {\n            discriminator = discr;\n        }\n        if (undefined === defaultLayout) {\n            defaultLayout = null;\n        }\n        if (!(null === defaultLayout || defaultLayout instanceof Layout)) {\n            throw new TypeError(\"defaultLayout must be null or a Layout\");\n        }\n        if (null !== defaultLayout) {\n            if (0 > defaultLayout.span) {\n                throw new Error(\"defaultLayout must have constant span\");\n            }\n            if (undefined === defaultLayout.property) {\n                defaultLayout = defaultLayout.replicate(\"content\");\n            }\n        }\n        /* The union span can be estimated only if there's a default\n         * layout.  The union spans its default layout, plus any prefix\n         * variant layout.  By construction both layouts, if present, have\n         * non-negative span. */ let span = -1;\n        if (defaultLayout) {\n            span = defaultLayout.span;\n            if (0 <= span && (discr instanceof UInt || discr instanceof UIntBE)) {\n                span += discriminator.layout.span;\n            }\n        }\n        super(span, property);\n        /** The interface for the discriminator value in isolation.\n         *\n         * This a {@link UnionDiscriminator} either passed to the\n         * constructor or synthesized from the `discr` constructor\n         * argument.  {@link\n         * Union#usesPrefixDiscriminator|usesPrefixDiscriminator} will be\n         * `true` iff the `discr` parameter was a non-offset {@link\n         * Layout} instance. */ this.discriminator = discriminator;\n        /** `true` if the {@link Union#discriminator|discriminator} is the\n         * first field in the union.\n         *\n         * If `false` the discriminator is obtained from somewhere\n         * else. */ this.usesPrefixDiscriminator = discr instanceof UInt || discr instanceof UIntBE;\n        /** The layout for non-discriminator content when the value of the\n         * discriminator is not recognized.\n         *\n         * This is the value passed to the constructor.  It is\n         * structurally equivalent to the second component of {@link\n         * Union#layout|layout} but may have a different property\n         * name. */ this.defaultLayout = defaultLayout;\n        /** A registry of allowed variants.\n         *\n         * The keys are unsigned integers which should be compatible with\n         * {@link Union.discriminator|discriminator}.  The property value\n         * is the corresponding {@link VariantLayout} instances assigned\n         * to this union by {@link Union#addVariant|addVariant}.\n         *\n         * **NOTE** The registry remains mutable so that variants can be\n         * {@link Union#addVariant|added} at any time.  Users should not\n         * manipulate the content of this property. */ this.registry = {};\n        /* Private variable used when invoking getSourceVariant */ let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);\n        /** Function to infer the variant selected by a source object.\n         *\n         * Defaults to {@link\n         * Union#defaultGetSourceVariant|defaultGetSourceVariant} but may\n         * be overridden using {@link\n         * Union#configGetSourceVariant|configGetSourceVariant}.\n         *\n         * @param {Object} src - as with {@link\n         * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\n         *\n         * @returns {(undefined|VariantLayout)} The default variant\n         * (`undefined`) or first registered variant that uses a property\n         * available in `src`. */ this.getSourceVariant = function(src) {\n            return boundGetSourceVariant(src);\n        };\n        /** Function to override the implementation of {@link\n         * Union#getSourceVariant|getSourceVariant}.\n         *\n         * Use this if the desired variant cannot be identified using the\n         * algorithm of {@link\n         * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\n         *\n         * **NOTE** The provided function will be invoked bound to this\n         * Union instance, providing local access to {@link\n         * Union#registry|registry}.\n         *\n         * @param {Function} gsv - a function that follows the API of\n         * {@link Union#defaultGetSourceVariant|defaultGetSourceVariant}. */ this.configGetSourceVariant = function(gsv) {\n            boundGetSourceVariant = gsv.bind(this);\n        };\n    }\n    /** @override */ getSpan(b, offset = 0) {\n        if (0 <= this.span) {\n            return this.span;\n        }\n        /* Default layouts always have non-negative span, so we don't have\n         * one and we have to recognize the variant which will in turn\n         * determine the span. */ const vlo = this.getVariant(b, offset);\n        if (!vlo) {\n            throw new Error(\"unable to determine span for unrecognized variant\");\n        }\n        return vlo.getSpan(b, offset);\n    }\n    /**\n     * Method to infer a registered Union variant compatible with `src`.\n     *\n     * The first satisfied rule in the following sequence defines the\n     * return value:\n     * * If `src` has properties matching the Union discriminator and\n     *   the default layout, `undefined` is returned regardless of the\n     *   value of the discriminator property (this ensures the default\n     *   layout will be used);\n     * * If `src` has a property matching the Union discriminator, the\n     *   value of the discriminator identifies a registered variant, and\n     *   either (a) the variant has no layout, or (b) `src` has the\n     *   variant's property, then the variant is returned (because the\n     *   source satisfies the constraints of the variant it identifies);\n     * * If `src` does not have a property matching the Union\n     *   discriminator, but does have a property matching a registered\n     *   variant, then the variant is returned (because the source\n     *   matches a variant without an explicit conflict);\n     * * An error is thrown (because we either can't identify a variant,\n     *   or we were explicitly told the variant but can't satisfy it).\n     *\n     * @param {Object} src - an object presumed to be compatible with\n     * the content of the Union.\n     *\n     * @return {(undefined|VariantLayout)} - as described above.\n     *\n     * @throws {Error} - if `src` cannot be associated with a default or\n     * registered variant.\n     */ defaultGetSourceVariant(src) {\n        if (Object.prototype.hasOwnProperty.call(src, this.discriminator.property)) {\n            if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(src, this.defaultLayout.property)) {\n                return undefined;\n            }\n            const vlo = this.registry[src[this.discriminator.property]];\n            if (vlo && (!vlo.layout || vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property))) {\n                return vlo;\n            }\n        } else {\n            for(const tag in this.registry){\n                const vlo = this.registry[tag];\n                if (vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property)) {\n                    return vlo;\n                }\n            }\n        }\n        throw new Error(\"unable to infer src variant\");\n    }\n    /** Implement {@link Layout#decode|decode} for {@link Union}.\n     *\n     * If the variant is {@link Union#addVariant|registered} the return\n     * value is an instance of that variant, with no explicit\n     * discriminator.  Otherwise the {@link Union#defaultLayout|default\n     * layout} is used to decode the content. */ decode(b, offset = 0) {\n        let dest;\n        const dlo = this.discriminator;\n        const discr = dlo.decode(b, offset);\n        const clo = this.registry[discr];\n        if (undefined === clo) {\n            const defaultLayout = this.defaultLayout;\n            let contentOffset = 0;\n            if (this.usesPrefixDiscriminator) {\n                contentOffset = dlo.layout.span;\n            }\n            dest = this.makeDestinationObject();\n            dest[dlo.property] = discr;\n            // defaultLayout.property can be undefined, but this is allowed by buffer-layout\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            dest[defaultLayout.property] = defaultLayout.decode(b, offset + contentOffset);\n        } else {\n            dest = clo.decode(b, offset);\n        }\n        return dest;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Union}.\n     *\n     * This API assumes the `src` object is consistent with the union's\n     * {@link Union#defaultLayout|default layout}.  To encode variants\n     * use the appropriate variant-specific {@link VariantLayout#encode}\n     * method. */ encode(src, b, offset = 0) {\n        const vlo = this.getSourceVariant(src);\n        if (undefined === vlo) {\n            const dlo = this.discriminator;\n            // this.defaultLayout is not undefined when vlo is undefined\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const clo = this.defaultLayout;\n            let contentOffset = 0;\n            if (this.usesPrefixDiscriminator) {\n                contentOffset = dlo.layout.span;\n            }\n            dlo.encode(src[dlo.property], b, offset);\n            // clo.property is not undefined when vlo is undefined\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            return contentOffset + clo.encode(src[clo.property], b, offset + contentOffset);\n        }\n        return vlo.encode(src, b, offset);\n    }\n    /** Register a new variant structure within a union.  The newly\n     * created variant is returned.\n     *\n     * @param {Number} variant - initializer for {@link\n     * VariantLayout#variant|variant}.\n     *\n     * @param {Layout} layout - initializer for {@link\n     * VariantLayout#layout|layout}.\n     *\n     * @param {String} property - initializer for {@link\n     * Layout#property|property}.\n     *\n     * @return {VariantLayout} */ addVariant(variant, layout, property) {\n        const rv = new VariantLayout(this, variant, layout, property);\n        this.registry[variant] = rv;\n        return rv;\n    }\n    /**\n     * Get the layout associated with a registered variant.\n     *\n     * If `vb` does not produce a registered variant the function returns\n     * `undefined`.\n     *\n     * @param {(Number|Uint8Array)} vb - either the variant number, or a\n     * buffer from which the discriminator is to be read.\n     *\n     * @param {Number} offset - offset into `vb` for the start of the\n     * union.  Used only when `vb` is an instance of {Uint8Array}.\n     *\n     * @return {({VariantLayout}|undefined)}\n     */ getVariant(vb, offset = 0) {\n        let variant;\n        if (vb instanceof Uint8Array) {\n            variant = this.discriminator.decode(vb, offset);\n        } else {\n            variant = vb;\n        }\n        return this.registry[variant];\n    }\n}\nexports.Union = Union;\n/**\n * Represent a specific variant within a containing union.\n *\n * **NOTE** The {@link Layout#span|span} of the variant may include\n * the span of the {@link Union#discriminator|discriminator} used to\n * identify it, but values read and written using the variant strictly\n * conform to the content of {@link VariantLayout#layout|layout}.\n *\n * **NOTE** User code should not invoke this constructor directly.  Use\n * the union {@link Union#addVariant|addVariant} helper method.\n *\n * @param {Union} union - initializer for {@link\n * VariantLayout#union|union}.\n *\n * @param {Number} variant - initializer for {@link\n * VariantLayout#variant|variant}.\n *\n * @param {Layout} [layout] - initializer for {@link\n * VariantLayout#layout|layout}.  If absent the variant carries no\n * data.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.  Unlike many other layouts, variant\n * layouts normally include a property name so they can be identified\n * within their containing {@link Union}.  The property identifier may\n * be absent only if `layout` is is absent.\n *\n * @augments {Layout}\n */ class VariantLayout extends Layout {\n    constructor(union, variant, layout, property){\n        if (!(union instanceof Union)) {\n            throw new TypeError(\"union must be a Union\");\n        }\n        if (!Number.isInteger(variant) || 0 > variant) {\n            throw new TypeError(\"variant must be a (non-negative) integer\");\n        }\n        if (\"string\" === typeof layout && undefined === property) {\n            property = layout;\n            layout = null;\n        }\n        if (layout) {\n            if (!(layout instanceof Layout)) {\n                throw new TypeError(\"layout must be a Layout\");\n            }\n            if (null !== union.defaultLayout && 0 <= layout.span && layout.span > union.defaultLayout.span) {\n                throw new Error(\"variant span exceeds span of containing union\");\n            }\n            if (\"string\" !== typeof property) {\n                throw new TypeError(\"variant must have a String property\");\n            }\n        }\n        let span = union.span;\n        if (0 > union.span) {\n            span = layout ? layout.span : 0;\n            if (0 <= span && union.usesPrefixDiscriminator) {\n                span += union.discriminator.layout.span;\n            }\n        }\n        super(span, property);\n        /** The {@link Union} to which this variant belongs. */ this.union = union;\n        /** The unsigned integral value identifying this variant within\n         * the {@link Union#discriminator|discriminator} of the containing\n         * union. */ this.variant = variant;\n        /** The {@link Layout} to be used when reading/writing the\n         * non-discriminator part of the {@link\n         * VariantLayout#union|union}.  If `null` the variant carries no\n         * data. */ this.layout = layout || null;\n    }\n    /** @override */ getSpan(b, offset = 0) {\n        if (0 <= this.span) {\n            /* Will be equal to the containing union span if that is not\n             * variable. */ return this.span;\n        }\n        let contentOffset = 0;\n        if (this.union.usesPrefixDiscriminator) {\n            contentOffset = this.union.discriminator.layout.span;\n        }\n        /* Span is defined solely by the variant (and prefix discriminator) */ let span = 0;\n        if (this.layout) {\n            span = this.layout.getSpan(b, offset + contentOffset);\n        }\n        return contentOffset + span;\n    }\n    /** @override */ decode(b, offset = 0) {\n        const dest = this.makeDestinationObject();\n        if (this !== this.union.getVariant(b, offset)) {\n            throw new Error(\"variant mismatch\");\n        }\n        let contentOffset = 0;\n        if (this.union.usesPrefixDiscriminator) {\n            contentOffset = this.union.discriminator.layout.span;\n        }\n        if (this.layout) {\n            dest[this.property] = this.layout.decode(b, offset + contentOffset);\n        } else if (this.property) {\n            dest[this.property] = true;\n        } else if (this.union.usesPrefixDiscriminator) {\n            dest[this.union.discriminator.property] = this.variant;\n        }\n        return dest;\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        let contentOffset = 0;\n        if (this.union.usesPrefixDiscriminator) {\n            contentOffset = this.union.discriminator.layout.span;\n        }\n        if (this.layout && !Object.prototype.hasOwnProperty.call(src, this.property)) {\n            throw new TypeError(\"variant lacks property \" + this.property);\n        }\n        this.union.discriminator.encode(this.variant, b, offset);\n        let span = contentOffset;\n        if (this.layout) {\n            this.layout.encode(src[this.property], b, offset + contentOffset);\n            span += this.layout.getSpan(b, offset + contentOffset);\n            if (0 <= this.union.span && span > this.union.span) {\n                throw new Error(\"encoded variant overruns containing union\");\n            }\n        }\n        return span;\n    }\n    /** Delegate {@link Layout#fromArray|fromArray} to {@link\n     * VariantLayout#layout|layout}. */ fromArray(values) {\n        if (this.layout) {\n            return this.layout.fromArray(values);\n        }\n        return undefined;\n    }\n}\nexports.VariantLayout = VariantLayout;\n/** JavaScript chose to define bitwise operations as operating on\n * signed 32-bit values in 2's complement form, meaning any integer\n * with bit 31 set is going to look negative.  For right shifts that's\n * not a problem, because `>>>` is a logical shift, but for every\n * other bitwise operator we have to compensate for possible negative\n * results. */ function fixBitwiseResult(v) {\n    if (0 > v) {\n        v += 0x100000000;\n    }\n    return v;\n}\n/**\n * Contain a sequence of bit fields as an unsigned integer.\n *\n * *Factory*: {@link module:Layout.bits|bits}\n *\n * This is a container element; within it there are {@link BitField}\n * instances that provide the extracted properties.  The container\n * simply defines the aggregate representation and its bit ordering.\n * The representation is an object containing properties with numeric\n * or {@link Boolean} values.\n *\n * {@link BitField}s are added with the {@link\n * BitStructure#addField|addField} and {@link\n * BitStructure#addBoolean|addBoolean} methods.\n\n * @param {Layout} word - initializer for {@link\n * BitStructure#word|word}.  The parameter must be an instance of\n * {@link UInt} (or {@link UIntBE}) that is no more than 4 bytes wide.\n *\n * @param {bool} [msb] - `true` if the bit numbering starts at the\n * most significant bit of the containing word; `false` (default) if\n * it starts at the least significant bit of the containing word.  If\n * the parameter at this position is a string and `property` is\n * `undefined` the value of this argument will instead be used as the\n * value of `property`.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class BitStructure extends Layout {\n    constructor(word, msb, property){\n        if (!(word instanceof UInt || word instanceof UIntBE)) {\n            throw new TypeError(\"word must be a UInt or UIntBE layout\");\n        }\n        if (\"string\" === typeof msb && undefined === property) {\n            property = msb;\n            msb = false;\n        }\n        if (4 < word.span) {\n            throw new RangeError(\"word cannot exceed 32 bits\");\n        }\n        super(word.span, property);\n        /** The layout used for the packed value.  {@link BitField}\n         * instances are packed sequentially depending on {@link\n         * BitStructure#msb|msb}. */ this.word = word;\n        /** Whether the bit sequences are packed starting at the most\n         * significant bit growing down (`true`), or the least significant\n         * bit growing up (`false`).\n         *\n         * **NOTE** Regardless of this value, the least significant bit of\n         * any {@link BitField} value is the least significant bit of the\n         * corresponding section of the packed value. */ this.msb = !!msb;\n        /** The sequence of {@link BitField} layouts that comprise the\n         * packed structure.\n         *\n         * **NOTE** The array remains mutable to allow fields to be {@link\n         * BitStructure#addField|added} after construction.  Users should\n         * not manipulate the content of this property.*/ this.fields = [];\n        /* Storage for the value.  Capture a variable instead of using an\n         * instance property because we don't want anything to change the\n         * value without going through the mutator. */ let value = 0;\n        this._packedSetValue = function(v) {\n            value = fixBitwiseResult(v);\n            return this;\n        };\n        this._packedGetValue = function() {\n            return value;\n        };\n    }\n    /** @override */ decode(b, offset = 0) {\n        const dest = this.makeDestinationObject();\n        const value = this.word.decode(b, offset);\n        this._packedSetValue(value);\n        for (const fd of this.fields){\n            if (undefined !== fd.property) {\n                dest[fd.property] = fd.decode(b);\n            }\n        }\n        return dest;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link BitStructure}.\n     *\n     * If `src` is missing a property for a member with a defined {@link\n     * Layout#property|property} the corresponding region of the packed\n     * value is left unmodified.  Unused bits are also left unmodified. */ encode(src, b, offset = 0) {\n        const value = this.word.decode(b, offset);\n        this._packedSetValue(value);\n        for (const fd of this.fields){\n            if (undefined !== fd.property) {\n                const fv = src[fd.property];\n                if (undefined !== fv) {\n                    fd.encode(fv);\n                }\n            }\n        }\n        return this.word.encode(this._packedGetValue(), b, offset);\n    }\n    /** Register a new bitfield with a containing bit structure.  The\n     * resulting bitfield is returned.\n     *\n     * @param {Number} bits - initializer for {@link BitField#bits|bits}.\n     *\n     * @param {string} property - initializer for {@link\n     * Layout#property|property}.\n     *\n     * @return {BitField} */ addField(bits, property) {\n        const bf = new BitField(this, bits, property);\n        this.fields.push(bf);\n        return bf;\n    }\n    /** As with {@link BitStructure#addField|addField} for single-bit\n     * fields with `boolean` value representation.\n     *\n     * @param {string} property - initializer for {@link\n     * Layout#property|property}.\n     *\n     * @return {Boolean} */ // `Boolean` conflicts with the native primitive type\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    addBoolean(property) {\n        // This is my Boolean, not the Javascript one.\n        const bf = new Boolean(this, property);\n        this.fields.push(bf);\n        return bf;\n    }\n    /**\n     * Get access to the bit field for a given property.\n     *\n     * @param {String} property - the bit field of interest.\n     *\n     * @return {BitField} - the field associated with `property`, or\n     * undefined if there is no such property.\n     */ fieldFor(property) {\n        if (\"string\" !== typeof property) {\n            throw new TypeError(\"property must be string\");\n        }\n        for (const fd of this.fields){\n            if (fd.property === property) {\n                return fd;\n            }\n        }\n        return undefined;\n    }\n}\nexports.BitStructure = BitStructure;\n/**\n * Represent a sequence of bits within a {@link BitStructure}.\n *\n * All bit field values are represented as unsigned integers.\n *\n * **NOTE** User code should not invoke this constructor directly.\n * Use the container {@link BitStructure#addField|addField} helper\n * method.\n *\n * **NOTE** BitField instances are not instances of {@link Layout}\n * since {@link Layout#span|span} measures 8-bit units.\n *\n * @param {BitStructure} container - initializer for {@link\n * BitField#container|container}.\n *\n * @param {Number} bits - initializer for {@link BitField#bits|bits}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n */ class BitField {\n    constructor(container, bits, property){\n        if (!(container instanceof BitStructure)) {\n            throw new TypeError(\"container must be a BitStructure\");\n        }\n        if (!Number.isInteger(bits) || 0 >= bits) {\n            throw new TypeError(\"bits must be positive integer\");\n        }\n        const totalBits = 8 * container.span;\n        const usedBits = container.fields.reduce((sum, fd)=>sum + fd.bits, 0);\n        if (bits + usedBits > totalBits) {\n            throw new Error(\"bits too long for span remainder (\" + (totalBits - usedBits) + \" of \" + totalBits + \" remain)\");\n        }\n        /** The {@link BitStructure} instance to which this bit field\n         * belongs. */ this.container = container;\n        /** The span of this value in bits. */ this.bits = bits;\n        /** A mask of {@link BitField#bits|bits} bits isolating value bits\n         * that fit within the field.\n         *\n         * That is, it masks a value that has not yet been shifted into\n         * position within its containing packed integer. */ this.valueMask = (1 << bits) - 1;\n        if (32 === bits) {\n            this.valueMask = 0xFFFFFFFF;\n        }\n        /** The offset of the value within the containing packed unsigned\n         * integer.  The least significant bit of the packed value is at\n         * offset zero, regardless of bit ordering used. */ this.start = usedBits;\n        if (this.container.msb) {\n            this.start = totalBits - usedBits - bits;\n        }\n        /** A mask of {@link BitField#bits|bits} isolating the field value\n         * within the containing packed unsigned integer. */ this.wordMask = fixBitwiseResult(this.valueMask << this.start);\n        /** The property name used when this bitfield is represented in an\n         * Object.\n         *\n         * Intended to be functionally equivalent to {@link\n         * Layout#property}.\n         *\n         * If left undefined the corresponding span of bits will be\n         * treated as padding: it will not be mutated by {@link\n         * Layout#encode|encode} nor represented as a property in the\n         * decoded Object. */ this.property = property;\n    }\n    /** Store a value into the corresponding subsequence of the containing\n     * bit field. */ decode(b, offset) {\n        const word = this.container._packedGetValue();\n        const wordValue = fixBitwiseResult(word & this.wordMask);\n        const value = wordValue >>> this.start;\n        return value;\n    }\n    /** Store a value into the corresponding subsequence of the containing\n     * bit field.\n     *\n     * **NOTE** This is not a specialization of {@link\n     * Layout#encode|Layout.encode} and there is no return value. */ encode(value) {\n        if (\"number\" !== typeof value || !Number.isInteger(value) || value !== fixBitwiseResult(value & this.valueMask)) {\n            throw new TypeError(nameWithProperty(\"BitField.encode\", this) + \" value must be integer not exceeding \" + this.valueMask);\n        }\n        const word = this.container._packedGetValue();\n        const wordValue = fixBitwiseResult(value << this.start);\n        this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask) | wordValue);\n    }\n}\nexports.BitField = BitField;\n/**\n * Represent a single bit within a {@link BitStructure} as a\n * JavaScript boolean.\n *\n * **NOTE** User code should not invoke this constructor directly.\n * Use the container {@link BitStructure#addBoolean|addBoolean} helper\n * method.\n *\n * @param {BitStructure} container - initializer for {@link\n * BitField#container|container}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {BitField}\n */ /* eslint-disable no-extend-native */ class Boolean extends BitField {\n    constructor(container, property){\n        super(container, 1, property);\n    }\n    /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.\n     *\n     * @returns {boolean} */ decode(b, offset) {\n        return !!super.decode(b, offset);\n    }\n    /** @override */ encode(value) {\n        if (\"boolean\" === typeof value) {\n            // BitField requires integer values\n            value = +value;\n        }\n        super.encode(value);\n    }\n}\nexports.Boolean = Boolean;\n/* eslint-enable no-extend-native */ /**\n * Contain a fixed-length block of arbitrary data, represented as a\n * Uint8Array.\n *\n * *Factory*: {@link module:Layout.blob|blob}\n *\n * @param {(Number|ExternalLayout)} length - initializes {@link\n * Blob#length|length}.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Blob extends Layout {\n    constructor(length, property){\n        if (!(length instanceof ExternalLayout && length.isCount() || Number.isInteger(length) && 0 <= length)) {\n            throw new TypeError(\"length must be positive integer \" + \"or an unsigned integer ExternalLayout\");\n        }\n        let span = -1;\n        if (!(length instanceof ExternalLayout)) {\n            span = length;\n        }\n        super(span, property);\n        /** The number of bytes in the blob.\n         *\n         * This may be a non-negative integer, or an instance of {@link\n         * ExternalLayout} that satisfies {@link\n         * ExternalLayout#isCount|isCount()}. */ this.length = length;\n    }\n    /** @override */ getSpan(b, offset) {\n        let span = this.span;\n        if (0 > span) {\n            span = this.length.decode(b, offset);\n        }\n        return span;\n    }\n    /** @override */ decode(b, offset = 0) {\n        let span = this.span;\n        if (0 > span) {\n            span = this.length.decode(b, offset);\n        }\n        return uint8ArrayToBuffer(b).slice(offset, offset + span);\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Blob}.\n     *\n     * **NOTE** If {@link Layout#count|count} is an instance of {@link\n     * ExternalLayout} then the length of `src` will be encoded as the\n     * count after `src` is encoded. */ encode(src, b, offset) {\n        let span = this.length;\n        if (this.length instanceof ExternalLayout) {\n            span = src.length;\n        }\n        if (!(src instanceof Uint8Array && span === src.length)) {\n            throw new TypeError(nameWithProperty(\"Blob.encode\", this) + \" requires (length \" + span + \") Uint8Array as src\");\n        }\n        if (offset + span > b.length) {\n            throw new RangeError(\"encoding overruns Uint8Array\");\n        }\n        const srcBuffer = uint8ArrayToBuffer(src);\n        uint8ArrayToBuffer(b).write(srcBuffer.toString(\"hex\"), offset, span, \"hex\");\n        if (this.length instanceof ExternalLayout) {\n            this.length.encode(span, b, offset);\n        }\n        return span;\n    }\n}\nexports.Blob = Blob;\n/**\n * Contain a `NUL`-terminated UTF8 string.\n *\n * *Factory*: {@link module:Layout.cstr|cstr}\n *\n * **NOTE** Any UTF8 string that incorporates a zero-valued byte will\n * not be correctly decoded by this layout.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class CString extends Layout {\n    constructor(property){\n        super(-1, property);\n    }\n    /** @override */ getSpan(b, offset = 0) {\n        checkUint8Array(b);\n        let idx = offset;\n        while(idx < b.length && 0 !== b[idx]){\n            idx += 1;\n        }\n        return 1 + idx - offset;\n    }\n    /** @override */ decode(b, offset = 0) {\n        const span = this.getSpan(b, offset);\n        return uint8ArrayToBuffer(b).slice(offset, offset + span - 1).toString(\"utf-8\");\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        /* Must force this to a string, lest it be a number and the\n         * \"utf8-encoding\" below actually allocate a buffer of length\n         * src */ if (\"string\" !== typeof src) {\n            src = String(src);\n        }\n        const srcb = buffer_1.Buffer.from(src, \"utf8\");\n        const span = srcb.length;\n        if (offset + span > b.length) {\n            throw new RangeError(\"encoding overruns Buffer\");\n        }\n        const buffer = uint8ArrayToBuffer(b);\n        srcb.copy(buffer, offset);\n        buffer[offset + span] = 0;\n        return span + 1;\n    }\n}\nexports.CString = CString;\n/**\n * Contain a UTF8 string with implicit length.\n *\n * *Factory*: {@link module:Layout.utf8|utf8}\n *\n * **NOTE** Because the length is implicit in the size of the buffer\n * this layout should be used only in isolation, or in a situation\n * where the length can be expressed by operating on a slice of the\n * containing buffer.\n *\n * @param {Number} [maxSpan] - the maximum length allowed for encoded\n * string content.  If not provided there is no bound on the allowed\n * content.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class UTF8 extends Layout {\n    constructor(maxSpan, property){\n        if (\"string\" === typeof maxSpan && undefined === property) {\n            property = maxSpan;\n            maxSpan = undefined;\n        }\n        if (undefined === maxSpan) {\n            maxSpan = -1;\n        } else if (!Number.isInteger(maxSpan)) {\n            throw new TypeError(\"maxSpan must be an integer\");\n        }\n        super(-1, property);\n        /** The maximum span of the layout in bytes.\n         *\n         * Positive values are generally expected.  Zero is abnormal.\n         * Attempts to encode or decode a value that exceeds this length\n         * will throw a `RangeError`.\n         *\n         * A negative value indicates that there is no bound on the length\n         * of the content. */ this.maxSpan = maxSpan;\n    }\n    /** @override */ getSpan(b, offset = 0) {\n        checkUint8Array(b);\n        return b.length - offset;\n    }\n    /** @override */ decode(b, offset = 0) {\n        const span = this.getSpan(b, offset);\n        if (0 <= this.maxSpan && this.maxSpan < span) {\n            throw new RangeError(\"text length exceeds maxSpan\");\n        }\n        return uint8ArrayToBuffer(b).slice(offset, offset + span).toString(\"utf-8\");\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        /* Must force this to a string, lest it be a number and the\n         * \"utf8-encoding\" below actually allocate a buffer of length\n         * src */ if (\"string\" !== typeof src) {\n            src = String(src);\n        }\n        const srcb = buffer_1.Buffer.from(src, \"utf8\");\n        const span = srcb.length;\n        if (0 <= this.maxSpan && this.maxSpan < span) {\n            throw new RangeError(\"text length exceeds maxSpan\");\n        }\n        if (offset + span > b.length) {\n            throw new RangeError(\"encoding overruns Buffer\");\n        }\n        srcb.copy(uint8ArrayToBuffer(b), offset);\n        return span;\n    }\n}\nexports.UTF8 = UTF8;\n/**\n * Contain a constant value.\n *\n * This layout may be used in cases where a JavaScript value can be\n * inferred without an expression in the binary encoding.  An example\n * would be a {@link VariantLayout|variant layout} where the content\n * is implied by the union {@link Union#discriminator|discriminator}.\n *\n * @param {Object|Number|String} value - initializer for {@link\n * Constant#value|value}.  If the value is an object (or array) and\n * the application intends the object to remain unchanged regardless\n * of what is done to values decoded by this layout, the value should\n * be frozen prior passing it to this constructor.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Constant extends Layout {\n    constructor(value, property){\n        super(0, property);\n        /** The value produced by this constant when the layout is {@link\n         * Constant#decode|decoded}.\n         *\n         * Any JavaScript value including `null` and `undefined` is\n         * permitted.\n         *\n         * **WARNING** If `value` passed in the constructor was not\n         * frozen, it is possible for users of decoded values to change\n         * the content of the value. */ this.value = value;\n    }\n    /** @override */ decode(b, offset) {\n        return this.value;\n    }\n    /** @override */ encode(src, b, offset) {\n        /* Constants take no space */ return 0;\n    }\n}\nexports.Constant = Constant;\n/** Factory for {@link GreedyCount}. */ exports.greedy = (elementSpan, property)=>new GreedyCount(elementSpan, property);\n/** Factory for {@link OffsetLayout}. */ exports.offset = (layout, offset, property)=>new OffsetLayout(layout, offset, property);\n/** Factory for {@link UInt|unsigned int layouts} spanning one\n * byte. */ exports.u8 = (property)=>new UInt(1, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning two bytes. */ exports.u16 = (property)=>new UInt(2, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning three bytes. */ exports.u24 = (property)=>new UInt(3, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning four bytes. */ exports.u32 = (property)=>new UInt(4, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning five bytes. */ exports.u40 = (property)=>new UInt(5, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning six bytes. */ exports.u48 = (property)=>new UInt(6, property);\n/** Factory for {@link NearUInt64|little-endian unsigned int\n * layouts} interpreted as Numbers. */ exports.nu64 = (property)=>new NearUInt64(property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning two bytes. */ exports.u16be = (property)=>new UIntBE(2, property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning three bytes. */ exports.u24be = (property)=>new UIntBE(3, property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning four bytes. */ exports.u32be = (property)=>new UIntBE(4, property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning five bytes. */ exports.u40be = (property)=>new UIntBE(5, property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning six bytes. */ exports.u48be = (property)=>new UIntBE(6, property);\n/** Factory for {@link NearUInt64BE|big-endian unsigned int\n * layouts} interpreted as Numbers. */ exports.nu64be = (property)=>new NearUInt64BE(property);\n/** Factory for {@link Int|signed int layouts} spanning one\n * byte. */ exports.s8 = (property)=>new Int(1, property);\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning two bytes. */ exports.s16 = (property)=>new Int(2, property);\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning three bytes. */ exports.s24 = (property)=>new Int(3, property);\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning four bytes. */ exports.s32 = (property)=>new Int(4, property);\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning five bytes. */ exports.s40 = (property)=>new Int(5, property);\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning six bytes. */ exports.s48 = (property)=>new Int(6, property);\n/** Factory for {@link NearInt64|little-endian signed int layouts}\n * interpreted as Numbers. */ exports.ns64 = (property)=>new NearInt64(property);\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning two bytes. */ exports.s16be = (property)=>new IntBE(2, property);\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning three bytes. */ exports.s24be = (property)=>new IntBE(3, property);\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning four bytes. */ exports.s32be = (property)=>new IntBE(4, property);\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning five bytes. */ exports.s40be = (property)=>new IntBE(5, property);\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning six bytes. */ exports.s48be = (property)=>new IntBE(6, property);\n/** Factory for {@link NearInt64BE|big-endian signed int layouts}\n * interpreted as Numbers. */ exports.ns64be = (property)=>new NearInt64BE(property);\n/** Factory for {@link Float|little-endian 32-bit floating point} values. */ exports.f32 = (property)=>new Float(property);\n/** Factory for {@link FloatBE|big-endian 32-bit floating point} values. */ exports.f32be = (property)=>new FloatBE(property);\n/** Factory for {@link Double|little-endian 64-bit floating point} values. */ exports.f64 = (property)=>new Double(property);\n/** Factory for {@link DoubleBE|big-endian 64-bit floating point} values. */ exports.f64be = (property)=>new DoubleBE(property);\n/** Factory for {@link Structure} values. */ exports.struct = (fields, property, decodePrefixes)=>new Structure(fields, property, decodePrefixes);\n/** Factory for {@link BitStructure} values. */ exports.bits = (word, msb, property)=>new BitStructure(word, msb, property);\n/** Factory for {@link Sequence} values. */ exports.seq = (elementLayout, count, property)=>new Sequence(elementLayout, count, property);\n/** Factory for {@link Union} values. */ exports.union = (discr, defaultLayout, property)=>new Union(discr, defaultLayout, property);\n/** Factory for {@link UnionLayoutDiscriminator} values. */ exports.unionLayoutDiscriminator = (layout, property)=>new UnionLayoutDiscriminator(layout, property);\n/** Factory for {@link Blob} values. */ exports.blob = (length, property)=>new Blob(length, property);\n/** Factory for {@link CString} values. */ exports.cstr = (property)=>new CString(property);\n/** Factory for {@link UTF8} values. */ exports.utf8 = (maxSpan, property)=>new UTF8(maxSpan, property);\n/** Factory for {@link Constant} values. */ exports.constant = (value, property)=>new Constant(value, property); //# sourceMappingURL=Layout.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS9idWZmZXItbGF5b3V0L2xpYi9MYXlvdXQuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXFCQyxHQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTJHQyxHQUNEO0FBQ0FBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxXQUFXLEdBQUdBLFVBQVUsR0FBR0EsY0FBYyxHQUFHQSxhQUFhLEdBQUdBLGFBQWEsR0FBR0EsYUFBYSxHQUFHQSxhQUFhLEdBQUdBLGFBQWEsR0FBR0EsWUFBWSxHQUFHQSxXQUFXLEdBQUdBLFdBQVcsR0FBR0EsV0FBVyxHQUFHQSxXQUFXLEdBQUdBLFdBQVcsR0FBR0EsVUFBVSxHQUFHQSxjQUFjLEdBQUdBLGNBQWMsR0FBR0EsZ0JBQWdCLEdBQUdBLFlBQVksR0FBR0EsZUFBZSxHQUFHQSxZQUFZLEdBQUdBLGVBQWUsR0FBR0EsZ0JBQWdCLEdBQUdBLG9CQUFvQixHQUFHQSxxQkFBcUIsR0FBR0EsYUFBYSxHQUFHQSxnQ0FBZ0MsR0FBR0EsMEJBQTBCLEdBQUdBLGlCQUFpQixHQUFHQSxnQkFBZ0IsR0FBR0EsZ0JBQWdCLEdBQUdBLGNBQWMsR0FBR0EsZUFBZSxHQUFHQSxhQUFhLEdBQUdBLG1CQUFtQixHQUFHQSxpQkFBaUIsR0FBR0Esb0JBQW9CLEdBQUdBLGtCQUFrQixHQUFHQSxhQUFhLEdBQUdBLFdBQVcsR0FBR0EsY0FBYyxHQUFHQSxZQUFZLEdBQUdBLG9CQUFvQixHQUFHQSxtQkFBbUIsR0FBR0Esc0JBQXNCLEdBQUdBLDZCQUE2QixHQUFHQSx3QkFBd0IsR0FBR0EsY0FBYyxHQUFHQSwwQkFBMEIsR0FBR0EsdUJBQXVCLEdBQUcsS0FBSztBQUN0N0JBLGdCQUFnQixH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QUFDekQseUNBQXlDLEdBQ3pDeEYsZ0JBQWdCLEdBQUksQ0FBQ0MsT0FBT3VGLFdBQWEsSUFBSXJFLFNBQVNsQixPQUFPdUYsV0FDN0Qsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2tyLWRvbWFpbi13YXRjaGVyLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvYnVmZmVyLWxheW91dC9saWIvTGF5b3V0LmpzPzY3ZGYiXSwic291cmNlc0NvbnRlbnQiOlsiLyogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBQZXRlciBBLiBCaWdvdFxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cbi8qKlxuICogU3VwcG9ydCBmb3IgdHJhbnNsYXRpbmcgYmV0d2VlbiBVaW50OEFycmF5IGluc3RhbmNlcyBhbmQgSmF2YVNjcmlwdFxuICogbmF0aXZlIHR5cGVzLlxuICpcbiAqIHtAbGluayBtb2R1bGU6TGF5b3V0fkxheW91dHxMYXlvdXR9IGlzIHRoZSBiYXNpcyBvZiBhIGNsYXNzXG4gKiBoaWVyYXJjaHkgdGhhdCBhc3NvY2lhdGVzIHByb3BlcnR5IG5hbWVzIHdpdGggc2VxdWVuY2VzIG9mIGVuY29kZWRcbiAqIGJ5dGVzLlxuICpcbiAqIExheW91dHMgYXJlIHN1cHBvcnRlZCBmb3IgdGhlc2Ugc2NhbGFyIChudW1lcmljKSB0eXBlczpcbiAqICoge0BsaW5rIG1vZHVsZTpMYXlvdXR+VUludHxVbnNpZ25lZCBpbnRlZ2VycyBpbiBsaXR0bGUtZW5kaWFuXG4gKiAgIGZvcm1hdH0gd2l0aCB7QGxpbmsgbW9kdWxlOkxheW91dC51OHw4LWJpdH0sIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0LnUxNnwxNi1iaXR9LCB7QGxpbmsgbW9kdWxlOkxheW91dC51MjR8MjQtYml0fSxcbiAqICAge0BsaW5rIG1vZHVsZTpMYXlvdXQudTMyfDMyLWJpdH0sIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0LnU0MHw0MC1iaXR9LCBhbmQge0BsaW5rIG1vZHVsZTpMYXlvdXQudTQ4fDQ4LWJpdH1cbiAqICAgcmVwcmVzZW50YXRpb24gcmFuZ2VzO1xuICogKiB7QGxpbmsgbW9kdWxlOkxheW91dH5VSW50QkV8VW5zaWduZWQgaW50ZWdlcnMgaW4gYmlnLWVuZGlhblxuICogICBmb3JtYXR9IHdpdGgge0BsaW5rIG1vZHVsZTpMYXlvdXQudTE2YmV8MTYtYml0fSwge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQudTI0YmV8MjQtYml0fSwge0BsaW5rIG1vZHVsZTpMYXlvdXQudTMyYmV8MzItYml0fSxcbiAqICAge0BsaW5rIG1vZHVsZTpMYXlvdXQudTQwYmV8NDAtYml0fSwgYW5kIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0LnU0OGJlfDQ4LWJpdH0gcmVwcmVzZW50YXRpb24gcmFuZ2VzO1xuICogKiB7QGxpbmsgbW9kdWxlOkxheW91dH5JbnR8U2lnbmVkIGludGVnZXJzIGluIGxpdHRsZS1lbmRpYW5cbiAqICAgZm9ybWF0fSB3aXRoIHtAbGluayBtb2R1bGU6TGF5b3V0LnM4fDgtYml0fSwge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQuczE2fDE2LWJpdH0sIHtAbGluayBtb2R1bGU6TGF5b3V0LnMyNHwyNC1iaXR9LFxuICogICB7QGxpbmsgbW9kdWxlOkxheW91dC5zMzJ8MzItYml0fSwge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQuczQwfDQwLWJpdH0sIGFuZCB7QGxpbmsgbW9kdWxlOkxheW91dC5zNDh8NDgtYml0fVxuICogICByZXByZXNlbnRhdGlvbiByYW5nZXM7XG4gKiAqIHtAbGluayBtb2R1bGU6TGF5b3V0fkludEJFfFNpZ25lZCBpbnRlZ2VycyBpbiBiaWctZW5kaWFuIGZvcm1hdH1cbiAqICAgd2l0aCB7QGxpbmsgbW9kdWxlOkxheW91dC5zMTZiZXwxNi1iaXR9LCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC5zMjRiZXwyNC1iaXR9LCB7QGxpbmsgbW9kdWxlOkxheW91dC5zMzJiZXwzMi1iaXR9LFxuICogICB7QGxpbmsgbW9kdWxlOkxheW91dC5zNDBiZXw0MC1iaXR9LCBhbmQge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQuczQ4YmV8NDgtYml0fSByZXByZXNlbnRhdGlvbiByYW5nZXM7XG4gKiAqIDY0LWJpdCBpbnRlZ3JhbCB2YWx1ZXMgdGhhdCBkZWNvZGUgdG8gYW4gZXhhY3QgKGlmIG1hZ25pdHVkZSBpc1xuICogICBsZXNzIHRoYW4gMl41Mykgb3IgbmVhcmJ5IGludGVncmFsIE51bWJlciBpbiB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC5udTY0fHVuc2lnbmVkIGxpdHRsZS1lbmRpYW59LCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC5udTY0YmV8dW5zaWduZWQgYmlnLWVuZGlhbn0sIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0Lm5zNjR8c2lnbmVkIGxpdHRsZS1lbmRpYW59LCBhbmQge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQubnM2NGJlfHVuc2lnbmVkIGJpZy1lbmRpYW59IGVuY29kaW5ncztcbiAqICogMzItYml0IGZsb2F0aW5nIHBvaW50IHZhbHVlcyB3aXRoIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0LmYzMnxsaXR0bGUtZW5kaWFufSBhbmQge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQuZjMyYmV8YmlnLWVuZGlhbn0gcmVwcmVzZW50YXRpb25zO1xuICogKiA2NC1iaXQgZmxvYXRpbmcgcG9pbnQgdmFsdWVzIHdpdGgge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQuZjY0fGxpdHRsZS1lbmRpYW59IGFuZCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC5mNjRiZXxiaWctZW5kaWFufSByZXByZXNlbnRhdGlvbnM7XG4gKiAqIHtAbGluayBtb2R1bGU6TGF5b3V0LmNvbnN0fENvbnN0YW50c30gdGhhdCB0YWtlIG5vIHNwYWNlIGluIHRoZVxuICogICBlbmNvZGVkIGV4cHJlc3Npb24uXG4gKlxuICogYW5kIGZvciB0aGVzZSBhZ2dyZWdhdGUgdHlwZXM6XG4gKiAqIHtAbGluayBtb2R1bGU6TGF5b3V0LnNlcXxTZXF1ZW5jZX1zIG9mIGluc3RhbmNlcyBvZiBhIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0fkxheW91dHxMYXlvdXR9LCB3aXRoIEphdmFTY3JpcHQgcmVwcmVzZW50YXRpb24gYXNcbiAqICAgYW4gQXJyYXkgYW5kIGNvbnN0YW50IG9yIGRhdGEtZGVwZW5kZW50IHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0flNlcXVlbmNlI2NvdW50fGxlbmd0aH07XG4gKiAqIHtAbGluayBtb2R1bGU6TGF5b3V0LnN0cnVjdHxTdHJ1Y3R1cmV9cyB0aGF0IGFnZ3JlZ2F0ZSBhXG4gKiAgIGhldGVyb2dlbmVvdXMgc2VxdWVuY2Ugb2Yge0BsaW5rIG1vZHVsZTpMYXlvdXR+TGF5b3V0fExheW91dH1cbiAqICAgaW5zdGFuY2VzLCB3aXRoIEphdmFTY3JpcHQgcmVwcmVzZW50YXRpb24gYXMgYW4gT2JqZWN0O1xuICogKiB7QGxpbmsgbW9kdWxlOkxheW91dC51bmlvbnxVbmlvbn1zIHRoYXQgc3VwcG9ydCBtdWx0aXBsZSB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dH5WYXJpYW50TGF5b3V0fHZhcmlhbnQgbGF5b3V0c30gb3ZlciBhIGZpeGVkXG4gKiAgIChwYWRkZWQpIG9yIHZhcmlhYmxlIChub3QgcGFkZGVkKSBzcGFuIG9mIGJ5dGVzLCB1c2luZyBhblxuICogICB1bnNpZ25lZCBpbnRlZ2VyIGF0IHRoZSBzdGFydCBvZiB0aGUgZGF0YSBvciBhIHNlcGFyYXRlIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0LnVuaW9uTGF5b3V0RGlzY3JpbWluYXRvcnxsYXlvdXQgZWxlbWVudH0gdG9cbiAqICAgZGV0ZXJtaW5lIHdoaWNoIGxheW91dCB0byB1c2Ugd2hlbiBpbnRlcnByZXRpbmcgdGhlIGJ1ZmZlclxuICogICBjb250ZW50cztcbiAqICoge0BsaW5rIG1vZHVsZTpMYXlvdXQuYml0c3xCaXRTdHJ1Y3R1cmV9cyB0aGF0IGNvbnRhaW4gYSBzZXF1ZW5jZVxuICogICBvZiBpbmRpdmlkdWFsIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0fkJpdFN0cnVjdHVyZSNhZGRGaWVsZHxCaXRGaWVsZH1zIHBhY2tlZCBpbnRvIGFuIDgsXG4gKiAgIDE2LCAyNCwgb3IgMzItYml0IHVuc2lnbmVkIGludGVnZXIgc3RhcnRpbmcgYXQgdGhlIGxlYXN0LSBvclxuICogICBtb3N0LXNpZ25pZmljYW50IGJpdDtcbiAqICoge0BsaW5rIG1vZHVsZTpMYXlvdXQuY3N0cnxDIHN0cmluZ3N9IG9mIHZhcnlpbmcgbGVuZ3RoO1xuICogKiB7QGxpbmsgbW9kdWxlOkxheW91dC5ibG9ifEJsb2JzfSBvZiBmaXhlZC0gb3IgdmFyaWFibGUte0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXR+QmxvYiNsZW5ndGh8bGVuZ3RofSByYXcgZGF0YS5cbiAqXG4gKiBBbGwge0BsaW5rIG1vZHVsZTpMYXlvdXR+TGF5b3V0fExheW91dH0gaW5zdGFuY2VzIGFyZSBpbW11dGFibGVcbiAqIGFmdGVyIGNvbnN0cnVjdGlvbiwgdG8gcHJldmVudCBpbnRlcm5hbCBzdGF0ZSBmcm9tIGJlY29taW5nXG4gKiBpbmNvbnNpc3RlbnQuXG4gKlxuICogQGxvY2FsIExheW91dFxuICogQGxvY2FsIEV4dGVybmFsTGF5b3V0XG4gKiBAbG9jYWwgR3JlZWR5Q291bnRcbiAqIEBsb2NhbCBPZmZzZXRMYXlvdXRcbiAqIEBsb2NhbCBVSW50XG4gKiBAbG9jYWwgVUludEJFXG4gKiBAbG9jYWwgSW50XG4gKiBAbG9jYWwgSW50QkVcbiAqIEBsb2NhbCBOZWFyVUludDY0XG4gKiBAbG9jYWwgTmVhclVJbnQ2NEJFXG4gKiBAbG9jYWwgTmVhckludDY0XG4gKiBAbG9jYWwgTmVhckludDY0QkVcbiAqIEBsb2NhbCBGbG9hdFxuICogQGxvY2FsIEZsb2F0QkVcbiAqIEBsb2NhbCBEb3VibGVcbiAqIEBsb2NhbCBEb3VibGVCRVxuICogQGxvY2FsIFNlcXVlbmNlXG4gKiBAbG9jYWwgU3RydWN0dXJlXG4gKiBAbG9jYWwgVW5pb25EaXNjcmltaW5hdG9yXG4gKiBAbG9jYWwgVW5pb25MYXlvdXREaXNjcmltaW5hdG9yXG4gKiBAbG9jYWwgVW5pb25cbiAqIEBsb2NhbCBWYXJpYW50TGF5b3V0XG4gKiBAbG9jYWwgQml0U3RydWN0dXJlXG4gKiBAbG9jYWwgQml0RmllbGRcbiAqIEBsb2NhbCBCb29sZWFuXG4gKiBAbG9jYWwgQmxvYlxuICogQGxvY2FsIENTdHJpbmdcbiAqIEBsb2NhbCBDb25zdGFudFxuICogQGxvY2FsIGJpbmRDb25zdHJ1Y3RvckxheW91dFxuICogQG1vZHVsZSBMYXlvdXRcbiAqIEBsaWNlbnNlIE1JVFxuICogQGF1dGhvciBQZXRlciBBLiBCaWdvdFxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3BhYmlnb3QvYnVmZmVyLWxheW91dHxidWZmZXItbGF5b3V0IG9uIEdpdEh1Yn1cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zMTYgPSBleHBvcnRzLnM4ID0gZXhwb3J0cy5udTY0YmUgPSBleHBvcnRzLnU0OGJlID0gZXhwb3J0cy51NDBiZSA9IGV4cG9ydHMudTMyYmUgPSBleHBvcnRzLnUyNGJlID0gZXhwb3J0cy51MTZiZSA9IGV4cG9ydHMubnU2NCA9IGV4cG9ydHMudTQ4ID0gZXhwb3J0cy51NDAgPSBleHBvcnRzLnUzMiA9IGV4cG9ydHMudTI0ID0gZXhwb3J0cy51MTYgPSBleHBvcnRzLnU4ID0gZXhwb3J0cy5vZmZzZXQgPSBleHBvcnRzLmdyZWVkeSA9IGV4cG9ydHMuQ29uc3RhbnQgPSBleHBvcnRzLlVURjggPSBleHBvcnRzLkNTdHJpbmcgPSBleHBvcnRzLkJsb2IgPSBleHBvcnRzLkJvb2xlYW4gPSBleHBvcnRzLkJpdEZpZWxkID0gZXhwb3J0cy5CaXRTdHJ1Y3R1cmUgPSBleHBvcnRzLlZhcmlhbnRMYXlvdXQgPSBleHBvcnRzLlVuaW9uID0gZXhwb3J0cy5VbmlvbkxheW91dERpc2NyaW1pbmF0b3IgPSBleHBvcnRzLlVuaW9uRGlzY3JpbWluYXRvciA9IGV4cG9ydHMuU3RydWN0dXJlID0gZXhwb3J0cy5TZXF1ZW5jZSA9IGV4cG9ydHMuRG91YmxlQkUgPSBleHBvcnRzLkRvdWJsZSA9IGV4cG9ydHMuRmxvYXRCRSA9IGV4cG9ydHMuRmxvYXQgPSBleHBvcnRzLk5lYXJJbnQ2NEJFID0gZXhwb3J0cy5OZWFySW50NjQgPSBleHBvcnRzLk5lYXJVSW50NjRCRSA9IGV4cG9ydHMuTmVhclVJbnQ2NCA9IGV4cG9ydHMuSW50QkUgPSBleHBvcnRzLkludCA9IGV4cG9ydHMuVUludEJFID0gZXhwb3J0cy5VSW50ID0gZXhwb3J0cy5PZmZzZXRMYXlvdXQgPSBleHBvcnRzLkdyZWVkeUNvdW50ID0gZXhwb3J0cy5FeHRlcm5hbExheW91dCA9IGV4cG9ydHMuYmluZENvbnN0cnVjdG9yTGF5b3V0ID0gZXhwb3J0cy5uYW1lV2l0aFByb3BlcnR5ID0gZXhwb3J0cy5MYXlvdXQgPSBleHBvcnRzLnVpbnQ4QXJyYXlUb0J1ZmZlciA9IGV4cG9ydHMuY2hlY2tVaW50OEFycmF5ID0gdm9pZCAwO1xuZXhwb3J0cy5jb25zdGFudCA9IGV4cG9ydHMudXRmOCA9IGV4cG9ydHMuY3N0ciA9IGV4cG9ydHMuYmxvYiA9IGV4cG9ydHMudW5pb25MYXlvdXREaXNjcmltaW5hdG9yID0gZXhwb3J0cy51bmlvbiA9IGV4cG9ydHMuc2VxID0gZXhwb3J0cy5iaXRzID0gZXhwb3J0cy5zdHJ1Y3QgPSBleHBvcnRzLmY2NGJlID0gZXhwb3J0cy5mNjQgPSBleHBvcnRzLmYzMmJlID0gZXhwb3J0cy5mMzIgPSBleHBvcnRzLm5zNjRiZSA9IGV4cG9ydHMuczQ4YmUgPSBleHBvcnRzLnM0MGJlID0gZXhwb3J0cy5zMzJiZSA9IGV4cG9ydHMuczI0YmUgPSBleHBvcnRzLnMxNmJlID0gZXhwb3J0cy5uczY0ID0gZXhwb3J0cy5zNDggPSBleHBvcnRzLnM0MCA9IGV4cG9ydHMuczMyID0gZXhwb3J0cy5zMjQgPSB2b2lkIDA7XG5jb25zdCBidWZmZXJfMSA9IHJlcXVpcmUoXCJidWZmZXJcIik7XG4vKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgVWludDhBcnJheS5cbiAqXG4gKiBAaWdub3JlICovXG5mdW5jdGlvbiBjaGVja1VpbnQ4QXJyYXkoYikge1xuICAgIGlmICghKGIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdiIG11c3QgYmUgYSBVaW50OEFycmF5Jyk7XG4gICAgfVxufVxuZXhwb3J0cy5jaGVja1VpbnQ4QXJyYXkgPSBjaGVja1VpbnQ4QXJyYXk7XG4vKiBDcmVhdGUgYSBCdWZmZXIgaW5zdGFuY2UgZnJvbSBhIFVpbnQ4QXJyYXkuXG4gKlxuICogQGlnbm9yZSAqL1xuZnVuY3Rpb24gdWludDhBcnJheVRvQnVmZmVyKGIpIHtcbiAgICBjaGVja1VpbnQ4QXJyYXkoYik7XG4gICAgcmV0dXJuIGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKGIuYnVmZmVyLCBiLmJ5dGVPZmZzZXQsIGIubGVuZ3RoKTtcbn1cbmV4cG9ydHMudWludDhBcnJheVRvQnVmZmVyID0gdWludDhBcnJheVRvQnVmZmVyO1xuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBsYXlvdXQgb2JqZWN0cy5cbiAqXG4gKiAqKk5PVEUqKiBUaGlzIGlzIGFuIGFic3RyYWN0IGJhc2UgY2xhc3M7IHlvdSBjYW4gY3JlYXRlIGluc3RhbmNlc1xuICogaWYgaXQgYW11c2VzIHlvdSwgYnV0IHRoZXkgd29uJ3Qgc3VwcG9ydCB0aGUge0BsaW5rXG4gKiBMYXlvdXQjZW5jb2RlfGVuY29kZX0gb3Ige0BsaW5rIExheW91dCNkZWNvZGV8ZGVjb2RlfSBmdW5jdGlvbnMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHNwYW4gLSBJbml0aWFsaXplciBmb3Ige0BsaW5rIExheW91dCNzcGFufHNwYW59LiAgVGhlXG4gKiBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBpbnRlZ2VyOyBhIG5lZ2F0aXZlIHZhbHVlIHNpZ25pZmllcyB0aGF0IHRoZVxuICogc3BhbiBpcyB7QGxpbmsgTGF5b3V0I2dldFNwYW58dmFsdWUtc3BlY2lmaWN9LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gSW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqL1xuY2xhc3MgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3RvcihzcGFuLCBwcm9wZXJ0eSkge1xuICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoc3BhbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NwYW4gbXVzdCBiZSBhbiBpbnRlZ2VyJyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIFRoZSBzcGFuIG9mIHRoZSBsYXlvdXQgaW4gYnl0ZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFBvc2l0aXZlIHZhbHVlcyBhcmUgZ2VuZXJhbGx5IGV4cGVjdGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBaZXJvIHdpbGwgb25seSBhcHBlYXIgaW4ge0BsaW5rIENvbnN0YW50fXMgYW5kIGluIHtAbGlua1xuICAgICAgICAgKiBTZXF1ZW5jZX1zIHdoZXJlIHRoZSB7QGxpbmsgU2VxdWVuY2UjY291bnR8Y291bnR9IGlzIHplcm8uXG4gICAgICAgICAqXG4gICAgICAgICAqIEEgbmVnYXRpdmUgdmFsdWUgaW5kaWNhdGVzIHRoYXQgdGhlIHNwYW4gaXMgdmFsdWUtc3BlY2lmaWMsIGFuZFxuICAgICAgICAgKiBtdXN0IGJlIG9idGFpbmVkIHVzaW5nIHtAbGluayBMYXlvdXQjZ2V0U3BhbnxnZXRTcGFufS4gKi9cbiAgICAgICAgdGhpcy5zcGFuID0gc3BhbjtcbiAgICAgICAgLyoqIFRoZSBwcm9wZXJ0eSBuYW1lIHVzZWQgd2hlbiB0aGlzIGxheW91dCBpcyByZXByZXNlbnRlZCBpbiBhblxuICAgICAgICAgKiBPYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIFVzZWQgb25seSBmb3IgbGF5b3V0cyB0aGF0IHtAbGluayBMYXlvdXQjZGVjb2RlfGRlY29kZX0gdG8gT2JqZWN0XG4gICAgICAgICAqIGluc3RhbmNlcy4gIElmIGxlZnQgdW5kZWZpbmVkIHRoZSBzcGFuIG9mIHRoZSB1bm5hbWVkIGxheW91dCB3aWxsXG4gICAgICAgICAqIGJlIHRyZWF0ZWQgYXMgcGFkZGluZzogaXQgd2lsbCBub3QgYmUgbXV0YXRlZCBieSB7QGxpbmtcbiAgICAgICAgICogTGF5b3V0I2VuY29kZXxlbmNvZGV9IG5vciByZXByZXNlbnRlZCBhcyBhIHByb3BlcnR5IGluIHRoZVxuICAgICAgICAgKiBkZWNvZGVkIE9iamVjdC4gKi9cbiAgICAgICAgdGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICAgIH1cbiAgICAvKiogRnVuY3Rpb24gdG8gY3JlYXRlIGFuIE9iamVjdCBpbnRvIHdoaWNoIGRlY29kZWQgcHJvcGVydGllcyB3aWxsXG4gICAgICogYmUgd3JpdHRlbi5cbiAgICAgKlxuICAgICAqIFVzZWQgb25seSBmb3IgbGF5b3V0cyB0aGF0IHtAbGluayBMYXlvdXQjZGVjb2RlfGRlY29kZX0gdG8gT2JqZWN0XG4gICAgICogaW5zdGFuY2VzLCB3aGljaCBtZWFuczpcbiAgICAgKiAqIHtAbGluayBTdHJ1Y3R1cmV9XG4gICAgICogKiB7QGxpbmsgVW5pb259XG4gICAgICogKiB7QGxpbmsgVmFyaWFudExheW91dH1cbiAgICAgKiAqIHtAbGluayBCaXRTdHJ1Y3R1cmV9XG4gICAgICpcbiAgICAgKiBJZiBsZWZ0IHVuZGVmaW5lZCB0aGUgSmF2YVNjcmlwdCByZXByZXNlbnRhdGlvbiBvZiB0aGVzZSBsYXlvdXRzXG4gICAgICogd2lsbCBiZSBPYmplY3QgaW5zdGFuY2VzLlxuICAgICAqXG4gICAgICogU2VlIHtAbGluayBiaW5kQ29uc3RydWN0b3JMYXlvdXR9LlxuICAgICAqL1xuICAgIG1ha2VEZXN0aW5hdGlvbk9iamVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIHNwYW4gb2YgYSBzcGVjaWZpYyBpbnN0YW5jZSBvZiBhIGxheW91dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gYiAtIHRoZSBidWZmZXIgdGhhdCBjb250YWlucyBhbiBlbmNvZGVkIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvZmZzZXRdIC0gdGhlIG9mZnNldCBhdCB3aGljaCB0aGUgZW5jb2RlZCBpbnN0YW5jZVxuICAgICAqIHN0YXJ0cy4gIElmIGFic2VudCBhIHplcm8gb2Zmc2V0IGlzIGluZmVycmVkLlxuICAgICAqXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAtIHRoZSBudW1iZXIgb2YgYnl0ZXMgY292ZXJlZCBieSB0aGUgbGF5b3V0XG4gICAgICogaW5zdGFuY2UuICBJZiB0aGlzIG1ldGhvZCBpcyBub3Qgb3ZlcnJpZGRlbiBpbiBhIHN1YmNsYXNzIHRoZVxuICAgICAqIGRlZmluaXRpb24tdGltZSBjb25zdGFudCB7QGxpbmsgTGF5b3V0I3NwYW58c3Bhbn0gd2lsbCBiZVxuICAgICAqIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gLSBpZiB0aGUgbGVuZ3RoIG9mIHRoZSB2YWx1ZSBjYW5ub3QgYmVcbiAgICAgKiBkZXRlcm1pbmVkLlxuICAgICAqL1xuICAgIGdldFNwYW4oYiwgb2Zmc2V0KSB7XG4gICAgICAgIGlmICgwID4gdGhpcy5zcGFuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignaW5kZXRlcm1pbmF0ZSBzcGFuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc3BhbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVwbGljYXRlIHRoZSBsYXlvdXQgdXNpbmcgYSBuZXcgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIG11c3QgYmUgdXNlZCB0byBnZXQgYSBzdHJ1Y3R1cmFsbHktZXF1aXZhbGVudCBsYXlvdXRcbiAgICAgKiB3aXRoIGEgZGlmZmVyZW50IG5hbWUgc2luY2UgYWxsIHtAbGluayBMYXlvdXR9IGluc3RhbmNlcyBhcmVcbiAgICAgKiBpbW11dGFibGUuXG4gICAgICpcbiAgICAgKiAqKk5PVEUqKiBUaGlzIGlzIGEgc2hhbGxvdyBjb3B5LiAgQWxsIGZpZWxkcyBleGNlcHQge0BsaW5rXG4gICAgICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fSBhcmUgc3RyaWN0bHkgZXF1YWwgdG8gdGhlIG9yaWdpbiBsYXlvdXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgLSB0aGUgdmFsdWUgZm9yIHtAbGlua1xuICAgICAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0gaW4gdGhlIHJlcGxpY2EuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7TGF5b3V0fSAtIHRoZSBjb3B5IHdpdGgge0BsaW5rIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX1cbiAgICAgKiBzZXQgdG8gYHByb3BlcnR5YC5cbiAgICAgKi9cbiAgICByZXBsaWNhdGUocHJvcGVydHkpIHtcbiAgICAgICAgY29uc3QgcnYgPSBPYmplY3QuY3JlYXRlKHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihydiwgdGhpcyk7XG4gICAgICAgIHJ2LnByb3BlcnR5ID0gcHJvcGVydHk7XG4gICAgICAgIHJldHVybiBydjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIG9iamVjdCBmcm9tIGxheW91dCBwcm9wZXJ0aWVzIGFuZCBhbiBhcnJheSBvZiB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiAqKk5PVEUqKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYHVuZGVmaW5lZGAgaWYgaW52b2tlZCBvbiBhIGxheW91dFxuICAgICAqIHRoYXQgZG9lcyBub3QgcmV0dXJuIGl0cyB2YWx1ZSBhcyBhbiBPYmplY3QuICBPYmplY3RzIGFyZVxuICAgICAqIHJldHVybmVkIGZvciB0aGluZ3MgdGhhdCBhcmUgYSB7QGxpbmsgU3RydWN0dXJlfSwgd2hpY2ggaW5jbHVkZXNcbiAgICAgKiB7QGxpbmsgVmFyaWFudExheW91dHx2YXJpYW50IGxheW91dHN9IGlmIHRoZXkgYXJlIHN0cnVjdHVyZXMsIGFuZFxuICAgICAqIGV4Y2x1ZGVzIHtAbGluayBVbmlvbn1zLiAgSWYgeW91IHdhbnQgdGhpcyBmZWF0dXJlIGZvciBhIHVuaW9uXG4gICAgICogeW91IG11c3QgdXNlIHtAbGluayBVbmlvbi5nZXRWYXJpYW50fGdldFZhcmlhbnR9IHRvIHNlbGVjdCB0aGVcbiAgICAgKiBkZXNpcmVkIGxheW91dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyAtIGFuIGFycmF5IG9mIHZhbHVlcyB0aGF0IGNvcnJlc3BvbmQgdG8gdGhlXG4gICAgICogZGVmYXVsdCBvcmRlciBmb3IgcHJvcGVydGllcy4gIEFzIHdpdGgge0BsaW5rIExheW91dCNkZWNvZGV8ZGVjb2RlfVxuICAgICAqIGxheW91dCBlbGVtZW50cyB0aGF0IGhhdmUgbm8gcHJvcGVydHkgbmFtZSBhcmUgc2tpcHBlZCB3aGVuXG4gICAgICogaXRlcmF0aW5nIG92ZXIgdGhlIGFycmF5IHZhbHVlcy4gIE9ubHkgdGhlIHRvcC1sZXZlbCBwcm9wZXJ0aWVzIGFyZVxuICAgICAqIGFzc2lnbmVkOyBhcmd1bWVudHMgYXJlIG5vdCBhc3NpZ25lZCB0byBwcm9wZXJ0aWVzIG9mIGNvbnRhaW5lZFxuICAgICAqIGxheW91dHMuICBBbnkgdW51c2VkIHZhbHVlcyBhcmUgaWdub3JlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4geyhPYmplY3R8dW5kZWZpbmVkKX1cbiAgICAgKi9cbiAgICBmcm9tQXJyYXkodmFsdWVzKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0cy5MYXlvdXQgPSBMYXlvdXQ7XG4vKiBQcm92aWRlIHRleHQgdGhhdCBjYXJyaWVzIGEgbmFtZSAoc3VjaCBhcyBmb3IgYSBmdW5jdGlvbiB0aGF0IHdpbGxcbiAqIGJlIHRocm93aW5nIGFuIGVycm9yKSBhbm5vdGF0ZWQgd2l0aCB0aGUgcHJvcGVydHkgb2YgYSBnaXZlbiBsYXlvdXRcbiAqIChzdWNoIGFzIG9uZSBmb3Igd2hpY2ggdGhlIHZhbHVlIHdhcyB1bmFjY2VwdGFibGUpLlxuICpcbiAqIEBpZ25vcmUgKi9cbmZ1bmN0aW9uIG5hbWVXaXRoUHJvcGVydHkobmFtZSwgbG8pIHtcbiAgICBpZiAobG8ucHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIG5hbWUgKyAnWycgKyBsby5wcm9wZXJ0eSArICddJztcbiAgICB9XG4gICAgcmV0dXJuIG5hbWU7XG59XG5leHBvcnRzLm5hbWVXaXRoUHJvcGVydHkgPSBuYW1lV2l0aFByb3BlcnR5O1xuLyoqXG4gKiBBdWdtZW50IGEgY2xhc3Mgc28gdGhhdCBpbnN0YW5jZXMgY2FuIGJlIGVuY29kZWQvZGVjb2RlZCB1c2luZyBhXG4gKiBnaXZlbiBsYXlvdXQuXG4gKlxuICogQ2FsbGluZyB0aGlzIGZ1bmN0aW9uIGNvdXBsZXMgYENsYXNzYCB3aXRoIGBsYXlvdXRgIGluIHNldmVyYWwgd2F5czpcbiAqXG4gKiAqIGBDbGFzcy5sYXlvdXRfYCBiZWNvbWVzIGEgc3RhdGljIG1lbWJlciBwcm9wZXJ0eSBlcXVhbCB0byBgbGF5b3V0YDtcbiAqICogYGxheW91dC5ib3VuZENvbnN0cnVjdG9yX2AgYmVjb21lcyBhIHN0YXRpYyBtZW1iZXIgcHJvcGVydHkgZXF1YWxcbiAqICAgIHRvIGBDbGFzc2A7XG4gKiAqIFRoZSB7QGxpbmsgTGF5b3V0I21ha2VEZXN0aW5hdGlvbk9iamVjdHxtYWtlRGVzdGluYXRpb25PYmplY3QoKX1cbiAqICAgcHJvcGVydHkgb2YgYGxheW91dGAgaXMgc2V0IHRvIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgYG5ld1xuICogICBDbGFzcygpYDtcbiAqICogYENsYXNzLmRlY29kZShiLCBvZmZzZXQpYCBiZWNvbWVzIGEgc3RhdGljIG1lbWJlciBmdW5jdGlvbiB0aGF0XG4gKiAgIGRlbGVnYXRlcyB0byB7QGxpbmsgTGF5b3V0I2RlY29kZXxsYXlvdXQuZGVjb2RlfS4gIFRoZVxuICogICBzeW50aGVzaXplZCBmdW5jdGlvbiBtYXkgYmUgY2FwdHVyZWQgYW5kIGV4dGVuZGVkLlxuICogKiBgQ2xhc3MucHJvdG90eXBlLmVuY29kZShiLCBvZmZzZXQpYCBwcm92aWRlcyBhbiBpbnN0YW5jZSBtZW1iZXJcbiAqICAgZnVuY3Rpb24gdGhhdCBkZWxlZ2F0ZXMgdG8ge0BsaW5rIExheW91dCNlbmNvZGV8bGF5b3V0LmVuY29kZX1cbiAqICAgd2l0aCBgc3JjYCBzZXQgdG8gYHRoaXNgLiAgVGhlIHN5bnRoZXNpemVkIGZ1bmN0aW9uIG1heSBiZVxuICogICBjYXB0dXJlZCBhbmQgZXh0ZW5kZWQsIGJ1dCB3aGVuIHRoZSBleHRlbnNpb24gaXMgaW52b2tlZCBgdGhpc2BcbiAqICAgbXVzdCBiZSBleHBsaWNpdGx5IGJvdW5kIHRvIHRoZSBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge2NsYXNzfSBDbGFzcyAtIGEgSmF2YVNjcmlwdCBjbGFzcyB3aXRoIGEgbnVsbGFyeVxuICogY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtMYXlvdXR9IGxheW91dCAtIHRoZSB7QGxpbmsgTGF5b3V0fSBpbnN0YW5jZSB1c2VkIHRvIGVuY29kZVxuICogaW5zdGFuY2VzIG9mIGBDbGFzc2AuXG4gKi9cbi8vIGBDbGFzc2AgbXVzdCBiZSBhIGNvbnN0cnVjdG9yIEZ1bmN0aW9uLCBidXQgdGhlIGFzc2lnbm1lbnQgb2YgYSBgbGF5b3V0X2AgcHJvcGVydHkgdG8gaXQgbWFrZXMgaXQgZGlmZmljdWx0IHRvIHR5cGVcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbW9kdWxlLWJvdW5kYXJ5LXR5cGVzXG5mdW5jdGlvbiBiaW5kQ29uc3RydWN0b3JMYXlvdXQoQ2xhc3MsIGxheW91dCkge1xuICAgIGlmICgnZnVuY3Rpb24nICE9PSB0eXBlb2YgQ2xhc3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2xhc3MgbXVzdCBiZSBjb25zdHJ1Y3RvcicpO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKENsYXNzLCAnbGF5b3V0XycpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2xhc3MgaXMgYWxyZWFkeSBib3VuZCB0byBhIGxheW91dCcpO1xuICAgIH1cbiAgICBpZiAoIShsYXlvdXQgJiYgKGxheW91dCBpbnN0YW5jZW9mIExheW91dCkpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xheW91dCBtdXN0IGJlIGEgTGF5b3V0Jyk7XG4gICAgfVxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobGF5b3V0LCAnYm91bmRDb25zdHJ1Y3Rvcl8nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xheW91dCBpcyBhbHJlYWR5IGJvdW5kIHRvIGEgY29uc3RydWN0b3InKTtcbiAgICB9XG4gICAgQ2xhc3MubGF5b3V0XyA9IGxheW91dDtcbiAgICBsYXlvdXQuYm91bmRDb25zdHJ1Y3Rvcl8gPSBDbGFzcztcbiAgICBsYXlvdXQubWFrZURlc3RpbmF0aW9uT2JqZWN0ID0gKCgpID0+IG5ldyBDbGFzcygpKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xhc3MucHJvdG90eXBlLCAnZW5jb2RlJywge1xuICAgICAgICB2YWx1ZShiLCBvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBsYXlvdXQuZW5jb2RlKHRoaXMsIGIsIG9mZnNldCk7XG4gICAgICAgIH0sXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDbGFzcywgJ2RlY29kZScsIHtcbiAgICAgICAgdmFsdWUoYiwgb2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gbGF5b3V0LmRlY29kZShiLCBvZmZzZXQpO1xuICAgICAgICB9LFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB9KTtcbn1cbmV4cG9ydHMuYmluZENvbnN0cnVjdG9yTGF5b3V0ID0gYmluZENvbnN0cnVjdG9yTGF5b3V0O1xuLyoqXG4gKiBBbiBvYmplY3QgdGhhdCBiZWhhdmVzIGxpa2UgYSBsYXlvdXQgYnV0IGRvZXMgbm90IGNvbnN1bWUgc3BhY2VcbiAqIHdpdGhpbiBpdHMgY29udGFpbmluZyBsYXlvdXQuXG4gKlxuICogVGhpcyBpcyBwcmltYXJpbHkgdXNlZCB0byBvYnRhaW4gbWV0YWRhdGEgYWJvdXQgYSBtZW1iZXIsIHN1Y2ggYXMgYVxuICoge0BsaW5rIE9mZnNldExheW91dH0gdGhhdCBjYW4gcHJvdmlkZSBkYXRhIGFib3V0IGEge0BsaW5rXG4gKiBMYXlvdXQjZ2V0U3Bhbnx2YWx1ZS1zcGVjaWZpYyBzcGFufS5cbiAqXG4gKiAqKk5PVEUqKiBUaGlzIGlzIGFuIGFic3RyYWN0IGJhc2UgY2xhc3M7IHlvdSBjYW4gY3JlYXRlIGluc3RhbmNlc1xuICogaWYgaXQgYW11c2VzIHlvdSwgYnV0IHRoZXkgd29uJ3Qgc3VwcG9ydCB7QGxpbmtcbiAqIEV4dGVybmFsTGF5b3V0I2lzQ291bnR8aXNDb3VudH0gb3Igb3RoZXIge0BsaW5rIExheW91dH0gZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBzcGFuIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGluayBMYXlvdXQjc3BhbnxzcGFufS5cbiAqIFRoZSBwYXJhbWV0ZXIgY2FuIHJhbmdlIGZyb20gMSB0aHJvdWdoIDYuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhYnN0cmFjdFxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIEV4dGVybmFsTGF5b3V0IGV4dGVuZHMgTGF5b3V0IHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYHRydWVgIGlmZiB0aGUgZXh0ZXJuYWwgbGF5b3V0IGRlY29kZXMgdG8gYW4gdW5zaWduZWRcbiAgICAgKiBpbnRlZ2VyIGxheW91dC5cbiAgICAgKlxuICAgICAqIEluIHRoYXQgY2FzZSBpdCBjYW4gYmUgdXNlZCBhcyB0aGUgc291cmNlIG9mIHtAbGlua1xuICAgICAqIFNlcXVlbmNlI2NvdW50fFNlcXVlbmNlIGNvdW50c30sIHtAbGluayBCbG9iI2xlbmd0aHxCbG9iIGxlbmd0aHN9LFxuICAgICAqIG9yIGFzIHtAbGluayBVbmlvbkxheW91dERpc2NyaW1pbmF0b3IjbGF5b3V0fGV4dGVybmFsIHVuaW9uXG4gICAgICogZGlzY3JpbWluYXRvcnN9LlxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgaXNDb3VudCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHRlcm5hbExheW91dCBpcyBhYnN0cmFjdCcpO1xuICAgIH1cbn1cbmV4cG9ydHMuRXh0ZXJuYWxMYXlvdXQgPSBFeHRlcm5hbExheW91dDtcbi8qKlxuICogQW4ge0BsaW5rIEV4dGVybmFsTGF5b3V0fSB0aGF0IGRldGVybWluZXMgaXRzIHtAbGlua1xuICogTGF5b3V0I2RlY29kZXx2YWx1ZX0gYmFzZWQgb24gb2Zmc2V0IGludG8gYW5kIGxlbmd0aCBvZiB0aGUgYnVmZmVyXG4gKiBvbiB3aGljaCBpdCBpcyBpbnZva2VkLlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQuZ3JlZWR5fGdyZWVkeX1cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gW2VsZW1lbnRTcGFuXSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIEdyZWVkeUNvdW50I2VsZW1lbnRTcGFufGVsZW1lbnRTcGFufS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtFeHRlcm5hbExheW91dH1cbiAqL1xuY2xhc3MgR3JlZWR5Q291bnQgZXh0ZW5kcyBFeHRlcm5hbExheW91dCB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudFNwYW4gPSAxLCBwcm9wZXJ0eSkge1xuICAgICAgICBpZiAoKCFOdW1iZXIuaXNJbnRlZ2VyKGVsZW1lbnRTcGFuKSkgfHwgKDAgPj0gZWxlbWVudFNwYW4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbGVtZW50U3BhbiBtdXN0IGJlIGEgKHBvc2l0aXZlKSBpbnRlZ2VyJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoLTEsIHByb3BlcnR5KTtcbiAgICAgICAgLyoqIFRoZSBsYXlvdXQgZm9yIGluZGl2aWR1YWwgZWxlbWVudHMgb2YgdGhlIHNlcXVlbmNlLiAgVGhlIHZhbHVlXG4gICAgICAgICAqIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLiAgSWYgbm90IHByb3ZpZGVkLCB0aGUgdmFsdWUgd2lsbCBiZVxuICAgICAgICAgKiAxLiAqL1xuICAgICAgICB0aGlzLmVsZW1lbnRTcGFuID0gZWxlbWVudFNwYW47XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBpc0NvdW50KCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNoZWNrVWludDhBcnJheShiKTtcbiAgICAgICAgY29uc3QgcmVtID0gYi5sZW5ndGggLSBvZmZzZXQ7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHJlbSAvIHRoaXMuZWxlbWVudFNwYW4pO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbn1cbmV4cG9ydHMuR3JlZWR5Q291bnQgPSBHcmVlZHlDb3VudDtcbi8qKlxuICogQW4ge0BsaW5rIEV4dGVybmFsTGF5b3V0fSB0aGF0IHN1cHBvcnRzIGFjY2Vzc2luZyBhIHtAbGluayBMYXlvdXR9XG4gKiBhdCBhIGZpeGVkIG9mZnNldCBmcm9tIHRoZSBzdGFydCBvZiBhbm90aGVyIExheW91dC4gIFRoZSBvZmZzZXQgbWF5XG4gKiBiZSBiZWZvcmUsIHdpdGhpbiwgb3IgYWZ0ZXIgdGhlIGJhc2UgbGF5b3V0LlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQub2Zmc2V0fG9mZnNldH1cbiAqXG4gKiBAcGFyYW0ge0xheW91dH0gbGF5b3V0IC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogT2Zmc2V0TGF5b3V0I2xheW91dHxsYXlvdXR9LCBtb2R1bG8gYHByb3BlcnR5YC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gW29mZnNldF0gLSBJbml0aWFsaXplcyB7QGxpbmtcbiAqIE9mZnNldExheW91dCNvZmZzZXR8b2Zmc2V0fS4gIERlZmF1bHRzIHRvIHplcm8uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBPcHRpb25hbCBuZXcgcHJvcGVydHkgbmFtZSBmb3IgYVxuICoge0BsaW5rIExheW91dCNyZXBsaWNhdGV8IHJlcGxpY2F9IG9mIGBsYXlvdXRgIHRvIGJlIHVzZWQgYXMge0BsaW5rXG4gKiBPZmZzZXRMYXlvdXQjbGF5b3V0fGxheW91dH0uICBJZiBub3QgcHJvdmlkZWQgdGhlIGBsYXlvdXRgIGlzIHVzZWRcbiAqIHVuY2hhbmdlZC5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgT2Zmc2V0TGF5b3V0IGV4dGVuZHMgRXh0ZXJuYWxMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKGxheW91dCwgb2Zmc2V0ID0gMCwgcHJvcGVydHkpIHtcbiAgICAgICAgaWYgKCEobGF5b3V0IGluc3RhbmNlb2YgTGF5b3V0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbGF5b3V0IG11c3QgYmUgYSBMYXlvdXQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIob2Zmc2V0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb2Zmc2V0IG11c3QgYmUgaW50ZWdlciBvciB1bmRlZmluZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihsYXlvdXQuc3BhbiwgcHJvcGVydHkgfHwgbGF5b3V0LnByb3BlcnR5KTtcbiAgICAgICAgLyoqIFRoZSBzdWJvcmRpbmF0ZWQgbGF5b3V0LiAqL1xuICAgICAgICB0aGlzLmxheW91dCA9IGxheW91dDtcbiAgICAgICAgLyoqIFRoZSBsb2NhdGlvbiBvZiB7QGxpbmsgT2Zmc2V0TGF5b3V0I2xheW91dH0gcmVsYXRpdmUgdG8gdGhlXG4gICAgICAgICAqIHN0YXJ0IG9mIGFub3RoZXIgbGF5b3V0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgdmFsdWUgbWF5IGJlIHBvc2l0aXZlIG9yIG5lZ2F0aXZlLCBidXQgYW4gZXJyb3Igd2lsbCB0aHJvd25cbiAgICAgICAgICogaWYgYXQgdGhlIHBvaW50IG9mIHVzZSBpdCBnb2VzIG91dHNpZGUgdGhlIHNwYW4gb2YgdGhlIFVpbnQ4QXJyYXlcbiAgICAgICAgICogYmVpbmcgYWNjZXNzZWQuICAqL1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGlzQ291bnQoKSB7XG4gICAgICAgIHJldHVybiAoKHRoaXMubGF5b3V0IGluc3RhbmNlb2YgVUludClcbiAgICAgICAgICAgIHx8ICh0aGlzLmxheW91dCBpbnN0YW5jZW9mIFVJbnRCRSkpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5b3V0LmRlY29kZShiLCBvZmZzZXQgKyB0aGlzLm9mZnNldCk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxheW91dC5lbmNvZGUoc3JjLCBiLCBvZmZzZXQgKyB0aGlzLm9mZnNldCk7XG4gICAgfVxufVxuZXhwb3J0cy5PZmZzZXRMYXlvdXQgPSBPZmZzZXRMYXlvdXQ7XG4vKipcbiAqIFJlcHJlc2VudCBhbiB1bnNpZ25lZCBpbnRlZ2VyIGluIGxpdHRsZS1lbmRpYW4gZm9ybWF0LlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQudTh8dTh9LCB7QGxpbmtcbiAqICBtb2R1bGU6TGF5b3V0LnUxNnx1MTZ9LCB7QGxpbmsgbW9kdWxlOkxheW91dC51MjR8dTI0fSwge0BsaW5rXG4gKiAgbW9kdWxlOkxheW91dC51MzJ8dTMyfSwge0BsaW5rIG1vZHVsZTpMYXlvdXQudTQwfHU0MH0sIHtAbGlua1xuICogIG1vZHVsZTpMYXlvdXQudTQ4fHU0OH1cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gc3BhbiAtIGluaXRpYWxpemVyIGZvciB7QGxpbmsgTGF5b3V0I3NwYW58c3Bhbn0uXG4gKiBUaGUgcGFyYW1ldGVyIGNhbiByYW5nZSBmcm9tIDEgdGhyb3VnaCA2LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgVUludCBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3Ioc3BhbiwgcHJvcGVydHkpIHtcbiAgICAgICAgc3VwZXIoc3BhbiwgcHJvcGVydHkpO1xuICAgICAgICBpZiAoNiA8IHRoaXMuc3Bhbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NwYW4gbXVzdCBub3QgZXhjZWVkIDYgYnl0ZXMnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgcmV0dXJuIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKS5yZWFkVUludExFKG9mZnNldCwgdGhpcy5zcGFuKTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgdWludDhBcnJheVRvQnVmZmVyKGIpLndyaXRlVUludExFKHNyYywgb2Zmc2V0LCB0aGlzLnNwYW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5zcGFuO1xuICAgIH1cbn1cbmV4cG9ydHMuVUludCA9IFVJbnQ7XG4vKipcbiAqIFJlcHJlc2VudCBhbiB1bnNpZ25lZCBpbnRlZ2VyIGluIGJpZy1lbmRpYW4gZm9ybWF0LlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQudThiZXx1OGJlfSwge0BsaW5rXG4gKiBtb2R1bGU6TGF5b3V0LnUxNmJlfHUxNmJlfSwge0BsaW5rIG1vZHVsZTpMYXlvdXQudTI0YmV8dTI0YmV9LFxuICoge0BsaW5rIG1vZHVsZTpMYXlvdXQudTMyYmV8dTMyYmV9LCB7QGxpbmtcbiAqIG1vZHVsZTpMYXlvdXQudTQwYmV8dTQwYmV9LCB7QGxpbmsgbW9kdWxlOkxheW91dC51NDhiZXx1NDhiZX1cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gc3BhbiAtIGluaXRpYWxpemVyIGZvciB7QGxpbmsgTGF5b3V0I3NwYW58c3Bhbn0uXG4gKiBUaGUgcGFyYW1ldGVyIGNhbiByYW5nZSBmcm9tIDEgdGhyb3VnaCA2LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgVUludEJFIGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3RvcihzcGFuLCBwcm9wZXJ0eSkge1xuICAgICAgICBzdXBlcihzcGFuLCBwcm9wZXJ0eSk7XG4gICAgICAgIGlmICg2IDwgdGhpcy5zcGFuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc3BhbiBtdXN0IG5vdCBleGNlZWQgNiBieXRlcycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICByZXR1cm4gdWludDhBcnJheVRvQnVmZmVyKGIpLnJlYWRVSW50QkUob2Zmc2V0LCB0aGlzLnNwYW4pO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICB1aW50OEFycmF5VG9CdWZmZXIoYikud3JpdGVVSW50QkUoc3JjLCBvZmZzZXQsIHRoaXMuc3Bhbik7XG4gICAgICAgIHJldHVybiB0aGlzLnNwYW47XG4gICAgfVxufVxuZXhwb3J0cy5VSW50QkUgPSBVSW50QkU7XG4vKipcbiAqIFJlcHJlc2VudCBhIHNpZ25lZCBpbnRlZ2VyIGluIGxpdHRsZS1lbmRpYW4gZm9ybWF0LlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQuczh8czh9LCB7QGxpbmtcbiAqICBtb2R1bGU6TGF5b3V0LnMxNnxzMTZ9LCB7QGxpbmsgbW9kdWxlOkxheW91dC5zMjR8czI0fSwge0BsaW5rXG4gKiAgbW9kdWxlOkxheW91dC5zMzJ8czMyfSwge0BsaW5rIG1vZHVsZTpMYXlvdXQuczQwfHM0MH0sIHtAbGlua1xuICogIG1vZHVsZTpMYXlvdXQuczQ4fHM0OH1cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gc3BhbiAtIGluaXRpYWxpemVyIGZvciB7QGxpbmsgTGF5b3V0I3NwYW58c3Bhbn0uXG4gKiBUaGUgcGFyYW1ldGVyIGNhbiByYW5nZSBmcm9tIDEgdGhyb3VnaCA2LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgSW50IGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3RvcihzcGFuLCBwcm9wZXJ0eSkge1xuICAgICAgICBzdXBlcihzcGFuLCBwcm9wZXJ0eSk7XG4gICAgICAgIGlmICg2IDwgdGhpcy5zcGFuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc3BhbiBtdXN0IG5vdCBleGNlZWQgNiBieXRlcycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICByZXR1cm4gdWludDhBcnJheVRvQnVmZmVyKGIpLnJlYWRJbnRMRShvZmZzZXQsIHRoaXMuc3Bhbik7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKS53cml0ZUludExFKHNyYywgb2Zmc2V0LCB0aGlzLnNwYW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5zcGFuO1xuICAgIH1cbn1cbmV4cG9ydHMuSW50ID0gSW50O1xuLyoqXG4gKiBSZXByZXNlbnQgYSBzaWduZWQgaW50ZWdlciBpbiBiaWctZW5kaWFuIGZvcm1hdC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LnM4YmV8czhiZX0sIHtAbGlua1xuICogbW9kdWxlOkxheW91dC5zMTZiZXxzMTZiZX0sIHtAbGluayBtb2R1bGU6TGF5b3V0LnMyNGJlfHMyNGJlfSxcbiAqIHtAbGluayBtb2R1bGU6TGF5b3V0LnMzMmJlfHMzMmJlfSwge0BsaW5rXG4gKiBtb2R1bGU6TGF5b3V0LnM0MGJlfHM0MGJlfSwge0BsaW5rIG1vZHVsZTpMYXlvdXQuczQ4YmV8czQ4YmV9XG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHNwYW4gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rIExheW91dCNzcGFufHNwYW59LlxuICogVGhlIHBhcmFtZXRlciBjYW4gcmFuZ2UgZnJvbSAxIHRocm91Z2ggNi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIEludEJFIGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3RvcihzcGFuLCBwcm9wZXJ0eSkge1xuICAgICAgICBzdXBlcihzcGFuLCBwcm9wZXJ0eSk7XG4gICAgICAgIGlmICg2IDwgdGhpcy5zcGFuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc3BhbiBtdXN0IG5vdCBleGNlZWQgNiBieXRlcycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICByZXR1cm4gdWludDhBcnJheVRvQnVmZmVyKGIpLnJlYWRJbnRCRShvZmZzZXQsIHRoaXMuc3Bhbik7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKS53cml0ZUludEJFKHNyYywgb2Zmc2V0LCB0aGlzLnNwYW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5zcGFuO1xuICAgIH1cbn1cbmV4cG9ydHMuSW50QkUgPSBJbnRCRTtcbmNvbnN0IFYyRTMyID0gTWF0aC5wb3coMiwgMzIpO1xuLyogVHJ1ZSBtb2R1bHVzIGhpZ2ggYW5kIGxvdyAzMi1iaXQgd29yZHMsIHdoZXJlIGxvdyB3b3JkIGlzIGFsd2F5c1xuICogbm9uLW5lZ2F0aXZlLiAqL1xuZnVuY3Rpb24gZGl2bW9kSW50NjQoc3JjKSB7XG4gICAgY29uc3QgaGkzMiA9IE1hdGguZmxvb3Ioc3JjIC8gVjJFMzIpO1xuICAgIGNvbnN0IGxvMzIgPSBzcmMgLSAoaGkzMiAqIFYyRTMyKTtcbiAgICByZXR1cm4geyBoaTMyLCBsbzMyIH07XG59XG4vKiBSZWNvbnN0cnVjdCBOdW1iZXIgZnJvbSBxdW90aWVudCBhbmQgbm9uLW5lZ2F0aXZlIHJlbWFpbmRlciAqL1xuZnVuY3Rpb24gcm91bmRlZEludDY0KGhpMzIsIGxvMzIpIHtcbiAgICByZXR1cm4gaGkzMiAqIFYyRTMyICsgbG8zMjtcbn1cbi8qKlxuICogUmVwcmVzZW50IGFuIHVuc2lnbmVkIDY0LWJpdCBpbnRlZ2VyIGluIGxpdHRsZS1lbmRpYW4gZm9ybWF0IHdoZW5cbiAqIGVuY29kZWQgYW5kIGFzIGEgbmVhciBpbnRlZ3JhbCBKYXZhU2NyaXB0IE51bWJlciB3aGVuIGRlY29kZWQuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5udTY0fG51NjR9XG4gKlxuICogKipOT1RFKiogVmFsdWVzIHdpdGggbWFnbml0dWRlIGdyZWF0ZXIgdGhhbiAyXjUyIG1heSBub3QgZGVjb2RlIHRvXG4gKiB0aGUgZXhhY3QgdmFsdWUgb2YgdGhlIGVuY29kZWQgcmVwcmVzZW50YXRpb24uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIE5lYXJVSW50NjQgZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BlcnR5KSB7XG4gICAgICAgIHN1cGVyKDgsIHByb3BlcnR5KTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHVpbnQ4QXJyYXlUb0J1ZmZlcihiKTtcbiAgICAgICAgY29uc3QgbG8zMiA9IGJ1ZmZlci5yZWFkVUludDMyTEUob2Zmc2V0KTtcbiAgICAgICAgY29uc3QgaGkzMiA9IGJ1ZmZlci5yZWFkVUludDMyTEUob2Zmc2V0ICsgNCk7XG4gICAgICAgIHJldHVybiByb3VuZGVkSW50NjQoaGkzMiwgbG8zMik7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNvbnN0IHNwbGl0ID0gZGl2bW9kSW50NjQoc3JjKTtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gdWludDhBcnJheVRvQnVmZmVyKGIpO1xuICAgICAgICBidWZmZXIud3JpdGVVSW50MzJMRShzcGxpdC5sbzMyLCBvZmZzZXQpO1xuICAgICAgICBidWZmZXIud3JpdGVVSW50MzJMRShzcGxpdC5oaTMyLCBvZmZzZXQgKyA0KTtcbiAgICAgICAgcmV0dXJuIDg7XG4gICAgfVxufVxuZXhwb3J0cy5OZWFyVUludDY0ID0gTmVhclVJbnQ2NDtcbi8qKlxuICogUmVwcmVzZW50IGFuIHVuc2lnbmVkIDY0LWJpdCBpbnRlZ2VyIGluIGJpZy1lbmRpYW4gZm9ybWF0IHdoZW5cbiAqIGVuY29kZWQgYW5kIGFzIGEgbmVhciBpbnRlZ3JhbCBKYXZhU2NyaXB0IE51bWJlciB3aGVuIGRlY29kZWQuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5udTY0YmV8bnU2NGJlfVxuICpcbiAqICoqTk9URSoqIFZhbHVlcyB3aXRoIG1hZ25pdHVkZSBncmVhdGVyIHRoYW4gMl41MiBtYXkgbm90IGRlY29kZSB0b1xuICogdGhlIGV4YWN0IHZhbHVlIG9mIHRoZSBlbmNvZGVkIHJlcHJlc2VudGF0aW9uLlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBOZWFyVUludDY0QkUgZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BlcnR5KSB7XG4gICAgICAgIHN1cGVyKDgsIHByb3BlcnR5KTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHVpbnQ4QXJyYXlUb0J1ZmZlcihiKTtcbiAgICAgICAgY29uc3QgaGkzMiA9IGJ1ZmZlci5yZWFkVUludDMyQkUob2Zmc2V0KTtcbiAgICAgICAgY29uc3QgbG8zMiA9IGJ1ZmZlci5yZWFkVUludDMyQkUob2Zmc2V0ICsgNCk7XG4gICAgICAgIHJldHVybiByb3VuZGVkSW50NjQoaGkzMiwgbG8zMik7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNvbnN0IHNwbGl0ID0gZGl2bW9kSW50NjQoc3JjKTtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gdWludDhBcnJheVRvQnVmZmVyKGIpO1xuICAgICAgICBidWZmZXIud3JpdGVVSW50MzJCRShzcGxpdC5oaTMyLCBvZmZzZXQpO1xuICAgICAgICBidWZmZXIud3JpdGVVSW50MzJCRShzcGxpdC5sbzMyLCBvZmZzZXQgKyA0KTtcbiAgICAgICAgcmV0dXJuIDg7XG4gICAgfVxufVxuZXhwb3J0cy5OZWFyVUludDY0QkUgPSBOZWFyVUludDY0QkU7XG4vKipcbiAqIFJlcHJlc2VudCBhIHNpZ25lZCA2NC1iaXQgaW50ZWdlciBpbiBsaXR0bGUtZW5kaWFuIGZvcm1hdCB3aGVuXG4gKiBlbmNvZGVkIGFuZCBhcyBhIG5lYXIgaW50ZWdyYWwgSmF2YVNjcmlwdCBOdW1iZXIgd2hlbiBkZWNvZGVkLlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQubnM2NHxuczY0fVxuICpcbiAqICoqTk9URSoqIFZhbHVlcyB3aXRoIG1hZ25pdHVkZSBncmVhdGVyIHRoYW4gMl41MiBtYXkgbm90IGRlY29kZSB0b1xuICogdGhlIGV4YWN0IHZhbHVlIG9mIHRoZSBlbmNvZGVkIHJlcHJlc2VudGF0aW9uLlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBOZWFySW50NjQgZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BlcnR5KSB7XG4gICAgICAgIHN1cGVyKDgsIHByb3BlcnR5KTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHVpbnQ4QXJyYXlUb0J1ZmZlcihiKTtcbiAgICAgICAgY29uc3QgbG8zMiA9IGJ1ZmZlci5yZWFkVUludDMyTEUob2Zmc2V0KTtcbiAgICAgICAgY29uc3QgaGkzMiA9IGJ1ZmZlci5yZWFkSW50MzJMRShvZmZzZXQgKyA0KTtcbiAgICAgICAgcmV0dXJuIHJvdW5kZWRJbnQ2NChoaTMyLCBsbzMyKTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY29uc3Qgc3BsaXQgPSBkaXZtb2RJbnQ2NChzcmMpO1xuICAgICAgICBjb25zdCBidWZmZXIgPSB1aW50OEFycmF5VG9CdWZmZXIoYik7XG4gICAgICAgIGJ1ZmZlci53cml0ZVVJbnQzMkxFKHNwbGl0LmxvMzIsIG9mZnNldCk7XG4gICAgICAgIGJ1ZmZlci53cml0ZUludDMyTEUoc3BsaXQuaGkzMiwgb2Zmc2V0ICsgNCk7XG4gICAgICAgIHJldHVybiA4O1xuICAgIH1cbn1cbmV4cG9ydHMuTmVhckludDY0ID0gTmVhckludDY0O1xuLyoqXG4gKiBSZXByZXNlbnQgYSBzaWduZWQgNjQtYml0IGludGVnZXIgaW4gYmlnLWVuZGlhbiBmb3JtYXQgd2hlblxuICogZW5jb2RlZCBhbmQgYXMgYSBuZWFyIGludGVncmFsIEphdmFTY3JpcHQgTnVtYmVyIHdoZW4gZGVjb2RlZC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0Lm5zNjRiZXxuczY0YmV9XG4gKlxuICogKipOT1RFKiogVmFsdWVzIHdpdGggbWFnbml0dWRlIGdyZWF0ZXIgdGhhbiAyXjUyIG1heSBub3QgZGVjb2RlIHRvXG4gKiB0aGUgZXhhY3QgdmFsdWUgb2YgdGhlIGVuY29kZWQgcmVwcmVzZW50YXRpb24uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIE5lYXJJbnQ2NEJFIGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eSkge1xuICAgICAgICBzdXBlcig4LCBwcm9wZXJ0eSk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjb25zdCBidWZmZXIgPSB1aW50OEFycmF5VG9CdWZmZXIoYik7XG4gICAgICAgIGNvbnN0IGhpMzIgPSBidWZmZXIucmVhZEludDMyQkUob2Zmc2V0KTtcbiAgICAgICAgY29uc3QgbG8zMiA9IGJ1ZmZlci5yZWFkVUludDMyQkUob2Zmc2V0ICsgNCk7XG4gICAgICAgIHJldHVybiByb3VuZGVkSW50NjQoaGkzMiwgbG8zMik7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNvbnN0IHNwbGl0ID0gZGl2bW9kSW50NjQoc3JjKTtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gdWludDhBcnJheVRvQnVmZmVyKGIpO1xuICAgICAgICBidWZmZXIud3JpdGVJbnQzMkJFKHNwbGl0LmhpMzIsIG9mZnNldCk7XG4gICAgICAgIGJ1ZmZlci53cml0ZVVJbnQzMkJFKHNwbGl0LmxvMzIsIG9mZnNldCArIDQpO1xuICAgICAgICByZXR1cm4gODtcbiAgICB9XG59XG5leHBvcnRzLk5lYXJJbnQ2NEJFID0gTmVhckludDY0QkU7XG4vKipcbiAqIFJlcHJlc2VudCBhIDMyLWJpdCBmbG9hdGluZyBwb2ludCBudW1iZXIgaW4gbGl0dGxlLWVuZGlhbiBmb3JtYXQuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5mMzJ8ZjMyfVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgRmxvYXQgZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BlcnR5KSB7XG4gICAgICAgIHN1cGVyKDQsIHByb3BlcnR5KTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHJldHVybiB1aW50OEFycmF5VG9CdWZmZXIoYikucmVhZEZsb2F0TEUob2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgdWludDhBcnJheVRvQnVmZmVyKGIpLndyaXRlRmxvYXRMRShzcmMsIG9mZnNldCk7XG4gICAgICAgIHJldHVybiA0O1xuICAgIH1cbn1cbmV4cG9ydHMuRmxvYXQgPSBGbG9hdDtcbi8qKlxuICogUmVwcmVzZW50IGEgMzItYml0IGZsb2F0aW5nIHBvaW50IG51bWJlciBpbiBiaWctZW5kaWFuIGZvcm1hdC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LmYzMmJlfGYzMmJlfVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgRmxvYXRCRSBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3IocHJvcGVydHkpIHtcbiAgICAgICAgc3VwZXIoNCwgcHJvcGVydHkpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgcmV0dXJuIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKS5yZWFkRmxvYXRCRShvZmZzZXQpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICB1aW50OEFycmF5VG9CdWZmZXIoYikud3JpdGVGbG9hdEJFKHNyYywgb2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIDQ7XG4gICAgfVxufVxuZXhwb3J0cy5GbG9hdEJFID0gRmxvYXRCRTtcbi8qKlxuICogUmVwcmVzZW50IGEgNjQtYml0IGZsb2F0aW5nIHBvaW50IG51bWJlciBpbiBsaXR0bGUtZW5kaWFuIGZvcm1hdC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LmY2NHxmNjR9XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBEb3VibGUgZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BlcnR5KSB7XG4gICAgICAgIHN1cGVyKDgsIHByb3BlcnR5KTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHJldHVybiB1aW50OEFycmF5VG9CdWZmZXIoYikucmVhZERvdWJsZUxFKG9mZnNldCk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKS53cml0ZURvdWJsZUxFKHNyYywgb2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIDg7XG4gICAgfVxufVxuZXhwb3J0cy5Eb3VibGUgPSBEb3VibGU7XG4vKipcbiAqIFJlcHJlc2VudCBhIDY0LWJpdCBmbG9hdGluZyBwb2ludCBudW1iZXIgaW4gYmlnLWVuZGlhbiBmb3JtYXQuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5mNjRiZXxmNjRiZX1cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIERvdWJsZUJFIGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eSkge1xuICAgICAgICBzdXBlcig4LCBwcm9wZXJ0eSk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICByZXR1cm4gdWludDhBcnJheVRvQnVmZmVyKGIpLnJlYWREb3VibGVCRShvZmZzZXQpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICB1aW50OEFycmF5VG9CdWZmZXIoYikud3JpdGVEb3VibGVCRShzcmMsIG9mZnNldCk7XG4gICAgICAgIHJldHVybiA4O1xuICAgIH1cbn1cbmV4cG9ydHMuRG91YmxlQkUgPSBEb3VibGVCRTtcbi8qKlxuICogUmVwcmVzZW50IGEgY29udGlndW91cyBzZXF1ZW5jZSBvZiBhIHNwZWNpZmljIGxheW91dCBhcyBhbiBBcnJheS5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LnNlcXxzZXF9XG4gKlxuICogQHBhcmFtIHtMYXlvdXR9IGVsZW1lbnRMYXlvdXQgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBTZXF1ZW5jZSNlbGVtZW50TGF5b3V0fGVsZW1lbnRMYXlvdXR9LlxuICpcbiAqIEBwYXJhbSB7KE51bWJlcnxFeHRlcm5hbExheW91dCl9IGNvdW50IC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogU2VxdWVuY2UjY291bnR8Y291bnR9LiAgVGhlIHBhcmFtZXRlciBtdXN0IGJlIGVpdGhlciBhIHBvc2l0aXZlXG4gKiBpbnRlZ2VyIG9yIGFuIGluc3RhbmNlIG9mIHtAbGluayBFeHRlcm5hbExheW91dH0uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBTZXF1ZW5jZSBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudExheW91dCwgY291bnQsIHByb3BlcnR5KSB7XG4gICAgICAgIGlmICghKGVsZW1lbnRMYXlvdXQgaW5zdGFuY2VvZiBMYXlvdXQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbGVtZW50TGF5b3V0IG11c3QgYmUgYSBMYXlvdXQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISgoKGNvdW50IGluc3RhbmNlb2YgRXh0ZXJuYWxMYXlvdXQpICYmIGNvdW50LmlzQ291bnQoKSlcbiAgICAgICAgICAgIHx8IChOdW1iZXIuaXNJbnRlZ2VyKGNvdW50KSAmJiAoMCA8PSBjb3VudCkpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY291bnQgbXVzdCBiZSBub24tbmVnYXRpdmUgaW50ZWdlciAnXG4gICAgICAgICAgICAgICAgKyAnb3IgYW4gdW5zaWduZWQgaW50ZWdlciBFeHRlcm5hbExheW91dCcpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzcGFuID0gLTE7XG4gICAgICAgIGlmICgoIShjb3VudCBpbnN0YW5jZW9mIEV4dGVybmFsTGF5b3V0KSlcbiAgICAgICAgICAgICYmICgwIDwgZWxlbWVudExheW91dC5zcGFuKSkge1xuICAgICAgICAgICAgc3BhbiA9IGNvdW50ICogZWxlbWVudExheW91dC5zcGFuO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKHNwYW4sIHByb3BlcnR5KTtcbiAgICAgICAgLyoqIFRoZSBsYXlvdXQgZm9yIGluZGl2aWR1YWwgZWxlbWVudHMgb2YgdGhlIHNlcXVlbmNlLiAqL1xuICAgICAgICB0aGlzLmVsZW1lbnRMYXlvdXQgPSBlbGVtZW50TGF5b3V0O1xuICAgICAgICAvKiogVGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgc2VxdWVuY2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgd2lsbCBiZSBlaXRoZXIgYSBub24tbmVnYXRpdmUgaW50ZWdlciBvciBhbiBpbnN0YW5jZSBvZlxuICAgICAgICAgKiB7QGxpbmsgRXh0ZXJuYWxMYXlvdXR9IGZvciB3aGljaCB7QGxpbmtcbiAgICAgICAgICogRXh0ZXJuYWxMYXlvdXQjaXNDb3VudHxpc0NvdW50KCl9IGlzIGB0cnVlYC4gKi9cbiAgICAgICAgdGhpcy5jb3VudCA9IGNvdW50O1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZ2V0U3BhbihiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGlmICgwIDw9IHRoaXMuc3Bhbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3BhbjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3BhbiA9IDA7XG4gICAgICAgIGxldCBjb3VudCA9IHRoaXMuY291bnQ7XG4gICAgICAgIGlmIChjb3VudCBpbnN0YW5jZW9mIEV4dGVybmFsTGF5b3V0KSB7XG4gICAgICAgICAgICBjb3VudCA9IGNvdW50LmRlY29kZShiLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgwIDwgdGhpcy5lbGVtZW50TGF5b3V0LnNwYW4pIHtcbiAgICAgICAgICAgIHNwYW4gPSBjb3VudCAqIHRoaXMuZWxlbWVudExheW91dC5zcGFuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGlkeCA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoaWR4IDwgY291bnQpIHtcbiAgICAgICAgICAgICAgICBzcGFuICs9IHRoaXMuZWxlbWVudExheW91dC5nZXRTcGFuKGIsIG9mZnNldCArIHNwYW4pO1xuICAgICAgICAgICAgICAgICsraWR4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGFuO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY29uc3QgcnYgPSBbXTtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBsZXQgY291bnQgPSB0aGlzLmNvdW50O1xuICAgICAgICBpZiAoY291bnQgaW5zdGFuY2VvZiBFeHRlcm5hbExheW91dCkge1xuICAgICAgICAgICAgY291bnQgPSBjb3VudC5kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoaSA8IGNvdW50KSB7XG4gICAgICAgICAgICBydi5wdXNoKHRoaXMuZWxlbWVudExheW91dC5kZWNvZGUoYiwgb2Zmc2V0KSk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gdGhpcy5lbGVtZW50TGF5b3V0LmdldFNwYW4oYiwgb2Zmc2V0KTtcbiAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnY7XG4gICAgfVxuICAgIC8qKiBJbXBsZW1lbnQge0BsaW5rIExheW91dCNlbmNvZGV8ZW5jb2RlfSBmb3Ige0BsaW5rIFNlcXVlbmNlfS5cbiAgICAgKlxuICAgICAqICoqTk9URSoqIElmIGBzcmNgIGlzIHNob3J0ZXIgdGhhbiB7QGxpbmsgU2VxdWVuY2UjY291bnR8Y291bnR9IHRoZW5cbiAgICAgKiB0aGUgdW51c2VkIHNwYWNlIGluIHRoZSBidWZmZXIgaXMgbGVmdCB1bmNoYW5nZWQuICBJZiBgc3JjYCBpc1xuICAgICAqIGxvbmdlciB0aGFuIHtAbGluayBTZXF1ZW5jZSNjb3VudHxjb3VudH0gdGhlIHVubmVlZGVkIGVsZW1lbnRzIGFyZVxuICAgICAqIGlnbm9yZWQuXG4gICAgICpcbiAgICAgKiAqKk5PVEUqKiBJZiB7QGxpbmsgTGF5b3V0I2NvdW50fGNvdW50fSBpcyBhbiBpbnN0YW5jZSBvZiB7QGxpbmtcbiAgICAgKiBFeHRlcm5hbExheW91dH0gdGhlbiB0aGUgbGVuZ3RoIG9mIGBzcmNgIHdpbGwgYmUgZW5jb2RlZCBhcyB0aGVcbiAgICAgKiBjb3VudCBhZnRlciBgc3JjYCBpcyBlbmNvZGVkLiAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY29uc3QgZWxvID0gdGhpcy5lbGVtZW50TGF5b3V0O1xuICAgICAgICBjb25zdCBzcGFuID0gc3JjLnJlZHVjZSgoc3BhbiwgdikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHNwYW4gKyBlbG8uZW5jb2RlKHYsIGIsIG9mZnNldCArIHNwYW4pO1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgaWYgKHRoaXMuY291bnQgaW5zdGFuY2VvZiBFeHRlcm5hbExheW91dCkge1xuICAgICAgICAgICAgdGhpcy5jb3VudC5lbmNvZGUoc3JjLmxlbmd0aCwgYiwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BhbjtcbiAgICB9XG59XG5leHBvcnRzLlNlcXVlbmNlID0gU2VxdWVuY2U7XG4vKipcbiAqIFJlcHJlc2VudCBhIGNvbnRpZ3VvdXMgc2VxdWVuY2Ugb2YgYXJiaXRyYXJ5IGxheW91dCBlbGVtZW50cyBhcyBhblxuICogT2JqZWN0LlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQuc3RydWN0fHN0cnVjdH1cbiAqXG4gKiAqKk5PVEUqKiBUaGUge0BsaW5rIExheW91dCNzcGFufHNwYW59IG9mIHRoZSBzdHJ1Y3R1cmUgaXMgdmFyaWFibGVcbiAqIGlmIGFueSBsYXlvdXQgaW4ge0BsaW5rIFN0cnVjdHVyZSNmaWVsZHN8ZmllbGRzfSBoYXMgYSB2YXJpYWJsZVxuICogc3Bhbi4gIFdoZW4ge0BsaW5rIExheW91dCNlbmNvZGV8ZW5jb2Rpbmd9IHdlIG11c3QgaGF2ZSBhIHZhbHVlIGZvclxuICogYWxsIHZhcmlhYmxlLWxlbmd0aCBmaWVsZHMsIG9yIHdlIHdvdWxkbid0IGJlIGFibGUgdG8gZmlndXJlIG91dFxuICogaG93IG11Y2ggc3BhY2UgdG8gdXNlIGZvciBzdG9yYWdlLiAgV2UgY2FuIG9ubHkgaWRlbnRpZnkgdGhlIHZhbHVlXG4gKiBmb3IgYSBmaWVsZCB3aGVuIGl0IGhhcyBhIHtAbGluayBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LiAgQXNcbiAqIHN1Y2gsIGFsdGhvdWdoIGEgc3RydWN0dXJlIG1heSBjb250YWluIGJvdGggdW5uYW1lZCBmaWVsZHMgYW5kXG4gKiB2YXJpYWJsZS1sZW5ndGggZmllbGRzLCBpdCBjYW5ub3QgY29udGFpbiBhbiB1bm5hbWVkXG4gKiB2YXJpYWJsZS1sZW5ndGggZmllbGQuXG4gKlxuICogQHBhcmFtIHtMYXlvdXRbXX0gZmllbGRzIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogU3RydWN0dXJlI2ZpZWxkc3xmaWVsZHN9LiAgQW4gZXJyb3IgaXMgcmFpc2VkIGlmIHRoaXMgY29udGFpbnMgYVxuICogdmFyaWFibGUtbGVuZ3RoIGZpZWxkIGZvciB3aGljaCBhIHtAbGluayBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9XG4gKiBpcyBub3QgZGVmaW5lZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBbZGVjb2RlUHJlZml4ZXNdIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogU3RydWN0dXJlI2RlY29kZVByZWZpeGVzfHByb3BlcnR5fS5cbiAqXG4gKiBAdGhyb3dzIHtFcnJvcn0gLSBpZiBgZmllbGRzYCBjb250YWlucyBhbiB1bm5hbWVkIHZhcmlhYmxlLWxlbmd0aFxuICogbGF5b3V0LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBTdHJ1Y3R1cmUgZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcywgcHJvcGVydHksIGRlY29kZVByZWZpeGVzKSB7XG4gICAgICAgIGlmICghKEFycmF5LmlzQXJyYXkoZmllbGRzKVxuICAgICAgICAgICAgJiYgZmllbGRzLnJlZHVjZSgoYWNjLCB2KSA9PiBhY2MgJiYgKHYgaW5zdGFuY2VvZiBMYXlvdXQpLCB0cnVlKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ZpZWxkcyBtdXN0IGJlIGFycmF5IG9mIExheW91dCBpbnN0YW5jZXMnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKCdib29sZWFuJyA9PT0gdHlwZW9mIHByb3BlcnR5KVxuICAgICAgICAgICAgJiYgKHVuZGVmaW5lZCA9PT0gZGVjb2RlUHJlZml4ZXMpKSB7XG4gICAgICAgICAgICBkZWNvZGVQcmVmaXhlcyA9IHByb3BlcnR5O1xuICAgICAgICAgICAgcHJvcGVydHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLyogVmVyaWZ5IGFic2VuY2Ugb2YgdW5uYW1lZCB2YXJpYWJsZS1sZW5ndGggZmllbGRzLiAqL1xuICAgICAgICBmb3IgKGNvbnN0IGZkIG9mIGZpZWxkcykge1xuICAgICAgICAgICAgaWYgKCgwID4gZmQuc3BhbilcbiAgICAgICAgICAgICAgICAmJiAodW5kZWZpbmVkID09PSBmZC5wcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpZWxkcyBjYW5ub3QgY29udGFpbiB1bm5hbWVkIHZhcmlhYmxlLWxlbmd0aCBsYXlvdXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgc3BhbiA9IC0xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3BhbiA9IGZpZWxkcy5yZWR1Y2UoKHNwYW4sIGZkKSA9PiBzcGFuICsgZmQuZ2V0U3BhbigpLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gaWdub3JlIGVycm9yXG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoc3BhbiwgcHJvcGVydHkpO1xuICAgICAgICAvKiogVGhlIHNlcXVlbmNlIG9mIHtAbGluayBMYXlvdXR9IHZhbHVlcyB0aGF0IGNvbXByaXNlIHRoZVxuICAgICAgICAgKiBzdHJ1Y3R1cmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBpbmRpdmlkdWFsIGVsZW1lbnRzIG5lZWQgbm90IGJlIHRoZSBzYW1lIHR5cGUsIGFuZCBtYXkgYmVcbiAgICAgICAgICogZWl0aGVyIHNjYWxhciBvciBhZ2dyZWdhdGUgbGF5b3V0cy4gIElmIGEgbWVtYmVyIGxheW91dCBsZWF2ZXNcbiAgICAgICAgICogaXRzIHtAbGluayBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9IHVuZGVmaW5lZCB0aGVcbiAgICAgICAgICogY29ycmVzcG9uZGluZyByZWdpb24gb2YgdGhlIGJ1ZmZlciBhc3NvY2lhdGVkIHdpdGggdGhlIGVsZW1lbnRcbiAgICAgICAgICogd2lsbCBub3QgYmUgbXV0YXRlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge0xheW91dFtdfSAqL1xuICAgICAgICB0aGlzLmZpZWxkcyA9IGZpZWxkcztcbiAgICAgICAgLyoqIENvbnRyb2wgYmVoYXZpb3Igb2Yge0BsaW5rIExheW91dCNkZWNvZGV8ZGVjb2RlKCl9IGdpdmVuIHNob3J0XG4gICAgICAgICAqIGJ1ZmZlcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEluIHNvbWUgc2l0dWF0aW9ucyBhIHN0cnVjdHVyZSBtYW55IGJlIGV4dGVuZGVkIHdpdGggYWRkaXRpb25hbFxuICAgICAgICAgKiBmaWVsZHMgb3ZlciB0aW1lLCB3aXRoIG9sZGVyIGluc3RhbGxhdGlvbnMgcHJvdmlkaW5nIG9ubHkgYVxuICAgICAgICAgKiBwcmVmaXggb2YgdGhlIGZ1bGwgc3RydWN0dXJlLiAgSWYgdGhpcyBwcm9wZXJ0eSBpcyBgdHJ1ZWBcbiAgICAgICAgICogZGVjb2Rpbmcgd2lsbCBhY2NlcHQgdGhvc2UgYnVmZmVycyBhbmQgbGVhdmUgc3Vic2VxdWVudCBmaWVsZHNcbiAgICAgICAgICogdW5kZWZpbmVkLCBhcyBsb25nIGFzIHRoZSBidWZmZXIgZW5kcyBhdCBhIGZpZWxkIGJvdW5kYXJ5LlxuICAgICAgICAgKiBEZWZhdWx0cyB0byBgZmFsc2VgLiAqL1xuICAgICAgICB0aGlzLmRlY29kZVByZWZpeGVzID0gISFkZWNvZGVQcmVmaXhlcztcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGdldFNwYW4oYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBpZiAoMCA8PSB0aGlzLnNwYW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNwYW47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNwYW4gPSAwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3BhbiA9IHRoaXMuZmllbGRzLnJlZHVjZSgoc3BhbiwgZmQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmc3AgPSBmZC5nZXRTcGFuKGIsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGZzcDtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3BhbiArIGZzcDtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignaW5kZXRlcm1pbmF0ZSBzcGFuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjaGVja1VpbnQ4QXJyYXkoYik7XG4gICAgICAgIGNvbnN0IGRlc3QgPSB0aGlzLm1ha2VEZXN0aW5hdGlvbk9iamVjdCgpO1xuICAgICAgICBmb3IgKGNvbnN0IGZkIG9mIHRoaXMuZmllbGRzKSB7XG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkICE9PSBmZC5wcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIGRlc3RbZmQucHJvcGVydHldID0gZmQuZGVjb2RlKGIsIG9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgKz0gZmQuZ2V0U3BhbihiLCBvZmZzZXQpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZGVjb2RlUHJlZml4ZXNcbiAgICAgICAgICAgICAgICAmJiAoYi5sZW5ndGggPT09IG9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9XG4gICAgLyoqIEltcGxlbWVudCB7QGxpbmsgTGF5b3V0I2VuY29kZXxlbmNvZGV9IGZvciB7QGxpbmsgU3RydWN0dXJlfS5cbiAgICAgKlxuICAgICAqIElmIGBzcmNgIGlzIG1pc3NpbmcgYSBwcm9wZXJ0eSBmb3IgYSBtZW1iZXIgd2l0aCBhIGRlZmluZWQge0BsaW5rXG4gICAgICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fSB0aGUgY29ycmVzcG9uZGluZyByZWdpb24gb2YgdGhlIGJ1ZmZlciBpc1xuICAgICAqIGxlZnQgdW5tb2RpZmllZC4gKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICBsZXQgbGFzdE9mZnNldCA9IDA7XG4gICAgICAgIGxldCBsYXN0V3JvdGUgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IGZkIG9mIHRoaXMuZmllbGRzKSB7XG4gICAgICAgICAgICBsZXQgc3BhbiA9IGZkLnNwYW47XG4gICAgICAgICAgICBsYXN0V3JvdGUgPSAoMCA8IHNwYW4pID8gc3BhbiA6IDA7XG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkICE9PSBmZC5wcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZ2ID0gc3JjW2ZkLnByb3BlcnR5XTtcbiAgICAgICAgICAgICAgICBpZiAodW5kZWZpbmVkICE9PSBmdikge1xuICAgICAgICAgICAgICAgICAgICBsYXN0V3JvdGUgPSBmZC5lbmNvZGUoZnYsIGIsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgwID4gc3Bhbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLyogUmVhZCB0aGUgYXMtZW5jb2RlZCBzcGFuLCB3aGljaCBpcyBub3QgbmVjZXNzYXJpbHkgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBzYW1lIGFzIHdoYXQgd2Ugd3JvdGUuICovXG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFuID0gZmQuZ2V0U3BhbihiLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgIG9mZnNldCArPSBzcGFuO1xuICAgICAgICB9XG4gICAgICAgIC8qIFVzZSAobGFzdE9mZnNldCArIGxhc3RXcm90ZSkgaW5zdGVhZCBvZiBvZmZzZXQgYmVjYXVzZSB0aGUgbGFzdFxuICAgICAgICAgKiBpdGVtIG1heSBoYXZlIGhhZCBhIGR5bmFtaWMgbGVuZ3RoIGFuZCB3ZSBkb24ndCB3YW50IHRvIGluY2x1ZGVcbiAgICAgICAgICogdGhlIHBhZGRpbmcgYmV0d2VlbiBpdCBhbmQgdGhlIGVuZCBvZiB0aGUgc3BhY2UgcmVzZXJ2ZWQgZm9yXG4gICAgICAgICAqIGl0LiAqL1xuICAgICAgICByZXR1cm4gKGxhc3RPZmZzZXQgKyBsYXN0V3JvdGUpIC0gZmlyc3RPZmZzZXQ7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBmcm9tQXJyYXkodmFsdWVzKSB7XG4gICAgICAgIGNvbnN0IGRlc3QgPSB0aGlzLm1ha2VEZXN0aW5hdGlvbk9iamVjdCgpO1xuICAgICAgICBmb3IgKGNvbnN0IGZkIG9mIHRoaXMuZmllbGRzKSB7XG4gICAgICAgICAgICBpZiAoKHVuZGVmaW5lZCAhPT0gZmQucHJvcGVydHkpXG4gICAgICAgICAgICAgICAgJiYgKDAgPCB2YWx1ZXMubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIGRlc3RbZmQucHJvcGVydHldID0gdmFsdWVzLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhY2Nlc3MgdG8gdGhlIGxheW91dCBvZiBhIGdpdmVuIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IC0gdGhlIHN0cnVjdHVyZSBtZW1iZXIgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtMYXlvdXR9IC0gdGhlIGxheW91dCBhc3NvY2lhdGVkIHdpdGggYHByb3BlcnR5YCwgb3JcbiAgICAgKiB1bmRlZmluZWQgaWYgdGhlcmUgaXMgbm8gc3VjaCBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBsYXlvdXRGb3IocHJvcGVydHkpIHtcbiAgICAgICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgcHJvcGVydHkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3Byb3BlcnR5IG11c3QgYmUgc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBmZCBvZiB0aGlzLmZpZWxkcykge1xuICAgICAgICAgICAgaWYgKGZkLnByb3BlcnR5ID09PSBwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG9mZnNldCBvZiBhIHN0cnVjdHVyZSBtZW1iZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgLSB0aGUgc3RydWN0dXJlIG1lbWJlciBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gLSB0aGUgb2Zmc2V0IGluIGJ5dGVzIHRvIHRoZSBzdGFydCBvZiBgcHJvcGVydHlgXG4gICAgICogd2l0aGluIHRoZSBzdHJ1Y3R1cmUsIG9yIHVuZGVmaW5lZCBpZiBgcHJvcGVydHlgIGlzIG5vdCBhIGZpZWxkXG4gICAgICogd2l0aGluIHRoZSBzdHJ1Y3R1cmUuICBJZiB0aGUgcHJvcGVydHkgaXMgYSBtZW1iZXIgYnV0IGZvbGxvd3MgYVxuICAgICAqIHZhcmlhYmxlLWxlbmd0aCBzdHJ1Y3R1cmUgbWVtYmVyIGEgbmVnYXRpdmUgbnVtYmVyIHdpbGwgYmVcbiAgICAgKiByZXR1cm5lZC5cbiAgICAgKi9cbiAgICBvZmZzZXRPZihwcm9wZXJ0eSkge1xuICAgICAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBwcm9wZXJ0eSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncHJvcGVydHkgbXVzdCBiZSBzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBmZCBvZiB0aGlzLmZpZWxkcykge1xuICAgICAgICAgICAgaWYgKGZkLnByb3BlcnR5ID09PSBwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoMCA+IGZkLnNwYW4pIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKDAgPD0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGZkLnNwYW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG5leHBvcnRzLlN0cnVjdHVyZSA9IFN0cnVjdHVyZTtcbi8qKlxuICogQW4gb2JqZWN0IHRoYXQgY2FuIHByb3ZpZGUgYSB7QGxpbmtcbiAqIFVuaW9uI2Rpc2NyaW1pbmF0b3J8ZGlzY3JpbWluYXRvcn0gQVBJIGZvciB7QGxpbmsgVW5pb259LlxuICpcbiAqICoqTk9URSoqIFRoaXMgaXMgYW4gYWJzdHJhY3QgYmFzZSBjbGFzczsgeW91IGNhbiBjcmVhdGUgaW5zdGFuY2VzXG4gKiBpZiBpdCBhbXVzZXMgeW91LCBidXQgdGhleSB3b24ndCBzdXBwb3J0IHRoZSB7QGxpbmtcbiAqIFVuaW9uRGlzY3JpbWluYXRvciNlbmNvZGV8ZW5jb2RlfSBvciB7QGxpbmtcbiAqIFVuaW9uRGlzY3JpbWluYXRvciNkZWNvZGV8ZGVjb2RlfSBmdW5jdGlvbnMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBEZWZhdWx0IGZvciB7QGxpbmtcbiAqIFVuaW9uRGlzY3JpbWluYXRvciNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGFic3RyYWN0XG4gKi9cbmNsYXNzIFVuaW9uRGlzY3JpbWluYXRvciB7XG4gICAgY29uc3RydWN0b3IocHJvcGVydHkpIHtcbiAgICAgICAgLyoqIFRoZSB7QGxpbmsgTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fSB0byBiZSB1c2VkIHdoZW4gdGhlXG4gICAgICAgICAqIGRpc2NyaW1pbmF0b3IgaXMgcmVmZXJlbmNlZCBpbiBpc29sYXRpb24gKGdlbmVyYWxseSB3aGVuIHtAbGlua1xuICAgICAgICAgKiBVbmlvbiNkZWNvZGV8VW5pb24gZGVjb2RlfSBjYW5ub3QgZGVsZWdhdGUgdG8gYSBzcGVjaWZpY1xuICAgICAgICAgKiB2YXJpYW50KS4gKi9cbiAgICAgICAgdGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICAgIH1cbiAgICAvKiogQW5hbG9nIHRvIHtAbGluayBMYXlvdXQjZGVjb2RlfExheW91dCBkZWNvZGV9IGZvciB1bmlvbiBkaXNjcmltaW5hdG9ycy5cbiAgICAgKlxuICAgICAqIFRoZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIG1ldGhvZCBuZWVkIG5vdCByZWZlcmVuY2UgdGhlIGJ1ZmZlciBpZlxuICAgICAqIHZhcmlhbnQgaW5mb3JtYXRpb24gaXMgYXZhaWxhYmxlIHRocm91Z2ggb3RoZXIgbWVhbnMuICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuaW9uRGlzY3JpbWluYXRvciBpcyBhYnN0cmFjdCcpO1xuICAgIH1cbiAgICAvKiogQW5hbG9nIHRvIHtAbGluayBMYXlvdXQjZGVjb2RlfExheW91dCBlbmNvZGV9IGZvciB1bmlvbiBkaXNjcmltaW5hdG9ycy5cbiAgICAgKlxuICAgICAqIFRoZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIG1ldGhvZCBuZWVkIG5vdCBzdG9yZSB0aGUgdmFsdWUgaWZcbiAgICAgKiB2YXJpYW50IGluZm9ybWF0aW9uIGlzIG1haW50YWluZWQgdGhyb3VnaCBvdGhlciBtZWFucy4gKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmlvbkRpc2NyaW1pbmF0b3IgaXMgYWJzdHJhY3QnKTtcbiAgICB9XG59XG5leHBvcnRzLlVuaW9uRGlzY3JpbWluYXRvciA9IFVuaW9uRGlzY3JpbWluYXRvcjtcbi8qKlxuICogQW4gb2JqZWN0IHRoYXQgY2FuIHByb3ZpZGUgYSB7QGxpbmtcbiAqIFVuaW9uRGlzY3JpbWluYXRvcnxkaXNjcmltaW5hdG9yIEFQSX0gZm9yIHtAbGluayBVbmlvbn0gdXNpbmcgYW5cbiAqIHVuc2lnbmVkIGludGVncmFsIHtAbGluayBMYXlvdXR9IGluc3RhbmNlIGxvY2F0ZWQgZWl0aGVyIGluc2lkZSBvclxuICogb3V0c2lkZSB0aGUgdW5pb24uXG4gKlxuICogQHBhcmFtIHtFeHRlcm5hbExheW91dH0gbGF5b3V0IC0gaW5pdGlhbGl6ZXMge0BsaW5rXG4gKiBVbmlvbkxheW91dERpc2NyaW1pbmF0b3IjbGF5b3V0fGxheW91dH0uICBNdXN0IHNhdGlzZnkge0BsaW5rXG4gKiBFeHRlcm5hbExheW91dCNpc0NvdW50fGlzQ291bnQoKX0uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBEZWZhdWx0IGZvciB7QGxpbmtcbiAqIFVuaW9uRGlzY3JpbWluYXRvciNwcm9wZXJ0eXxwcm9wZXJ0eX0sIHN1cGVyc2VkaW5nIHRoZSBwcm9wZXJ0eVxuICogZnJvbSBgbGF5b3V0YCwgYnV0IGRlZmF1bHRpbmcgdG8gYHZhcmlhbnRgIGlmIG5laXRoZXIgYHByb3BlcnR5YFxuICogbm9yIGxheW91dCBwcm92aWRlIGEgcHJvcGVydHkgbmFtZS5cbiAqXG4gKiBAYXVnbWVudHMge1VuaW9uRGlzY3JpbWluYXRvcn1cbiAqL1xuY2xhc3MgVW5pb25MYXlvdXREaXNjcmltaW5hdG9yIGV4dGVuZHMgVW5pb25EaXNjcmltaW5hdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihsYXlvdXQsIHByb3BlcnR5KSB7XG4gICAgICAgIGlmICghKChsYXlvdXQgaW5zdGFuY2VvZiBFeHRlcm5hbExheW91dClcbiAgICAgICAgICAgICYmIGxheW91dC5pc0NvdW50KCkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdsYXlvdXQgbXVzdCBiZSBhbiB1bnNpZ25lZCBpbnRlZ2VyIEV4dGVybmFsTGF5b3V0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIocHJvcGVydHkgfHwgbGF5b3V0LnByb3BlcnR5IHx8ICd2YXJpYW50Jyk7XG4gICAgICAgIC8qKiBUaGUge0BsaW5rIEV4dGVybmFsTGF5b3V0fSB1c2VkIHRvIGFjY2VzcyB0aGUgZGlzY3JpbWluYXRvclxuICAgICAgICAgKiB2YWx1ZS4gKi9cbiAgICAgICAgdGhpcy5sYXlvdXQgPSBsYXlvdXQ7XG4gICAgfVxuICAgIC8qKiBEZWxlZ2F0ZSBkZWNvZGluZyB0byB7QGxpbmsgVW5pb25MYXlvdXREaXNjcmltaW5hdG9yI2xheW91dHxsYXlvdXR9LiAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5b3V0LmRlY29kZShiLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKiogRGVsZWdhdGUgZW5jb2RpbmcgdG8ge0BsaW5rIFVuaW9uTGF5b3V0RGlzY3JpbWluYXRvciNsYXlvdXR8bGF5b3V0fS4gKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5b3V0LmVuY29kZShzcmMsIGIsIG9mZnNldCk7XG4gICAgfVxufVxuZXhwb3J0cy5VbmlvbkxheW91dERpc2NyaW1pbmF0b3IgPSBVbmlvbkxheW91dERpc2NyaW1pbmF0b3I7XG4vKipcbiAqIFJlcHJlc2VudCBhbnkgbnVtYmVyIG9mIHNwYW4tY29tcGF0aWJsZSBsYXlvdXRzLlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQudW5pb258dW5pb259XG4gKlxuICogSWYgdGhlIHVuaW9uIGhhcyBhIHtAbGluayBVbmlvbiNkZWZhdWx0TGF5b3V0fGRlZmF1bHQgbGF5b3V0fSB0aGF0XG4gKiBsYXlvdXQgbXVzdCBoYXZlIGEgbm9uLW5lZ2F0aXZlIHtAbGluayBMYXlvdXQjc3BhbnxzcGFufS4gIFRoZSBzcGFuXG4gKiBvZiBhIGZpeGVkLXNwYW4gdW5pb24gaW5jbHVkZXMgaXRzIHtAbGlua1xuICogVW5pb24jZGlzY3JpbWluYXRvcnxkaXNjcmltaW5hdG9yfSBpZiB0aGUgdmFyaWFudCBpcyBhIHtAbGlua1xuICogVW5pb24jdXNlc1ByZWZpeERpc2NyaW1pbmF0b3J8cHJlZml4IG9mIHRoZSB1bmlvbn0sIHBsdXMgdGhlIHNwYW5cbiAqIG9mIGl0cyB7QGxpbmsgVW5pb24jZGVmYXVsdExheW91dHxkZWZhdWx0IGxheW91dH0uXG4gKlxuICogSWYgdGhlIHVuaW9uIGRvZXMgbm90IGhhdmUgYSBkZWZhdWx0IGxheW91dCB0aGVuIHRoZSBlbmNvZGVkIHNwYW5cbiAqIG9mIHRoZSB1bmlvbiBkZXBlbmRzIG9uIHRoZSBlbmNvZGVkIHNwYW4gb2YgaXRzIHZhcmlhbnQgKHdoaWNoIG1heVxuICogYmUgZml4ZWQgb3IgdmFyaWFibGUpLlxuICpcbiAqIHtAbGluayBWYXJpYW50TGF5b3V0I2xheW91dHxWYXJpYW50IGxheW91dH1zIGFyZSBhZGRlZCB0aHJvdWdoXG4gKiB7QGxpbmsgVW5pb24jYWRkVmFyaWFudHxhZGRWYXJpYW50fS4gIElmIHRoZSB1bmlvbiBoYXMgYSBkZWZhdWx0XG4gKiBsYXlvdXQsIHRoZSBzcGFuIG9mIHRoZSB7QGxpbmsgVmFyaWFudExheW91dCNsYXlvdXR8bGF5b3V0XG4gKiBjb250YWluZWQgYnkgdGhlIHZhcmlhbnR9IG11c3Qgbm90IGV4Y2VlZCB0aGUgc3BhbiBvZiB0aGUge0BsaW5rXG4gKiBVbmlvbiNkZWZhdWx0TGF5b3V0fGRlZmF1bHQgbGF5b3V0fSAobWludXMgdGhlIHNwYW4gb2YgYSB7QGxpbmtcbiAqIFVuaW9uI3VzZXNQcmVmaXhEaXNjcmltaW5hdG9yfHByZWZpeCBkaXNyaW1pbmF0b3J9LCBpZiB1c2VkKS4gIFRoZVxuICogc3BhbiBvZiB0aGUgdmFyaWFudCB3aWxsIGVxdWFsIHRoZSBzcGFuIG9mIHRoZSB1bmlvbiBpdHNlbGYuXG4gKlxuICogVGhlIHZhcmlhbnQgZm9yIGEgYnVmZmVyIGNhbiBvbmx5IGJlIGlkZW50aWZpZWQgZnJvbSB0aGUge0BsaW5rXG4gKiBVbmlvbiNkaXNjcmltaW5hdG9yfGRpc2NyaW1pbmF0b3J9IHtAbGlua1xuICogVW5pb25EaXNjcmltaW5hdG9yI3Byb3BlcnR5fHByb3BlcnR5fSAoaW4gdGhlIGNhc2Ugb2YgdGhlIHtAbGlua1xuICogVW5pb24jZGVmYXVsdExheW91dHxkZWZhdWx0IGxheW91dH0pLCBvciBieSB1c2luZyB7QGxpbmtcbiAqIFVuaW9uI2dldFZhcmlhbnR8Z2V0VmFyaWFudH0gYW5kIGV4YW1pbmluZyB0aGUgcmVzdWx0aW5nIHtAbGlua1xuICogVmFyaWFudExheW91dH0gaW5zdGFuY2UuXG4gKlxuICogQSB2YXJpYW50IGNvbXBhdGlibGUgd2l0aCBhIEphdmFTY3JpcHQgb2JqZWN0IGNhbiBiZSBpZGVudGlmaWVkXG4gKiB1c2luZyB7QGxpbmsgVW5pb24jZ2V0U291cmNlVmFyaWFudHxnZXRTb3VyY2VWYXJpYW50fS5cbiAqXG4gKiBAcGFyYW0geyhVbmlvbkRpc2NyaW1pbmF0b3J8RXh0ZXJuYWxMYXlvdXR8TGF5b3V0KX0gZGlzY3IgLSBIb3cgdG9cbiAqIGlkZW50aWZ5IHRoZSBsYXlvdXQgdXNlZCB0byBpbnRlcnByZXQgdGhlIHVuaW9uIGNvbnRlbnRzLiAgVGhlXG4gKiBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgVW5pb25EaXNjcmltaW5hdG9yfSwgYW5cbiAqIHtAbGluayBFeHRlcm5hbExheW91dH0gdGhhdCBzYXRpc2ZpZXMge0BsaW5rXG4gKiBFeHRlcm5hbExheW91dCNpc0NvdW50fGlzQ291bnQoKX0sIG9yIHtAbGluayBVSW50fSAob3Ige0BsaW5rXG4gKiBVSW50QkV9KS4gIFdoZW4gYSBub24tZXh0ZXJuYWwgbGF5b3V0IGVsZW1lbnQgaXMgcGFzc2VkIHRoZSBsYXlvdXRcbiAqIGFwcGVhcnMgYXQgdGhlIHN0YXJ0IG9mIHRoZSB1bmlvbi4gIEluIGFsbCBjYXNlcyB0aGUgKHN5bnRoZXNpemVkKVxuICoge0BsaW5rIFVuaW9uRGlzY3JpbWluYXRvcn0gaW5zdGFuY2UgaXMgcmVjb3JkZWQgYXMge0BsaW5rXG4gKiBVbmlvbiNkaXNjcmltaW5hdG9yfGRpc2NyaW1pbmF0b3J9LlxuICpcbiAqIEBwYXJhbSB7KExheW91dHxudWxsKX0gZGVmYXVsdExheW91dCAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIFVuaW9uI2RlZmF1bHRMYXlvdXR8ZGVmYXVsdExheW91dH0uICBJZiBhYnNlbnQgZGVmYXVsdHMgdG8gYG51bGxgLlxuICogSWYgYG51bGxgIHRoZXJlIGlzIG5vIGRlZmF1bHQgbGF5b3V0OiB0aGUgdW5pb24gaGFzIGRhdGEtZGVwZW5kZW50XG4gKiBsZW5ndGggYW5kIGF0dGVtcHRzIHRvIGRlY29kZSBvciBlbmNvZGUgdW5yZWNvZ25pemVkIHZhcmlhbnRzIHdpbGxcbiAqIHRocm93IGFuIGV4Y2VwdGlvbi4gIEEge0BsaW5rIExheW91dH0gaW5zdGFuY2UgbXVzdCBoYXZlIGFcbiAqIG5vbi1uZWdhdGl2ZSB7QGxpbmsgTGF5b3V0I3NwYW58c3Bhbn0sIGFuZCBpZiBpdCBsYWNrcyBhIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fSB0aGUge0BsaW5rXG4gKiBVbmlvbiNkZWZhdWx0TGF5b3V0fGRlZmF1bHRMYXlvdXR9IHdpbGwgYmUgYSB7QGxpbmtcbiAqIExheW91dCNyZXBsaWNhdGV8cmVwbGljYX0gd2l0aCBwcm9wZXJ0eSBgY29udGVudGAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBVbmlvbiBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3IoZGlzY3IsIGRlZmF1bHRMYXlvdXQsIHByb3BlcnR5KSB7XG4gICAgICAgIGxldCBkaXNjcmltaW5hdG9yO1xuICAgICAgICBpZiAoKGRpc2NyIGluc3RhbmNlb2YgVUludClcbiAgICAgICAgICAgIHx8IChkaXNjciBpbnN0YW5jZW9mIFVJbnRCRSkpIHtcbiAgICAgICAgICAgIGRpc2NyaW1pbmF0b3IgPSBuZXcgVW5pb25MYXlvdXREaXNjcmltaW5hdG9yKG5ldyBPZmZzZXRMYXlvdXQoZGlzY3IpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoZGlzY3IgaW5zdGFuY2VvZiBFeHRlcm5hbExheW91dClcbiAgICAgICAgICAgICYmIGRpc2NyLmlzQ291bnQoKSkge1xuICAgICAgICAgICAgZGlzY3JpbWluYXRvciA9IG5ldyBVbmlvbkxheW91dERpc2NyaW1pbmF0b3IoZGlzY3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCEoZGlzY3IgaW5zdGFuY2VvZiBVbmlvbkRpc2NyaW1pbmF0b3IpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdkaXNjciBtdXN0IGJlIGEgVW5pb25EaXNjcmltaW5hdG9yICdcbiAgICAgICAgICAgICAgICArICdvciBhbiB1bnNpZ25lZCBpbnRlZ2VyIGxheW91dCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGlzY3JpbWluYXRvciA9IGRpc2NyO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bmRlZmluZWQgPT09IGRlZmF1bHRMYXlvdXQpIHtcbiAgICAgICAgICAgIGRlZmF1bHRMYXlvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKChudWxsID09PSBkZWZhdWx0TGF5b3V0KVxuICAgICAgICAgICAgfHwgKGRlZmF1bHRMYXlvdXQgaW5zdGFuY2VvZiBMYXlvdXQpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZGVmYXVsdExheW91dCBtdXN0IGJlIG51bGwgb3IgYSBMYXlvdXQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobnVsbCAhPT0gZGVmYXVsdExheW91dCkge1xuICAgICAgICAgICAgaWYgKDAgPiBkZWZhdWx0TGF5b3V0LnNwYW4pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RlZmF1bHRMYXlvdXQgbXVzdCBoYXZlIGNvbnN0YW50IHNwYW4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgPT09IGRlZmF1bHRMYXlvdXQucHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0TGF5b3V0ID0gZGVmYXVsdExheW91dC5yZXBsaWNhdGUoJ2NvbnRlbnQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKiBUaGUgdW5pb24gc3BhbiBjYW4gYmUgZXN0aW1hdGVkIG9ubHkgaWYgdGhlcmUncyBhIGRlZmF1bHRcbiAgICAgICAgICogbGF5b3V0LiAgVGhlIHVuaW9uIHNwYW5zIGl0cyBkZWZhdWx0IGxheW91dCwgcGx1cyBhbnkgcHJlZml4XG4gICAgICAgICAqIHZhcmlhbnQgbGF5b3V0LiAgQnkgY29uc3RydWN0aW9uIGJvdGggbGF5b3V0cywgaWYgcHJlc2VudCwgaGF2ZVxuICAgICAgICAgKiBub24tbmVnYXRpdmUgc3Bhbi4gKi9cbiAgICAgICAgbGV0IHNwYW4gPSAtMTtcbiAgICAgICAgaWYgKGRlZmF1bHRMYXlvdXQpIHtcbiAgICAgICAgICAgIHNwYW4gPSBkZWZhdWx0TGF5b3V0LnNwYW47XG4gICAgICAgICAgICBpZiAoKDAgPD0gc3BhbikgJiYgKChkaXNjciBpbnN0YW5jZW9mIFVJbnQpXG4gICAgICAgICAgICAgICAgfHwgKGRpc2NyIGluc3RhbmNlb2YgVUludEJFKSkpIHtcbiAgICAgICAgICAgICAgICBzcGFuICs9IGRpc2NyaW1pbmF0b3IubGF5b3V0LnNwYW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoc3BhbiwgcHJvcGVydHkpO1xuICAgICAgICAvKiogVGhlIGludGVyZmFjZSBmb3IgdGhlIGRpc2NyaW1pbmF0b3IgdmFsdWUgaW4gaXNvbGF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGEge0BsaW5rIFVuaW9uRGlzY3JpbWluYXRvcn0gZWl0aGVyIHBhc3NlZCB0byB0aGVcbiAgICAgICAgICogY29uc3RydWN0b3Igb3Igc3ludGhlc2l6ZWQgZnJvbSB0aGUgYGRpc2NyYCBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBhcmd1bWVudC4gIHtAbGlua1xuICAgICAgICAgKiBVbmlvbiN1c2VzUHJlZml4RGlzY3JpbWluYXRvcnx1c2VzUHJlZml4RGlzY3JpbWluYXRvcn0gd2lsbCBiZVxuICAgICAgICAgKiBgdHJ1ZWAgaWZmIHRoZSBgZGlzY3JgIHBhcmFtZXRlciB3YXMgYSBub24tb2Zmc2V0IHtAbGlua1xuICAgICAgICAgKiBMYXlvdXR9IGluc3RhbmNlLiAqL1xuICAgICAgICB0aGlzLmRpc2NyaW1pbmF0b3IgPSBkaXNjcmltaW5hdG9yO1xuICAgICAgICAvKiogYHRydWVgIGlmIHRoZSB7QGxpbmsgVW5pb24jZGlzY3JpbWluYXRvcnxkaXNjcmltaW5hdG9yfSBpcyB0aGVcbiAgICAgICAgICogZmlyc3QgZmllbGQgaW4gdGhlIHVuaW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBgZmFsc2VgIHRoZSBkaXNjcmltaW5hdG9yIGlzIG9idGFpbmVkIGZyb20gc29tZXdoZXJlXG4gICAgICAgICAqIGVsc2UuICovXG4gICAgICAgIHRoaXMudXNlc1ByZWZpeERpc2NyaW1pbmF0b3IgPSAoZGlzY3IgaW5zdGFuY2VvZiBVSW50KVxuICAgICAgICAgICAgfHwgKGRpc2NyIGluc3RhbmNlb2YgVUludEJFKTtcbiAgICAgICAgLyoqIFRoZSBsYXlvdXQgZm9yIG5vbi1kaXNjcmltaW5hdG9yIGNvbnRlbnQgd2hlbiB0aGUgdmFsdWUgb2YgdGhlXG4gICAgICAgICAqIGRpc2NyaW1pbmF0b3IgaXMgbm90IHJlY29nbml6ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgaXMgdGhlIHZhbHVlIHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3IuICBJdCBpc1xuICAgICAgICAgKiBzdHJ1Y3R1cmFsbHkgZXF1aXZhbGVudCB0byB0aGUgc2Vjb25kIGNvbXBvbmVudCBvZiB7QGxpbmtcbiAgICAgICAgICogVW5pb24jbGF5b3V0fGxheW91dH0gYnV0IG1heSBoYXZlIGEgZGlmZmVyZW50IHByb3BlcnR5XG4gICAgICAgICAqIG5hbWUuICovXG4gICAgICAgIHRoaXMuZGVmYXVsdExheW91dCA9IGRlZmF1bHRMYXlvdXQ7XG4gICAgICAgIC8qKiBBIHJlZ2lzdHJ5IG9mIGFsbG93ZWQgdmFyaWFudHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBrZXlzIGFyZSB1bnNpZ25lZCBpbnRlZ2VycyB3aGljaCBzaG91bGQgYmUgY29tcGF0aWJsZSB3aXRoXG4gICAgICAgICAqIHtAbGluayBVbmlvbi5kaXNjcmltaW5hdG9yfGRpc2NyaW1pbmF0b3J9LiAgVGhlIHByb3BlcnR5IHZhbHVlXG4gICAgICAgICAqIGlzIHRoZSBjb3JyZXNwb25kaW5nIHtAbGluayBWYXJpYW50TGF5b3V0fSBpbnN0YW5jZXMgYXNzaWduZWRcbiAgICAgICAgICogdG8gdGhpcyB1bmlvbiBieSB7QGxpbmsgVW5pb24jYWRkVmFyaWFudHxhZGRWYXJpYW50fS5cbiAgICAgICAgICpcbiAgICAgICAgICogKipOT1RFKiogVGhlIHJlZ2lzdHJ5IHJlbWFpbnMgbXV0YWJsZSBzbyB0aGF0IHZhcmlhbnRzIGNhbiBiZVxuICAgICAgICAgKiB7QGxpbmsgVW5pb24jYWRkVmFyaWFudHxhZGRlZH0gYXQgYW55IHRpbWUuICBVc2VycyBzaG91bGQgbm90XG4gICAgICAgICAqIG1hbmlwdWxhdGUgdGhlIGNvbnRlbnQgb2YgdGhpcyBwcm9wZXJ0eS4gKi9cbiAgICAgICAgdGhpcy5yZWdpc3RyeSA9IHt9O1xuICAgICAgICAvKiBQcml2YXRlIHZhcmlhYmxlIHVzZWQgd2hlbiBpbnZva2luZyBnZXRTb3VyY2VWYXJpYW50ICovXG4gICAgICAgIGxldCBib3VuZEdldFNvdXJjZVZhcmlhbnQgPSB0aGlzLmRlZmF1bHRHZXRTb3VyY2VWYXJpYW50LmJpbmQodGhpcyk7XG4gICAgICAgIC8qKiBGdW5jdGlvbiB0byBpbmZlciB0aGUgdmFyaWFudCBzZWxlY3RlZCBieSBhIHNvdXJjZSBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIERlZmF1bHRzIHRvIHtAbGlua1xuICAgICAgICAgKiBVbmlvbiNkZWZhdWx0R2V0U291cmNlVmFyaWFudHxkZWZhdWx0R2V0U291cmNlVmFyaWFudH0gYnV0IG1heVxuICAgICAgICAgKiBiZSBvdmVycmlkZGVuIHVzaW5nIHtAbGlua1xuICAgICAgICAgKiBVbmlvbiNjb25maWdHZXRTb3VyY2VWYXJpYW50fGNvbmZpZ0dldFNvdXJjZVZhcmlhbnR9LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gc3JjIC0gYXMgd2l0aCB7QGxpbmtcbiAgICAgICAgICogVW5pb24jZGVmYXVsdEdldFNvdXJjZVZhcmlhbnR8ZGVmYXVsdEdldFNvdXJjZVZhcmlhbnR9LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB7KHVuZGVmaW5lZHxWYXJpYW50TGF5b3V0KX0gVGhlIGRlZmF1bHQgdmFyaWFudFxuICAgICAgICAgKiAoYHVuZGVmaW5lZGApIG9yIGZpcnN0IHJlZ2lzdGVyZWQgdmFyaWFudCB0aGF0IHVzZXMgYSBwcm9wZXJ0eVxuICAgICAgICAgKiBhdmFpbGFibGUgaW4gYHNyY2AuICovXG4gICAgICAgIHRoaXMuZ2V0U291cmNlVmFyaWFudCA9IGZ1bmN0aW9uIChzcmMpIHtcbiAgICAgICAgICAgIHJldHVybiBib3VuZEdldFNvdXJjZVZhcmlhbnQoc3JjKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEZ1bmN0aW9uIHRvIG92ZXJyaWRlIHRoZSBpbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmtcbiAgICAgICAgICogVW5pb24jZ2V0U291cmNlVmFyaWFudHxnZXRTb3VyY2VWYXJpYW50fS5cbiAgICAgICAgICpcbiAgICAgICAgICogVXNlIHRoaXMgaWYgdGhlIGRlc2lyZWQgdmFyaWFudCBjYW5ub3QgYmUgaWRlbnRpZmllZCB1c2luZyB0aGVcbiAgICAgICAgICogYWxnb3JpdGhtIG9mIHtAbGlua1xuICAgICAgICAgKiBVbmlvbiNkZWZhdWx0R2V0U291cmNlVmFyaWFudHxkZWZhdWx0R2V0U291cmNlVmFyaWFudH0uXG4gICAgICAgICAqXG4gICAgICAgICAqICoqTk9URSoqIFRoZSBwcm92aWRlZCBmdW5jdGlvbiB3aWxsIGJlIGludm9rZWQgYm91bmQgdG8gdGhpc1xuICAgICAgICAgKiBVbmlvbiBpbnN0YW5jZSwgcHJvdmlkaW5nIGxvY2FsIGFjY2VzcyB0byB7QGxpbmtcbiAgICAgICAgICogVW5pb24jcmVnaXN0cnl8cmVnaXN0cnl9LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBnc3YgLSBhIGZ1bmN0aW9uIHRoYXQgZm9sbG93cyB0aGUgQVBJIG9mXG4gICAgICAgICAqIHtAbGluayBVbmlvbiNkZWZhdWx0R2V0U291cmNlVmFyaWFudHxkZWZhdWx0R2V0U291cmNlVmFyaWFudH0uICovXG4gICAgICAgIHRoaXMuY29uZmlnR2V0U291cmNlVmFyaWFudCA9IGZ1bmN0aW9uIChnc3YpIHtcbiAgICAgICAgICAgIGJvdW5kR2V0U291cmNlVmFyaWFudCA9IGdzdi5iaW5kKHRoaXMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZ2V0U3BhbihiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGlmICgwIDw9IHRoaXMuc3Bhbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3BhbjtcbiAgICAgICAgfVxuICAgICAgICAvKiBEZWZhdWx0IGxheW91dHMgYWx3YXlzIGhhdmUgbm9uLW5lZ2F0aXZlIHNwYW4sIHNvIHdlIGRvbid0IGhhdmVcbiAgICAgICAgICogb25lIGFuZCB3ZSBoYXZlIHRvIHJlY29nbml6ZSB0aGUgdmFyaWFudCB3aGljaCB3aWxsIGluIHR1cm5cbiAgICAgICAgICogZGV0ZXJtaW5lIHRoZSBzcGFuLiAqL1xuICAgICAgICBjb25zdCB2bG8gPSB0aGlzLmdldFZhcmlhbnQoYiwgb2Zmc2V0KTtcbiAgICAgICAgaWYgKCF2bG8pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5hYmxlIHRvIGRldGVybWluZSBzcGFuIGZvciB1bnJlY29nbml6ZWQgdmFyaWFudCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2bG8uZ2V0U3BhbihiLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdG8gaW5mZXIgYSByZWdpc3RlcmVkIFVuaW9uIHZhcmlhbnQgY29tcGF0aWJsZSB3aXRoIGBzcmNgLlxuICAgICAqXG4gICAgICogVGhlIGZpcnN0IHNhdGlzZmllZCBydWxlIGluIHRoZSBmb2xsb3dpbmcgc2VxdWVuY2UgZGVmaW5lcyB0aGVcbiAgICAgKiByZXR1cm4gdmFsdWU6XG4gICAgICogKiBJZiBgc3JjYCBoYXMgcHJvcGVydGllcyBtYXRjaGluZyB0aGUgVW5pb24gZGlzY3JpbWluYXRvciBhbmRcbiAgICAgKiAgIHRoZSBkZWZhdWx0IGxheW91dCwgYHVuZGVmaW5lZGAgaXMgcmV0dXJuZWQgcmVnYXJkbGVzcyBvZiB0aGVcbiAgICAgKiAgIHZhbHVlIG9mIHRoZSBkaXNjcmltaW5hdG9yIHByb3BlcnR5ICh0aGlzIGVuc3VyZXMgdGhlIGRlZmF1bHRcbiAgICAgKiAgIGxheW91dCB3aWxsIGJlIHVzZWQpO1xuICAgICAqICogSWYgYHNyY2AgaGFzIGEgcHJvcGVydHkgbWF0Y2hpbmcgdGhlIFVuaW9uIGRpc2NyaW1pbmF0b3IsIHRoZVxuICAgICAqICAgdmFsdWUgb2YgdGhlIGRpc2NyaW1pbmF0b3IgaWRlbnRpZmllcyBhIHJlZ2lzdGVyZWQgdmFyaWFudCwgYW5kXG4gICAgICogICBlaXRoZXIgKGEpIHRoZSB2YXJpYW50IGhhcyBubyBsYXlvdXQsIG9yIChiKSBgc3JjYCBoYXMgdGhlXG4gICAgICogICB2YXJpYW50J3MgcHJvcGVydHksIHRoZW4gdGhlIHZhcmlhbnQgaXMgcmV0dXJuZWQgKGJlY2F1c2UgdGhlXG4gICAgICogICBzb3VyY2Ugc2F0aXNmaWVzIHRoZSBjb25zdHJhaW50cyBvZiB0aGUgdmFyaWFudCBpdCBpZGVudGlmaWVzKTtcbiAgICAgKiAqIElmIGBzcmNgIGRvZXMgbm90IGhhdmUgYSBwcm9wZXJ0eSBtYXRjaGluZyB0aGUgVW5pb25cbiAgICAgKiAgIGRpc2NyaW1pbmF0b3IsIGJ1dCBkb2VzIGhhdmUgYSBwcm9wZXJ0eSBtYXRjaGluZyBhIHJlZ2lzdGVyZWRcbiAgICAgKiAgIHZhcmlhbnQsIHRoZW4gdGhlIHZhcmlhbnQgaXMgcmV0dXJuZWQgKGJlY2F1c2UgdGhlIHNvdXJjZVxuICAgICAqICAgbWF0Y2hlcyBhIHZhcmlhbnQgd2l0aG91dCBhbiBleHBsaWNpdCBjb25mbGljdCk7XG4gICAgICogKiBBbiBlcnJvciBpcyB0aHJvd24gKGJlY2F1c2Ugd2UgZWl0aGVyIGNhbid0IGlkZW50aWZ5IGEgdmFyaWFudCxcbiAgICAgKiAgIG9yIHdlIHdlcmUgZXhwbGljaXRseSB0b2xkIHRoZSB2YXJpYW50IGJ1dCBjYW4ndCBzYXRpc2Z5IGl0KS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzcmMgLSBhbiBvYmplY3QgcHJlc3VtZWQgdG8gYmUgY29tcGF0aWJsZSB3aXRoXG4gICAgICogdGhlIGNvbnRlbnQgb2YgdGhlIFVuaW9uLlxuICAgICAqXG4gICAgICogQHJldHVybiB7KHVuZGVmaW5lZHxWYXJpYW50TGF5b3V0KX0gLSBhcyBkZXNjcmliZWQgYWJvdmUuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBpZiBgc3JjYCBjYW5ub3QgYmUgYXNzb2NpYXRlZCB3aXRoIGEgZGVmYXVsdCBvclxuICAgICAqIHJlZ2lzdGVyZWQgdmFyaWFudC5cbiAgICAgKi9cbiAgICBkZWZhdWx0R2V0U291cmNlVmFyaWFudChzcmMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzcmMsIHRoaXMuZGlzY3JpbWluYXRvci5wcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlZmF1bHRMYXlvdXQgJiYgdGhpcy5kZWZhdWx0TGF5b3V0LnByb3BlcnR5XG4gICAgICAgICAgICAgICAgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNyYywgdGhpcy5kZWZhdWx0TGF5b3V0LnByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2bG8gPSB0aGlzLnJlZ2lzdHJ5W3NyY1t0aGlzLmRpc2NyaW1pbmF0b3IucHJvcGVydHldXTtcbiAgICAgICAgICAgIGlmICh2bG9cbiAgICAgICAgICAgICAgICAmJiAoKCF2bG8ubGF5b3V0KVxuICAgICAgICAgICAgICAgICAgICB8fCAodmxvLnByb3BlcnR5ICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzcmMsIHZsby5wcm9wZXJ0eSkpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2bG87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRhZyBpbiB0aGlzLnJlZ2lzdHJ5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmxvID0gdGhpcy5yZWdpc3RyeVt0YWddO1xuICAgICAgICAgICAgICAgIGlmICh2bG8ucHJvcGVydHkgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNyYywgdmxvLnByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmxvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuYWJsZSB0byBpbmZlciBzcmMgdmFyaWFudCcpO1xuICAgIH1cbiAgICAvKiogSW1wbGVtZW50IHtAbGluayBMYXlvdXQjZGVjb2RlfGRlY29kZX0gZm9yIHtAbGluayBVbmlvbn0uXG4gICAgICpcbiAgICAgKiBJZiB0aGUgdmFyaWFudCBpcyB7QGxpbmsgVW5pb24jYWRkVmFyaWFudHxyZWdpc3RlcmVkfSB0aGUgcmV0dXJuXG4gICAgICogdmFsdWUgaXMgYW4gaW5zdGFuY2Ugb2YgdGhhdCB2YXJpYW50LCB3aXRoIG5vIGV4cGxpY2l0XG4gICAgICogZGlzY3JpbWluYXRvci4gIE90aGVyd2lzZSB0aGUge0BsaW5rIFVuaW9uI2RlZmF1bHRMYXlvdXR8ZGVmYXVsdFxuICAgICAqIGxheW91dH0gaXMgdXNlZCB0byBkZWNvZGUgdGhlIGNvbnRlbnQuICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgbGV0IGRlc3Q7XG4gICAgICAgIGNvbnN0IGRsbyA9IHRoaXMuZGlzY3JpbWluYXRvcjtcbiAgICAgICAgY29uc3QgZGlzY3IgPSBkbG8uZGVjb2RlKGIsIG9mZnNldCk7XG4gICAgICAgIGNvbnN0IGNsbyA9IHRoaXMucmVnaXN0cnlbZGlzY3JdO1xuICAgICAgICBpZiAodW5kZWZpbmVkID09PSBjbG8pIHtcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRMYXlvdXQgPSB0aGlzLmRlZmF1bHRMYXlvdXQ7XG4gICAgICAgICAgICBsZXQgY29udGVudE9mZnNldCA9IDA7XG4gICAgICAgICAgICBpZiAodGhpcy51c2VzUHJlZml4RGlzY3JpbWluYXRvcikge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRPZmZzZXQgPSBkbG8ubGF5b3V0LnNwYW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZXN0ID0gdGhpcy5tYWtlRGVzdGluYXRpb25PYmplY3QoKTtcbiAgICAgICAgICAgIGRlc3RbZGxvLnByb3BlcnR5XSA9IGRpc2NyO1xuICAgICAgICAgICAgLy8gZGVmYXVsdExheW91dC5wcm9wZXJ0eSBjYW4gYmUgdW5kZWZpbmVkLCBidXQgdGhpcyBpcyBhbGxvd2VkIGJ5IGJ1ZmZlci1sYXlvdXRcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICBkZXN0W2RlZmF1bHRMYXlvdXQucHJvcGVydHldID0gZGVmYXVsdExheW91dC5kZWNvZGUoYiwgb2Zmc2V0ICsgY29udGVudE9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZXN0ID0gY2xvLmRlY29kZShiLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH1cbiAgICAvKiogSW1wbGVtZW50IHtAbGluayBMYXlvdXQjZW5jb2RlfGVuY29kZX0gZm9yIHtAbGluayBVbmlvbn0uXG4gICAgICpcbiAgICAgKiBUaGlzIEFQSSBhc3N1bWVzIHRoZSBgc3JjYCBvYmplY3QgaXMgY29uc2lzdGVudCB3aXRoIHRoZSB1bmlvbidzXG4gICAgICoge0BsaW5rIFVuaW9uI2RlZmF1bHRMYXlvdXR8ZGVmYXVsdCBsYXlvdXR9LiAgVG8gZW5jb2RlIHZhcmlhbnRzXG4gICAgICogdXNlIHRoZSBhcHByb3ByaWF0ZSB2YXJpYW50LXNwZWNpZmljIHtAbGluayBWYXJpYW50TGF5b3V0I2VuY29kZX1cbiAgICAgKiBtZXRob2QuICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjb25zdCB2bG8gPSB0aGlzLmdldFNvdXJjZVZhcmlhbnQoc3JjKTtcbiAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gdmxvKSB7XG4gICAgICAgICAgICBjb25zdCBkbG8gPSB0aGlzLmRpc2NyaW1pbmF0b3I7XG4gICAgICAgICAgICAvLyB0aGlzLmRlZmF1bHRMYXlvdXQgaXMgbm90IHVuZGVmaW5lZCB3aGVuIHZsbyBpcyB1bmRlZmluZWRcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICBjb25zdCBjbG8gPSB0aGlzLmRlZmF1bHRMYXlvdXQ7XG4gICAgICAgICAgICBsZXQgY29udGVudE9mZnNldCA9IDA7XG4gICAgICAgICAgICBpZiAodGhpcy51c2VzUHJlZml4RGlzY3JpbWluYXRvcikge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRPZmZzZXQgPSBkbG8ubGF5b3V0LnNwYW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkbG8uZW5jb2RlKHNyY1tkbG8ucHJvcGVydHldLCBiLCBvZmZzZXQpO1xuICAgICAgICAgICAgLy8gY2xvLnByb3BlcnR5IGlzIG5vdCB1bmRlZmluZWQgd2hlbiB2bG8gaXMgdW5kZWZpbmVkXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRPZmZzZXQgKyBjbG8uZW5jb2RlKHNyY1tjbG8ucHJvcGVydHldLCBiLCBvZmZzZXQgKyBjb250ZW50T2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmxvLmVuY29kZShzcmMsIGIsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKiBSZWdpc3RlciBhIG5ldyB2YXJpYW50IHN0cnVjdHVyZSB3aXRoaW4gYSB1bmlvbi4gIFRoZSBuZXdseVxuICAgICAqIGNyZWF0ZWQgdmFyaWFudCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YXJpYW50IC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICAgICAqIFZhcmlhbnRMYXlvdXQjdmFyaWFudHx2YXJpYW50fS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TGF5b3V0fSBsYXlvdXQgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gICAgICogVmFyaWFudExheW91dCNsYXlvdXR8bGF5b3V0fS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAgICAgKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICAgICAqXG4gICAgICogQHJldHVybiB7VmFyaWFudExheW91dH0gKi9cbiAgICBhZGRWYXJpYW50KHZhcmlhbnQsIGxheW91dCwgcHJvcGVydHkpIHtcbiAgICAgICAgY29uc3QgcnYgPSBuZXcgVmFyaWFudExheW91dCh0aGlzLCB2YXJpYW50LCBsYXlvdXQsIHByb3BlcnR5KTtcbiAgICAgICAgdGhpcy5yZWdpc3RyeVt2YXJpYW50XSA9IHJ2O1xuICAgICAgICByZXR1cm4gcnY7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbGF5b3V0IGFzc29jaWF0ZWQgd2l0aCBhIHJlZ2lzdGVyZWQgdmFyaWFudC5cbiAgICAgKlxuICAgICAqIElmIGB2YmAgZG9lcyBub3QgcHJvZHVjZSBhIHJlZ2lzdGVyZWQgdmFyaWFudCB0aGUgZnVuY3Rpb24gcmV0dXJuc1xuICAgICAqIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsoTnVtYmVyfFVpbnQ4QXJyYXkpfSB2YiAtIGVpdGhlciB0aGUgdmFyaWFudCBudW1iZXIsIG9yIGFcbiAgICAgKiBidWZmZXIgZnJvbSB3aGljaCB0aGUgZGlzY3JpbWluYXRvciBpcyB0byBiZSByZWFkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCAtIG9mZnNldCBpbnRvIGB2YmAgZm9yIHRoZSBzdGFydCBvZiB0aGVcbiAgICAgKiB1bmlvbi4gIFVzZWQgb25seSB3aGVuIGB2YmAgaXMgYW4gaW5zdGFuY2Ugb2Yge1VpbnQ4QXJyYXl9LlxuICAgICAqXG4gICAgICogQHJldHVybiB7KHtWYXJpYW50TGF5b3V0fXx1bmRlZmluZWQpfVxuICAgICAqL1xuICAgIGdldFZhcmlhbnQodmIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgbGV0IHZhcmlhbnQ7XG4gICAgICAgIGlmICh2YiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgIHZhcmlhbnQgPSB0aGlzLmRpc2NyaW1pbmF0b3IuZGVjb2RlKHZiLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyaWFudCA9IHZiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlZ2lzdHJ5W3ZhcmlhbnRdO1xuICAgIH1cbn1cbmV4cG9ydHMuVW5pb24gPSBVbmlvbjtcbi8qKlxuICogUmVwcmVzZW50IGEgc3BlY2lmaWMgdmFyaWFudCB3aXRoaW4gYSBjb250YWluaW5nIHVuaW9uLlxuICpcbiAqICoqTk9URSoqIFRoZSB7QGxpbmsgTGF5b3V0I3NwYW58c3Bhbn0gb2YgdGhlIHZhcmlhbnQgbWF5IGluY2x1ZGVcbiAqIHRoZSBzcGFuIG9mIHRoZSB7QGxpbmsgVW5pb24jZGlzY3JpbWluYXRvcnxkaXNjcmltaW5hdG9yfSB1c2VkIHRvXG4gKiBpZGVudGlmeSBpdCwgYnV0IHZhbHVlcyByZWFkIGFuZCB3cml0dGVuIHVzaW5nIHRoZSB2YXJpYW50IHN0cmljdGx5XG4gKiBjb25mb3JtIHRvIHRoZSBjb250ZW50IG9mIHtAbGluayBWYXJpYW50TGF5b3V0I2xheW91dHxsYXlvdXR9LlxuICpcbiAqICoqTk9URSoqIFVzZXIgY29kZSBzaG91bGQgbm90IGludm9rZSB0aGlzIGNvbnN0cnVjdG9yIGRpcmVjdGx5LiAgVXNlXG4gKiB0aGUgdW5pb24ge0BsaW5rIFVuaW9uI2FkZFZhcmlhbnR8YWRkVmFyaWFudH0gaGVscGVyIG1ldGhvZC5cbiAqXG4gKiBAcGFyYW0ge1VuaW9ufSB1bmlvbiAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIFZhcmlhbnRMYXlvdXQjdW5pb258dW5pb259LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YXJpYW50IC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogVmFyaWFudExheW91dCN2YXJpYW50fHZhcmlhbnR9LlxuICpcbiAqIEBwYXJhbSB7TGF5b3V0fSBbbGF5b3V0XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIFZhcmlhbnRMYXlvdXQjbGF5b3V0fGxheW91dH0uICBJZiBhYnNlbnQgdGhlIHZhcmlhbnQgY2FycmllcyBub1xuICogZGF0YS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uICBVbmxpa2UgbWFueSBvdGhlciBsYXlvdXRzLCB2YXJpYW50XG4gKiBsYXlvdXRzIG5vcm1hbGx5IGluY2x1ZGUgYSBwcm9wZXJ0eSBuYW1lIHNvIHRoZXkgY2FuIGJlIGlkZW50aWZpZWRcbiAqIHdpdGhpbiB0aGVpciBjb250YWluaW5nIHtAbGluayBVbmlvbn0uICBUaGUgcHJvcGVydHkgaWRlbnRpZmllciBtYXlcbiAqIGJlIGFic2VudCBvbmx5IGlmIGBsYXlvdXRgIGlzIGlzIGFic2VudC5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgVmFyaWFudExheW91dCBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3IodW5pb24sIHZhcmlhbnQsIGxheW91dCwgcHJvcGVydHkpIHtcbiAgICAgICAgaWYgKCEodW5pb24gaW5zdGFuY2VvZiBVbmlvbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3VuaW9uIG11c3QgYmUgYSBVbmlvbicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoIU51bWJlci5pc0ludGVnZXIodmFyaWFudCkpIHx8ICgwID4gdmFyaWFudCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhcmlhbnQgbXVzdCBiZSBhIChub24tbmVnYXRpdmUpIGludGVnZXInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKCdzdHJpbmcnID09PSB0eXBlb2YgbGF5b3V0KVxuICAgICAgICAgICAgJiYgKHVuZGVmaW5lZCA9PT0gcHJvcGVydHkpKSB7XG4gICAgICAgICAgICBwcm9wZXJ0eSA9IGxheW91dDtcbiAgICAgICAgICAgIGxheW91dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxheW91dCkge1xuICAgICAgICAgICAgaWYgKCEobGF5b3V0IGluc3RhbmNlb2YgTGF5b3V0KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xheW91dCBtdXN0IGJlIGEgTGF5b3V0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKG51bGwgIT09IHVuaW9uLmRlZmF1bHRMYXlvdXQpXG4gICAgICAgICAgICAgICAgJiYgKDAgPD0gbGF5b3V0LnNwYW4pXG4gICAgICAgICAgICAgICAgJiYgKGxheW91dC5zcGFuID4gdW5pb24uZGVmYXVsdExheW91dC5zcGFuKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndmFyaWFudCBzcGFuIGV4Y2VlZHMgc3BhbiBvZiBjb250YWluaW5nIHVuaW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhcmlhbnQgbXVzdCBoYXZlIGEgU3RyaW5nIHByb3BlcnR5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNwYW4gPSB1bmlvbi5zcGFuO1xuICAgICAgICBpZiAoMCA+IHVuaW9uLnNwYW4pIHtcbiAgICAgICAgICAgIHNwYW4gPSBsYXlvdXQgPyBsYXlvdXQuc3BhbiA6IDA7XG4gICAgICAgICAgICBpZiAoKDAgPD0gc3BhbikgJiYgdW5pb24udXNlc1ByZWZpeERpc2NyaW1pbmF0b3IpIHtcbiAgICAgICAgICAgICAgICBzcGFuICs9IHVuaW9uLmRpc2NyaW1pbmF0b3IubGF5b3V0LnNwYW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoc3BhbiwgcHJvcGVydHkpO1xuICAgICAgICAvKiogVGhlIHtAbGluayBVbmlvbn0gdG8gd2hpY2ggdGhpcyB2YXJpYW50IGJlbG9uZ3MuICovXG4gICAgICAgIHRoaXMudW5pb24gPSB1bmlvbjtcbiAgICAgICAgLyoqIFRoZSB1bnNpZ25lZCBpbnRlZ3JhbCB2YWx1ZSBpZGVudGlmeWluZyB0aGlzIHZhcmlhbnQgd2l0aGluXG4gICAgICAgICAqIHRoZSB7QGxpbmsgVW5pb24jZGlzY3JpbWluYXRvcnxkaXNjcmltaW5hdG9yfSBvZiB0aGUgY29udGFpbmluZ1xuICAgICAgICAgKiB1bmlvbi4gKi9cbiAgICAgICAgdGhpcy52YXJpYW50ID0gdmFyaWFudDtcbiAgICAgICAgLyoqIFRoZSB7QGxpbmsgTGF5b3V0fSB0byBiZSB1c2VkIHdoZW4gcmVhZGluZy93cml0aW5nIHRoZVxuICAgICAgICAgKiBub24tZGlzY3JpbWluYXRvciBwYXJ0IG9mIHRoZSB7QGxpbmtcbiAgICAgICAgICogVmFyaWFudExheW91dCN1bmlvbnx1bmlvbn0uICBJZiBgbnVsbGAgdGhlIHZhcmlhbnQgY2FycmllcyBub1xuICAgICAgICAgKiBkYXRhLiAqL1xuICAgICAgICB0aGlzLmxheW91dCA9IGxheW91dCB8fCBudWxsO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZ2V0U3BhbihiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGlmICgwIDw9IHRoaXMuc3Bhbikge1xuICAgICAgICAgICAgLyogV2lsbCBiZSBlcXVhbCB0byB0aGUgY29udGFpbmluZyB1bmlvbiBzcGFuIGlmIHRoYXQgaXMgbm90XG4gICAgICAgICAgICAgKiB2YXJpYWJsZS4gKi9cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNwYW47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbnRlbnRPZmZzZXQgPSAwO1xuICAgICAgICBpZiAodGhpcy51bmlvbi51c2VzUHJlZml4RGlzY3JpbWluYXRvcikge1xuICAgICAgICAgICAgY29udGVudE9mZnNldCA9IHRoaXMudW5pb24uZGlzY3JpbWluYXRvci5sYXlvdXQuc3BhbjtcbiAgICAgICAgfVxuICAgICAgICAvKiBTcGFuIGlzIGRlZmluZWQgc29sZWx5IGJ5IHRoZSB2YXJpYW50IChhbmQgcHJlZml4IGRpc2NyaW1pbmF0b3IpICovXG4gICAgICAgIGxldCBzcGFuID0gMDtcbiAgICAgICAgaWYgKHRoaXMubGF5b3V0KSB7XG4gICAgICAgICAgICBzcGFuID0gdGhpcy5sYXlvdXQuZ2V0U3BhbihiLCBvZmZzZXQgKyBjb250ZW50T2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udGVudE9mZnNldCArIHNwYW47XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjb25zdCBkZXN0ID0gdGhpcy5tYWtlRGVzdGluYXRpb25PYmplY3QoKTtcbiAgICAgICAgaWYgKHRoaXMgIT09IHRoaXMudW5pb24uZ2V0VmFyaWFudChiLCBvZmZzZXQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZhcmlhbnQgbWlzbWF0Y2gnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29udGVudE9mZnNldCA9IDA7XG4gICAgICAgIGlmICh0aGlzLnVuaW9uLnVzZXNQcmVmaXhEaXNjcmltaW5hdG9yKSB7XG4gICAgICAgICAgICBjb250ZW50T2Zmc2V0ID0gdGhpcy51bmlvbi5kaXNjcmltaW5hdG9yLmxheW91dC5zcGFuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxheW91dCkge1xuICAgICAgICAgICAgZGVzdFt0aGlzLnByb3BlcnR5XSA9IHRoaXMubGF5b3V0LmRlY29kZShiLCBvZmZzZXQgKyBjb250ZW50T2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnByb3BlcnR5KSB7XG4gICAgICAgICAgICBkZXN0W3RoaXMucHJvcGVydHldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnVuaW9uLnVzZXNQcmVmaXhEaXNjcmltaW5hdG9yKSB7XG4gICAgICAgICAgICBkZXN0W3RoaXMudW5pb24uZGlzY3JpbWluYXRvci5wcm9wZXJ0eV0gPSB0aGlzLnZhcmlhbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGxldCBjb250ZW50T2Zmc2V0ID0gMDtcbiAgICAgICAgaWYgKHRoaXMudW5pb24udXNlc1ByZWZpeERpc2NyaW1pbmF0b3IpIHtcbiAgICAgICAgICAgIGNvbnRlbnRPZmZzZXQgPSB0aGlzLnVuaW9uLmRpc2NyaW1pbmF0b3IubGF5b3V0LnNwYW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubGF5b3V0XG4gICAgICAgICAgICAmJiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzcmMsIHRoaXMucHJvcGVydHkpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFyaWFudCBsYWNrcyBwcm9wZXJ0eSAnICsgdGhpcy5wcm9wZXJ0eSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51bmlvbi5kaXNjcmltaW5hdG9yLmVuY29kZSh0aGlzLnZhcmlhbnQsIGIsIG9mZnNldCk7XG4gICAgICAgIGxldCBzcGFuID0gY29udGVudE9mZnNldDtcbiAgICAgICAgaWYgKHRoaXMubGF5b3V0KSB7XG4gICAgICAgICAgICB0aGlzLmxheW91dC5lbmNvZGUoc3JjW3RoaXMucHJvcGVydHldLCBiLCBvZmZzZXQgKyBjb250ZW50T2Zmc2V0KTtcbiAgICAgICAgICAgIHNwYW4gKz0gdGhpcy5sYXlvdXQuZ2V0U3BhbihiLCBvZmZzZXQgKyBjb250ZW50T2Zmc2V0KTtcbiAgICAgICAgICAgIGlmICgoMCA8PSB0aGlzLnVuaW9uLnNwYW4pXG4gICAgICAgICAgICAgICAgJiYgKHNwYW4gPiB0aGlzLnVuaW9uLnNwYW4pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbmNvZGVkIHZhcmlhbnQgb3ZlcnJ1bnMgY29udGFpbmluZyB1bmlvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGFuO1xuICAgIH1cbiAgICAvKiogRGVsZWdhdGUge0BsaW5rIExheW91dCNmcm9tQXJyYXl8ZnJvbUFycmF5fSB0byB7QGxpbmtcbiAgICAgKiBWYXJpYW50TGF5b3V0I2xheW91dHxsYXlvdXR9LiAqL1xuICAgIGZyb21BcnJheSh2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHRoaXMubGF5b3V0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYXlvdXQuZnJvbUFycmF5KHZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG5leHBvcnRzLlZhcmlhbnRMYXlvdXQgPSBWYXJpYW50TGF5b3V0O1xuLyoqIEphdmFTY3JpcHQgY2hvc2UgdG8gZGVmaW5lIGJpdHdpc2Ugb3BlcmF0aW9ucyBhcyBvcGVyYXRpbmcgb25cbiAqIHNpZ25lZCAzMi1iaXQgdmFsdWVzIGluIDIncyBjb21wbGVtZW50IGZvcm0sIG1lYW5pbmcgYW55IGludGVnZXJcbiAqIHdpdGggYml0IDMxIHNldCBpcyBnb2luZyB0byBsb29rIG5lZ2F0aXZlLiAgRm9yIHJpZ2h0IHNoaWZ0cyB0aGF0J3NcbiAqIG5vdCBhIHByb2JsZW0sIGJlY2F1c2UgYD4+PmAgaXMgYSBsb2dpY2FsIHNoaWZ0LCBidXQgZm9yIGV2ZXJ5XG4gKiBvdGhlciBiaXR3aXNlIG9wZXJhdG9yIHdlIGhhdmUgdG8gY29tcGVuc2F0ZSBmb3IgcG9zc2libGUgbmVnYXRpdmVcbiAqIHJlc3VsdHMuICovXG5mdW5jdGlvbiBmaXhCaXR3aXNlUmVzdWx0KHYpIHtcbiAgICBpZiAoMCA+IHYpIHtcbiAgICAgICAgdiArPSAweDEwMDAwMDAwMDtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG59XG4vKipcbiAqIENvbnRhaW4gYSBzZXF1ZW5jZSBvZiBiaXQgZmllbGRzIGFzIGFuIHVuc2lnbmVkIGludGVnZXIuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5iaXRzfGJpdHN9XG4gKlxuICogVGhpcyBpcyBhIGNvbnRhaW5lciBlbGVtZW50OyB3aXRoaW4gaXQgdGhlcmUgYXJlIHtAbGluayBCaXRGaWVsZH1cbiAqIGluc3RhbmNlcyB0aGF0IHByb3ZpZGUgdGhlIGV4dHJhY3RlZCBwcm9wZXJ0aWVzLiAgVGhlIGNvbnRhaW5lclxuICogc2ltcGx5IGRlZmluZXMgdGhlIGFnZ3JlZ2F0ZSByZXByZXNlbnRhdGlvbiBhbmQgaXRzIGJpdCBvcmRlcmluZy5cbiAqIFRoZSByZXByZXNlbnRhdGlvbiBpcyBhbiBvYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzIHdpdGggbnVtZXJpY1xuICogb3Ige0BsaW5rIEJvb2xlYW59IHZhbHVlcy5cbiAqXG4gKiB7QGxpbmsgQml0RmllbGR9cyBhcmUgYWRkZWQgd2l0aCB0aGUge0BsaW5rXG4gKiBCaXRTdHJ1Y3R1cmUjYWRkRmllbGR8YWRkRmllbGR9IGFuZCB7QGxpbmtcbiAqIEJpdFN0cnVjdHVyZSNhZGRCb29sZWFufGFkZEJvb2xlYW59IG1ldGhvZHMuXG5cbiAqIEBwYXJhbSB7TGF5b3V0fSB3b3JkIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogQml0U3RydWN0dXJlI3dvcmR8d29yZH0uICBUaGUgcGFyYW1ldGVyIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2ZcbiAqIHtAbGluayBVSW50fSAob3Ige0BsaW5rIFVJbnRCRX0pIHRoYXQgaXMgbm8gbW9yZSB0aGFuIDQgYnl0ZXMgd2lkZS5cbiAqXG4gKiBAcGFyYW0ge2Jvb2x9IFttc2JdIC0gYHRydWVgIGlmIHRoZSBiaXQgbnVtYmVyaW5nIHN0YXJ0cyBhdCB0aGVcbiAqIG1vc3Qgc2lnbmlmaWNhbnQgYml0IG9mIHRoZSBjb250YWluaW5nIHdvcmQ7IGBmYWxzZWAgKGRlZmF1bHQpIGlmXG4gKiBpdCBzdGFydHMgYXQgdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdCBvZiB0aGUgY29udGFpbmluZyB3b3JkLiAgSWZcbiAqIHRoZSBwYXJhbWV0ZXIgYXQgdGhpcyBwb3NpdGlvbiBpcyBhIHN0cmluZyBhbmQgYHByb3BlcnR5YCBpc1xuICogYHVuZGVmaW5lZGAgdGhlIHZhbHVlIG9mIHRoaXMgYXJndW1lbnQgd2lsbCBpbnN0ZWFkIGJlIHVzZWQgYXMgdGhlXG4gKiB2YWx1ZSBvZiBgcHJvcGVydHlgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgQml0U3RydWN0dXJlIGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3Rvcih3b3JkLCBtc2IsIHByb3BlcnR5KSB7XG4gICAgICAgIGlmICghKCh3b3JkIGluc3RhbmNlb2YgVUludClcbiAgICAgICAgICAgIHx8ICh3b3JkIGluc3RhbmNlb2YgVUludEJFKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3dvcmQgbXVzdCBiZSBhIFVJbnQgb3IgVUludEJFIGxheW91dCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoJ3N0cmluZycgPT09IHR5cGVvZiBtc2IpXG4gICAgICAgICAgICAmJiAodW5kZWZpbmVkID09PSBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIHByb3BlcnR5ID0gbXNiO1xuICAgICAgICAgICAgbXNiID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKDQgPCB3b3JkLnNwYW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd3b3JkIGNhbm5vdCBleGNlZWQgMzIgYml0cycpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKHdvcmQuc3BhbiwgcHJvcGVydHkpO1xuICAgICAgICAvKiogVGhlIGxheW91dCB1c2VkIGZvciB0aGUgcGFja2VkIHZhbHVlLiAge0BsaW5rIEJpdEZpZWxkfVxuICAgICAgICAgKiBpbnN0YW5jZXMgYXJlIHBhY2tlZCBzZXF1ZW50aWFsbHkgZGVwZW5kaW5nIG9uIHtAbGlua1xuICAgICAgICAgKiBCaXRTdHJ1Y3R1cmUjbXNifG1zYn0uICovXG4gICAgICAgIHRoaXMud29yZCA9IHdvcmQ7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSBiaXQgc2VxdWVuY2VzIGFyZSBwYWNrZWQgc3RhcnRpbmcgYXQgdGhlIG1vc3RcbiAgICAgICAgICogc2lnbmlmaWNhbnQgYml0IGdyb3dpbmcgZG93biAoYHRydWVgKSwgb3IgdGhlIGxlYXN0IHNpZ25pZmljYW50XG4gICAgICAgICAqIGJpdCBncm93aW5nIHVwIChgZmFsc2VgKS5cbiAgICAgICAgICpcbiAgICAgICAgICogKipOT1RFKiogUmVnYXJkbGVzcyBvZiB0aGlzIHZhbHVlLCB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0IG9mXG4gICAgICAgICAqIGFueSB7QGxpbmsgQml0RmllbGR9IHZhbHVlIGlzIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQgb2YgdGhlXG4gICAgICAgICAqIGNvcnJlc3BvbmRpbmcgc2VjdGlvbiBvZiB0aGUgcGFja2VkIHZhbHVlLiAqL1xuICAgICAgICB0aGlzLm1zYiA9ICEhbXNiO1xuICAgICAgICAvKiogVGhlIHNlcXVlbmNlIG9mIHtAbGluayBCaXRGaWVsZH0gbGF5b3V0cyB0aGF0IGNvbXByaXNlIHRoZVxuICAgICAgICAgKiBwYWNrZWQgc3RydWN0dXJlLlxuICAgICAgICAgKlxuICAgICAgICAgKiAqKk5PVEUqKiBUaGUgYXJyYXkgcmVtYWlucyBtdXRhYmxlIHRvIGFsbG93IGZpZWxkcyB0byBiZSB7QGxpbmtcbiAgICAgICAgICogQml0U3RydWN0dXJlI2FkZEZpZWxkfGFkZGVkfSBhZnRlciBjb25zdHJ1Y3Rpb24uICBVc2VycyBzaG91bGRcbiAgICAgICAgICogbm90IG1hbmlwdWxhdGUgdGhlIGNvbnRlbnQgb2YgdGhpcyBwcm9wZXJ0eS4qL1xuICAgICAgICB0aGlzLmZpZWxkcyA9IFtdO1xuICAgICAgICAvKiBTdG9yYWdlIGZvciB0aGUgdmFsdWUuICBDYXB0dXJlIGEgdmFyaWFibGUgaW5zdGVhZCBvZiB1c2luZyBhblxuICAgICAgICAgKiBpbnN0YW5jZSBwcm9wZXJ0eSBiZWNhdXNlIHdlIGRvbid0IHdhbnQgYW55dGhpbmcgdG8gY2hhbmdlIHRoZVxuICAgICAgICAgKiB2YWx1ZSB3aXRob3V0IGdvaW5nIHRocm91Z2ggdGhlIG11dGF0b3IuICovXG4gICAgICAgIGxldCB2YWx1ZSA9IDA7XG4gICAgICAgIHRoaXMuX3BhY2tlZFNldFZhbHVlID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZml4Qml0d2lzZVJlc3VsdCh2KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9wYWNrZWRHZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNvbnN0IGRlc3QgPSB0aGlzLm1ha2VEZXN0aW5hdGlvbk9iamVjdCgpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMud29yZC5kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgICAgICAgdGhpcy5fcGFja2VkU2V0VmFsdWUodmFsdWUpO1xuICAgICAgICBmb3IgKGNvbnN0IGZkIG9mIHRoaXMuZmllbGRzKSB7XG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkICE9PSBmZC5wcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIGRlc3RbZmQucHJvcGVydHldID0gZmQuZGVjb2RlKGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH1cbiAgICAvKiogSW1wbGVtZW50IHtAbGluayBMYXlvdXQjZW5jb2RlfGVuY29kZX0gZm9yIHtAbGluayBCaXRTdHJ1Y3R1cmV9LlxuICAgICAqXG4gICAgICogSWYgYHNyY2AgaXMgbWlzc2luZyBhIHByb3BlcnR5IGZvciBhIG1lbWJlciB3aXRoIGEgZGVmaW5lZCB7QGxpbmtcbiAgICAgKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9IHRoZSBjb3JyZXNwb25kaW5nIHJlZ2lvbiBvZiB0aGUgcGFja2VkXG4gICAgICogdmFsdWUgaXMgbGVmdCB1bm1vZGlmaWVkLiAgVW51c2VkIGJpdHMgYXJlIGFsc28gbGVmdCB1bm1vZGlmaWVkLiAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLndvcmQuZGVjb2RlKGIsIG9mZnNldCk7XG4gICAgICAgIHRoaXMuX3BhY2tlZFNldFZhbHVlKHZhbHVlKTtcbiAgICAgICAgZm9yIChjb25zdCBmZCBvZiB0aGlzLmZpZWxkcykge1xuICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCAhPT0gZmQucHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmdiA9IHNyY1tmZC5wcm9wZXJ0eV07XG4gICAgICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCAhPT0gZnYpIHtcbiAgICAgICAgICAgICAgICAgICAgZmQuZW5jb2RlKGZ2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMud29yZC5lbmNvZGUodGhpcy5fcGFja2VkR2V0VmFsdWUoKSwgYiwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqIFJlZ2lzdGVyIGEgbmV3IGJpdGZpZWxkIHdpdGggYSBjb250YWluaW5nIGJpdCBzdHJ1Y3R1cmUuICBUaGVcbiAgICAgKiByZXN1bHRpbmcgYml0ZmllbGQgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYml0cyAtIGluaXRpYWxpemVyIGZvciB7QGxpbmsgQml0RmllbGQjYml0c3xiaXRzfS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAgICAgKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICAgICAqXG4gICAgICogQHJldHVybiB7Qml0RmllbGR9ICovXG4gICAgYWRkRmllbGQoYml0cywgcHJvcGVydHkpIHtcbiAgICAgICAgY29uc3QgYmYgPSBuZXcgQml0RmllbGQodGhpcywgYml0cywgcHJvcGVydHkpO1xuICAgICAgICB0aGlzLmZpZWxkcy5wdXNoKGJmKTtcbiAgICAgICAgcmV0dXJuIGJmO1xuICAgIH1cbiAgICAvKiogQXMgd2l0aCB7QGxpbmsgQml0U3RydWN0dXJlI2FkZEZpZWxkfGFkZEZpZWxkfSBmb3Igc2luZ2xlLWJpdFxuICAgICAqIGZpZWxkcyB3aXRoIGBib29sZWFuYCB2YWx1ZSByZXByZXNlbnRhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAgICAgKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICAgICAqXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gKi9cbiAgICAvLyBgQm9vbGVhbmAgY29uZmxpY3RzIHdpdGggdGhlIG5hdGl2ZSBwcmltaXRpdmUgdHlwZVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXG4gICAgYWRkQm9vbGVhbihwcm9wZXJ0eSkge1xuICAgICAgICAvLyBUaGlzIGlzIG15IEJvb2xlYW4sIG5vdCB0aGUgSmF2YXNjcmlwdCBvbmUuXG4gICAgICAgIGNvbnN0IGJmID0gbmV3IEJvb2xlYW4odGhpcywgcHJvcGVydHkpO1xuICAgICAgICB0aGlzLmZpZWxkcy5wdXNoKGJmKTtcbiAgICAgICAgcmV0dXJuIGJmO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYWNjZXNzIHRvIHRoZSBiaXQgZmllbGQgZm9yIGEgZ2l2ZW4gcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgLSB0aGUgYml0IGZpZWxkIG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHJldHVybiB7Qml0RmllbGR9IC0gdGhlIGZpZWxkIGFzc29jaWF0ZWQgd2l0aCBgcHJvcGVydHlgLCBvclxuICAgICAqIHVuZGVmaW5lZCBpZiB0aGVyZSBpcyBubyBzdWNoIHByb3BlcnR5LlxuICAgICAqL1xuICAgIGZpZWxkRm9yKHByb3BlcnR5KSB7XG4gICAgICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIHByb3BlcnR5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwcm9wZXJ0eSBtdXN0IGJlIHN0cmluZycpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZmQgb2YgdGhpcy5maWVsZHMpIHtcbiAgICAgICAgICAgIGlmIChmZC5wcm9wZXJ0eSA9PT0gcHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG5leHBvcnRzLkJpdFN0cnVjdHVyZSA9IEJpdFN0cnVjdHVyZTtcbi8qKlxuICogUmVwcmVzZW50IGEgc2VxdWVuY2Ugb2YgYml0cyB3aXRoaW4gYSB7QGxpbmsgQml0U3RydWN0dXJlfS5cbiAqXG4gKiBBbGwgYml0IGZpZWxkIHZhbHVlcyBhcmUgcmVwcmVzZW50ZWQgYXMgdW5zaWduZWQgaW50ZWdlcnMuXG4gKlxuICogKipOT1RFKiogVXNlciBjb2RlIHNob3VsZCBub3QgaW52b2tlIHRoaXMgY29uc3RydWN0b3IgZGlyZWN0bHkuXG4gKiBVc2UgdGhlIGNvbnRhaW5lciB7QGxpbmsgQml0U3RydWN0dXJlI2FkZEZpZWxkfGFkZEZpZWxkfSBoZWxwZXJcbiAqIG1ldGhvZC5cbiAqXG4gKiAqKk5PVEUqKiBCaXRGaWVsZCBpbnN0YW5jZXMgYXJlIG5vdCBpbnN0YW5jZXMgb2Yge0BsaW5rIExheW91dH1cbiAqIHNpbmNlIHtAbGluayBMYXlvdXQjc3BhbnxzcGFufSBtZWFzdXJlcyA4LWJpdCB1bml0cy5cbiAqXG4gKiBAcGFyYW0ge0JpdFN0cnVjdHVyZX0gY29udGFpbmVyIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogQml0RmllbGQjY29udGFpbmVyfGNvbnRhaW5lcn0uXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGJpdHMgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rIEJpdEZpZWxkI2JpdHN8Yml0c30uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICovXG5jbGFzcyBCaXRGaWVsZCB7XG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyLCBiaXRzLCBwcm9wZXJ0eSkge1xuICAgICAgICBpZiAoIShjb250YWluZXIgaW5zdGFuY2VvZiBCaXRTdHJ1Y3R1cmUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjb250YWluZXIgbXVzdCBiZSBhIEJpdFN0cnVjdHVyZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoIU51bWJlci5pc0ludGVnZXIoYml0cykpIHx8ICgwID49IGJpdHMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdiaXRzIG11c3QgYmUgcG9zaXRpdmUgaW50ZWdlcicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvdGFsQml0cyA9IDggKiBjb250YWluZXIuc3BhbjtcbiAgICAgICAgY29uc3QgdXNlZEJpdHMgPSBjb250YWluZXIuZmllbGRzLnJlZHVjZSgoc3VtLCBmZCkgPT4gc3VtICsgZmQuYml0cywgMCk7XG4gICAgICAgIGlmICgoYml0cyArIHVzZWRCaXRzKSA+IHRvdGFsQml0cykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiaXRzIHRvbyBsb25nIGZvciBzcGFuIHJlbWFpbmRlciAoJ1xuICAgICAgICAgICAgICAgICsgKHRvdGFsQml0cyAtIHVzZWRCaXRzKSArICcgb2YgJ1xuICAgICAgICAgICAgICAgICsgdG90YWxCaXRzICsgJyByZW1haW4pJyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIFRoZSB7QGxpbmsgQml0U3RydWN0dXJlfSBpbnN0YW5jZSB0byB3aGljaCB0aGlzIGJpdCBmaWVsZFxuICAgICAgICAgKiBiZWxvbmdzLiAqL1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgLyoqIFRoZSBzcGFuIG9mIHRoaXMgdmFsdWUgaW4gYml0cy4gKi9cbiAgICAgICAgdGhpcy5iaXRzID0gYml0cztcbiAgICAgICAgLyoqIEEgbWFzayBvZiB7QGxpbmsgQml0RmllbGQjYml0c3xiaXRzfSBiaXRzIGlzb2xhdGluZyB2YWx1ZSBiaXRzXG4gICAgICAgICAqIHRoYXQgZml0IHdpdGhpbiB0aGUgZmllbGQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoYXQgaXMsIGl0IG1hc2tzIGEgdmFsdWUgdGhhdCBoYXMgbm90IHlldCBiZWVuIHNoaWZ0ZWQgaW50b1xuICAgICAgICAgKiBwb3NpdGlvbiB3aXRoaW4gaXRzIGNvbnRhaW5pbmcgcGFja2VkIGludGVnZXIuICovXG4gICAgICAgIHRoaXMudmFsdWVNYXNrID0gKDEgPDwgYml0cykgLSAxO1xuICAgICAgICBpZiAoMzIgPT09IGJpdHMpIHsgLy8gc2hpZnRlZCB2YWx1ZSBvdXQgb2YgcmFuZ2VcbiAgICAgICAgICAgIHRoaXMudmFsdWVNYXNrID0gMHhGRkZGRkZGRjtcbiAgICAgICAgfVxuICAgICAgICAvKiogVGhlIG9mZnNldCBvZiB0aGUgdmFsdWUgd2l0aGluIHRoZSBjb250YWluaW5nIHBhY2tlZCB1bnNpZ25lZFxuICAgICAgICAgKiBpbnRlZ2VyLiAgVGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdCBvZiB0aGUgcGFja2VkIHZhbHVlIGlzIGF0XG4gICAgICAgICAqIG9mZnNldCB6ZXJvLCByZWdhcmRsZXNzIG9mIGJpdCBvcmRlcmluZyB1c2VkLiAqL1xuICAgICAgICB0aGlzLnN0YXJ0ID0gdXNlZEJpdHM7XG4gICAgICAgIGlmICh0aGlzLmNvbnRhaW5lci5tc2IpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQgPSB0b3RhbEJpdHMgLSB1c2VkQml0cyAtIGJpdHM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEEgbWFzayBvZiB7QGxpbmsgQml0RmllbGQjYml0c3xiaXRzfSBpc29sYXRpbmcgdGhlIGZpZWxkIHZhbHVlXG4gICAgICAgICAqIHdpdGhpbiB0aGUgY29udGFpbmluZyBwYWNrZWQgdW5zaWduZWQgaW50ZWdlci4gKi9cbiAgICAgICAgdGhpcy53b3JkTWFzayA9IGZpeEJpdHdpc2VSZXN1bHQodGhpcy52YWx1ZU1hc2sgPDwgdGhpcy5zdGFydCk7XG4gICAgICAgIC8qKiBUaGUgcHJvcGVydHkgbmFtZSB1c2VkIHdoZW4gdGhpcyBiaXRmaWVsZCBpcyByZXByZXNlbnRlZCBpbiBhblxuICAgICAgICAgKiBPYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEludGVuZGVkIHRvIGJlIGZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIHtAbGlua1xuICAgICAgICAgKiBMYXlvdXQjcHJvcGVydHl9LlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBsZWZ0IHVuZGVmaW5lZCB0aGUgY29ycmVzcG9uZGluZyBzcGFuIG9mIGJpdHMgd2lsbCBiZVxuICAgICAgICAgKiB0cmVhdGVkIGFzIHBhZGRpbmc6IGl0IHdpbGwgbm90IGJlIG11dGF0ZWQgYnkge0BsaW5rXG4gICAgICAgICAqIExheW91dCNlbmNvZGV8ZW5jb2RlfSBub3IgcmVwcmVzZW50ZWQgYXMgYSBwcm9wZXJ0eSBpbiB0aGVcbiAgICAgICAgICogZGVjb2RlZCBPYmplY3QuICovXG4gICAgICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICB9XG4gICAgLyoqIFN0b3JlIGEgdmFsdWUgaW50byB0aGUgY29ycmVzcG9uZGluZyBzdWJzZXF1ZW5jZSBvZiB0aGUgY29udGFpbmluZ1xuICAgICAqIGJpdCBmaWVsZC4gKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IHdvcmQgPSB0aGlzLmNvbnRhaW5lci5fcGFja2VkR2V0VmFsdWUoKTtcbiAgICAgICAgY29uc3Qgd29yZFZhbHVlID0gZml4Qml0d2lzZVJlc3VsdCh3b3JkICYgdGhpcy53b3JkTWFzayk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gd29yZFZhbHVlID4+PiB0aGlzLnN0YXJ0O1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIC8qKiBTdG9yZSBhIHZhbHVlIGludG8gdGhlIGNvcnJlc3BvbmRpbmcgc3Vic2VxdWVuY2Ugb2YgdGhlIGNvbnRhaW5pbmdcbiAgICAgKiBiaXQgZmllbGQuXG4gICAgICpcbiAgICAgKiAqKk5PVEUqKiBUaGlzIGlzIG5vdCBhIHNwZWNpYWxpemF0aW9uIG9mIHtAbGlua1xuICAgICAqIExheW91dCNlbmNvZGV8TGF5b3V0LmVuY29kZX0gYW5kIHRoZXJlIGlzIG5vIHJldHVybiB2YWx1ZS4gKi9cbiAgICBlbmNvZGUodmFsdWUpIHtcbiAgICAgICAgaWYgKCdudW1iZXInICE9PSB0eXBlb2YgdmFsdWVcbiAgICAgICAgICAgIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKVxuICAgICAgICAgICAgfHwgKHZhbHVlICE9PSBmaXhCaXR3aXNlUmVzdWx0KHZhbHVlICYgdGhpcy52YWx1ZU1hc2spKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihuYW1lV2l0aFByb3BlcnR5KCdCaXRGaWVsZC5lbmNvZGUnLCB0aGlzKVxuICAgICAgICAgICAgICAgICsgJyB2YWx1ZSBtdXN0IGJlIGludGVnZXIgbm90IGV4Y2VlZGluZyAnICsgdGhpcy52YWx1ZU1hc2spO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdvcmQgPSB0aGlzLmNvbnRhaW5lci5fcGFja2VkR2V0VmFsdWUoKTtcbiAgICAgICAgY29uc3Qgd29yZFZhbHVlID0gZml4Qml0d2lzZVJlc3VsdCh2YWx1ZSA8PCB0aGlzLnN0YXJ0KTtcbiAgICAgICAgdGhpcy5jb250YWluZXIuX3BhY2tlZFNldFZhbHVlKGZpeEJpdHdpc2VSZXN1bHQod29yZCAmIH50aGlzLndvcmRNYXNrKVxuICAgICAgICAgICAgfCB3b3JkVmFsdWUpO1xuICAgIH1cbn1cbmV4cG9ydHMuQml0RmllbGQgPSBCaXRGaWVsZDtcbi8qKlxuICogUmVwcmVzZW50IGEgc2luZ2xlIGJpdCB3aXRoaW4gYSB7QGxpbmsgQml0U3RydWN0dXJlfSBhcyBhXG4gKiBKYXZhU2NyaXB0IGJvb2xlYW4uXG4gKlxuICogKipOT1RFKiogVXNlciBjb2RlIHNob3VsZCBub3QgaW52b2tlIHRoaXMgY29uc3RydWN0b3IgZGlyZWN0bHkuXG4gKiBVc2UgdGhlIGNvbnRhaW5lciB7QGxpbmsgQml0U3RydWN0dXJlI2FkZEJvb2xlYW58YWRkQm9vbGVhbn0gaGVscGVyXG4gKiBtZXRob2QuXG4gKlxuICogQHBhcmFtIHtCaXRTdHJ1Y3R1cmV9IGNvbnRhaW5lciAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIEJpdEZpZWxkI2NvbnRhaW5lcnxjb250YWluZXJ9LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0JpdEZpZWxkfVxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1leHRlbmQtbmF0aXZlICovXG5jbGFzcyBCb29sZWFuIGV4dGVuZHMgQml0RmllbGQge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRhaW5lciwgcHJvcGVydHkpIHtcbiAgICAgICAgc3VwZXIoY29udGFpbmVyLCAxLCBwcm9wZXJ0eSk7XG4gICAgfVxuICAgIC8qKiBPdmVycmlkZSB7QGxpbmsgQml0RmllbGQjZGVjb2RlfGRlY29kZX0gZm9yIHtAbGluayBCb29sZWFufEJvb2xlYW59LlxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59ICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gISFzdXBlci5kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZSh2YWx1ZSkge1xuICAgICAgICBpZiAoJ2Jvb2xlYW4nID09PSB0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIEJpdEZpZWxkIHJlcXVpcmVzIGludGVnZXIgdmFsdWVzXG4gICAgICAgICAgICB2YWx1ZSA9ICt2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5lbmNvZGUodmFsdWUpO1xuICAgIH1cbn1cbmV4cG9ydHMuQm9vbGVhbiA9IEJvb2xlYW47XG4vKiBlc2xpbnQtZW5hYmxlIG5vLWV4dGVuZC1uYXRpdmUgKi9cbi8qKlxuICogQ29udGFpbiBhIGZpeGVkLWxlbmd0aCBibG9jayBvZiBhcmJpdHJhcnkgZGF0YSwgcmVwcmVzZW50ZWQgYXMgYVxuICogVWludDhBcnJheS5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LmJsb2J8YmxvYn1cbiAqXG4gKiBAcGFyYW0geyhOdW1iZXJ8RXh0ZXJuYWxMYXlvdXQpfSBsZW5ndGggLSBpbml0aWFsaXplcyB7QGxpbmtcbiAqIEJsb2IjbGVuZ3RofGxlbmd0aH0uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBCbG9iIGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgsIHByb3BlcnR5KSB7XG4gICAgICAgIGlmICghKCgobGVuZ3RoIGluc3RhbmNlb2YgRXh0ZXJuYWxMYXlvdXQpICYmIGxlbmd0aC5pc0NvdW50KCkpXG4gICAgICAgICAgICB8fCAoTnVtYmVyLmlzSW50ZWdlcihsZW5ndGgpICYmICgwIDw9IGxlbmd0aCkpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbGVuZ3RoIG11c3QgYmUgcG9zaXRpdmUgaW50ZWdlciAnXG4gICAgICAgICAgICAgICAgKyAnb3IgYW4gdW5zaWduZWQgaW50ZWdlciBFeHRlcm5hbExheW91dCcpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzcGFuID0gLTE7XG4gICAgICAgIGlmICghKGxlbmd0aCBpbnN0YW5jZW9mIEV4dGVybmFsTGF5b3V0KSkge1xuICAgICAgICAgICAgc3BhbiA9IGxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihzcGFuLCBwcm9wZXJ0eSk7XG4gICAgICAgIC8qKiBUaGUgbnVtYmVyIG9mIGJ5dGVzIGluIHRoZSBibG9iLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIG1heSBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyLCBvciBhbiBpbnN0YW5jZSBvZiB7QGxpbmtcbiAgICAgICAgICogRXh0ZXJuYWxMYXlvdXR9IHRoYXQgc2F0aXNmaWVzIHtAbGlua1xuICAgICAgICAgKiBFeHRlcm5hbExheW91dCNpc0NvdW50fGlzQ291bnQoKX0uICovXG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZ2V0U3BhbihiLCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IHNwYW4gPSB0aGlzLnNwYW47XG4gICAgICAgIGlmICgwID4gc3Bhbikge1xuICAgICAgICAgICAgc3BhbiA9IHRoaXMubGVuZ3RoLmRlY29kZShiLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGFuO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgbGV0IHNwYW4gPSB0aGlzLnNwYW47XG4gICAgICAgIGlmICgwID4gc3Bhbikge1xuICAgICAgICAgICAgc3BhbiA9IHRoaXMubGVuZ3RoLmRlY29kZShiLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1aW50OEFycmF5VG9CdWZmZXIoYikuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBzcGFuKTtcbiAgICB9XG4gICAgLyoqIEltcGxlbWVudCB7QGxpbmsgTGF5b3V0I2VuY29kZXxlbmNvZGV9IGZvciB7QGxpbmsgQmxvYn0uXG4gICAgICpcbiAgICAgKiAqKk5PVEUqKiBJZiB7QGxpbmsgTGF5b3V0I2NvdW50fGNvdW50fSBpcyBhbiBpbnN0YW5jZSBvZiB7QGxpbmtcbiAgICAgKiBFeHRlcm5hbExheW91dH0gdGhlbiB0aGUgbGVuZ3RoIG9mIGBzcmNgIHdpbGwgYmUgZW5jb2RlZCBhcyB0aGVcbiAgICAgKiBjb3VudCBhZnRlciBgc3JjYCBpcyBlbmNvZGVkLiAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCkge1xuICAgICAgICBsZXQgc3BhbiA9IHRoaXMubGVuZ3RoO1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggaW5zdGFuY2VvZiBFeHRlcm5hbExheW91dCkge1xuICAgICAgICAgICAgc3BhbiA9IHNyYy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoc3JjIGluc3RhbmNlb2YgVWludDhBcnJheSAmJiBzcGFuID09PSBzcmMubGVuZ3RoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihuYW1lV2l0aFByb3BlcnR5KCdCbG9iLmVuY29kZScsIHRoaXMpXG4gICAgICAgICAgICAgICAgKyAnIHJlcXVpcmVzIChsZW5ndGggJyArIHNwYW4gKyAnKSBVaW50OEFycmF5IGFzIHNyYycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgob2Zmc2V0ICsgc3BhbikgPiBiLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2VuY29kaW5nIG92ZXJydW5zIFVpbnQ4QXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzcmNCdWZmZXIgPSB1aW50OEFycmF5VG9CdWZmZXIoc3JjKTtcbiAgICAgICAgdWludDhBcnJheVRvQnVmZmVyKGIpLndyaXRlKHNyY0J1ZmZlci50b1N0cmluZygnaGV4JyksIG9mZnNldCwgc3BhbiwgJ2hleCcpO1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggaW5zdGFuY2VvZiBFeHRlcm5hbExheW91dCkge1xuICAgICAgICAgICAgdGhpcy5sZW5ndGguZW5jb2RlKHNwYW4sIGIsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgfVxufVxuZXhwb3J0cy5CbG9iID0gQmxvYjtcbi8qKlxuICogQ29udGFpbiBhIGBOVUxgLXRlcm1pbmF0ZWQgVVRGOCBzdHJpbmcuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5jc3RyfGNzdHJ9XG4gKlxuICogKipOT1RFKiogQW55IFVURjggc3RyaW5nIHRoYXQgaW5jb3Jwb3JhdGVzIGEgemVyby12YWx1ZWQgYnl0ZSB3aWxsXG4gKiBub3QgYmUgY29ycmVjdGx5IGRlY29kZWQgYnkgdGhpcyBsYXlvdXQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBDU3RyaW5nIGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eSkge1xuICAgICAgICBzdXBlcigtMSwgcHJvcGVydHkpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZ2V0U3BhbihiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNoZWNrVWludDhBcnJheShiKTtcbiAgICAgICAgbGV0IGlkeCA9IG9mZnNldDtcbiAgICAgICAgd2hpbGUgKChpZHggPCBiLmxlbmd0aCkgJiYgKDAgIT09IGJbaWR4XSkpIHtcbiAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAxICsgaWR4IC0gb2Zmc2V0O1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY29uc3Qgc3BhbiA9IHRoaXMuZ2V0U3BhbihiLCBvZmZzZXQpO1xuICAgICAgICByZXR1cm4gdWludDhBcnJheVRvQnVmZmVyKGIpLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgc3BhbiAtIDEpLnRvU3RyaW5nKCd1dGYtOCcpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICAvKiBNdXN0IGZvcmNlIHRoaXMgdG8gYSBzdHJpbmcsIGxlc3QgaXQgYmUgYSBudW1iZXIgYW5kIHRoZVxuICAgICAgICAgKiBcInV0ZjgtZW5jb2RpbmdcIiBiZWxvdyBhY3R1YWxseSBhbGxvY2F0ZSBhIGJ1ZmZlciBvZiBsZW5ndGhcbiAgICAgICAgICogc3JjICovXG4gICAgICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIHNyYykge1xuICAgICAgICAgICAgc3JjID0gU3RyaW5nKHNyYyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3JjYiA9IGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKHNyYywgJ3V0ZjgnKTtcbiAgICAgICAgY29uc3Qgc3BhbiA9IHNyY2IubGVuZ3RoO1xuICAgICAgICBpZiAoKG9mZnNldCArIHNwYW4pID4gYi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdlbmNvZGluZyBvdmVycnVucyBCdWZmZXInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWZmZXIgPSB1aW50OEFycmF5VG9CdWZmZXIoYik7XG4gICAgICAgIHNyY2IuY29weShidWZmZXIsIG9mZnNldCk7XG4gICAgICAgIGJ1ZmZlcltvZmZzZXQgKyBzcGFuXSA9IDA7XG4gICAgICAgIHJldHVybiBzcGFuICsgMTtcbiAgICB9XG59XG5leHBvcnRzLkNTdHJpbmcgPSBDU3RyaW5nO1xuLyoqXG4gKiBDb250YWluIGEgVVRGOCBzdHJpbmcgd2l0aCBpbXBsaWNpdCBsZW5ndGguXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC51dGY4fHV0Zjh9XG4gKlxuICogKipOT1RFKiogQmVjYXVzZSB0aGUgbGVuZ3RoIGlzIGltcGxpY2l0IGluIHRoZSBzaXplIG9mIHRoZSBidWZmZXJcbiAqIHRoaXMgbGF5b3V0IHNob3VsZCBiZSB1c2VkIG9ubHkgaW4gaXNvbGF0aW9uLCBvciBpbiBhIHNpdHVhdGlvblxuICogd2hlcmUgdGhlIGxlbmd0aCBjYW4gYmUgZXhwcmVzc2VkIGJ5IG9wZXJhdGluZyBvbiBhIHNsaWNlIG9mIHRoZVxuICogY29udGFpbmluZyBidWZmZXIuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IFttYXhTcGFuXSAtIHRoZSBtYXhpbXVtIGxlbmd0aCBhbGxvd2VkIGZvciBlbmNvZGVkXG4gKiBzdHJpbmcgY29udGVudC4gIElmIG5vdCBwcm92aWRlZCB0aGVyZSBpcyBubyBib3VuZCBvbiB0aGUgYWxsb3dlZFxuICogY29udGVudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIFVURjggZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKG1heFNwYW4sIHByb3BlcnR5KSB7XG4gICAgICAgIGlmICgoJ3N0cmluZycgPT09IHR5cGVvZiBtYXhTcGFuKSAmJiAodW5kZWZpbmVkID09PSBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIHByb3BlcnR5ID0gbWF4U3BhbjtcbiAgICAgICAgICAgIG1heFNwYW4gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gbWF4U3Bhbikge1xuICAgICAgICAgICAgbWF4U3BhbiA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heFNwYW4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtYXhTcGFuIG11c3QgYmUgYW4gaW50ZWdlcicpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKC0xLCBwcm9wZXJ0eSk7XG4gICAgICAgIC8qKiBUaGUgbWF4aW11bSBzcGFuIG9mIHRoZSBsYXlvdXQgaW4gYnl0ZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFBvc2l0aXZlIHZhbHVlcyBhcmUgZ2VuZXJhbGx5IGV4cGVjdGVkLiAgWmVybyBpcyBhYm5vcm1hbC5cbiAgICAgICAgICogQXR0ZW1wdHMgdG8gZW5jb2RlIG9yIGRlY29kZSBhIHZhbHVlIHRoYXQgZXhjZWVkcyB0aGlzIGxlbmd0aFxuICAgICAgICAgKiB3aWxsIHRocm93IGEgYFJhbmdlRXJyb3JgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBBIG5lZ2F0aXZlIHZhbHVlIGluZGljYXRlcyB0aGF0IHRoZXJlIGlzIG5vIGJvdW5kIG9uIHRoZSBsZW5ndGhcbiAgICAgICAgICogb2YgdGhlIGNvbnRlbnQuICovXG4gICAgICAgIHRoaXMubWF4U3BhbiA9IG1heFNwYW47XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBnZXRTcGFuKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY2hlY2tVaW50OEFycmF5KGIpO1xuICAgICAgICByZXR1cm4gYi5sZW5ndGggLSBvZmZzZXQ7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjb25zdCBzcGFuID0gdGhpcy5nZXRTcGFuKGIsIG9mZnNldCk7XG4gICAgICAgIGlmICgoMCA8PSB0aGlzLm1heFNwYW4pXG4gICAgICAgICAgICAmJiAodGhpcy5tYXhTcGFuIDwgc3BhbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0ZXh0IGxlbmd0aCBleGNlZWRzIG1heFNwYW4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdWludDhBcnJheVRvQnVmZmVyKGIpLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgc3BhbikudG9TdHJpbmcoJ3V0Zi04Jyk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIC8qIE11c3QgZm9yY2UgdGhpcyB0byBhIHN0cmluZywgbGVzdCBpdCBiZSBhIG51bWJlciBhbmQgdGhlXG4gICAgICAgICAqIFwidXRmOC1lbmNvZGluZ1wiIGJlbG93IGFjdHVhbGx5IGFsbG9jYXRlIGEgYnVmZmVyIG9mIGxlbmd0aFxuICAgICAgICAgKiBzcmMgKi9cbiAgICAgICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2Ygc3JjKSB7XG4gICAgICAgICAgICBzcmMgPSBTdHJpbmcoc3JjKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzcmNiID0gYnVmZmVyXzEuQnVmZmVyLmZyb20oc3JjLCAndXRmOCcpO1xuICAgICAgICBjb25zdCBzcGFuID0gc3JjYi5sZW5ndGg7XG4gICAgICAgIGlmICgoMCA8PSB0aGlzLm1heFNwYW4pXG4gICAgICAgICAgICAmJiAodGhpcy5tYXhTcGFuIDwgc3BhbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0ZXh0IGxlbmd0aCBleGNlZWRzIG1heFNwYW4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKG9mZnNldCArIHNwYW4pID4gYi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdlbmNvZGluZyBvdmVycnVucyBCdWZmZXInKTtcbiAgICAgICAgfVxuICAgICAgICBzcmNiLmNvcHkodWludDhBcnJheVRvQnVmZmVyKGIpLCBvZmZzZXQpO1xuICAgICAgICByZXR1cm4gc3BhbjtcbiAgICB9XG59XG5leHBvcnRzLlVURjggPSBVVEY4O1xuLyoqXG4gKiBDb250YWluIGEgY29uc3RhbnQgdmFsdWUuXG4gKlxuICogVGhpcyBsYXlvdXQgbWF5IGJlIHVzZWQgaW4gY2FzZXMgd2hlcmUgYSBKYXZhU2NyaXB0IHZhbHVlIGNhbiBiZVxuICogaW5mZXJyZWQgd2l0aG91dCBhbiBleHByZXNzaW9uIGluIHRoZSBiaW5hcnkgZW5jb2RpbmcuICBBbiBleGFtcGxlXG4gKiB3b3VsZCBiZSBhIHtAbGluayBWYXJpYW50TGF5b3V0fHZhcmlhbnQgbGF5b3V0fSB3aGVyZSB0aGUgY29udGVudFxuICogaXMgaW1wbGllZCBieSB0aGUgdW5pb24ge0BsaW5rIFVuaW9uI2Rpc2NyaW1pbmF0b3J8ZGlzY3JpbWluYXRvcn0uXG4gKlxuICogQHBhcmFtIHtPYmplY3R8TnVtYmVyfFN0cmluZ30gdmFsdWUgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBDb25zdGFudCN2YWx1ZXx2YWx1ZX0uICBJZiB0aGUgdmFsdWUgaXMgYW4gb2JqZWN0IChvciBhcnJheSkgYW5kXG4gKiB0aGUgYXBwbGljYXRpb24gaW50ZW5kcyB0aGUgb2JqZWN0IHRvIHJlbWFpbiB1bmNoYW5nZWQgcmVnYXJkbGVzc1xuICogb2Ygd2hhdCBpcyBkb25lIHRvIHZhbHVlcyBkZWNvZGVkIGJ5IHRoaXMgbGF5b3V0LCB0aGUgdmFsdWUgc2hvdWxkXG4gKiBiZSBmcm96ZW4gcHJpb3IgcGFzc2luZyBpdCB0byB0aGlzIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgQ29uc3RhbnQgZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCBwcm9wZXJ0eSkge1xuICAgICAgICBzdXBlcigwLCBwcm9wZXJ0eSk7XG4gICAgICAgIC8qKiBUaGUgdmFsdWUgcHJvZHVjZWQgYnkgdGhpcyBjb25zdGFudCB3aGVuIHRoZSBsYXlvdXQgaXMge0BsaW5rXG4gICAgICAgICAqIENvbnN0YW50I2RlY29kZXxkZWNvZGVkfS5cbiAgICAgICAgICpcbiAgICAgICAgICogQW55IEphdmFTY3JpcHQgdmFsdWUgaW5jbHVkaW5nIGBudWxsYCBhbmQgYHVuZGVmaW5lZGAgaXNcbiAgICAgICAgICogcGVybWl0dGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiAqKldBUk5JTkcqKiBJZiBgdmFsdWVgIHBhc3NlZCBpbiB0aGUgY29uc3RydWN0b3Igd2FzIG5vdFxuICAgICAgICAgKiBmcm96ZW4sIGl0IGlzIHBvc3NpYmxlIGZvciB1c2VycyBvZiBkZWNvZGVkIHZhbHVlcyB0byBjaGFuZ2VcbiAgICAgICAgICogdGhlIGNvbnRlbnQgb2YgdGhlIHZhbHVlLiAqL1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgICAgIC8qIENvbnN0YW50cyB0YWtlIG5vIHNwYWNlICovXG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29uc3RhbnQgPSBDb25zdGFudDtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgR3JlZWR5Q291bnR9LiAqL1xuZXhwb3J0cy5ncmVlZHkgPSAoKGVsZW1lbnRTcGFuLCBwcm9wZXJ0eSkgPT4gbmV3IEdyZWVkeUNvdW50KGVsZW1lbnRTcGFuLCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBPZmZzZXRMYXlvdXR9LiAqL1xuZXhwb3J0cy5vZmZzZXQgPSAoKGxheW91dCwgb2Zmc2V0LCBwcm9wZXJ0eSkgPT4gbmV3IE9mZnNldExheW91dChsYXlvdXQsIG9mZnNldCwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgVUludHx1bnNpZ25lZCBpbnQgbGF5b3V0c30gc3Bhbm5pbmcgb25lXG4gKiBieXRlLiAqL1xuZXhwb3J0cy51OCA9ICgocHJvcGVydHkpID0+IG5ldyBVSW50KDEsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVJbnR8bGl0dGxlLWVuZGlhbiB1bnNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIHR3byBieXRlcy4gKi9cbmV4cG9ydHMudTE2ID0gKChwcm9wZXJ0eSkgPT4gbmV3IFVJbnQoMiwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgVUludHxsaXR0bGUtZW5kaWFuIHVuc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgdGhyZWUgYnl0ZXMuICovXG5leHBvcnRzLnUyNCA9ICgocHJvcGVydHkpID0+IG5ldyBVSW50KDMsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVJbnR8bGl0dGxlLWVuZGlhbiB1bnNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIGZvdXIgYnl0ZXMuICovXG5leHBvcnRzLnUzMiA9ICgocHJvcGVydHkpID0+IG5ldyBVSW50KDQsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVJbnR8bGl0dGxlLWVuZGlhbiB1bnNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIGZpdmUgYnl0ZXMuICovXG5leHBvcnRzLnU0MCA9ICgocHJvcGVydHkpID0+IG5ldyBVSW50KDUsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVJbnR8bGl0dGxlLWVuZGlhbiB1bnNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIHNpeCBieXRlcy4gKi9cbmV4cG9ydHMudTQ4ID0gKChwcm9wZXJ0eSkgPT4gbmV3IFVJbnQoNiwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgTmVhclVJbnQ2NHxsaXR0bGUtZW5kaWFuIHVuc2lnbmVkIGludFxuICogbGF5b3V0c30gaW50ZXJwcmV0ZWQgYXMgTnVtYmVycy4gKi9cbmV4cG9ydHMubnU2NCA9ICgocHJvcGVydHkpID0+IG5ldyBOZWFyVUludDY0KHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVJbnR8YmlnLWVuZGlhbiB1bnNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIHR3byBieXRlcy4gKi9cbmV4cG9ydHMudTE2YmUgPSAoKHByb3BlcnR5KSA9PiBuZXcgVUludEJFKDIsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVJbnR8YmlnLWVuZGlhbiB1bnNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIHRocmVlIGJ5dGVzLiAqL1xuZXhwb3J0cy51MjRiZSA9ICgocHJvcGVydHkpID0+IG5ldyBVSW50QkUoMywgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgVUludHxiaWctZW5kaWFuIHVuc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgZm91ciBieXRlcy4gKi9cbmV4cG9ydHMudTMyYmUgPSAoKHByb3BlcnR5KSA9PiBuZXcgVUludEJFKDQsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVJbnR8YmlnLWVuZGlhbiB1bnNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIGZpdmUgYnl0ZXMuICovXG5leHBvcnRzLnU0MGJlID0gKChwcm9wZXJ0eSkgPT4gbmV3IFVJbnRCRSg1LCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVSW50fGJpZy1lbmRpYW4gdW5zaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyBzaXggYnl0ZXMuICovXG5leHBvcnRzLnU0OGJlID0gKChwcm9wZXJ0eSkgPT4gbmV3IFVJbnRCRSg2LCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBOZWFyVUludDY0QkV8YmlnLWVuZGlhbiB1bnNpZ25lZCBpbnRcbiAqIGxheW91dHN9IGludGVycHJldGVkIGFzIE51bWJlcnMuICovXG5leHBvcnRzLm51NjRiZSA9ICgocHJvcGVydHkpID0+IG5ldyBOZWFyVUludDY0QkUocHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgSW50fHNpZ25lZCBpbnQgbGF5b3V0c30gc3Bhbm5pbmcgb25lXG4gKiBieXRlLiAqL1xuZXhwb3J0cy5zOCA9ICgocHJvcGVydHkpID0+IG5ldyBJbnQoMSwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgSW50fGxpdHRsZS1lbmRpYW4gc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgdHdvIGJ5dGVzLiAqL1xuZXhwb3J0cy5zMTYgPSAoKHByb3BlcnR5KSA9PiBuZXcgSW50KDIsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEludHxsaXR0bGUtZW5kaWFuIHNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIHRocmVlIGJ5dGVzLiAqL1xuZXhwb3J0cy5zMjQgPSAoKHByb3BlcnR5KSA9PiBuZXcgSW50KDMsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEludHxsaXR0bGUtZW5kaWFuIHNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIGZvdXIgYnl0ZXMuICovXG5leHBvcnRzLnMzMiA9ICgocHJvcGVydHkpID0+IG5ldyBJbnQoNCwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgSW50fGxpdHRsZS1lbmRpYW4gc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgZml2ZSBieXRlcy4gKi9cbmV4cG9ydHMuczQwID0gKChwcm9wZXJ0eSkgPT4gbmV3IEludCg1LCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBJbnR8bGl0dGxlLWVuZGlhbiBzaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyBzaXggYnl0ZXMuICovXG5leHBvcnRzLnM0OCA9ICgocHJvcGVydHkpID0+IG5ldyBJbnQoNiwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgTmVhckludDY0fGxpdHRsZS1lbmRpYW4gc2lnbmVkIGludCBsYXlvdXRzfVxuICogaW50ZXJwcmV0ZWQgYXMgTnVtYmVycy4gKi9cbmV4cG9ydHMubnM2NCA9ICgocHJvcGVydHkpID0+IG5ldyBOZWFySW50NjQocHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgSW50fGJpZy1lbmRpYW4gc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgdHdvIGJ5dGVzLiAqL1xuZXhwb3J0cy5zMTZiZSA9ICgocHJvcGVydHkpID0+IG5ldyBJbnRCRSgyLCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBJbnR8YmlnLWVuZGlhbiBzaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyB0aHJlZSBieXRlcy4gKi9cbmV4cG9ydHMuczI0YmUgPSAoKHByb3BlcnR5KSA9PiBuZXcgSW50QkUoMywgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgSW50fGJpZy1lbmRpYW4gc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgZm91ciBieXRlcy4gKi9cbmV4cG9ydHMuczMyYmUgPSAoKHByb3BlcnR5KSA9PiBuZXcgSW50QkUoNCwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgSW50fGJpZy1lbmRpYW4gc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgZml2ZSBieXRlcy4gKi9cbmV4cG9ydHMuczQwYmUgPSAoKHByb3BlcnR5KSA9PiBuZXcgSW50QkUoNSwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgSW50fGJpZy1lbmRpYW4gc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgc2l4IGJ5dGVzLiAqL1xuZXhwb3J0cy5zNDhiZSA9ICgocHJvcGVydHkpID0+IG5ldyBJbnRCRSg2LCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBOZWFySW50NjRCRXxiaWctZW5kaWFuIHNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIGludGVycHJldGVkIGFzIE51bWJlcnMuICovXG5leHBvcnRzLm5zNjRiZSA9ICgocHJvcGVydHkpID0+IG5ldyBOZWFySW50NjRCRShwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBGbG9hdHxsaXR0bGUtZW5kaWFuIDMyLWJpdCBmbG9hdGluZyBwb2ludH0gdmFsdWVzLiAqL1xuZXhwb3J0cy5mMzIgPSAoKHByb3BlcnR5KSA9PiBuZXcgRmxvYXQocHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgRmxvYXRCRXxiaWctZW5kaWFuIDMyLWJpdCBmbG9hdGluZyBwb2ludH0gdmFsdWVzLiAqL1xuZXhwb3J0cy5mMzJiZSA9ICgocHJvcGVydHkpID0+IG5ldyBGbG9hdEJFKHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIERvdWJsZXxsaXR0bGUtZW5kaWFuIDY0LWJpdCBmbG9hdGluZyBwb2ludH0gdmFsdWVzLiAqL1xuZXhwb3J0cy5mNjQgPSAoKHByb3BlcnR5KSA9PiBuZXcgRG91YmxlKHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIERvdWJsZUJFfGJpZy1lbmRpYW4gNjQtYml0IGZsb2F0aW5nIHBvaW50fSB2YWx1ZXMuICovXG5leHBvcnRzLmY2NGJlID0gKChwcm9wZXJ0eSkgPT4gbmV3IERvdWJsZUJFKHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFN0cnVjdHVyZX0gdmFsdWVzLiAqL1xuZXhwb3J0cy5zdHJ1Y3QgPSAoKGZpZWxkcywgcHJvcGVydHksIGRlY29kZVByZWZpeGVzKSA9PiBuZXcgU3RydWN0dXJlKGZpZWxkcywgcHJvcGVydHksIGRlY29kZVByZWZpeGVzKSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEJpdFN0cnVjdHVyZX0gdmFsdWVzLiAqL1xuZXhwb3J0cy5iaXRzID0gKCh3b3JkLCBtc2IsIHByb3BlcnR5KSA9PiBuZXcgQml0U3RydWN0dXJlKHdvcmQsIG1zYiwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgU2VxdWVuY2V9IHZhbHVlcy4gKi9cbmV4cG9ydHMuc2VxID0gKChlbGVtZW50TGF5b3V0LCBjb3VudCwgcHJvcGVydHkpID0+IG5ldyBTZXF1ZW5jZShlbGVtZW50TGF5b3V0LCBjb3VudCwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgVW5pb259IHZhbHVlcy4gKi9cbmV4cG9ydHMudW5pb24gPSAoKGRpc2NyLCBkZWZhdWx0TGF5b3V0LCBwcm9wZXJ0eSkgPT4gbmV3IFVuaW9uKGRpc2NyLCBkZWZhdWx0TGF5b3V0LCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVbmlvbkxheW91dERpc2NyaW1pbmF0b3J9IHZhbHVlcy4gKi9cbmV4cG9ydHMudW5pb25MYXlvdXREaXNjcmltaW5hdG9yID0gKChsYXlvdXQsIHByb3BlcnR5KSA9PiBuZXcgVW5pb25MYXlvdXREaXNjcmltaW5hdG9yKGxheW91dCwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgQmxvYn0gdmFsdWVzLiAqL1xuZXhwb3J0cy5ibG9iID0gKChsZW5ndGgsIHByb3BlcnR5KSA9PiBuZXcgQmxvYihsZW5ndGgsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIENTdHJpbmd9IHZhbHVlcy4gKi9cbmV4cG9ydHMuY3N0ciA9ICgocHJvcGVydHkpID0+IG5ldyBDU3RyaW5nKHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVURjh9IHZhbHVlcy4gKi9cbmV4cG9ydHMudXRmOCA9ICgobWF4U3BhbiwgcHJvcGVydHkpID0+IG5ldyBVVEY4KG1heFNwYW4sIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIENvbnN0YW50fSB2YWx1ZXMuICovXG5leHBvcnRzLmNvbnN0YW50ID0gKCh2YWx1ZSwgcHJvcGVydHkpID0+IG5ldyBDb25zdGFudCh2YWx1ZSwgcHJvcGVydHkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxheW91dC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJzMTYiLCJzOCIsIm51NjRiZSIsInU0OGJlIiwidTQwYmUiLCJ1MzJiZSIsInUyNGJlIiwidTE2YmUiLCJudTY0IiwidTQ4IiwidTQwIiwidTMyIiwidTI0IiwidTE2IiwidTgiLCJvZmZzZXQiLCJncmVlZHkiLCJDb25zdGFudCIsIlVURjgiLCJDU3RyaW5nIiwiQmxvYiIsIkJvb2xlYW4iLCJCaXRGaWVsZCIsIkJpdFN0cnVjdHVyZSIsIlZhcmlhbnRMYXlvdXQiLCJVbmlvbiIsIlVuaW9uTGF5b3V0RGlzY3JpbWluYXRvciIsIlVuaW9uRGlzY3JpbWluYXRvciIsIlN0cnVjdHVyZSIsIlNlcXVlbmNlIiwiRG91YmxlQkUiLCJEb3VibGUiLCJGbG9hdEJFIiwiRmxvYXQiLCJOZWFySW50NjRCRSIsIk5lYXJJbnQ2NCIsIk5lYXJVSW50NjRCRSIsIk5lYXJVSW50NjQiLCJJbnRCRSIsIkludCIsIlVJbnRCRSIsIlVJbnQiLCJPZmZzZXRMYXlvdXQiLCJHcmVlZHlDb3VudCIsIkV4dGVybmFsTGF5b3V0IiwiYmluZENvbnN0cnVjdG9yTGF5b3V0IiwibmFtZVdpdGhQcm9wZXJ0eSIsIkxheW91dCIsInVpbnQ4QXJyYXlUb0J1ZmZlciIsImNoZWNrVWludDhBcnJheSIsImNvbnN0YW50IiwidXRmOCIsImNzdHIiLCJibG9iIiwidW5pb25MYXlvdXREaXNjcmltaW5hdG9yIiwidW5pb24iLCJzZXEiLCJiaXRzIiwic3RydWN0IiwiZjY0YmUiLCJmNjQiLCJmMzJiZSIsImYzMiIsIm5zNjRiZSIsInM0OGJlIiwiczQwYmUiLCJzMzJiZSIsInMyNGJlIiwiczE2YmUiLCJuczY0IiwiczQ4IiwiczQwIiwiczMyIiwiczI0IiwiYnVmZmVyXzEiLCJyZXF1aXJlIiwiYiIsIlVpbnQ4QXJyYXkiLCJUeXBlRXJyb3IiLCJCdWZmZXIiLCJmcm9tIiwiYnVmZmVyIiwiYnl0ZU9mZnNldCIsImxlbmd0aCIsImNvbnN0cnVjdG9yIiwic3BhbiIsInByb3BlcnR5IiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwibWFrZURlc3RpbmF0aW9uT2JqZWN0IiwiZ2V0U3BhbiIsIlJhbmdlRXJyb3IiLCJyZXBsaWNhdGUiLCJydiIsImNyZWF0ZSIsInByb3RvdHlwZSIsImFzc2lnbiIsImZyb21BcnJheSIsInZhbHVlcyIsInVuZGVmaW5lZCIsIm5hbWUiLCJsbyIsIkNsYXNzIiwibGF5b3V0IiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiRXJyb3IiLCJsYXlvdXRfIiwiYm91bmRDb25zdHJ1Y3Rvcl8iLCJlbmNvZGUiLCJ3cml0YWJsZSIsImRlY29kZSIsImlzQ291bnQiLCJlbGVtZW50U3BhbiIsInJlbSIsIk1hdGgiLCJmbG9vciIsInNyYyIsInJlYWRVSW50TEUiLCJ3cml0ZVVJbnRMRSIsInJlYWRVSW50QkUiLCJ3cml0ZVVJbnRCRSIsInJlYWRJbnRMRSIsIndyaXRlSW50TEUiLCJyZWFkSW50QkUiLCJ3cml0ZUludEJFIiwiVjJFMzIiLCJwb3ciLCJkaXZtb2RJbnQ2NCIsImhpMzIiLCJsbzMyIiwicm91bmRlZEludDY0IiwicmVhZFVJbnQzMkxFIiwic3BsaXQiLCJ3cml0ZVVJbnQzMkxFIiwicmVhZFVJbnQzMkJFIiwid3JpdGVVSW50MzJCRSIsInJlYWRJbnQzMkxFIiwid3JpdGVJbnQzMkxFIiwicmVhZEludDMyQkUiLCJ3cml0ZUludDMyQkUiLCJyZWFkRmxvYXRMRSIsIndyaXRlRmxvYXRMRSIsInJlYWRGbG9hdEJFIiwid3JpdGVGbG9hdEJFIiwicmVhZERvdWJsZUxFIiwid3JpdGVEb3VibGVMRSIsInJlYWREb3VibGVCRSIsIndyaXRlRG91YmxlQkUiLCJlbGVtZW50TGF5b3V0IiwiY291bnQiLCJpZHgiLCJpIiwicHVzaCIsImVsbyIsInJlZHVjZSIsInYiLCJmaWVsZHMiLCJkZWNvZGVQcmVmaXhlcyIsIkFycmF5IiwiaXNBcnJheSIsImFjYyIsImZkIiwiZSIsImZzcCIsImRlc3QiLCJmaXJzdE9mZnNldCIsImxhc3RPZmZzZXQiLCJsYXN0V3JvdGUiLCJmdiIsInNoaWZ0IiwibGF5b3V0Rm9yIiwib2Zmc2V0T2YiLCJkaXNjciIsImRlZmF1bHRMYXlvdXQiLCJkaXNjcmltaW5hdG9yIiwidXNlc1ByZWZpeERpc2NyaW1pbmF0b3IiLCJyZWdpc3RyeSIsImJvdW5kR2V0U291cmNlVmFyaWFudCIsImRlZmF1bHRHZXRTb3VyY2VWYXJpYW50IiwiYmluZCIsImdldFNvdXJjZVZhcmlhbnQiLCJjb25maWdHZXRTb3VyY2VWYXJpYW50IiwiZ3N2IiwidmxvIiwiZ2V0VmFyaWFudCIsInRhZyIsImRsbyIsImNsbyIsImNvbnRlbnRPZmZzZXQiLCJhZGRWYXJpYW50IiwidmFyaWFudCIsInZiIiwiZml4Qml0d2lzZVJlc3VsdCIsIndvcmQiLCJtc2IiLCJfcGFja2VkU2V0VmFsdWUiLCJfcGFja2VkR2V0VmFsdWUiLCJhZGRGaWVsZCIsImJmIiwiYWRkQm9vbGVhbiIsImZpZWxkRm9yIiwiY29udGFpbmVyIiwidG90YWxCaXRzIiwidXNlZEJpdHMiLCJzdW0iLCJ2YWx1ZU1hc2siLCJzdGFydCIsIndvcmRNYXNrIiwid29yZFZhbHVlIiwic2xpY2UiLCJzcmNCdWZmZXIiLCJ3cml0ZSIsInRvU3RyaW5nIiwiU3RyaW5nIiwic3JjYiIsImNvcHkiLCJtYXhTcGFuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@solana/buffer-layout/lib/Layout.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@solana/web3.js/lib/index.esm.js":
/*!*******************************************************!*\
  !*** ./node_modules/@solana/web3.js/lib/index.esm.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Account: () => (/* binding */ Account),\n/* harmony export */   AddressLookupTableAccount: () => (/* binding */ AddressLookupTableAccount),\n/* harmony export */   AddressLookupTableInstruction: () => (/* binding */ AddressLookupTableInstruction),\n/* harmony export */   AddressLookupTableProgram: () => (/* binding */ AddressLookupTableProgram),\n/* harmony export */   Authorized: () => (/* binding */ Authorized),\n/* harmony export */   BLOCKHASH_CACHE_TIMEOUT_MS: () => (/* binding */ BLOCKHASH_CACHE_TIMEOUT_MS),\n/* harmony export */   BPF_LOADER_DEPRECATED_PROGRAM_ID: () => (/* binding */ BPF_LOADER_DEPRECATED_PROGRAM_ID),\n/* harmony export */   BPF_LOADER_PROGRAM_ID: () => (/* binding */ BPF_LOADER_PROGRAM_ID),\n/* harmony export */   BpfLoader: () => (/* binding */ BpfLoader),\n/* harmony export */   COMPUTE_BUDGET_INSTRUCTION_LAYOUTS: () => (/* binding */ COMPUTE_BUDGET_INSTRUCTION_LAYOUTS),\n/* harmony export */   ComputeBudgetInstruction: () => (/* binding */ ComputeBudgetInstruction),\n/* harmony export */   ComputeBudgetProgram: () => (/* binding */ ComputeBudgetProgram),\n/* harmony export */   Connection: () => (/* binding */ Connection),\n/* harmony export */   Ed25519Program: () => (/* binding */ Ed25519Program),\n/* harmony export */   Enum: () => (/* binding */ Enum),\n/* harmony export */   EpochSchedule: () => (/* binding */ EpochSchedule),\n/* harmony export */   FeeCalculatorLayout: () => (/* binding */ FeeCalculatorLayout),\n/* harmony export */   Keypair: () => (/* binding */ Keypair),\n/* harmony export */   LAMPORTS_PER_SOL: () => (/* binding */ LAMPORTS_PER_SOL),\n/* harmony export */   LOOKUP_TABLE_INSTRUCTION_LAYOUTS: () => (/* binding */ LOOKUP_TABLE_INSTRUCTION_LAYOUTS),\n/* harmony export */   Loader: () => (/* binding */ Loader),\n/* harmony export */   Lockup: () => (/* binding */ Lockup),\n/* harmony export */   MAX_SEED_LENGTH: () => (/* binding */ MAX_SEED_LENGTH),\n/* harmony export */   Message: () => (/* binding */ Message),\n/* harmony export */   MessageAccountKeys: () => (/* binding */ MessageAccountKeys),\n/* harmony export */   MessageV0: () => (/* binding */ MessageV0),\n/* harmony export */   NONCE_ACCOUNT_LENGTH: () => (/* binding */ NONCE_ACCOUNT_LENGTH),\n/* harmony export */   NonceAccount: () => (/* binding */ NonceAccount),\n/* harmony export */   PACKET_DATA_SIZE: () => (/* binding */ PACKET_DATA_SIZE),\n/* harmony export */   PUBLIC_KEY_LENGTH: () => (/* binding */ PUBLIC_KEY_LENGTH),\n/* harmony export */   PublicKey: () => (/* binding */ PublicKey),\n/* harmony export */   SIGNATURE_LENGTH_IN_BYTES: () => (/* binding */ SIGNATURE_LENGTH_IN_BYTES),\n/* harmony export */   SOLANA_SCHEMA: () => (/* binding */ SOLANA_SCHEMA),\n/* harmony export */   STAKE_CONFIG_ID: () => (/* binding */ STAKE_CONFIG_ID),\n/* harmony export */   STAKE_INSTRUCTION_LAYOUTS: () => (/* binding */ STAKE_INSTRUCTION_LAYOUTS),\n/* harmony export */   SYSTEM_INSTRUCTION_LAYOUTS: () => (/* binding */ SYSTEM_INSTRUCTION_LAYOUTS),\n/* harmony export */   SYSVAR_CLOCK_PUBKEY: () => (/* binding */ SYSVAR_CLOCK_PUBKEY),\n/* harmony export */   SYSVAR_EPOCH_SCHEDULE_PUBKEY: () => (/* binding */ SYSVAR_EPOCH_SCHEDULE_PUBKEY),\n/* harmony export */   SYSVAR_INSTRUCTIONS_PUBKEY: () => (/* binding */ SYSVAR_INSTRUCTIONS_PUBKEY),\n/* harmony export */   SYSVAR_RECENT_BLOCKHASHES_PUBKEY: () => (/* binding */ SYSVAR_RECENT_BLOCKHASHES_PUBKEY),\n/* harmony export */   SYSVAR_RENT_PUBKEY: () => (/* binding */ SYSVAR_RENT_PUBKEY),\n/* harmony export */   SYSVAR_REWARDS_PUBKEY: () => (/* binding */ SYSVAR_REWARDS_PUBKEY),\n/* harmony export */   SYSVAR_SLOT_HASHES_PUBKEY: () => (/* binding */ SYSVAR_SLOT_HASHES_PUBKEY),\n/* harmony export */   SYSVAR_SLOT_HISTORY_PUBKEY: () => (/* binding */ SYSVAR_SLOT_HISTORY_PUBKEY),\n/* harmony export */   SYSVAR_STAKE_HISTORY_PUBKEY: () => (/* binding */ SYSVAR_STAKE_HISTORY_PUBKEY),\n/* harmony export */   Secp256k1Program: () => (/* binding */ Secp256k1Program),\n/* harmony export */   SendTransactionError: () => (/* binding */ SendTransactionError),\n/* harmony export */   SolanaJSONRPCError: () => (/* binding */ SolanaJSONRPCError),\n/* harmony export */   SolanaJSONRPCErrorCode: () => (/* binding */ SolanaJSONRPCErrorCode),\n/* harmony export */   StakeAuthorizationLayout: () => (/* binding */ StakeAuthorizationLayout),\n/* harmony export */   StakeInstruction: () => (/* binding */ StakeInstruction),\n/* harmony export */   StakeProgram: () => (/* binding */ StakeProgram),\n/* harmony export */   Struct: () => (/* binding */ Struct),\n/* harmony export */   SystemInstruction: () => (/* binding */ SystemInstruction),\n/* harmony export */   SystemProgram: () => (/* binding */ SystemProgram),\n/* harmony export */   Transaction: () => (/* binding */ Transaction),\n/* harmony export */   TransactionExpiredBlockheightExceededError: () => (/* binding */ TransactionExpiredBlockheightExceededError),\n/* harmony export */   TransactionExpiredNonceInvalidError: () => (/* binding */ TransactionExpiredNonceInvalidError),\n/* harmony export */   TransactionExpiredTimeoutError: () => (/* binding */ TransactionExpiredTimeoutError),\n/* harmony export */   TransactionInstruction: () => (/* binding */ TransactionInstruction),\n/* harmony export */   TransactionMessage: () => (/* binding */ TransactionMessage),\n/* harmony export */   TransactionStatus: () => (/* binding */ TransactionStatus),\n/* harmony export */   VALIDATOR_INFO_KEY: () => (/* binding */ VALIDATOR_INFO_KEY),\n/* harmony export */   VERSION_PREFIX_MASK: () => (/* binding */ VERSION_PREFIX_MASK),\n/* harmony export */   VOTE_PROGRAM_ID: () => (/* binding */ VOTE_PROGRAM_ID),\n/* harmony export */   ValidatorInfo: () => (/* binding */ ValidatorInfo),\n/* harmony export */   VersionedMessage: () => (/* binding */ VersionedMessage),\n/* harmony export */   VersionedTransaction: () => (/* binding */ VersionedTransaction),\n/* harmony export */   VoteAccount: () => (/* binding */ VoteAccount),\n/* harmony export */   VoteAuthorizationLayout: () => (/* binding */ VoteAuthorizationLayout),\n/* harmony export */   VoteInit: () => (/* binding */ VoteInit),\n/* harmony export */   VoteInstruction: () => (/* binding */ VoteInstruction),\n/* harmony export */   VoteProgram: () => (/* binding */ VoteProgram),\n/* harmony export */   clusterApiUrl: () => (/* binding */ clusterApiUrl),\n/* harmony export */   sendAndConfirmRawTransaction: () => (/* binding */ sendAndConfirmRawTransaction),\n/* harmony export */   sendAndConfirmTransaction: () => (/* binding */ sendAndConfirmTransaction)\n/* harmony export */ });\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! buffer */ \"buffer\");\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(buffer__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @noble/curves/ed25519 */ \"(rsc)/./node_modules/@noble/curves/esm/ed25519.js\");\n/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bn.js */ \"(rsc)/./node_modules/bn.js/lib/bn.js\");\n/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(bn_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var bs58__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! bs58 */ \"(rsc)/./node_modules/bs58/index.js\");\n/* harmony import */ var bs58__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(bs58__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(rsc)/./node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var borsh__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! borsh */ \"(rsc)/./node_modules/borsh/lib/index.js\");\n/* harmony import */ var borsh__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(borsh__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @solana/buffer-layout */ \"(rsc)/./node_modules/@solana/buffer-layout/lib/Layout.js\");\n/* harmony import */ var _solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @solana/codecs-numbers */ \"(rsc)/./node_modules/@solana/codecs-numbers/dist/index.node.mjs\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! util */ \"util\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! http */ \"http\");\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(http__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! https */ \"https\");\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(https__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var superstruct__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! superstruct */ \"(rsc)/./node_modules/superstruct/dist/index.mjs\");\n/* harmony import */ var jayson_lib_client_browser__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! jayson/lib/client/browser */ \"(rsc)/./node_modules/jayson/lib/client/browser/index.js\");\n/* harmony import */ var jayson_lib_client_browser__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(jayson_lib_client_browser__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! node-fetch */ \"(rsc)/./node_modules/node-fetch/lib/index.mjs\");\n/* harmony import */ var rpc_websockets__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! rpc-websockets */ \"(rsc)/./node_modules/rpc-websockets/dist/index.mjs\");\n/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @noble/hashes/sha3 */ \"(rsc)/./node_modules/@noble/hashes/esm/sha3.js\");\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(rsc)/./node_modules/@noble/curves/esm/secp256k1.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * A 64 byte secret key, the first 32 bytes of which is the\n * private scalar and the last 32 bytes is the public key.\n * Read more: https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/\n */ /**\n * Ed25519 Keypair\n */ const generatePrivateKey = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_11__.ed25519.utils.randomPrivateKey;\nconst generateKeypair = ()=>{\n    const privateScalar = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_11__.ed25519.utils.randomPrivateKey();\n    const publicKey = getPublicKey(privateScalar);\n    const secretKey = new Uint8Array(64);\n    secretKey.set(privateScalar);\n    secretKey.set(publicKey, 32);\n    return {\n        publicKey,\n        secretKey\n    };\n};\nconst getPublicKey = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_11__.ed25519.getPublicKey;\nfunction isOnCurve(publicKey) {\n    try {\n        _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_11__.ed25519.ExtendedPoint.fromHex(publicKey);\n        return true;\n    } catch  {\n        return false;\n    }\n}\nconst sign = (message, secretKey)=>_noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_11__.ed25519.sign(message, secretKey.slice(0, 32));\nconst verify = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_11__.ed25519.verify;\nconst toBuffer = (arr)=>{\n    if (buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.isBuffer(arr)) {\n        return arr;\n    } else if (arr instanceof Uint8Array) {\n        return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);\n    } else {\n        return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(arr);\n    }\n};\n// Class wrapping a plain object\nclass Struct {\n    constructor(properties){\n        Object.assign(this, properties);\n    }\n    encode() {\n        return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from((0,borsh__WEBPACK_IMPORTED_MODULE_3__.serialize)(SOLANA_SCHEMA, this));\n    }\n    static decode(data) {\n        return (0,borsh__WEBPACK_IMPORTED_MODULE_3__.deserialize)(SOLANA_SCHEMA, this, data);\n    }\n    static decodeUnchecked(data) {\n        return (0,borsh__WEBPACK_IMPORTED_MODULE_3__.deserializeUnchecked)(SOLANA_SCHEMA, this, data);\n    }\n}\n// Class representing a Rust-compatible enum, since enums are only strings or\n// numbers in pure JS\nclass Enum extends Struct {\n    constructor(properties){\n        super(properties);\n        this.enum = \"\";\n        if (Object.keys(properties).length !== 1) {\n            throw new Error(\"Enum can only take single value\");\n        }\n        Object.keys(properties).map((key)=>{\n            this.enum = key;\n        });\n    }\n}\nconst SOLANA_SCHEMA = new Map();\nvar _PublicKey;\n/**\n * Maximum length of derived pubkey seed\n */ const MAX_SEED_LENGTH = 32;\n/**\n * Size of public key in bytes\n */ const PUBLIC_KEY_LENGTH = 32;\n/**\n * Value to be converted into public key\n */ /**\n * JSON object representation of PublicKey class\n */ function isPublicKeyData(value) {\n    return value._bn !== undefined;\n}\n// local counter used by PublicKey.unique()\nlet uniquePublicKeyCounter = 1;\n/**\n * A public key\n */ class PublicKey extends Struct {\n    /**\n   * Create a new PublicKey object\n   * @param value ed25519 public key as buffer or base-58 encoded string\n   */ constructor(value){\n        super({});\n        /** @internal */ this._bn = void 0;\n        if (isPublicKeyData(value)) {\n            this._bn = value._bn;\n        } else {\n            if (typeof value === \"string\") {\n                // assume base 58 encoding by default\n                const decoded = bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(value);\n                if (decoded.length != PUBLIC_KEY_LENGTH) {\n                    throw new Error(`Invalid public key input`);\n                }\n                this._bn = new (bn_js__WEBPACK_IMPORTED_MODULE_1___default())(decoded);\n            } else {\n                this._bn = new (bn_js__WEBPACK_IMPORTED_MODULE_1___default())(value);\n            }\n            if (this._bn.byteLength() > PUBLIC_KEY_LENGTH) {\n                throw new Error(`Invalid public key input`);\n            }\n        }\n    }\n    /**\n   * Returns a unique PublicKey for tests and benchmarks using a counter\n   */ static unique() {\n        const key = new PublicKey(uniquePublicKeyCounter);\n        uniquePublicKeyCounter += 1;\n        return new PublicKey(key.toBuffer());\n    }\n    /**\n   * Default public key value. The base58-encoded string representation is all ones (as seen below)\n   * The underlying BN number is 32 bytes that are all zeros\n   */ /**\n   * Checks if two publicKeys are equal\n   */ equals(publicKey) {\n        return this._bn.eq(publicKey._bn);\n    }\n    /**\n   * Return the base-58 representation of the public key\n   */ toBase58() {\n        return bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(this.toBytes());\n    }\n    toJSON() {\n        return this.toBase58();\n    }\n    /**\n   * Return the byte array representation of the public key in big endian\n   */ toBytes() {\n        const buf = this.toBuffer();\n        return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);\n    }\n    /**\n   * Return the Buffer representation of the public key in big endian\n   */ toBuffer() {\n        const b = this._bn.toArrayLike(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer);\n        if (b.length === PUBLIC_KEY_LENGTH) {\n            return b;\n        }\n        const zeroPad = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(32);\n        b.copy(zeroPad, 32 - b.length);\n        return zeroPad;\n    }\n    get [Symbol.toStringTag]() {\n        return `PublicKey(${this.toString()})`;\n    }\n    /**\n   * Return the base-58 representation of the public key\n   */ toString() {\n        return this.toBase58();\n    }\n    /**\n   * Derive a public key from another key, a seed, and a program ID.\n   * The program ID will also serve as the owner of the public key, giving\n   * it permission to write data to the account.\n   */ /* eslint-disable require-await */ static async createWithSeed(fromPublicKey, seed, programId) {\n        const buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([\n            fromPublicKey.toBuffer(),\n            buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(seed),\n            programId.toBuffer()\n        ]);\n        const publicKeyBytes = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_12__.sha256)(buffer);\n        return new PublicKey(publicKeyBytes);\n    }\n    /**\n   * Derive a program address from seeds and a program ID.\n   */ /* eslint-disable require-await */ static createProgramAddressSync(seeds, programId) {\n        let buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(0);\n        seeds.forEach(function(seed) {\n            if (seed.length > MAX_SEED_LENGTH) {\n                throw new TypeError(`Max seed length exceeded`);\n            }\n            buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([\n                buffer,\n                toBuffer(seed)\n            ]);\n        });\n        buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([\n            buffer,\n            programId.toBuffer(),\n            buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(\"ProgramDerivedAddress\")\n        ]);\n        const publicKeyBytes = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_12__.sha256)(buffer);\n        if (isOnCurve(publicKeyBytes)) {\n            throw new Error(`Invalid seeds, address must fall off the curve`);\n        }\n        return new PublicKey(publicKeyBytes);\n    }\n    /**\n   * Async version of createProgramAddressSync\n   * For backwards compatibility\n   *\n   * @deprecated Use {@link createProgramAddressSync} instead\n   */ /* eslint-disable require-await */ static async createProgramAddress(seeds, programId) {\n        return this.createProgramAddressSync(seeds, programId);\n    }\n    /**\n   * Find a valid program address\n   *\n   * Valid program addresses must fall off the ed25519 curve.  This function\n   * iterates a nonce until it finds one that when combined with the seeds\n   * results in a valid program address.\n   */ static findProgramAddressSync(seeds, programId) {\n        let nonce = 255;\n        let address;\n        while(nonce != 0){\n            try {\n                const seedsWithNonce = seeds.concat(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([\n                    nonce\n                ]));\n                address = this.createProgramAddressSync(seedsWithNonce, programId);\n            } catch (err) {\n                if (err instanceof TypeError) {\n                    throw err;\n                }\n                nonce--;\n                continue;\n            }\n            return [\n                address,\n                nonce\n            ];\n        }\n        throw new Error(`Unable to find a viable program address nonce`);\n    }\n    /**\n   * Async version of findProgramAddressSync\n   * For backwards compatibility\n   *\n   * @deprecated Use {@link findProgramAddressSync} instead\n   */ static async findProgramAddress(seeds, programId) {\n        return this.findProgramAddressSync(seeds, programId);\n    }\n    /**\n   * Check that a pubkey is on the ed25519 curve.\n   */ static isOnCurve(pubkeyData) {\n        const pubkey = new PublicKey(pubkeyData);\n        return isOnCurve(pubkey.toBytes());\n    }\n}\n_PublicKey = PublicKey;\nPublicKey.default = new _PublicKey(\"11111111111111111111111111111111\");\nSOLANA_SCHEMA.set(PublicKey, {\n    kind: \"struct\",\n    fields: [\n        [\n            \"_bn\",\n            \"u256\"\n        ]\n    ]\n});\n/**\n * An account key pair (public and secret keys).\n *\n * @deprecated since v1.10.0, please use {@link Keypair} instead.\n */ class Account {\n    /**\n   * Create a new Account object\n   *\n   * If the secretKey parameter is not provided a new key pair is randomly\n   * created for the account\n   *\n   * @param secretKey Secret key for the account\n   */ constructor(secretKey){\n        /** @internal */ this._publicKey = void 0;\n        /** @internal */ this._secretKey = void 0;\n        if (secretKey) {\n            const secretKeyBuffer = toBuffer(secretKey);\n            if (secretKey.length !== 64) {\n                throw new Error(\"bad secret key size\");\n            }\n            this._publicKey = secretKeyBuffer.slice(32, 64);\n            this._secretKey = secretKeyBuffer.slice(0, 32);\n        } else {\n            this._secretKey = toBuffer(generatePrivateKey());\n            this._publicKey = toBuffer(getPublicKey(this._secretKey));\n        }\n    }\n    /**\n   * The public key for this account\n   */ get publicKey() {\n        return new PublicKey(this._publicKey);\n    }\n    /**\n   * The **unencrypted** secret key for this account. The first 32 bytes\n   * is the private scalar and the last 32 bytes is the public key.\n   * Read more: https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/\n   */ get secretKey() {\n        return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([\n            this._secretKey,\n            this._publicKey\n        ], 64);\n    }\n}\nconst BPF_LOADER_DEPRECATED_PROGRAM_ID = new PublicKey(\"BPFLoader1111111111111111111111111111111111\");\n/**\n * Maximum over-the-wire size of a Transaction\n *\n * 1280 is IPv6 minimum MTU\n * 40 bytes is the size of the IPv6 header\n * 8 bytes is the size of the fragment header\n */ const PACKET_DATA_SIZE = 1280 - 40 - 8;\nconst VERSION_PREFIX_MASK = 0x7f;\nconst SIGNATURE_LENGTH_IN_BYTES = 64;\nclass TransactionExpiredBlockheightExceededError extends Error {\n    constructor(signature){\n        super(`Signature ${signature} has expired: block height exceeded.`);\n        this.signature = void 0;\n        this.signature = signature;\n    }\n}\nObject.defineProperty(TransactionExpiredBlockheightExceededError.prototype, \"name\", {\n    value: \"TransactionExpiredBlockheightExceededError\"\n});\nclass TransactionExpiredTimeoutError extends Error {\n    constructor(signature, timeoutSeconds){\n        super(`Transaction was not confirmed in ${timeoutSeconds.toFixed(2)} seconds. It is ` + \"unknown if it succeeded or failed. Check signature \" + `${signature} using the Solana Explorer or CLI tools.`);\n        this.signature = void 0;\n        this.signature = signature;\n    }\n}\nObject.defineProperty(TransactionExpiredTimeoutError.prototype, \"name\", {\n    value: \"TransactionExpiredTimeoutError\"\n});\nclass TransactionExpiredNonceInvalidError extends Error {\n    constructor(signature){\n        super(`Signature ${signature} has expired: the nonce is no longer valid.`);\n        this.signature = void 0;\n        this.signature = signature;\n    }\n}\nObject.defineProperty(TransactionExpiredNonceInvalidError.prototype, \"name\", {\n    value: \"TransactionExpiredNonceInvalidError\"\n});\nclass MessageAccountKeys {\n    constructor(staticAccountKeys, accountKeysFromLookups){\n        this.staticAccountKeys = void 0;\n        this.accountKeysFromLookups = void 0;\n        this.staticAccountKeys = staticAccountKeys;\n        this.accountKeysFromLookups = accountKeysFromLookups;\n    }\n    keySegments() {\n        const keySegments = [\n            this.staticAccountKeys\n        ];\n        if (this.accountKeysFromLookups) {\n            keySegments.push(this.accountKeysFromLookups.writable);\n            keySegments.push(this.accountKeysFromLookups.readonly);\n        }\n        return keySegments;\n    }\n    get(index) {\n        for (const keySegment of this.keySegments()){\n            if (index < keySegment.length) {\n                return keySegment[index];\n            } else {\n                index -= keySegment.length;\n            }\n        }\n        return;\n    }\n    get length() {\n        return this.keySegments().flat().length;\n    }\n    compileInstructions(instructions) {\n        // Bail early if any account indexes would overflow a u8\n        const U8_MAX = 255;\n        if (this.length > U8_MAX + 1) {\n            throw new Error(\"Account index overflow encountered during compilation\");\n        }\n        const keyIndexMap = new Map();\n        this.keySegments().flat().forEach((key, index)=>{\n            keyIndexMap.set(key.toBase58(), index);\n        });\n        const findKeyIndex = (key)=>{\n            const keyIndex = keyIndexMap.get(key.toBase58());\n            if (keyIndex === undefined) throw new Error(\"Encountered an unknown instruction account key during compilation\");\n            return keyIndex;\n        };\n        return instructions.map((instruction)=>{\n            return {\n                programIdIndex: findKeyIndex(instruction.programId),\n                accountKeyIndexes: instruction.keys.map((meta)=>findKeyIndex(meta.pubkey)),\n                data: instruction.data\n            };\n        });\n    }\n}\n/**\n * Layout for a public key\n */ const publicKey = (property = \"publicKey\")=>{\n    return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(32, property);\n};\n/**\n * Layout for a signature\n */ const signature = (property = \"signature\")=>{\n    return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(64, property);\n};\n/**\n * Layout for a Rust String type\n */ const rustString = (property = \"string\")=>{\n    const rsl = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"length\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"lengthPadding\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(), -8), \"chars\")\n    ], property);\n    const _decode = rsl.decode.bind(rsl);\n    const _encode = rsl.encode.bind(rsl);\n    const rslShim = rsl;\n    rslShim.decode = (b, offset)=>{\n        const data = _decode(b, offset);\n        return data[\"chars\"].toString();\n    };\n    rslShim.encode = (str, b, offset)=>{\n        const data = {\n            chars: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(str, \"utf8\")\n        };\n        return _encode(data, b, offset);\n    };\n    rslShim.alloc = (str)=>{\n        return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32().span + _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32().span + buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(str, \"utf8\").length;\n    };\n    return rslShim;\n};\n/**\n * Layout for an Authorized object\n */ const authorized = (property = \"authorized\")=>{\n    return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        publicKey(\"staker\"),\n        publicKey(\"withdrawer\")\n    ], property);\n};\n/**\n * Layout for a Lockup object\n */ const lockup = (property = \"lockup\")=>{\n    return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"unixTimestamp\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"epoch\"),\n        publicKey(\"custodian\")\n    ], property);\n};\n/**\n *  Layout for a VoteInit object\n */ const voteInit = (property = \"voteInit\")=>{\n    return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        publicKey(\"nodePubkey\"),\n        publicKey(\"authorizedVoter\"),\n        publicKey(\"authorizedWithdrawer\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"commission\")\n    ], property);\n};\n/**\n *  Layout for a VoteAuthorizeWithSeedArgs object\n */ const voteAuthorizeWithSeedArgs = (property = \"voteAuthorizeWithSeedArgs\")=>{\n    return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"voteAuthorizationType\"),\n        publicKey(\"currentAuthorityDerivedKeyOwnerPubkey\"),\n        rustString(\"currentAuthorityDerivedKeySeed\"),\n        publicKey(\"newAuthorized\")\n    ], property);\n};\nfunction getAlloc(type, fields) {\n    const getItemAlloc = (item)=>{\n        if (item.span >= 0) {\n            return item.span;\n        } else if (typeof item.alloc === \"function\") {\n            return item.alloc(fields[item.property]);\n        } else if (\"count\" in item && \"elementLayout\" in item) {\n            const field = fields[item.property];\n            if (Array.isArray(field)) {\n                return field.length * getItemAlloc(item.elementLayout);\n            }\n        } else if (\"fields\" in item) {\n            // This is a `Structure` whose size needs to be recursively measured.\n            return getAlloc({\n                layout: item\n            }, fields[item.property]);\n        }\n        // Couldn't determine allocated size of layout\n        return 0;\n    };\n    let alloc = 0;\n    type.layout.fields.forEach((item)=>{\n        alloc += getItemAlloc(item);\n    });\n    return alloc;\n}\nfunction decodeLength(bytes) {\n    let len = 0;\n    let size = 0;\n    for(;;){\n        let elem = bytes.shift();\n        len |= (elem & 0x7f) << size * 7;\n        size += 1;\n        if ((elem & 0x80) === 0) {\n            break;\n        }\n    }\n    return len;\n}\nfunction encodeLength(bytes, len) {\n    let rem_len = len;\n    for(;;){\n        let elem = rem_len & 0x7f;\n        rem_len >>= 7;\n        if (rem_len == 0) {\n            bytes.push(elem);\n            break;\n        } else {\n            elem |= 0x80;\n            bytes.push(elem);\n        }\n    }\n}\nfunction assert(condition, message) {\n    if (!condition) {\n        throw new Error(message || \"Assertion failed\");\n    }\n}\nclass CompiledKeys {\n    constructor(payer, keyMetaMap){\n        this.payer = void 0;\n        this.keyMetaMap = void 0;\n        this.payer = payer;\n        this.keyMetaMap = keyMetaMap;\n    }\n    static compile(instructions, payer) {\n        const keyMetaMap = new Map();\n        const getOrInsertDefault = (pubkey)=>{\n            const address = pubkey.toBase58();\n            let keyMeta = keyMetaMap.get(address);\n            if (keyMeta === undefined) {\n                keyMeta = {\n                    isSigner: false,\n                    isWritable: false,\n                    isInvoked: false\n                };\n                keyMetaMap.set(address, keyMeta);\n            }\n            return keyMeta;\n        };\n        const payerKeyMeta = getOrInsertDefault(payer);\n        payerKeyMeta.isSigner = true;\n        payerKeyMeta.isWritable = true;\n        for (const ix of instructions){\n            getOrInsertDefault(ix.programId).isInvoked = true;\n            for (const accountMeta of ix.keys){\n                const keyMeta = getOrInsertDefault(accountMeta.pubkey);\n                keyMeta.isSigner ||= accountMeta.isSigner;\n                keyMeta.isWritable ||= accountMeta.isWritable;\n            }\n        }\n        return new CompiledKeys(payer, keyMetaMap);\n    }\n    getMessageComponents() {\n        const mapEntries = [\n            ...this.keyMetaMap.entries()\n        ];\n        assert(mapEntries.length <= 256, \"Max static account keys length exceeded\");\n        const writableSigners = mapEntries.filter(([, meta])=>meta.isSigner && meta.isWritable);\n        const readonlySigners = mapEntries.filter(([, meta])=>meta.isSigner && !meta.isWritable);\n        const writableNonSigners = mapEntries.filter(([, meta])=>!meta.isSigner && meta.isWritable);\n        const readonlyNonSigners = mapEntries.filter(([, meta])=>!meta.isSigner && !meta.isWritable);\n        const header = {\n            numRequiredSignatures: writableSigners.length + readonlySigners.length,\n            numReadonlySignedAccounts: readonlySigners.length,\n            numReadonlyUnsignedAccounts: readonlyNonSigners.length\n        };\n        // sanity checks\n        {\n            assert(writableSigners.length > 0, \"Expected at least one writable signer key\");\n            const [payerAddress] = writableSigners[0];\n            assert(payerAddress === this.payer.toBase58(), \"Expected first writable signer key to be the fee payer\");\n        }\n        const staticAccountKeys = [\n            ...writableSigners.map(([address])=>new PublicKey(address)),\n            ...readonlySigners.map(([address])=>new PublicKey(address)),\n            ...writableNonSigners.map(([address])=>new PublicKey(address)),\n            ...readonlyNonSigners.map(([address])=>new PublicKey(address))\n        ];\n        return [\n            header,\n            staticAccountKeys\n        ];\n    }\n    extractTableLookup(lookupTable) {\n        const [writableIndexes, drainedWritableKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta)=>!keyMeta.isSigner && !keyMeta.isInvoked && keyMeta.isWritable);\n        const [readonlyIndexes, drainedReadonlyKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta)=>!keyMeta.isSigner && !keyMeta.isInvoked && !keyMeta.isWritable);\n        // Don't extract lookup if no keys were found\n        if (writableIndexes.length === 0 && readonlyIndexes.length === 0) {\n            return;\n        }\n        return [\n            {\n                accountKey: lookupTable.key,\n                writableIndexes,\n                readonlyIndexes\n            },\n            {\n                writable: drainedWritableKeys,\n                readonly: drainedReadonlyKeys\n            }\n        ];\n    }\n    /** @internal */ drainKeysFoundInLookupTable(lookupTableEntries, keyMetaFilter) {\n        const lookupTableIndexes = new Array();\n        const drainedKeys = new Array();\n        for (const [address, keyMeta] of this.keyMetaMap.entries()){\n            if (keyMetaFilter(keyMeta)) {\n                const key = new PublicKey(address);\n                const lookupTableIndex = lookupTableEntries.findIndex((entry)=>entry.equals(key));\n                if (lookupTableIndex >= 0) {\n                    assert(lookupTableIndex < 256, \"Max lookup table index exceeded\");\n                    lookupTableIndexes.push(lookupTableIndex);\n                    drainedKeys.push(key);\n                    this.keyMetaMap.delete(address);\n                }\n            }\n        }\n        return [\n            lookupTableIndexes,\n            drainedKeys\n        ];\n    }\n}\nconst END_OF_BUFFER_ERROR_MESSAGE = \"Reached end of buffer unexpectedly\";\n/**\n * Delegates to `Array#shift`, but throws if the array is zero-length.\n */ function guardedShift(byteArray) {\n    if (byteArray.length === 0) {\n        throw new Error(END_OF_BUFFER_ERROR_MESSAGE);\n    }\n    return byteArray.shift();\n}\n/**\n * Delegates to `Array#splice`, but throws if the section being spliced out extends past the end of\n * the array.\n */ function guardedSplice(byteArray, ...args) {\n    const [start] = args;\n    if (args.length === 2 // Implies that `deleteCount` was supplied\n     ? start + (args[1] ?? 0) > byteArray.length : start >= byteArray.length) {\n        throw new Error(END_OF_BUFFER_ERROR_MESSAGE);\n    }\n    return byteArray.splice(...args);\n}\n/**\n * An instruction to execute by a program\n *\n * @property {number} programIdIndex\n * @property {number[]} accounts\n * @property {string} data\n */ /**\n * Message constructor arguments\n */ /**\n * List of instructions to be processed atomically\n */ class Message {\n    constructor(args){\n        this.header = void 0;\n        this.accountKeys = void 0;\n        this.recentBlockhash = void 0;\n        this.instructions = void 0;\n        this.indexToProgramIds = new Map();\n        this.header = args.header;\n        this.accountKeys = args.accountKeys.map((account)=>new PublicKey(account));\n        this.recentBlockhash = args.recentBlockhash;\n        this.instructions = args.instructions;\n        this.instructions.forEach((ix)=>this.indexToProgramIds.set(ix.programIdIndex, this.accountKeys[ix.programIdIndex]));\n    }\n    get version() {\n        return \"legacy\";\n    }\n    get staticAccountKeys() {\n        return this.accountKeys;\n    }\n    get compiledInstructions() {\n        return this.instructions.map((ix)=>({\n                programIdIndex: ix.programIdIndex,\n                accountKeyIndexes: ix.accounts,\n                data: bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(ix.data)\n            }));\n    }\n    get addressTableLookups() {\n        return [];\n    }\n    getAccountKeys() {\n        return new MessageAccountKeys(this.staticAccountKeys);\n    }\n    static compile(args) {\n        const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);\n        const [header, staticAccountKeys] = compiledKeys.getMessageComponents();\n        const accountKeys = new MessageAccountKeys(staticAccountKeys);\n        const instructions = accountKeys.compileInstructions(args.instructions).map((ix)=>({\n                programIdIndex: ix.programIdIndex,\n                accounts: ix.accountKeyIndexes,\n                data: bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(ix.data)\n            }));\n        return new Message({\n            header,\n            accountKeys: staticAccountKeys,\n            recentBlockhash: args.recentBlockhash,\n            instructions\n        });\n    }\n    isAccountSigner(index) {\n        return index < this.header.numRequiredSignatures;\n    }\n    isAccountWritable(index) {\n        const numSignedAccounts = this.header.numRequiredSignatures;\n        if (index >= this.header.numRequiredSignatures) {\n            const unsignedAccountIndex = index - numSignedAccounts;\n            const numUnsignedAccounts = this.accountKeys.length - numSignedAccounts;\n            const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;\n            return unsignedAccountIndex < numWritableUnsignedAccounts;\n        } else {\n            const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;\n            return index < numWritableSignedAccounts;\n        }\n    }\n    isProgramId(index) {\n        return this.indexToProgramIds.has(index);\n    }\n    programIds() {\n        return [\n            ...this.indexToProgramIds.values()\n        ];\n    }\n    nonProgramIds() {\n        return this.accountKeys.filter((_, index)=>!this.isProgramId(index));\n    }\n    serialize() {\n        const numKeys = this.accountKeys.length;\n        let keyCount = [];\n        encodeLength(keyCount, numKeys);\n        const instructions = this.instructions.map((instruction)=>{\n            const { accounts, programIdIndex } = instruction;\n            const data = Array.from(bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(instruction.data));\n            let keyIndicesCount = [];\n            encodeLength(keyIndicesCount, accounts.length);\n            let dataCount = [];\n            encodeLength(dataCount, data.length);\n            return {\n                programIdIndex,\n                keyIndicesCount: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(keyIndicesCount),\n                keyIndices: accounts,\n                dataLength: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(dataCount),\n                data\n            };\n        });\n        let instructionCount = [];\n        encodeLength(instructionCount, instructions.length);\n        let instructionBuffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(PACKET_DATA_SIZE);\n        buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(instructionCount).copy(instructionBuffer);\n        let instructionBufferLength = instructionCount.length;\n        instructions.forEach((instruction)=>{\n            const instructionLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"programIdIndex\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(instruction.keyIndicesCount.length, \"keyIndicesCount\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"keyIndex\"), instruction.keyIndices.length, \"keyIndices\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(instruction.dataLength.length, \"dataLength\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"userdatum\"), instruction.data.length, \"data\")\n            ]);\n            const length = instructionLayout.encode(instruction, instructionBuffer, instructionBufferLength);\n            instructionBufferLength += length;\n        });\n        instructionBuffer = instructionBuffer.slice(0, instructionBufferLength);\n        const signDataLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(1, \"numRequiredSignatures\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(1, \"numReadonlySignedAccounts\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(1, \"numReadonlyUnsignedAccounts\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(keyCount.length, \"keyCount\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(publicKey(\"key\"), numKeys, \"keys\"),\n            publicKey(\"recentBlockhash\")\n        ]);\n        const transaction = {\n            numRequiredSignatures: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([\n                this.header.numRequiredSignatures\n            ]),\n            numReadonlySignedAccounts: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([\n                this.header.numReadonlySignedAccounts\n            ]),\n            numReadonlyUnsignedAccounts: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([\n                this.header.numReadonlyUnsignedAccounts\n            ]),\n            keyCount: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(keyCount),\n            keys: this.accountKeys.map((key)=>toBuffer(key.toBytes())),\n            recentBlockhash: bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(this.recentBlockhash)\n        };\n        let signData = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(2048);\n        const length = signDataLayout.encode(transaction, signData);\n        instructionBuffer.copy(signData, length);\n        return signData.slice(0, length + instructionBuffer.length);\n    }\n    /**\n   * Decode a compiled message into a Message object.\n   */ static from(buffer) {\n        // Slice up wire data\n        let byteArray = [\n            ...buffer\n        ];\n        const numRequiredSignatures = guardedShift(byteArray);\n        if (numRequiredSignatures !== (numRequiredSignatures & VERSION_PREFIX_MASK)) {\n            throw new Error(\"Versioned messages must be deserialized with VersionedMessage.deserialize()\");\n        }\n        const numReadonlySignedAccounts = guardedShift(byteArray);\n        const numReadonlyUnsignedAccounts = guardedShift(byteArray);\n        const accountCount = decodeLength(byteArray);\n        let accountKeys = [];\n        for(let i = 0; i < accountCount; i++){\n            const account = guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH);\n            accountKeys.push(new PublicKey(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(account)));\n        }\n        const recentBlockhash = guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH);\n        const instructionCount = decodeLength(byteArray);\n        let instructions = [];\n        for(let i = 0; i < instructionCount; i++){\n            const programIdIndex = guardedShift(byteArray);\n            const accountCount = decodeLength(byteArray);\n            const accounts = guardedSplice(byteArray, 0, accountCount);\n            const dataLength = decodeLength(byteArray);\n            const dataSlice = guardedSplice(byteArray, 0, dataLength);\n            const data = bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(dataSlice));\n            instructions.push({\n                programIdIndex,\n                accounts,\n                data\n            });\n        }\n        const messageArgs = {\n            header: {\n                numRequiredSignatures,\n                numReadonlySignedAccounts,\n                numReadonlyUnsignedAccounts\n            },\n            recentBlockhash: bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(recentBlockhash)),\n            accountKeys,\n            instructions\n        };\n        return new Message(messageArgs);\n    }\n}\n/**\n * Message constructor arguments\n */ class MessageV0 {\n    constructor(args){\n        this.header = void 0;\n        this.staticAccountKeys = void 0;\n        this.recentBlockhash = void 0;\n        this.compiledInstructions = void 0;\n        this.addressTableLookups = void 0;\n        this.header = args.header;\n        this.staticAccountKeys = args.staticAccountKeys;\n        this.recentBlockhash = args.recentBlockhash;\n        this.compiledInstructions = args.compiledInstructions;\n        this.addressTableLookups = args.addressTableLookups;\n    }\n    get version() {\n        return 0;\n    }\n    get numAccountKeysFromLookups() {\n        let count = 0;\n        for (const lookup of this.addressTableLookups){\n            count += lookup.readonlyIndexes.length + lookup.writableIndexes.length;\n        }\n        return count;\n    }\n    getAccountKeys(args) {\n        let accountKeysFromLookups;\n        if (args && \"accountKeysFromLookups\" in args && args.accountKeysFromLookups) {\n            if (this.numAccountKeysFromLookups != args.accountKeysFromLookups.writable.length + args.accountKeysFromLookups.readonly.length) {\n                throw new Error(\"Failed to get account keys because of a mismatch in the number of account keys from lookups\");\n            }\n            accountKeysFromLookups = args.accountKeysFromLookups;\n        } else if (args && \"addressLookupTableAccounts\" in args && args.addressLookupTableAccounts) {\n            accountKeysFromLookups = this.resolveAddressTableLookups(args.addressLookupTableAccounts);\n        } else if (this.addressTableLookups.length > 0) {\n            throw new Error(\"Failed to get account keys because address table lookups were not resolved\");\n        }\n        return new MessageAccountKeys(this.staticAccountKeys, accountKeysFromLookups);\n    }\n    isAccountSigner(index) {\n        return index < this.header.numRequiredSignatures;\n    }\n    isAccountWritable(index) {\n        const numSignedAccounts = this.header.numRequiredSignatures;\n        const numStaticAccountKeys = this.staticAccountKeys.length;\n        if (index >= numStaticAccountKeys) {\n            const lookupAccountKeysIndex = index - numStaticAccountKeys;\n            const numWritableLookupAccountKeys = this.addressTableLookups.reduce((count, lookup)=>count + lookup.writableIndexes.length, 0);\n            return lookupAccountKeysIndex < numWritableLookupAccountKeys;\n        } else if (index >= this.header.numRequiredSignatures) {\n            const unsignedAccountIndex = index - numSignedAccounts;\n            const numUnsignedAccounts = numStaticAccountKeys - numSignedAccounts;\n            const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;\n            return unsignedAccountIndex < numWritableUnsignedAccounts;\n        } else {\n            const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;\n            return index < numWritableSignedAccounts;\n        }\n    }\n    resolveAddressTableLookups(addressLookupTableAccounts) {\n        const accountKeysFromLookups = {\n            writable: [],\n            readonly: []\n        };\n        for (const tableLookup of this.addressTableLookups){\n            const tableAccount = addressLookupTableAccounts.find((account)=>account.key.equals(tableLookup.accountKey));\n            if (!tableAccount) {\n                throw new Error(`Failed to find address lookup table account for table key ${tableLookup.accountKey.toBase58()}`);\n            }\n            for (const index of tableLookup.writableIndexes){\n                if (index < tableAccount.state.addresses.length) {\n                    accountKeysFromLookups.writable.push(tableAccount.state.addresses[index]);\n                } else {\n                    throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);\n                }\n            }\n            for (const index of tableLookup.readonlyIndexes){\n                if (index < tableAccount.state.addresses.length) {\n                    accountKeysFromLookups.readonly.push(tableAccount.state.addresses[index]);\n                } else {\n                    throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);\n                }\n            }\n        }\n        return accountKeysFromLookups;\n    }\n    static compile(args) {\n        const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);\n        const addressTableLookups = new Array();\n        const accountKeysFromLookups = {\n            writable: new Array(),\n            readonly: new Array()\n        };\n        const lookupTableAccounts = args.addressLookupTableAccounts || [];\n        for (const lookupTable of lookupTableAccounts){\n            const extractResult = compiledKeys.extractTableLookup(lookupTable);\n            if (extractResult !== undefined) {\n                const [addressTableLookup, { writable, readonly }] = extractResult;\n                addressTableLookups.push(addressTableLookup);\n                accountKeysFromLookups.writable.push(...writable);\n                accountKeysFromLookups.readonly.push(...readonly);\n            }\n        }\n        const [header, staticAccountKeys] = compiledKeys.getMessageComponents();\n        const accountKeys = new MessageAccountKeys(staticAccountKeys, accountKeysFromLookups);\n        const compiledInstructions = accountKeys.compileInstructions(args.instructions);\n        return new MessageV0({\n            header,\n            staticAccountKeys,\n            recentBlockhash: args.recentBlockhash,\n            compiledInstructions,\n            addressTableLookups\n        });\n    }\n    serialize() {\n        const encodedStaticAccountKeysLength = Array();\n        encodeLength(encodedStaticAccountKeysLength, this.staticAccountKeys.length);\n        const serializedInstructions = this.serializeInstructions();\n        const encodedInstructionsLength = Array();\n        encodeLength(encodedInstructionsLength, this.compiledInstructions.length);\n        const serializedAddressTableLookups = this.serializeAddressTableLookups();\n        const encodedAddressTableLookupsLength = Array();\n        encodeLength(encodedAddressTableLookupsLength, this.addressTableLookups.length);\n        const messageLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"prefix\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"numRequiredSignatures\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"numReadonlySignedAccounts\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"numReadonlyUnsignedAccounts\")\n            ], \"header\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedStaticAccountKeysLength.length, \"staticAccountKeysLength\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(publicKey(), this.staticAccountKeys.length, \"staticAccountKeys\"),\n            publicKey(\"recentBlockhash\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedInstructionsLength.length, \"instructionsLength\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(serializedInstructions.length, \"serializedInstructions\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedAddressTableLookupsLength.length, \"addressTableLookupsLength\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(serializedAddressTableLookups.length, \"serializedAddressTableLookups\")\n        ]);\n        const serializedMessage = new Uint8Array(PACKET_DATA_SIZE);\n        const MESSAGE_VERSION_0_PREFIX = 1 << 7;\n        const serializedMessageLength = messageLayout.encode({\n            prefix: MESSAGE_VERSION_0_PREFIX,\n            header: this.header,\n            staticAccountKeysLength: new Uint8Array(encodedStaticAccountKeysLength),\n            staticAccountKeys: this.staticAccountKeys.map((key)=>key.toBytes()),\n            recentBlockhash: bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(this.recentBlockhash),\n            instructionsLength: new Uint8Array(encodedInstructionsLength),\n            serializedInstructions,\n            addressTableLookupsLength: new Uint8Array(encodedAddressTableLookupsLength),\n            serializedAddressTableLookups\n        }, serializedMessage);\n        return serializedMessage.slice(0, serializedMessageLength);\n    }\n    serializeInstructions() {\n        let serializedLength = 0;\n        const serializedInstructions = new Uint8Array(PACKET_DATA_SIZE);\n        for (const instruction of this.compiledInstructions){\n            const encodedAccountKeyIndexesLength = Array();\n            encodeLength(encodedAccountKeyIndexesLength, instruction.accountKeyIndexes.length);\n            const encodedDataLength = Array();\n            encodeLength(encodedDataLength, instruction.data.length);\n            const instructionLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"programIdIndex\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedAccountKeyIndexesLength.length, \"encodedAccountKeyIndexesLength\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(), instruction.accountKeyIndexes.length, \"accountKeyIndexes\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedDataLength.length, \"encodedDataLength\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(instruction.data.length, \"data\")\n            ]);\n            serializedLength += instructionLayout.encode({\n                programIdIndex: instruction.programIdIndex,\n                encodedAccountKeyIndexesLength: new Uint8Array(encodedAccountKeyIndexesLength),\n                accountKeyIndexes: instruction.accountKeyIndexes,\n                encodedDataLength: new Uint8Array(encodedDataLength),\n                data: instruction.data\n            }, serializedInstructions, serializedLength);\n        }\n        return serializedInstructions.slice(0, serializedLength);\n    }\n    serializeAddressTableLookups() {\n        let serializedLength = 0;\n        const serializedAddressTableLookups = new Uint8Array(PACKET_DATA_SIZE);\n        for (const lookup of this.addressTableLookups){\n            const encodedWritableIndexesLength = Array();\n            encodeLength(encodedWritableIndexesLength, lookup.writableIndexes.length);\n            const encodedReadonlyIndexesLength = Array();\n            encodeLength(encodedReadonlyIndexesLength, lookup.readonlyIndexes.length);\n            const addressTableLookupLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n                publicKey(\"accountKey\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedWritableIndexesLength.length, \"encodedWritableIndexesLength\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(), lookup.writableIndexes.length, \"writableIndexes\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedReadonlyIndexesLength.length, \"encodedReadonlyIndexesLength\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(), lookup.readonlyIndexes.length, \"readonlyIndexes\")\n            ]);\n            serializedLength += addressTableLookupLayout.encode({\n                accountKey: lookup.accountKey.toBytes(),\n                encodedWritableIndexesLength: new Uint8Array(encodedWritableIndexesLength),\n                writableIndexes: lookup.writableIndexes,\n                encodedReadonlyIndexesLength: new Uint8Array(encodedReadonlyIndexesLength),\n                readonlyIndexes: lookup.readonlyIndexes\n            }, serializedAddressTableLookups, serializedLength);\n        }\n        return serializedAddressTableLookups.slice(0, serializedLength);\n    }\n    static deserialize(serializedMessage) {\n        let byteArray = [\n            ...serializedMessage\n        ];\n        const prefix = guardedShift(byteArray);\n        const maskedPrefix = prefix & VERSION_PREFIX_MASK;\n        assert(prefix !== maskedPrefix, `Expected versioned message but received legacy message`);\n        const version = maskedPrefix;\n        assert(version === 0, `Expected versioned message with version 0 but found version ${version}`);\n        const header = {\n            numRequiredSignatures: guardedShift(byteArray),\n            numReadonlySignedAccounts: guardedShift(byteArray),\n            numReadonlyUnsignedAccounts: guardedShift(byteArray)\n        };\n        const staticAccountKeys = [];\n        const staticAccountKeysLength = decodeLength(byteArray);\n        for(let i = 0; i < staticAccountKeysLength; i++){\n            staticAccountKeys.push(new PublicKey(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH)));\n        }\n        const recentBlockhash = bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));\n        const instructionCount = decodeLength(byteArray);\n        const compiledInstructions = [];\n        for(let i = 0; i < instructionCount; i++){\n            const programIdIndex = guardedShift(byteArray);\n            const accountKeyIndexesLength = decodeLength(byteArray);\n            const accountKeyIndexes = guardedSplice(byteArray, 0, accountKeyIndexesLength);\n            const dataLength = decodeLength(byteArray);\n            const data = new Uint8Array(guardedSplice(byteArray, 0, dataLength));\n            compiledInstructions.push({\n                programIdIndex,\n                accountKeyIndexes,\n                data\n            });\n        }\n        const addressTableLookupsCount = decodeLength(byteArray);\n        const addressTableLookups = [];\n        for(let i = 0; i < addressTableLookupsCount; i++){\n            const accountKey = new PublicKey(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));\n            const writableIndexesLength = decodeLength(byteArray);\n            const writableIndexes = guardedSplice(byteArray, 0, writableIndexesLength);\n            const readonlyIndexesLength = decodeLength(byteArray);\n            const readonlyIndexes = guardedSplice(byteArray, 0, readonlyIndexesLength);\n            addressTableLookups.push({\n                accountKey,\n                writableIndexes,\n                readonlyIndexes\n            });\n        }\n        return new MessageV0({\n            header,\n            staticAccountKeys,\n            recentBlockhash,\n            compiledInstructions,\n            addressTableLookups\n        });\n    }\n}\n// eslint-disable-next-line no-redeclare\nconst VersionedMessage = {\n    deserializeMessageVersion (serializedMessage) {\n        const prefix = serializedMessage[0];\n        const maskedPrefix = prefix & VERSION_PREFIX_MASK;\n        // if the highest bit of the prefix is not set, the message is not versioned\n        if (maskedPrefix === prefix) {\n            return \"legacy\";\n        }\n        // the lower 7 bits of the prefix indicate the message version\n        return maskedPrefix;\n    },\n    deserialize: (serializedMessage)=>{\n        const version = VersionedMessage.deserializeMessageVersion(serializedMessage);\n        if (version === \"legacy\") {\n            return Message.from(serializedMessage);\n        }\n        if (version === 0) {\n            return MessageV0.deserialize(serializedMessage);\n        } else {\n            throw new Error(`Transaction message version ${version} deserialization is not supported`);\n        }\n    }\n};\n/** @internal */ /**\n * Transaction signature as base-58 encoded string\n */ let TransactionStatus = /*#__PURE__*/ function(TransactionStatus) {\n    TransactionStatus[TransactionStatus[\"BLOCKHEIGHT_EXCEEDED\"] = 0] = \"BLOCKHEIGHT_EXCEEDED\";\n    TransactionStatus[TransactionStatus[\"PROCESSED\"] = 1] = \"PROCESSED\";\n    TransactionStatus[TransactionStatus[\"TIMED_OUT\"] = 2] = \"TIMED_OUT\";\n    TransactionStatus[TransactionStatus[\"NONCE_INVALID\"] = 3] = \"NONCE_INVALID\";\n    return TransactionStatus;\n}({});\n/**\n * Default (empty) signature\n */ const DEFAULT_SIGNATURE = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0);\n/**\n * Account metadata used to define instructions\n */ /**\n * List of TransactionInstruction object fields that may be initialized at construction\n */ /**\n * Configuration object for Transaction.serialize()\n */ /**\n * @internal\n */ /**\n * Transaction Instruction class\n */ class TransactionInstruction {\n    constructor(opts){\n        /**\n     * Public keys to include in this transaction\n     * Boolean represents whether this pubkey needs to sign the transaction\n     */ this.keys = void 0;\n        /**\n     * Program Id to execute\n     */ this.programId = void 0;\n        /**\n     * Program input\n     */ this.data = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(0);\n        this.programId = opts.programId;\n        this.keys = opts.keys;\n        if (opts.data) {\n            this.data = opts.data;\n        }\n    }\n    /**\n   * @internal\n   */ toJSON() {\n        return {\n            keys: this.keys.map(({ pubkey, isSigner, isWritable })=>({\n                    pubkey: pubkey.toJSON(),\n                    isSigner,\n                    isWritable\n                })),\n            programId: this.programId.toJSON(),\n            data: [\n                ...this.data\n            ]\n        };\n    }\n}\n/**\n * Pair of signature and corresponding public key\n */ /**\n * List of Transaction object fields that may be initialized at construction\n */ // For backward compatibility; an unfortunate consequence of being\n// forced to over-export types by the documentation generator.\n// See https://github.com/solana-labs/solana/pull/25820\n/**\n * Blockhash-based transactions have a lifetime that are defined by\n * the blockhash they include. Any transaction whose blockhash is\n * too old will be rejected.\n */ /**\n * Use these options to construct a durable nonce transaction.\n */ /**\n * Nonce information to be used to build an offline Transaction.\n */ /**\n * @internal\n */ /**\n * Transaction class\n */ class Transaction {\n    /**\n   * The first (payer) Transaction signature\n   *\n   * @returns {Buffer | null} Buffer of payer's signature\n   */ get signature() {\n        if (this.signatures.length > 0) {\n            return this.signatures[0].signature;\n        }\n        return null;\n    }\n    /**\n   * The transaction fee payer\n   */ // Construct a transaction with a blockhash and lastValidBlockHeight\n    // Construct a transaction using a durable nonce\n    /**\n   * @deprecated `TransactionCtorFields` has been deprecated and will be removed in a future version.\n   * Please supply a `TransactionBlockhashCtor` instead.\n   */ /**\n   * Construct an empty Transaction\n   */ constructor(opts){\n        /**\n     * Signatures for the transaction.  Typically created by invoking the\n     * `sign()` method\n     */ this.signatures = [];\n        this.feePayer = void 0;\n        /**\n     * The instructions to atomically execute\n     */ this.instructions = [];\n        /**\n     * A recent transaction id. Must be populated by the caller\n     */ this.recentBlockhash = void 0;\n        /**\n     * the last block chain can advance to before tx is declared expired\n     * */ this.lastValidBlockHeight = void 0;\n        /**\n     * Optional Nonce information. If populated, transaction will use a durable\n     * Nonce hash instead of a recentBlockhash. Must be populated by the caller\n     */ this.nonceInfo = void 0;\n        /**\n     * If this is a nonce transaction this represents the minimum slot from which\n     * to evaluate if the nonce has advanced when attempting to confirm the\n     * transaction. This protects against a case where the transaction confirmation\n     * logic loads the nonce account from an old slot and assumes the mismatch in\n     * nonce value implies that the nonce has been advanced.\n     */ this.minNonceContextSlot = void 0;\n        /**\n     * @internal\n     */ this._message = void 0;\n        /**\n     * @internal\n     */ this._json = void 0;\n        if (!opts) {\n            return;\n        }\n        if (opts.feePayer) {\n            this.feePayer = opts.feePayer;\n        }\n        if (opts.signatures) {\n            this.signatures = opts.signatures;\n        }\n        if (Object.prototype.hasOwnProperty.call(opts, \"nonceInfo\")) {\n            const { minContextSlot, nonceInfo } = opts;\n            this.minNonceContextSlot = minContextSlot;\n            this.nonceInfo = nonceInfo;\n        } else if (Object.prototype.hasOwnProperty.call(opts, \"lastValidBlockHeight\")) {\n            const { blockhash, lastValidBlockHeight } = opts;\n            this.recentBlockhash = blockhash;\n            this.lastValidBlockHeight = lastValidBlockHeight;\n        } else {\n            const { recentBlockhash, nonceInfo } = opts;\n            if (nonceInfo) {\n                this.nonceInfo = nonceInfo;\n            }\n            this.recentBlockhash = recentBlockhash;\n        }\n    }\n    /**\n   * @internal\n   */ toJSON() {\n        return {\n            recentBlockhash: this.recentBlockhash || null,\n            feePayer: this.feePayer ? this.feePayer.toJSON() : null,\n            nonceInfo: this.nonceInfo ? {\n                nonce: this.nonceInfo.nonce,\n                nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()\n            } : null,\n            instructions: this.instructions.map((instruction)=>instruction.toJSON()),\n            signers: this.signatures.map(({ publicKey })=>{\n                return publicKey.toJSON();\n            })\n        };\n    }\n    /**\n   * Add one or more instructions to this Transaction\n   *\n   * @param {Array< Transaction | TransactionInstruction | TransactionInstructionCtorFields >} items - Instructions to add to the Transaction\n   */ add(...items) {\n        if (items.length === 0) {\n            throw new Error(\"No instructions\");\n        }\n        items.forEach((item)=>{\n            if (\"instructions\" in item) {\n                this.instructions = this.instructions.concat(item.instructions);\n            } else if (\"data\" in item && \"programId\" in item && \"keys\" in item) {\n                this.instructions.push(item);\n            } else {\n                this.instructions.push(new TransactionInstruction(item));\n            }\n        });\n        return this;\n    }\n    /**\n   * Compile transaction data\n   */ compileMessage() {\n        if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json)) {\n            return this._message;\n        }\n        let recentBlockhash;\n        let instructions;\n        if (this.nonceInfo) {\n            recentBlockhash = this.nonceInfo.nonce;\n            if (this.instructions[0] != this.nonceInfo.nonceInstruction) {\n                instructions = [\n                    this.nonceInfo.nonceInstruction,\n                    ...this.instructions\n                ];\n            } else {\n                instructions = this.instructions;\n            }\n        } else {\n            recentBlockhash = this.recentBlockhash;\n            instructions = this.instructions;\n        }\n        if (!recentBlockhash) {\n            throw new Error(\"Transaction recentBlockhash required\");\n        }\n        if (instructions.length < 1) {\n            console.warn(\"No instructions provided\");\n        }\n        let feePayer;\n        if (this.feePayer) {\n            feePayer = this.feePayer;\n        } else if (this.signatures.length > 0 && this.signatures[0].publicKey) {\n            // Use implicit fee payer\n            feePayer = this.signatures[0].publicKey;\n        } else {\n            throw new Error(\"Transaction fee payer required\");\n        }\n        for(let i = 0; i < instructions.length; i++){\n            if (instructions[i].programId === undefined) {\n                throw new Error(`Transaction instruction index ${i} has undefined program id`);\n            }\n        }\n        const programIds = [];\n        const accountMetas = [];\n        instructions.forEach((instruction)=>{\n            instruction.keys.forEach((accountMeta)=>{\n                accountMetas.push({\n                    ...accountMeta\n                });\n            });\n            const programId = instruction.programId.toString();\n            if (!programIds.includes(programId)) {\n                programIds.push(programId);\n            }\n        });\n        // Append programID account metas\n        programIds.forEach((programId)=>{\n            accountMetas.push({\n                pubkey: new PublicKey(programId),\n                isSigner: false,\n                isWritable: false\n            });\n        });\n        // Cull duplicate account metas\n        const uniqueMetas = [];\n        accountMetas.forEach((accountMeta)=>{\n            const pubkeyString = accountMeta.pubkey.toString();\n            const uniqueIndex = uniqueMetas.findIndex((x)=>{\n                return x.pubkey.toString() === pubkeyString;\n            });\n            if (uniqueIndex > -1) {\n                uniqueMetas[uniqueIndex].isWritable = uniqueMetas[uniqueIndex].isWritable || accountMeta.isWritable;\n                uniqueMetas[uniqueIndex].isSigner = uniqueMetas[uniqueIndex].isSigner || accountMeta.isSigner;\n            } else {\n                uniqueMetas.push(accountMeta);\n            }\n        });\n        // Sort. Prioritizing first by signer, then by writable\n        uniqueMetas.sort(function(x, y) {\n            if (x.isSigner !== y.isSigner) {\n                // Signers always come before non-signers\n                return x.isSigner ? -1 : 1;\n            }\n            if (x.isWritable !== y.isWritable) {\n                // Writable accounts always come before read-only accounts\n                return x.isWritable ? -1 : 1;\n            }\n            // Otherwise, sort by pubkey, stringwise.\n            const options = {\n                localeMatcher: \"best fit\",\n                usage: \"sort\",\n                sensitivity: \"variant\",\n                ignorePunctuation: false,\n                numeric: false,\n                caseFirst: \"lower\"\n            };\n            return x.pubkey.toBase58().localeCompare(y.pubkey.toBase58(), \"en\", options);\n        });\n        // Move fee payer to the front\n        const feePayerIndex = uniqueMetas.findIndex((x)=>{\n            return x.pubkey.equals(feePayer);\n        });\n        if (feePayerIndex > -1) {\n            const [payerMeta] = uniqueMetas.splice(feePayerIndex, 1);\n            payerMeta.isSigner = true;\n            payerMeta.isWritable = true;\n            uniqueMetas.unshift(payerMeta);\n        } else {\n            uniqueMetas.unshift({\n                pubkey: feePayer,\n                isSigner: true,\n                isWritable: true\n            });\n        }\n        // Disallow unknown signers\n        for (const signature of this.signatures){\n            const uniqueIndex = uniqueMetas.findIndex((x)=>{\n                return x.pubkey.equals(signature.publicKey);\n            });\n            if (uniqueIndex > -1) {\n                if (!uniqueMetas[uniqueIndex].isSigner) {\n                    uniqueMetas[uniqueIndex].isSigner = true;\n                    console.warn(\"Transaction references a signature that is unnecessary, \" + \"only the fee payer and instruction signer accounts should sign a transaction. \" + \"This behavior is deprecated and will throw an error in the next major version release.\");\n                }\n            } else {\n                throw new Error(`unknown signer: ${signature.publicKey.toString()}`);\n            }\n        }\n        let numRequiredSignatures = 0;\n        let numReadonlySignedAccounts = 0;\n        let numReadonlyUnsignedAccounts = 0;\n        // Split out signing from non-signing keys and count header values\n        const signedKeys = [];\n        const unsignedKeys = [];\n        uniqueMetas.forEach(({ pubkey, isSigner, isWritable })=>{\n            if (isSigner) {\n                signedKeys.push(pubkey.toString());\n                numRequiredSignatures += 1;\n                if (!isWritable) {\n                    numReadonlySignedAccounts += 1;\n                }\n            } else {\n                unsignedKeys.push(pubkey.toString());\n                if (!isWritable) {\n                    numReadonlyUnsignedAccounts += 1;\n                }\n            }\n        });\n        const accountKeys = signedKeys.concat(unsignedKeys);\n        const compiledInstructions = instructions.map((instruction)=>{\n            const { data, programId } = instruction;\n            return {\n                programIdIndex: accountKeys.indexOf(programId.toString()),\n                accounts: instruction.keys.map((meta)=>accountKeys.indexOf(meta.pubkey.toString())),\n                data: bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(data)\n            };\n        });\n        compiledInstructions.forEach((instruction)=>{\n            assert(instruction.programIdIndex >= 0);\n            instruction.accounts.forEach((keyIndex)=>assert(keyIndex >= 0));\n        });\n        return new Message({\n            header: {\n                numRequiredSignatures,\n                numReadonlySignedAccounts,\n                numReadonlyUnsignedAccounts\n            },\n            accountKeys,\n            recentBlockhash,\n            instructions: compiledInstructions\n        });\n    }\n    /**\n   * @internal\n   */ _compile() {\n        const message = this.compileMessage();\n        const signedKeys = message.accountKeys.slice(0, message.header.numRequiredSignatures);\n        if (this.signatures.length === signedKeys.length) {\n            const valid = this.signatures.every((pair, index)=>{\n                return signedKeys[index].equals(pair.publicKey);\n            });\n            if (valid) return message;\n        }\n        this.signatures = signedKeys.map((publicKey)=>({\n                signature: null,\n                publicKey\n            }));\n        return message;\n    }\n    /**\n   * Get a buffer of the Transaction data that need to be covered by signatures\n   */ serializeMessage() {\n        return this._compile().serialize();\n    }\n    /**\n   * Get the estimated fee associated with a transaction\n   *\n   * @param {Connection} connection Connection to RPC Endpoint.\n   *\n   * @returns {Promise<number | null>} The estimated fee for the transaction\n   */ async getEstimatedFee(connection) {\n        return (await connection.getFeeForMessage(this.compileMessage())).value;\n    }\n    /**\n   * Specify the public keys which will be used to sign the Transaction.\n   * The first signer will be used as the transaction fee payer account.\n   *\n   * Signatures can be added with either `partialSign` or `addSignature`\n   *\n   * @deprecated Deprecated since v0.84.0. Only the fee payer needs to be\n   * specified and it can be set in the Transaction constructor or with the\n   * `feePayer` property.\n   */ setSigners(...signers) {\n        if (signers.length === 0) {\n            throw new Error(\"No signers\");\n        }\n        const seen = new Set();\n        this.signatures = signers.filter((publicKey)=>{\n            const key = publicKey.toString();\n            if (seen.has(key)) {\n                return false;\n            } else {\n                seen.add(key);\n                return true;\n            }\n        }).map((publicKey)=>({\n                signature: null,\n                publicKey\n            }));\n    }\n    /**\n   * Sign the Transaction with the specified signers. Multiple signatures may\n   * be applied to a Transaction. The first signature is considered \"primary\"\n   * and is used identify and confirm transactions.\n   *\n   * If the Transaction `feePayer` is not set, the first signer will be used\n   * as the transaction fee payer account.\n   *\n   * Transaction fields should not be modified after the first call to `sign`,\n   * as doing so may invalidate the signature and cause the Transaction to be\n   * rejected.\n   *\n   * The Transaction must be assigned a valid `recentBlockhash` before invoking this method\n   *\n   * @param {Array<Signer>} signers Array of signers that will sign the transaction\n   */ sign(...signers) {\n        if (signers.length === 0) {\n            throw new Error(\"No signers\");\n        }\n        // Dedupe signers\n        const seen = new Set();\n        const uniqueSigners = [];\n        for (const signer of signers){\n            const key = signer.publicKey.toString();\n            if (seen.has(key)) {\n                continue;\n            } else {\n                seen.add(key);\n                uniqueSigners.push(signer);\n            }\n        }\n        this.signatures = uniqueSigners.map((signer)=>({\n                signature: null,\n                publicKey: signer.publicKey\n            }));\n        const message = this._compile();\n        this._partialSign(message, ...uniqueSigners);\n    }\n    /**\n   * Partially sign a transaction with the specified accounts. All accounts must\n   * correspond to either the fee payer or a signer account in the transaction\n   * instructions.\n   *\n   * All the caveats from the `sign` method apply to `partialSign`\n   *\n   * @param {Array<Signer>} signers Array of signers that will sign the transaction\n   */ partialSign(...signers) {\n        if (signers.length === 0) {\n            throw new Error(\"No signers\");\n        }\n        // Dedupe signers\n        const seen = new Set();\n        const uniqueSigners = [];\n        for (const signer of signers){\n            const key = signer.publicKey.toString();\n            if (seen.has(key)) {\n                continue;\n            } else {\n                seen.add(key);\n                uniqueSigners.push(signer);\n            }\n        }\n        const message = this._compile();\n        this._partialSign(message, ...uniqueSigners);\n    }\n    /**\n   * @internal\n   */ _partialSign(message, ...signers) {\n        const signData = message.serialize();\n        signers.forEach((signer)=>{\n            const signature = sign(signData, signer.secretKey);\n            this._addSignature(signer.publicKey, toBuffer(signature));\n        });\n    }\n    /**\n   * Add an externally created signature to a transaction. The public key\n   * must correspond to either the fee payer or a signer account in the transaction\n   * instructions.\n   *\n   * @param {PublicKey} pubkey Public key that will be added to the transaction.\n   * @param {Buffer} signature An externally created signature to add to the transaction.\n   */ addSignature(pubkey, signature) {\n        this._compile(); // Ensure signatures array is populated\n        this._addSignature(pubkey, signature);\n    }\n    /**\n   * @internal\n   */ _addSignature(pubkey, signature) {\n        assert(signature.length === 64);\n        const index = this.signatures.findIndex((sigpair)=>pubkey.equals(sigpair.publicKey));\n        if (index < 0) {\n            throw new Error(`unknown signer: ${pubkey.toString()}`);\n        }\n        this.signatures[index].signature = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(signature);\n    }\n    /**\n   * Verify signatures of a Transaction\n   * Optional parameter specifies if we're expecting a fully signed Transaction or a partially signed one.\n   * If no boolean is provided, we expect a fully signed Transaction by default.\n   *\n   * @param {boolean} [requireAllSignatures=true] Require a fully signed Transaction\n   */ verifySignatures(requireAllSignatures = true) {\n        const signatureErrors = this._getMessageSignednessErrors(this.serializeMessage(), requireAllSignatures);\n        return !signatureErrors;\n    }\n    /**\n   * @internal\n   */ _getMessageSignednessErrors(message, requireAllSignatures) {\n        const errors = {};\n        for (const { signature, publicKey } of this.signatures){\n            if (signature === null) {\n                if (requireAllSignatures) {\n                    (errors.missing ||= []).push(publicKey);\n                }\n            } else {\n                if (!verify(signature, message, publicKey.toBytes())) {\n                    (errors.invalid ||= []).push(publicKey);\n                }\n            }\n        }\n        return errors.invalid || errors.missing ? errors : undefined;\n    }\n    /**\n   * Serialize the Transaction in the wire format.\n   *\n   * @param {Buffer} [config] Config of transaction.\n   *\n   * @returns {Buffer} Signature of transaction in wire format.\n   */ serialize(config) {\n        const { requireAllSignatures, verifySignatures } = Object.assign({\n            requireAllSignatures: true,\n            verifySignatures: true\n        }, config);\n        const signData = this.serializeMessage();\n        if (verifySignatures) {\n            const sigErrors = this._getMessageSignednessErrors(signData, requireAllSignatures);\n            if (sigErrors) {\n                let errorMessage = \"Signature verification failed.\";\n                if (sigErrors.invalid) {\n                    errorMessage += `\\nInvalid signature for public key${sigErrors.invalid.length === 1 ? \"\" : \"(s)\"} [\\`${sigErrors.invalid.map((p)=>p.toBase58()).join(\"`, `\")}\\`].`;\n                }\n                if (sigErrors.missing) {\n                    errorMessage += `\\nMissing signature for public key${sigErrors.missing.length === 1 ? \"\" : \"(s)\"} [\\`${sigErrors.missing.map((p)=>p.toBase58()).join(\"`, `\")}\\`].`;\n                }\n                throw new Error(errorMessage);\n            }\n        }\n        return this._serialize(signData);\n    }\n    /**\n   * @internal\n   */ _serialize(signData) {\n        const { signatures } = this;\n        const signatureCount = [];\n        encodeLength(signatureCount, signatures.length);\n        const transactionLength = signatureCount.length + signatures.length * 64 + signData.length;\n        const wireTransaction = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(transactionLength);\n        assert(signatures.length < 256);\n        buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(signatureCount).copy(wireTransaction, 0);\n        signatures.forEach(({ signature }, index)=>{\n            if (signature !== null) {\n                assert(signature.length === 64, `signature has invalid length`);\n                buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(signature).copy(wireTransaction, signatureCount.length + index * 64);\n            }\n        });\n        signData.copy(wireTransaction, signatureCount.length + signatures.length * 64);\n        assert(wireTransaction.length <= PACKET_DATA_SIZE, `Transaction too large: ${wireTransaction.length} > ${PACKET_DATA_SIZE}`);\n        return wireTransaction;\n    }\n    /**\n   * Deprecated method\n   * @internal\n   */ get keys() {\n        assert(this.instructions.length === 1);\n        return this.instructions[0].keys.map((keyObj)=>keyObj.pubkey);\n    }\n    /**\n   * Deprecated method\n   * @internal\n   */ get programId() {\n        assert(this.instructions.length === 1);\n        return this.instructions[0].programId;\n    }\n    /**\n   * Deprecated method\n   * @internal\n   */ get data() {\n        assert(this.instructions.length === 1);\n        return this.instructions[0].data;\n    }\n    /**\n   * Parse a wire transaction into a Transaction object.\n   *\n   * @param {Buffer | Uint8Array | Array<number>} buffer Signature of wire Transaction\n   *\n   * @returns {Transaction} Transaction associated with the signature\n   */ static from(buffer) {\n        // Slice up wire data\n        let byteArray = [\n            ...buffer\n        ];\n        const signatureCount = decodeLength(byteArray);\n        let signatures = [];\n        for(let i = 0; i < signatureCount; i++){\n            const signature = guardedSplice(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES);\n            signatures.push(bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(signature)));\n        }\n        return Transaction.populate(Message.from(byteArray), signatures);\n    }\n    /**\n   * Populate Transaction object from message and signatures\n   *\n   * @param {Message} message Message of transaction\n   * @param {Array<string>} signatures List of signatures to assign to the transaction\n   *\n   * @returns {Transaction} The populated Transaction\n   */ static populate(message, signatures = []) {\n        const transaction = new Transaction();\n        transaction.recentBlockhash = message.recentBlockhash;\n        if (message.header.numRequiredSignatures > 0) {\n            transaction.feePayer = message.accountKeys[0];\n        }\n        signatures.forEach((signature, index)=>{\n            const sigPubkeyPair = {\n                signature: signature == bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(DEFAULT_SIGNATURE) ? null : bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(signature),\n                publicKey: message.accountKeys[index]\n            };\n            transaction.signatures.push(sigPubkeyPair);\n        });\n        message.instructions.forEach((instruction)=>{\n            const keys = instruction.accounts.map((account)=>{\n                const pubkey = message.accountKeys[account];\n                return {\n                    pubkey,\n                    isSigner: transaction.signatures.some((keyObj)=>keyObj.publicKey.toString() === pubkey.toString()) || message.isAccountSigner(account),\n                    isWritable: message.isAccountWritable(account)\n                };\n            });\n            transaction.instructions.push(new TransactionInstruction({\n                keys,\n                programId: message.accountKeys[instruction.programIdIndex],\n                data: bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(instruction.data)\n            }));\n        });\n        transaction._message = message;\n        transaction._json = transaction.toJSON();\n        return transaction;\n    }\n}\nclass TransactionMessage {\n    constructor(args){\n        this.payerKey = void 0;\n        this.instructions = void 0;\n        this.recentBlockhash = void 0;\n        this.payerKey = args.payerKey;\n        this.instructions = args.instructions;\n        this.recentBlockhash = args.recentBlockhash;\n    }\n    static decompile(message, args) {\n        const { header, compiledInstructions, recentBlockhash } = message;\n        const { numRequiredSignatures, numReadonlySignedAccounts, numReadonlyUnsignedAccounts } = header;\n        const numWritableSignedAccounts = numRequiredSignatures - numReadonlySignedAccounts;\n        assert(numWritableSignedAccounts > 0, \"Message header is invalid\");\n        const numWritableUnsignedAccounts = message.staticAccountKeys.length - numRequiredSignatures - numReadonlyUnsignedAccounts;\n        assert(numWritableUnsignedAccounts >= 0, \"Message header is invalid\");\n        const accountKeys = message.getAccountKeys(args);\n        const payerKey = accountKeys.get(0);\n        if (payerKey === undefined) {\n            throw new Error(\"Failed to decompile message because no account keys were found\");\n        }\n        const instructions = [];\n        for (const compiledIx of compiledInstructions){\n            const keys = [];\n            for (const keyIndex of compiledIx.accountKeyIndexes){\n                const pubkey = accountKeys.get(keyIndex);\n                if (pubkey === undefined) {\n                    throw new Error(`Failed to find key for account key index ${keyIndex}`);\n                }\n                const isSigner = keyIndex < numRequiredSignatures;\n                let isWritable;\n                if (isSigner) {\n                    isWritable = keyIndex < numWritableSignedAccounts;\n                } else if (keyIndex < accountKeys.staticAccountKeys.length) {\n                    isWritable = keyIndex - numRequiredSignatures < numWritableUnsignedAccounts;\n                } else {\n                    isWritable = keyIndex - accountKeys.staticAccountKeys.length < // accountKeysFromLookups cannot be undefined because we already found a pubkey for this index above\n                    accountKeys.accountKeysFromLookups.writable.length;\n                }\n                keys.push({\n                    pubkey,\n                    isSigner: keyIndex < header.numRequiredSignatures,\n                    isWritable\n                });\n            }\n            const programId = accountKeys.get(compiledIx.programIdIndex);\n            if (programId === undefined) {\n                throw new Error(`Failed to find program id for program id index ${compiledIx.programIdIndex}`);\n            }\n            instructions.push(new TransactionInstruction({\n                programId,\n                data: toBuffer(compiledIx.data),\n                keys\n            }));\n        }\n        return new TransactionMessage({\n            payerKey,\n            instructions,\n            recentBlockhash\n        });\n    }\n    compileToLegacyMessage() {\n        return Message.compile({\n            payerKey: this.payerKey,\n            recentBlockhash: this.recentBlockhash,\n            instructions: this.instructions\n        });\n    }\n    compileToV0Message(addressLookupTableAccounts) {\n        return MessageV0.compile({\n            payerKey: this.payerKey,\n            recentBlockhash: this.recentBlockhash,\n            instructions: this.instructions,\n            addressLookupTableAccounts\n        });\n    }\n}\n/**\n * Versioned transaction class\n */ class VersionedTransaction {\n    get version() {\n        return this.message.version;\n    }\n    constructor(message, signatures){\n        this.signatures = void 0;\n        this.message = void 0;\n        if (signatures !== undefined) {\n            assert(signatures.length === message.header.numRequiredSignatures, \"Expected signatures length to be equal to the number of required signatures\");\n            this.signatures = signatures;\n        } else {\n            const defaultSignatures = [];\n            for(let i = 0; i < message.header.numRequiredSignatures; i++){\n                defaultSignatures.push(new Uint8Array(SIGNATURE_LENGTH_IN_BYTES));\n            }\n            this.signatures = defaultSignatures;\n        }\n        this.message = message;\n    }\n    serialize() {\n        const serializedMessage = this.message.serialize();\n        const encodedSignaturesLength = Array();\n        encodeLength(encodedSignaturesLength, this.signatures.length);\n        const transactionLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedSignaturesLength.length, \"encodedSignaturesLength\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(signature(), this.signatures.length, \"signatures\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(serializedMessage.length, \"serializedMessage\")\n        ]);\n        const serializedTransaction = new Uint8Array(2048);\n        const serializedTransactionLength = transactionLayout.encode({\n            encodedSignaturesLength: new Uint8Array(encodedSignaturesLength),\n            signatures: this.signatures,\n            serializedMessage\n        }, serializedTransaction);\n        return serializedTransaction.slice(0, serializedTransactionLength);\n    }\n    static deserialize(serializedTransaction) {\n        let byteArray = [\n            ...serializedTransaction\n        ];\n        const signatures = [];\n        const signaturesLength = decodeLength(byteArray);\n        for(let i = 0; i < signaturesLength; i++){\n            signatures.push(new Uint8Array(guardedSplice(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES)));\n        }\n        const message = VersionedMessage.deserialize(new Uint8Array(byteArray));\n        return new VersionedTransaction(message, signatures);\n    }\n    sign(signers) {\n        const messageData = this.message.serialize();\n        const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);\n        for (const signer of signers){\n            const signerIndex = signerPubkeys.findIndex((pubkey)=>pubkey.equals(signer.publicKey));\n            assert(signerIndex >= 0, `Cannot sign with non signer key ${signer.publicKey.toBase58()}`);\n            this.signatures[signerIndex] = sign(messageData, signer.secretKey);\n        }\n    }\n    addSignature(publicKey, signature) {\n        assert(signature.byteLength === 64, \"Signature must be 64 bytes long\");\n        const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);\n        const signerIndex = signerPubkeys.findIndex((pubkey)=>pubkey.equals(publicKey));\n        assert(signerIndex >= 0, `Can not add signature; \\`${publicKey.toBase58()}\\` is not required to sign this transaction`);\n        this.signatures[signerIndex] = signature;\n    }\n}\n// TODO: These constants should be removed in favor of reading them out of a\n// Syscall account\n/**\n * @internal\n */ const NUM_TICKS_PER_SECOND = 160;\n/**\n * @internal\n */ const DEFAULT_TICKS_PER_SLOT = 64;\n/**\n * @internal\n */ const NUM_SLOTS_PER_SECOND = NUM_TICKS_PER_SECOND / DEFAULT_TICKS_PER_SLOT;\n/**\n * @internal\n */ const MS_PER_SLOT = 1000 / NUM_SLOTS_PER_SECOND;\nconst SYSVAR_CLOCK_PUBKEY = new PublicKey(\"SysvarC1ock11111111111111111111111111111111\");\nconst SYSVAR_EPOCH_SCHEDULE_PUBKEY = new PublicKey(\"SysvarEpochSchedu1e111111111111111111111111\");\nconst SYSVAR_INSTRUCTIONS_PUBKEY = new PublicKey(\"Sysvar1nstructions1111111111111111111111111\");\nconst SYSVAR_RECENT_BLOCKHASHES_PUBKEY = new PublicKey(\"SysvarRecentB1ockHashes11111111111111111111\");\nconst SYSVAR_RENT_PUBKEY = new PublicKey(\"SysvarRent111111111111111111111111111111111\");\nconst SYSVAR_REWARDS_PUBKEY = new PublicKey(\"SysvarRewards111111111111111111111111111111\");\nconst SYSVAR_SLOT_HASHES_PUBKEY = new PublicKey(\"SysvarS1otHashes111111111111111111111111111\");\nconst SYSVAR_SLOT_HISTORY_PUBKEY = new PublicKey(\"SysvarS1otHistory11111111111111111111111111\");\nconst SYSVAR_STAKE_HISTORY_PUBKEY = new PublicKey(\"SysvarStakeHistory1111111111111111111111111\");\nclass SendTransactionError extends Error {\n    constructor({ action, signature, transactionMessage, logs }){\n        const maybeLogsOutput = logs ? `Logs: \\n${JSON.stringify(logs.slice(-10), null, 2)}. ` : \"\";\n        const guideText = \"\\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.\";\n        let message;\n        switch(action){\n            case \"send\":\n                message = `Transaction ${signature} resulted in an error. \\n` + `${transactionMessage}. ` + maybeLogsOutput + guideText;\n                break;\n            case \"simulate\":\n                message = `Simulation failed. \\nMessage: ${transactionMessage}. \\n` + maybeLogsOutput + guideText;\n                break;\n            default:\n                {\n                    message = `Unknown action '${((a)=>a)(action)}'`;\n                }\n        }\n        super(message);\n        this.signature = void 0;\n        this.transactionMessage = void 0;\n        this.transactionLogs = void 0;\n        this.signature = signature;\n        this.transactionMessage = transactionMessage;\n        this.transactionLogs = logs ? logs : undefined;\n    }\n    get transactionError() {\n        return {\n            message: this.transactionMessage,\n            logs: Array.isArray(this.transactionLogs) ? this.transactionLogs : undefined\n        };\n    }\n    /* @deprecated Use `await getLogs()` instead */ get logs() {\n        const cachedLogs = this.transactionLogs;\n        if (cachedLogs != null && typeof cachedLogs === \"object\" && \"then\" in cachedLogs) {\n            return undefined;\n        }\n        return cachedLogs;\n    }\n    async getLogs(connection) {\n        if (!Array.isArray(this.transactionLogs)) {\n            this.transactionLogs = new Promise((resolve, reject)=>{\n                connection.getTransaction(this.signature).then((tx)=>{\n                    if (tx && tx.meta && tx.meta.logMessages) {\n                        const logs = tx.meta.logMessages;\n                        this.transactionLogs = logs;\n                        resolve(logs);\n                    } else {\n                        reject(new Error(\"Log messages not found\"));\n                    }\n                }).catch(reject);\n            });\n        }\n        return await this.transactionLogs;\n    }\n}\n// Keep in sync with client/src/rpc_custom_errors.rs\n// Typescript `enums` thwart tree-shaking. See https://bargsten.org/jsts/enums/\nconst SolanaJSONRPCErrorCode = {\n    JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP: -32001,\n    JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: -32002,\n    JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE: -32003,\n    JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE: -32004,\n    JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY: -32005,\n    JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE: -32006,\n    JSON_RPC_SERVER_ERROR_SLOT_SKIPPED: -32007,\n    JSON_RPC_SERVER_ERROR_NO_SNAPSHOT: -32008,\n    JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: -32009,\n    JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: -32010,\n    JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: -32011,\n    JSON_RPC_SCAN_ERROR: -32012,\n    JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: -32013,\n    JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: -32014,\n    JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: -32015,\n    JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: -32016\n};\nclass SolanaJSONRPCError extends Error {\n    constructor({ code, message, data }, customMessage){\n        super(customMessage != null ? `${customMessage}: ${message}` : message);\n        this.code = void 0;\n        this.data = void 0;\n        this.code = code;\n        this.data = data;\n        this.name = \"SolanaJSONRPCError\";\n    }\n}\n/**\n * Sign, send and confirm a transaction.\n *\n * If `commitment` option is not specified, defaults to 'max' commitment.\n *\n * @param {Connection} connection\n * @param {Transaction} transaction\n * @param {Array<Signer>} signers\n * @param {ConfirmOptions} [options]\n * @returns {Promise<TransactionSignature>}\n */ async function sendAndConfirmTransaction(connection, transaction, signers, options) {\n    const sendOptions = options && {\n        skipPreflight: options.skipPreflight,\n        preflightCommitment: options.preflightCommitment || options.commitment,\n        maxRetries: options.maxRetries,\n        minContextSlot: options.minContextSlot\n    };\n    const signature = await connection.sendTransaction(transaction, signers, sendOptions);\n    let status;\n    if (transaction.recentBlockhash != null && transaction.lastValidBlockHeight != null) {\n        status = (await connection.confirmTransaction({\n            abortSignal: options?.abortSignal,\n            signature: signature,\n            blockhash: transaction.recentBlockhash,\n            lastValidBlockHeight: transaction.lastValidBlockHeight\n        }, options && options.commitment)).value;\n    } else if (transaction.minNonceContextSlot != null && transaction.nonceInfo != null) {\n        const { nonceInstruction } = transaction.nonceInfo;\n        const nonceAccountPubkey = nonceInstruction.keys[0].pubkey;\n        status = (await connection.confirmTransaction({\n            abortSignal: options?.abortSignal,\n            minContextSlot: transaction.minNonceContextSlot,\n            nonceAccountPubkey,\n            nonceValue: transaction.nonceInfo.nonce,\n            signature\n        }, options && options.commitment)).value;\n    } else {\n        if (options?.abortSignal != null) {\n            console.warn(\"sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was \" + \"supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` \" + \"or a combination of `nonceInfo` and `minNonceContextSlot` are abortable.\");\n        }\n        status = (await connection.confirmTransaction(signature, options && options.commitment)).value;\n    }\n    if (status.err) {\n        if (signature != null) {\n            throw new SendTransactionError({\n                action: \"send\",\n                signature: signature,\n                transactionMessage: `Status: (${JSON.stringify(status)})`\n            });\n        }\n        throw new Error(`Transaction ${signature} failed (${JSON.stringify(status)})`);\n    }\n    return signature;\n}\n// zzz\nfunction sleep(ms) {\n    return new Promise((resolve)=>setTimeout(resolve, ms));\n}\n/**\n * @internal\n */ /**\n * Populate a buffer of instruction data using an InstructionType\n * @internal\n */ function encodeData(type, fields) {\n    const allocLength = type.layout.span >= 0 ? type.layout.span : getAlloc(type, fields);\n    const data = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(allocLength);\n    const layoutFields = Object.assign({\n        instruction: type.index\n    }, fields);\n    type.layout.encode(layoutFields, data);\n    return data;\n}\n/**\n * Decode instruction data buffer using an InstructionType\n * @internal\n */ function decodeData$1(type, buffer) {\n    let data;\n    try {\n        data = type.layout.decode(buffer);\n    } catch (err) {\n        throw new Error(\"invalid instruction; \" + err);\n    }\n    if (data.instruction !== type.index) {\n        throw new Error(`invalid instruction; instruction index mismatch ${data.instruction} != ${type.index}`);\n    }\n    return data;\n}\n/**\n * https://github.com/solana-labs/solana/blob/90bedd7e067b5b8f3ddbb45da00a4e9cabb22c62/sdk/src/fee_calculator.rs#L7-L11\n *\n * @internal\n */ const FeeCalculatorLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"lamportsPerSignature\");\n/**\n * Calculator for transaction fees.\n *\n * @deprecated Deprecated since Solana v1.8.0.\n */ /**\n * See https://github.com/solana-labs/solana/blob/0ea2843ec9cdc517572b8e62c959f41b55cf4453/sdk/src/nonce_state.rs#L29-L32\n *\n * @internal\n */ const NonceAccountLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"version\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"state\"),\n    publicKey(\"authorizedPubkey\"),\n    publicKey(\"nonce\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        FeeCalculatorLayout\n    ], \"feeCalculator\")\n]);\nconst NONCE_ACCOUNT_LENGTH = NonceAccountLayout.span;\n/**\n * A durable nonce is a 32 byte value encoded as a base58 string.\n */ /**\n * NonceAccount class\n */ class NonceAccount {\n    /**\n   * @internal\n   */ constructor(args){\n        this.authorizedPubkey = void 0;\n        this.nonce = void 0;\n        this.feeCalculator = void 0;\n        this.authorizedPubkey = args.authorizedPubkey;\n        this.nonce = args.nonce;\n        this.feeCalculator = args.feeCalculator;\n    }\n    /**\n   * Deserialize NonceAccount from the account data.\n   *\n   * @param buffer account data\n   * @return NonceAccount\n   */ static fromAccountData(buffer) {\n        const nonceAccount = NonceAccountLayout.decode(toBuffer(buffer), 0);\n        return new NonceAccount({\n            authorizedPubkey: new PublicKey(nonceAccount.authorizedPubkey),\n            nonce: new PublicKey(nonceAccount.nonce).toString(),\n            feeCalculator: nonceAccount.feeCalculator\n        });\n    }\n}\nfunction u64(property) {\n    const layout = (0,_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob)(8 /* bytes */ , property);\n    const decode = layout.decode.bind(layout);\n    const encode = layout.encode.bind(layout);\n    const bigIntLayout = layout;\n    const codec = (0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_13__.getU64Codec)();\n    bigIntLayout.decode = (buffer, offset)=>{\n        const src = decode(buffer, offset);\n        return codec.decode(src);\n    };\n    bigIntLayout.encode = (bigInt, buffer, offset)=>{\n        const src = codec.encode(bigInt);\n        return encode(src, buffer, offset);\n    };\n    return bigIntLayout;\n}\n/**\n * Create account system transaction params\n */ /**\n * Transfer system transaction params\n */ /**\n * Assign system transaction params\n */ /**\n * Create account with seed system transaction params\n */ /**\n * Create nonce account system transaction params\n */ /**\n * Create nonce account with seed system transaction params\n */ /**\n * Initialize nonce account system instruction params\n */ /**\n * Advance nonce account system instruction params\n */ /**\n * Withdraw nonce account system transaction params\n */ /**\n * Authorize nonce account system transaction params\n */ /**\n * Allocate account system transaction params\n */ /**\n * Allocate account with seed system transaction params\n */ /**\n * Assign account with seed system transaction params\n */ /**\n * Transfer with seed system transaction params\n */ /** Decoded transfer system transaction instruction */ /** Decoded transferWithSeed system transaction instruction */ /**\n * System Instruction class\n */ class SystemInstruction {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Decode a system instruction and retrieve the instruction type.\n   */ static decodeInstructionType(instruction) {\n        this.checkProgramId(instruction.programId);\n        const instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\");\n        const typeIndex = instructionTypeLayout.decode(instruction.data);\n        let type;\n        for (const [ixType, layout] of Object.entries(SYSTEM_INSTRUCTION_LAYOUTS)){\n            if (layout.index == typeIndex) {\n                type = ixType;\n                break;\n            }\n        }\n        if (!type) {\n            throw new Error(\"Instruction type incorrect; not a SystemInstruction\");\n        }\n        return type;\n    }\n    /**\n   * Decode a create account system instruction and retrieve the instruction params.\n   */ static decodeCreateAccount(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 2);\n        const { lamports, space, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Create, instruction.data);\n        return {\n            fromPubkey: instruction.keys[0].pubkey,\n            newAccountPubkey: instruction.keys[1].pubkey,\n            lamports,\n            space,\n            programId: new PublicKey(programId)\n        };\n    }\n    /**\n   * Decode a transfer system instruction and retrieve the instruction params.\n   */ static decodeTransfer(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 2);\n        const { lamports } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Transfer, instruction.data);\n        return {\n            fromPubkey: instruction.keys[0].pubkey,\n            toPubkey: instruction.keys[1].pubkey,\n            lamports\n        };\n    }\n    /**\n   * Decode a transfer with seed system instruction and retrieve the instruction params.\n   */ static decodeTransferWithSeed(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { lamports, seed, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed, instruction.data);\n        return {\n            fromPubkey: instruction.keys[0].pubkey,\n            basePubkey: instruction.keys[1].pubkey,\n            toPubkey: instruction.keys[2].pubkey,\n            lamports,\n            seed,\n            programId: new PublicKey(programId)\n        };\n    }\n    /**\n   * Decode an allocate system instruction and retrieve the instruction params.\n   */ static decodeAllocate(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 1);\n        const { space } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Allocate, instruction.data);\n        return {\n            accountPubkey: instruction.keys[0].pubkey,\n            space\n        };\n    }\n    /**\n   * Decode an allocate with seed system instruction and retrieve the instruction params.\n   */ static decodeAllocateWithSeed(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 1);\n        const { base, seed, space, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed, instruction.data);\n        return {\n            accountPubkey: instruction.keys[0].pubkey,\n            basePubkey: new PublicKey(base),\n            seed,\n            space,\n            programId: new PublicKey(programId)\n        };\n    }\n    /**\n   * Decode an assign system instruction and retrieve the instruction params.\n   */ static decodeAssign(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 1);\n        const { programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Assign, instruction.data);\n        return {\n            accountPubkey: instruction.keys[0].pubkey,\n            programId: new PublicKey(programId)\n        };\n    }\n    /**\n   * Decode an assign with seed system instruction and retrieve the instruction params.\n   */ static decodeAssignWithSeed(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 1);\n        const { base, seed, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed, instruction.data);\n        return {\n            accountPubkey: instruction.keys[0].pubkey,\n            basePubkey: new PublicKey(base),\n            seed,\n            programId: new PublicKey(programId)\n        };\n    }\n    /**\n   * Decode a create account with seed system instruction and retrieve the instruction params.\n   */ static decodeCreateWithSeed(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 2);\n        const { base, seed, lamports, space, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed, instruction.data);\n        return {\n            fromPubkey: instruction.keys[0].pubkey,\n            newAccountPubkey: instruction.keys[1].pubkey,\n            basePubkey: new PublicKey(base),\n            seed,\n            lamports,\n            space,\n            programId: new PublicKey(programId)\n        };\n    }\n    /**\n   * Decode a nonce initialize system instruction and retrieve the instruction params.\n   */ static decodeNonceInitialize(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { authorized } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount, instruction.data);\n        return {\n            noncePubkey: instruction.keys[0].pubkey,\n            authorizedPubkey: new PublicKey(authorized)\n        };\n    }\n    /**\n   * Decode a nonce advance system instruction and retrieve the instruction params.\n   */ static decodeNonceAdvance(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount, instruction.data);\n        return {\n            noncePubkey: instruction.keys[0].pubkey,\n            authorizedPubkey: instruction.keys[2].pubkey\n        };\n    }\n    /**\n   * Decode a nonce withdraw system instruction and retrieve the instruction params.\n   */ static decodeNonceWithdraw(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 5);\n        const { lamports } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount, instruction.data);\n        return {\n            noncePubkey: instruction.keys[0].pubkey,\n            toPubkey: instruction.keys[1].pubkey,\n            authorizedPubkey: instruction.keys[4].pubkey,\n            lamports\n        };\n    }\n    /**\n   * Decode a nonce authorize system instruction and retrieve the instruction params.\n   */ static decodeNonceAuthorize(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 2);\n        const { authorized } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount, instruction.data);\n        return {\n            noncePubkey: instruction.keys[0].pubkey,\n            authorizedPubkey: instruction.keys[1].pubkey,\n            newAuthorizedPubkey: new PublicKey(authorized)\n        };\n    }\n    /**\n   * @internal\n   */ static checkProgramId(programId) {\n        if (!programId.equals(SystemProgram.programId)) {\n            throw new Error(\"invalid instruction; programId is not SystemProgram\");\n        }\n    }\n    /**\n   * @internal\n   */ static checkKeyLength(keys, expectedLength) {\n        if (keys.length < expectedLength) {\n            throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);\n        }\n    }\n}\n/**\n * An enumeration of valid SystemInstructionType's\n */ /**\n * An enumeration of valid system InstructionType's\n * @internal\n */ const SYSTEM_INSTRUCTION_LAYOUTS = Object.freeze({\n    Create: {\n        index: 0,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"lamports\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"space\"),\n            publicKey(\"programId\")\n        ])\n    },\n    Assign: {\n        index: 1,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"programId\")\n        ])\n    },\n    Transfer: {\n        index: 2,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            u64(\"lamports\")\n        ])\n    },\n    CreateWithSeed: {\n        index: 3,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"base\"),\n            rustString(\"seed\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"lamports\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"space\"),\n            publicKey(\"programId\")\n        ])\n    },\n    AdvanceNonceAccount: {\n        index: 4,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    WithdrawNonceAccount: {\n        index: 5,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"lamports\")\n        ])\n    },\n    InitializeNonceAccount: {\n        index: 6,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"authorized\")\n        ])\n    },\n    AuthorizeNonceAccount: {\n        index: 7,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"authorized\")\n        ])\n    },\n    Allocate: {\n        index: 8,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"space\")\n        ])\n    },\n    AllocateWithSeed: {\n        index: 9,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"base\"),\n            rustString(\"seed\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"space\"),\n            publicKey(\"programId\")\n        ])\n    },\n    AssignWithSeed: {\n        index: 10,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"base\"),\n            rustString(\"seed\"),\n            publicKey(\"programId\")\n        ])\n    },\n    TransferWithSeed: {\n        index: 11,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            u64(\"lamports\"),\n            rustString(\"seed\"),\n            publicKey(\"programId\")\n        ])\n    },\n    UpgradeNonceAccount: {\n        index: 12,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    }\n});\n/**\n * Factory class for transactions to interact with the System program\n */ class SystemProgram {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Public key that identifies the System program\n   */ /**\n   * Generate a transaction instruction that creates a new account\n   */ static createAccount(params) {\n        const type = SYSTEM_INSTRUCTION_LAYOUTS.Create;\n        const data = encodeData(type, {\n            lamports: params.lamports,\n            space: params.space,\n            programId: toBuffer(params.programId.toBuffer())\n        });\n        return new TransactionInstruction({\n            keys: [\n                {\n                    pubkey: params.fromPubkey,\n                    isSigner: true,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.newAccountPubkey,\n                    isSigner: true,\n                    isWritable: true\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction instruction that transfers lamports from one account to another\n   */ static transfer(params) {\n        let data;\n        let keys;\n        if (\"basePubkey\" in params) {\n            const type = SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed;\n            data = encodeData(type, {\n                lamports: BigInt(params.lamports),\n                seed: params.seed,\n                programId: toBuffer(params.programId.toBuffer())\n            });\n            keys = [\n                {\n                    pubkey: params.fromPubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.basePubkey,\n                    isSigner: true,\n                    isWritable: false\n                },\n                {\n                    pubkey: params.toPubkey,\n                    isSigner: false,\n                    isWritable: true\n                }\n            ];\n        } else {\n            const type = SYSTEM_INSTRUCTION_LAYOUTS.Transfer;\n            data = encodeData(type, {\n                lamports: BigInt(params.lamports)\n            });\n            keys = [\n                {\n                    pubkey: params.fromPubkey,\n                    isSigner: true,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.toPubkey,\n                    isSigner: false,\n                    isWritable: true\n                }\n            ];\n        }\n        return new TransactionInstruction({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction instruction that assigns an account to a program\n   */ static assign(params) {\n        let data;\n        let keys;\n        if (\"basePubkey\" in params) {\n            const type = SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed;\n            data = encodeData(type, {\n                base: toBuffer(params.basePubkey.toBuffer()),\n                seed: params.seed,\n                programId: toBuffer(params.programId.toBuffer())\n            });\n            keys = [\n                {\n                    pubkey: params.accountPubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.basePubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ];\n        } else {\n            const type = SYSTEM_INSTRUCTION_LAYOUTS.Assign;\n            data = encodeData(type, {\n                programId: toBuffer(params.programId.toBuffer())\n            });\n            keys = [\n                {\n                    pubkey: params.accountPubkey,\n                    isSigner: true,\n                    isWritable: true\n                }\n            ];\n        }\n        return new TransactionInstruction({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction instruction that creates a new account at\n   *   an address generated with `from`, a seed, and programId\n   */ static createAccountWithSeed(params) {\n        const type = SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed;\n        const data = encodeData(type, {\n            base: toBuffer(params.basePubkey.toBuffer()),\n            seed: params.seed,\n            lamports: params.lamports,\n            space: params.space,\n            programId: toBuffer(params.programId.toBuffer())\n        });\n        let keys = [\n            {\n                pubkey: params.fromPubkey,\n                isSigner: true,\n                isWritable: true\n            },\n            {\n                pubkey: params.newAccountPubkey,\n                isSigner: false,\n                isWritable: true\n            }\n        ];\n        if (!params.basePubkey.equals(params.fromPubkey)) {\n            keys.push({\n                pubkey: params.basePubkey,\n                isSigner: true,\n                isWritable: false\n            });\n        }\n        return new TransactionInstruction({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction that creates a new Nonce account\n   */ static createNonceAccount(params) {\n        const transaction = new Transaction();\n        if (\"basePubkey\" in params && \"seed\" in params) {\n            transaction.add(SystemProgram.createAccountWithSeed({\n                fromPubkey: params.fromPubkey,\n                newAccountPubkey: params.noncePubkey,\n                basePubkey: params.basePubkey,\n                seed: params.seed,\n                lamports: params.lamports,\n                space: NONCE_ACCOUNT_LENGTH,\n                programId: this.programId\n            }));\n        } else {\n            transaction.add(SystemProgram.createAccount({\n                fromPubkey: params.fromPubkey,\n                newAccountPubkey: params.noncePubkey,\n                lamports: params.lamports,\n                space: NONCE_ACCOUNT_LENGTH,\n                programId: this.programId\n            }));\n        }\n        const initParams = {\n            noncePubkey: params.noncePubkey,\n            authorizedPubkey: params.authorizedPubkey\n        };\n        transaction.add(this.nonceInitialize(initParams));\n        return transaction;\n    }\n    /**\n   * Generate an instruction to initialize a Nonce account\n   */ static nonceInitialize(params) {\n        const type = SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount;\n        const data = encodeData(type, {\n            authorized: toBuffer(params.authorizedPubkey.toBuffer())\n        });\n        const instructionData = {\n            keys: [\n                {\n                    pubkey: params.noncePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: SYSVAR_RENT_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        };\n        return new TransactionInstruction(instructionData);\n    }\n    /**\n   * Generate an instruction to advance the nonce in a Nonce account\n   */ static nonceAdvance(params) {\n        const type = SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount;\n        const data = encodeData(type);\n        const instructionData = {\n            keys: [\n                {\n                    pubkey: params.noncePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: params.authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        };\n        return new TransactionInstruction(instructionData);\n    }\n    /**\n   * Generate a transaction instruction that withdraws lamports from a Nonce account\n   */ static nonceWithdraw(params) {\n        const type = SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount;\n        const data = encodeData(type, {\n            lamports: params.lamports\n        });\n        return new TransactionInstruction({\n            keys: [\n                {\n                    pubkey: params.noncePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.toPubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: SYSVAR_RENT_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: params.authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction instruction that authorizes a new PublicKey as the authority\n   * on a Nonce account.\n   */ static nonceAuthorize(params) {\n        const type = SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount;\n        const data = encodeData(type, {\n            authorized: toBuffer(params.newAuthorizedPubkey.toBuffer())\n        });\n        return new TransactionInstruction({\n            keys: [\n                {\n                    pubkey: params.noncePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction instruction that allocates space in an account without funding\n   */ static allocate(params) {\n        let data;\n        let keys;\n        if (\"basePubkey\" in params) {\n            const type = SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed;\n            data = encodeData(type, {\n                base: toBuffer(params.basePubkey.toBuffer()),\n                seed: params.seed,\n                space: params.space,\n                programId: toBuffer(params.programId.toBuffer())\n            });\n            keys = [\n                {\n                    pubkey: params.accountPubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.basePubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ];\n        } else {\n            const type = SYSTEM_INSTRUCTION_LAYOUTS.Allocate;\n            data = encodeData(type, {\n                space: params.space\n            });\n            keys = [\n                {\n                    pubkey: params.accountPubkey,\n                    isSigner: true,\n                    isWritable: true\n                }\n            ];\n        }\n        return new TransactionInstruction({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n}\nSystemProgram.programId = new PublicKey(\"11111111111111111111111111111111\");\n// Keep program chunks under PACKET_DATA_SIZE, leaving enough room for the\n// rest of the Transaction fields\n//\n// TODO: replace 300 with a proper constant for the size of the other\n// Transaction fields\nconst CHUNK_SIZE = PACKET_DATA_SIZE - 300;\n/**\n * Program loader interface\n */ class Loader {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Amount of program data placed in each load Transaction\n   */ /**\n   * Minimum number of signatures required to load a program not including\n   * retries\n   *\n   * Can be used to calculate transaction fees\n   */ static getMinNumSignatures(dataLength) {\n        return 2 * // Every transaction requires two signatures (payer + program)\n        (Math.ceil(dataLength / Loader.chunkSize) + 1 + // Add one for Create transaction\n        1 // Add one for Finalize transaction\n        );\n    }\n    /**\n   * Loads a generic program\n   *\n   * @param connection The connection to use\n   * @param payer System account that pays to load the program\n   * @param program Account to load the program into\n   * @param programId Public key that identifies the loader\n   * @param data Program octets\n   * @return true if program was loaded successfully, false if program was already loaded\n   */ static async load(connection, payer, program, programId, data) {\n        {\n            const balanceNeeded = await connection.getMinimumBalanceForRentExemption(data.length);\n            // Fetch program account info to check if it has already been created\n            const programInfo = await connection.getAccountInfo(program.publicKey, \"confirmed\");\n            let transaction = null;\n            if (programInfo !== null) {\n                if (programInfo.executable) {\n                    console.error(\"Program load failed, account is already executable\");\n                    return false;\n                }\n                if (programInfo.data.length !== data.length) {\n                    transaction = transaction || new Transaction();\n                    transaction.add(SystemProgram.allocate({\n                        accountPubkey: program.publicKey,\n                        space: data.length\n                    }));\n                }\n                if (!programInfo.owner.equals(programId)) {\n                    transaction = transaction || new Transaction();\n                    transaction.add(SystemProgram.assign({\n                        accountPubkey: program.publicKey,\n                        programId\n                    }));\n                }\n                if (programInfo.lamports < balanceNeeded) {\n                    transaction = transaction || new Transaction();\n                    transaction.add(SystemProgram.transfer({\n                        fromPubkey: payer.publicKey,\n                        toPubkey: program.publicKey,\n                        lamports: balanceNeeded - programInfo.lamports\n                    }));\n                }\n            } else {\n                transaction = new Transaction().add(SystemProgram.createAccount({\n                    fromPubkey: payer.publicKey,\n                    newAccountPubkey: program.publicKey,\n                    lamports: balanceNeeded > 0 ? balanceNeeded : 1,\n                    space: data.length,\n                    programId\n                }));\n            }\n            // If the account is already created correctly, skip this step\n            // and proceed directly to loading instructions\n            if (transaction !== null) {\n                await sendAndConfirmTransaction(connection, transaction, [\n                    payer,\n                    program\n                ], {\n                    commitment: \"confirmed\"\n                });\n            }\n        }\n        const dataLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"offset\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"bytesLength\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"bytesLengthPadding\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"byte\"), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(), -8), \"bytes\")\n        ]);\n        const chunkSize = Loader.chunkSize;\n        let offset = 0;\n        let array = data;\n        let transactions = [];\n        while(array.length > 0){\n            const bytes = array.slice(0, chunkSize);\n            const data = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(chunkSize + 16);\n            dataLayout.encode({\n                instruction: 0,\n                // Load instruction\n                offset,\n                bytes: bytes,\n                bytesLength: 0,\n                bytesLengthPadding: 0\n            }, data);\n            const transaction = new Transaction().add({\n                keys: [\n                    {\n                        pubkey: program.publicKey,\n                        isSigner: true,\n                        isWritable: true\n                    }\n                ],\n                programId,\n                data\n            });\n            transactions.push(sendAndConfirmTransaction(connection, transaction, [\n                payer,\n                program\n            ], {\n                commitment: \"confirmed\"\n            }));\n            // Delay between sends in an attempt to reduce rate limit errors\n            if (connection._rpcEndpoint.includes(\"solana.com\")) {\n                const REQUESTS_PER_SECOND = 4;\n                await sleep(1000 / REQUESTS_PER_SECOND);\n            }\n            offset += chunkSize;\n            array = array.slice(chunkSize);\n        }\n        await Promise.all(transactions);\n        // Finalize the account loaded with program data for execution\n        {\n            const dataLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n            ]);\n            const data = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(dataLayout.span);\n            dataLayout.encode({\n                instruction: 1 // Finalize instruction\n            }, data);\n            const transaction = new Transaction().add({\n                keys: [\n                    {\n                        pubkey: program.publicKey,\n                        isSigner: true,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: SYSVAR_RENT_PUBKEY,\n                        isSigner: false,\n                        isWritable: false\n                    }\n                ],\n                programId,\n                data\n            });\n            const deployCommitment = \"processed\";\n            const finalizeSignature = await connection.sendTransaction(transaction, [\n                payer,\n                program\n            ], {\n                preflightCommitment: deployCommitment\n            });\n            const { context, value } = await connection.confirmTransaction({\n                signature: finalizeSignature,\n                lastValidBlockHeight: transaction.lastValidBlockHeight,\n                blockhash: transaction.recentBlockhash\n            }, deployCommitment);\n            if (value.err) {\n                throw new Error(`Transaction ${finalizeSignature} failed (${JSON.stringify(value)})`);\n            }\n            // We prevent programs from being usable until the slot after their deployment.\n            // See https://github.com/solana-labs/solana/pull/29654\n            while(true // eslint-disable-line no-constant-condition\n            ){\n                try {\n                    const currentSlot = await connection.getSlot({\n                        commitment: deployCommitment\n                    });\n                    if (currentSlot > context.slot) {\n                        break;\n                    }\n                } catch  {\n                /* empty */ }\n                await new Promise((resolve)=>setTimeout(resolve, Math.round(MS_PER_SLOT / 2)));\n            }\n        }\n        // success\n        return true;\n    }\n}\nLoader.chunkSize = CHUNK_SIZE;\n/**\n * @deprecated Deprecated since Solana v1.17.20.\n */ const BPF_LOADER_PROGRAM_ID = new PublicKey(\"BPFLoader2111111111111111111111111111111111\");\n/**\n * Factory class for transactions to interact with a program loader\n *\n * @deprecated Deprecated since Solana v1.17.20.\n */ class BpfLoader {\n    /**\n   * Minimum number of signatures required to load a program not including\n   * retries\n   *\n   * Can be used to calculate transaction fees\n   */ static getMinNumSignatures(dataLength) {\n        return Loader.getMinNumSignatures(dataLength);\n    }\n    /**\n   * Load a SBF program\n   *\n   * @param connection The connection to use\n   * @param payer Account that will pay program loading fees\n   * @param program Account to load the program into\n   * @param elf The entire ELF containing the SBF program\n   * @param loaderProgramId The program id of the BPF loader to use\n   * @return true if program was loaded successfully, false if program was already loaded\n   */ static load(connection, payer, program, elf, loaderProgramId) {\n        return Loader.load(connection, payer, program, loaderProgramId, elf);\n    }\n}\nfunction getDefaultExportFromCjs(x) {\n    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\nvar agentkeepalive = {\n    exports: {}\n};\n/**\n * Helpers.\n */ var ms;\nvar hasRequiredMs;\nfunction requireMs() {\n    if (hasRequiredMs) return ms;\n    hasRequiredMs = 1;\n    var s = 1000;\n    var m = s * 60;\n    var h = m * 60;\n    var d = h * 24;\n    var w = d * 7;\n    var y = d * 365.25;\n    /**\n\t * Parse or format the given `val`.\n\t *\n\t * Options:\n\t *\n\t *  - `long` verbose formatting [false]\n\t *\n\t * @param {String|Number} val\n\t * @param {Object} [options]\n\t * @throws {Error} throw an error if val is not a non-empty string or a number\n\t * @return {String|Number}\n\t * @api public\n\t */ ms = function(val, options) {\n        options = options || {};\n        var type = typeof val;\n        if (type === \"string\" && val.length > 0) {\n            return parse(val);\n        } else if (type === \"number\" && isFinite(val)) {\n            return options.long ? fmtLong(val) : fmtShort(val);\n        }\n        throw new Error(\"val is not a non-empty string or a valid number. val=\" + JSON.stringify(val));\n    };\n    /**\n\t * Parse the given `str` and return milliseconds.\n\t *\n\t * @param {String} str\n\t * @return {Number}\n\t * @api private\n\t */ function parse(str) {\n        str = String(str);\n        if (str.length > 100) {\n            return;\n        }\n        var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);\n        if (!match) {\n            return;\n        }\n        var n = parseFloat(match[1]);\n        var type = (match[2] || \"ms\").toLowerCase();\n        switch(type){\n            case \"years\":\n            case \"year\":\n            case \"yrs\":\n            case \"yr\":\n            case \"y\":\n                return n * y;\n            case \"weeks\":\n            case \"week\":\n            case \"w\":\n                return n * w;\n            case \"days\":\n            case \"day\":\n            case \"d\":\n                return n * d;\n            case \"hours\":\n            case \"hour\":\n            case \"hrs\":\n            case \"hr\":\n            case \"h\":\n                return n * h;\n            case \"minutes\":\n            case \"minute\":\n            case \"mins\":\n            case \"min\":\n            case \"m\":\n                return n * m;\n            case \"seconds\":\n            case \"second\":\n            case \"secs\":\n            case \"sec\":\n            case \"s\":\n                return n * s;\n            case \"milliseconds\":\n            case \"millisecond\":\n            case \"msecs\":\n            case \"msec\":\n            case \"ms\":\n                return n;\n            default:\n                return undefined;\n        }\n    }\n    /**\n\t * Short format for `ms`.\n\t *\n\t * @param {Number} ms\n\t * @return {String}\n\t * @api private\n\t */ function fmtShort(ms) {\n        var msAbs = Math.abs(ms);\n        if (msAbs >= d) {\n            return Math.round(ms / d) + \"d\";\n        }\n        if (msAbs >= h) {\n            return Math.round(ms / h) + \"h\";\n        }\n        if (msAbs >= m) {\n            return Math.round(ms / m) + \"m\";\n        }\n        if (msAbs >= s) {\n            return Math.round(ms / s) + \"s\";\n        }\n        return ms + \"ms\";\n    }\n    /**\n\t * Long format for `ms`.\n\t *\n\t * @param {Number} ms\n\t * @return {String}\n\t * @api private\n\t */ function fmtLong(ms) {\n        var msAbs = Math.abs(ms);\n        if (msAbs >= d) {\n            return plural(ms, msAbs, d, \"day\");\n        }\n        if (msAbs >= h) {\n            return plural(ms, msAbs, h, \"hour\");\n        }\n        if (msAbs >= m) {\n            return plural(ms, msAbs, m, \"minute\");\n        }\n        if (msAbs >= s) {\n            return plural(ms, msAbs, s, \"second\");\n        }\n        return ms + \" ms\";\n    }\n    /**\n\t * Pluralization helper.\n\t */ function plural(ms, msAbs, n, name) {\n        var isPlural = msAbs >= n * 1.5;\n        return Math.round(ms / n) + \" \" + name + (isPlural ? \"s\" : \"\");\n    }\n    return ms;\n}\n/*!\n * humanize-ms - index.js\n * Copyright(c) 2014 dead_horse <dead_horse@qq.com>\n * MIT Licensed\n */ var humanizeMs;\nvar hasRequiredHumanizeMs;\nfunction requireHumanizeMs() {\n    if (hasRequiredHumanizeMs) return humanizeMs;\n    hasRequiredHumanizeMs = 1;\n    /**\n\t * Module dependencies.\n\t */ var util = (util__WEBPACK_IMPORTED_MODULE_5___default());\n    var ms = /*@__PURE__*/ requireMs();\n    humanizeMs = function(t) {\n        if (typeof t === \"number\") return t;\n        var r = ms(t);\n        if (r === undefined) {\n            var err = new Error(util.format(\"humanize-ms(%j) result undefined\", t));\n            console.warn(err.stack);\n        }\n        return r;\n    };\n    return humanizeMs;\n}\nvar constants;\nvar hasRequiredConstants;\nfunction requireConstants() {\n    if (hasRequiredConstants) return constants;\n    hasRequiredConstants = 1;\n    constants = {\n        // agent\n        CURRENT_ID: Symbol(\"agentkeepalive#currentId\"),\n        CREATE_ID: Symbol(\"agentkeepalive#createId\"),\n        INIT_SOCKET: Symbol(\"agentkeepalive#initSocket\"),\n        CREATE_HTTPS_CONNECTION: Symbol(\"agentkeepalive#createHttpsConnection\"),\n        // socket\n        SOCKET_CREATED_TIME: Symbol(\"agentkeepalive#socketCreatedTime\"),\n        SOCKET_NAME: Symbol(\"agentkeepalive#socketName\"),\n        SOCKET_REQUEST_COUNT: Symbol(\"agentkeepalive#socketRequestCount\"),\n        SOCKET_REQUEST_FINISHED_COUNT: Symbol(\"agentkeepalive#socketRequestFinishedCount\")\n    };\n    return constants;\n}\nvar agent;\nvar hasRequiredAgent;\nfunction requireAgent() {\n    if (hasRequiredAgent) return agent;\n    hasRequiredAgent = 1;\n    const OriginalAgent = (http__WEBPACK_IMPORTED_MODULE_6___default().Agent);\n    const ms = /*@__PURE__*/ requireHumanizeMs();\n    const debug = util__WEBPACK_IMPORTED_MODULE_5___default().debuglog(\"agentkeepalive\");\n    const { INIT_SOCKET, CURRENT_ID, CREATE_ID, SOCKET_CREATED_TIME, SOCKET_NAME, SOCKET_REQUEST_COUNT, SOCKET_REQUEST_FINISHED_COUNT } = /*@__PURE__*/ requireConstants();\n    // OriginalAgent come from\n    // - https://github.com/nodejs/node/blob/v8.12.0/lib/_http_agent.js\n    // - https://github.com/nodejs/node/blob/v10.12.0/lib/_http_agent.js\n    // node <= 10\n    let defaultTimeoutListenerCount = 1;\n    const majorVersion = parseInt(process.version.split(\".\", 1)[0].substring(1));\n    if (majorVersion >= 11 && majorVersion <= 12) {\n        defaultTimeoutListenerCount = 2;\n    } else if (majorVersion >= 13) {\n        defaultTimeoutListenerCount = 3;\n    }\n    function deprecate(message) {\n        console.log(\"[agentkeepalive:deprecated] %s\", message);\n    }\n    class Agent extends OriginalAgent {\n        constructor(options){\n            options = options || {};\n            options.keepAlive = options.keepAlive !== false;\n            // default is keep-alive and 4s free socket timeout\n            // see https://medium.com/ssense-tech/reduce-networking-errors-in-nodejs-23b4eb9f2d83\n            if (options.freeSocketTimeout === undefined) {\n                options.freeSocketTimeout = 4000;\n            }\n            // Legacy API: keepAliveTimeout should be rename to `freeSocketTimeout`\n            if (options.keepAliveTimeout) {\n                deprecate(\"options.keepAliveTimeout is deprecated, please use options.freeSocketTimeout instead\");\n                options.freeSocketTimeout = options.keepAliveTimeout;\n                delete options.keepAliveTimeout;\n            }\n            // Legacy API: freeSocketKeepAliveTimeout should be rename to `freeSocketTimeout`\n            if (options.freeSocketKeepAliveTimeout) {\n                deprecate(\"options.freeSocketKeepAliveTimeout is deprecated, please use options.freeSocketTimeout instead\");\n                options.freeSocketTimeout = options.freeSocketKeepAliveTimeout;\n                delete options.freeSocketKeepAliveTimeout;\n            }\n            // Sets the socket to timeout after timeout milliseconds of inactivity on the socket.\n            // By default is double free socket timeout.\n            if (options.timeout === undefined) {\n                // make sure socket default inactivity timeout >= 8s\n                options.timeout = Math.max(options.freeSocketTimeout * 2, 8000);\n            }\n            // support humanize format\n            options.timeout = ms(options.timeout);\n            options.freeSocketTimeout = ms(options.freeSocketTimeout);\n            options.socketActiveTTL = options.socketActiveTTL ? ms(options.socketActiveTTL) : 0;\n            super(options);\n            this[CURRENT_ID] = 0;\n            // create socket success counter\n            this.createSocketCount = 0;\n            this.createSocketCountLastCheck = 0;\n            this.createSocketErrorCount = 0;\n            this.createSocketErrorCountLastCheck = 0;\n            this.closeSocketCount = 0;\n            this.closeSocketCountLastCheck = 0;\n            // socket error event count\n            this.errorSocketCount = 0;\n            this.errorSocketCountLastCheck = 0;\n            // request finished counter\n            this.requestCount = 0;\n            this.requestCountLastCheck = 0;\n            // including free socket timeout counter\n            this.timeoutSocketCount = 0;\n            this.timeoutSocketCountLastCheck = 0;\n            this.on(\"free\", (socket)=>{\n                // https://github.com/nodejs/node/pull/32000\n                // Node.js native agent will check socket timeout eqs agent.options.timeout.\n                // Use the ttl or freeSocketTimeout to overwrite.\n                const timeout = this.calcSocketTimeout(socket);\n                if (timeout > 0 && socket.timeout !== timeout) {\n                    socket.setTimeout(timeout);\n                }\n            });\n        }\n        get freeSocketKeepAliveTimeout() {\n            deprecate(\"agent.freeSocketKeepAliveTimeout is deprecated, please use agent.options.freeSocketTimeout instead\");\n            return this.options.freeSocketTimeout;\n        }\n        get timeout() {\n            deprecate(\"agent.timeout is deprecated, please use agent.options.timeout instead\");\n            return this.options.timeout;\n        }\n        get socketActiveTTL() {\n            deprecate(\"agent.socketActiveTTL is deprecated, please use agent.options.socketActiveTTL instead\");\n            return this.options.socketActiveTTL;\n        }\n        calcSocketTimeout(socket) {\n            /**\n\t     * return <= 0: should free socket\n\t     * return > 0: should update socket timeout\n\t     * return undefined: not find custom timeout\n\t     */ let freeSocketTimeout = this.options.freeSocketTimeout;\n            const socketActiveTTL = this.options.socketActiveTTL;\n            if (socketActiveTTL) {\n                // check socketActiveTTL\n                const aliveTime = Date.now() - socket[SOCKET_CREATED_TIME];\n                const diff = socketActiveTTL - aliveTime;\n                if (diff <= 0) {\n                    return diff;\n                }\n                if (freeSocketTimeout && diff < freeSocketTimeout) {\n                    freeSocketTimeout = diff;\n                }\n            }\n            // set freeSocketTimeout\n            if (freeSocketTimeout) {\n                // set free keepalive timer\n                // try to use socket custom freeSocketTimeout first, support headers['keep-alive']\n                // https://github.com/node-modules/urllib/blob/b76053020923f4d99a1c93cf2e16e0c5ba10bacf/lib/urllib.js#L498\n                const customFreeSocketTimeout = socket.freeSocketTimeout || socket.freeSocketKeepAliveTimeout;\n                return customFreeSocketTimeout || freeSocketTimeout;\n            }\n        }\n        keepSocketAlive(socket) {\n            const result = super.keepSocketAlive(socket);\n            // should not keepAlive, do nothing\n            if (!result) return result;\n            const customTimeout = this.calcSocketTimeout(socket);\n            if (typeof customTimeout === \"undefined\") {\n                return true;\n            }\n            if (customTimeout <= 0) {\n                debug(\"%s(requests: %s, finished: %s) free but need to destroy by TTL, request count %s, diff is %s\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], customTimeout);\n                return false;\n            }\n            if (socket.timeout !== customTimeout) {\n                socket.setTimeout(customTimeout);\n            }\n            return true;\n        }\n        // only call on addRequest\n        reuseSocket(...args) {\n            // reuseSocket(socket, req)\n            super.reuseSocket(...args);\n            const socket = args[0];\n            const req = args[1];\n            req.reusedSocket = true;\n            const agentTimeout = this.options.timeout;\n            if (getSocketTimeout(socket) !== agentTimeout) {\n                // reset timeout before use\n                socket.setTimeout(agentTimeout);\n                debug(\"%s reset timeout to %sms\", socket[SOCKET_NAME], agentTimeout);\n            }\n            socket[SOCKET_REQUEST_COUNT]++;\n            debug(\"%s(requests: %s, finished: %s) reuse on addRequest, timeout %sms\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], getSocketTimeout(socket));\n        }\n        [CREATE_ID]() {\n            const id = this[CURRENT_ID]++;\n            if (this[CURRENT_ID] === Number.MAX_SAFE_INTEGER) this[CURRENT_ID] = 0;\n            return id;\n        }\n        [INIT_SOCKET](socket, options) {\n            // bugfix here.\n            // https on node 8, 10 won't set agent.options.timeout by default\n            // TODO: need to fix on node itself\n            if (options.timeout) {\n                const timeout = getSocketTimeout(socket);\n                if (!timeout) {\n                    socket.setTimeout(options.timeout);\n                }\n            }\n            if (this.options.keepAlive) {\n                // Disable Nagle's algorithm: http://blog.caustik.com/2012/04/08/scaling-node-js-to-100k-concurrent-connections/\n                // https://fengmk2.com/benchmark/nagle-algorithm-delayed-ack-mock.html\n                socket.setNoDelay(true);\n            }\n            this.createSocketCount++;\n            if (this.options.socketActiveTTL) {\n                socket[SOCKET_CREATED_TIME] = Date.now();\n            }\n            // don't show the hole '-----BEGIN CERTIFICATE----' key string\n            socket[SOCKET_NAME] = `sock[${this[CREATE_ID]()}#${options._agentKey}]`.split(\"-----BEGIN\", 1)[0];\n            socket[SOCKET_REQUEST_COUNT] = 1;\n            socket[SOCKET_REQUEST_FINISHED_COUNT] = 0;\n            installListeners(this, socket, options);\n        }\n        createConnection(options, oncreate) {\n            let called = false;\n            const onNewCreate = (err, socket)=>{\n                if (called) return;\n                called = true;\n                if (err) {\n                    this.createSocketErrorCount++;\n                    return oncreate(err);\n                }\n                this[INIT_SOCKET](socket, options);\n                oncreate(err, socket);\n            };\n            const newSocket = super.createConnection(options, onNewCreate);\n            if (newSocket) onNewCreate(null, newSocket);\n            return newSocket;\n        }\n        get statusChanged() {\n            const changed = this.createSocketCount !== this.createSocketCountLastCheck || this.createSocketErrorCount !== this.createSocketErrorCountLastCheck || this.closeSocketCount !== this.closeSocketCountLastCheck || this.errorSocketCount !== this.errorSocketCountLastCheck || this.timeoutSocketCount !== this.timeoutSocketCountLastCheck || this.requestCount !== this.requestCountLastCheck;\n            if (changed) {\n                this.createSocketCountLastCheck = this.createSocketCount;\n                this.createSocketErrorCountLastCheck = this.createSocketErrorCount;\n                this.closeSocketCountLastCheck = this.closeSocketCount;\n                this.errorSocketCountLastCheck = this.errorSocketCount;\n                this.timeoutSocketCountLastCheck = this.timeoutSocketCount;\n                this.requestCountLastCheck = this.requestCount;\n            }\n            return changed;\n        }\n        getCurrentStatus() {\n            return {\n                createSocketCount: this.createSocketCount,\n                createSocketErrorCount: this.createSocketErrorCount,\n                closeSocketCount: this.closeSocketCount,\n                errorSocketCount: this.errorSocketCount,\n                timeoutSocketCount: this.timeoutSocketCount,\n                requestCount: this.requestCount,\n                freeSockets: inspect(this.freeSockets),\n                sockets: inspect(this.sockets),\n                requests: inspect(this.requests)\n            };\n        }\n    }\n    // node 8 don't has timeout attribute on socket\n    // https://github.com/nodejs/node/pull/21204/files#diff-e6ef024c3775d787c38487a6309e491dR408\n    function getSocketTimeout(socket) {\n        return socket.timeout || socket._idleTimeout;\n    }\n    function installListeners(agent, socket, options) {\n        debug(\"%s create, timeout %sms\", socket[SOCKET_NAME], getSocketTimeout(socket));\n        // listener socket events: close, timeout, error, free\n        function onFree() {\n            // create and socket.emit('free') logic\n            // https://github.com/nodejs/node/blob/master/lib/_http_agent.js#L311\n            // no req on the socket, it should be the new socket\n            if (!socket._httpMessage && socket[SOCKET_REQUEST_COUNT] === 1) return;\n            socket[SOCKET_REQUEST_FINISHED_COUNT]++;\n            agent.requestCount++;\n            debug(\"%s(requests: %s, finished: %s) free\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);\n            // should reuse on pedding requests?\n            const name = agent.getName(options);\n            if (socket.writable && agent.requests[name] && agent.requests[name].length) {\n                // will be reuse on agent free listener\n                socket[SOCKET_REQUEST_COUNT]++;\n                debug(\"%s(requests: %s, finished: %s) will be reuse on agent free event\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);\n            }\n        }\n        socket.on(\"free\", onFree);\n        function onClose(isError) {\n            debug(\"%s(requests: %s, finished: %s) close, isError: %s\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], isError);\n            agent.closeSocketCount++;\n        }\n        socket.on(\"close\", onClose);\n        // start socket timeout handler\n        function onTimeout() {\n            // onTimeout and emitRequestTimeout(_http_client.js)\n            // https://github.com/nodejs/node/blob/v12.x/lib/_http_client.js#L711\n            const listenerCount = socket.listeners(\"timeout\").length;\n            // node <= 10, default listenerCount is 1, onTimeout\n            // 11 < node <= 12, default listenerCount is 2, onTimeout and emitRequestTimeout\n            // node >= 13, default listenerCount is 3, onTimeout,\n            //   onTimeout(https://github.com/nodejs/node/pull/32000/files#diff-5f7fb0850412c6be189faeddea6c5359R333)\n            //   and emitRequestTimeout\n            const timeout = getSocketTimeout(socket);\n            const req = socket._httpMessage;\n            const reqTimeoutListenerCount = req && req.listeners(\"timeout\").length || 0;\n            debug(\"%s(requests: %s, finished: %s) timeout after %sms, listeners %s, defaultTimeoutListenerCount %s, hasHttpRequest %s, HttpRequest timeoutListenerCount %s\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], timeout, listenerCount, defaultTimeoutListenerCount, !!req, reqTimeoutListenerCount);\n            if (debug.enabled) {\n                debug(\"timeout listeners: %s\", socket.listeners(\"timeout\").map((f)=>f.name).join(\", \"));\n            }\n            agent.timeoutSocketCount++;\n            const name = agent.getName(options);\n            if (agent.freeSockets[name] && agent.freeSockets[name].indexOf(socket) !== -1) {\n                // free socket timeout, destroy quietly\n                socket.destroy();\n                // Remove it from freeSockets list immediately to prevent new requests\n                // from being sent through this socket.\n                agent.removeSocket(socket, options);\n                debug(\"%s is free, destroy quietly\", socket[SOCKET_NAME]);\n            } else {\n                // if there is no any request socket timeout handler,\n                // agent need to handle socket timeout itself.\n                //\n                // custom request socket timeout handle logic must follow these rules:\n                //  1. Destroy socket first\n                //  2. Must emit socket 'agentRemove' event tell agent remove socket\n                //     from freeSockets list immediately.\n                //     Otherise you may be get 'socket hang up' error when reuse\n                //     free socket and timeout happen in the same time.\n                if (reqTimeoutListenerCount === 0) {\n                    const error = new Error(\"Socket timeout\");\n                    error.code = \"ERR_SOCKET_TIMEOUT\";\n                    error.timeout = timeout;\n                    // must manually call socket.end() or socket.destroy() to end the connection.\n                    // https://nodejs.org/dist/latest-v10.x/docs/api/net.html#net_socket_settimeout_timeout_callback\n                    socket.destroy(error);\n                    agent.removeSocket(socket, options);\n                    debug(\"%s destroy with timeout error\", socket[SOCKET_NAME]);\n                }\n            }\n        }\n        socket.on(\"timeout\", onTimeout);\n        function onError(err) {\n            const listenerCount = socket.listeners(\"error\").length;\n            debug(\"%s(requests: %s, finished: %s) error: %s, listenerCount: %s\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], err, listenerCount);\n            agent.errorSocketCount++;\n            if (listenerCount === 1) {\n                // if socket don't contain error event handler, don't catch it, emit it again\n                debug(\"%s emit uncaught error event\", socket[SOCKET_NAME]);\n                socket.removeListener(\"error\", onError);\n                socket.emit(\"error\", err);\n            }\n        }\n        socket.on(\"error\", onError);\n        function onRemove() {\n            debug(\"%s(requests: %s, finished: %s) agentRemove\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);\n            // We need this function for cases like HTTP 'upgrade'\n            // (defined by WebSockets) where we need to remove a socket from the\n            // pool because it'll be locked up indefinitely\n            socket.removeListener(\"close\", onClose);\n            socket.removeListener(\"error\", onError);\n            socket.removeListener(\"free\", onFree);\n            socket.removeListener(\"timeout\", onTimeout);\n            socket.removeListener(\"agentRemove\", onRemove);\n        }\n        socket.on(\"agentRemove\", onRemove);\n    }\n    agent = Agent;\n    function inspect(obj) {\n        const res = {};\n        for(const key in obj){\n            res[key] = obj[key].length;\n        }\n        return res;\n    }\n    return agent;\n}\nvar https_agent;\nvar hasRequiredHttps_agent;\nfunction requireHttps_agent() {\n    if (hasRequiredHttps_agent) return https_agent;\n    hasRequiredHttps_agent = 1;\n    const OriginalHttpsAgent = (https__WEBPACK_IMPORTED_MODULE_7___default().Agent);\n    const HttpAgent = /*@__PURE__*/ requireAgent();\n    const { INIT_SOCKET, CREATE_HTTPS_CONNECTION } = /*@__PURE__*/ requireConstants();\n    class HttpsAgent extends HttpAgent {\n        constructor(options){\n            super(options);\n            this.defaultPort = 443;\n            this.protocol = \"https:\";\n            this.maxCachedSessions = this.options.maxCachedSessions;\n            /* istanbul ignore next */ if (this.maxCachedSessions === undefined) {\n                this.maxCachedSessions = 100;\n            }\n            this._sessionCache = {\n                map: {},\n                list: []\n            };\n        }\n        createConnection(options, oncreate) {\n            const socket = this[CREATE_HTTPS_CONNECTION](options, oncreate);\n            this[INIT_SOCKET](socket, options);\n            return socket;\n        }\n    }\n    // https://github.com/nodejs/node/blob/master/lib/https.js#L89\n    HttpsAgent.prototype[CREATE_HTTPS_CONNECTION] = OriginalHttpsAgent.prototype.createConnection;\n    [\n        \"getName\",\n        \"_getSession\",\n        \"_cacheSession\",\n        // https://github.com/nodejs/node/pull/4982\n        \"_evictSession\"\n    ].forEach(function(method) {\n        /* istanbul ignore next */ if (typeof OriginalHttpsAgent.prototype[method] === \"function\") {\n            HttpsAgent.prototype[method] = OriginalHttpsAgent.prototype[method];\n        }\n    });\n    https_agent = HttpsAgent;\n    return https_agent;\n}\nvar hasRequiredAgentkeepalive;\nfunction requireAgentkeepalive() {\n    if (hasRequiredAgentkeepalive) return agentkeepalive.exports;\n    hasRequiredAgentkeepalive = 1;\n    agentkeepalive.exports = /*@__PURE__*/ requireAgent();\n    agentkeepalive.exports.HttpsAgent = /*@__PURE__*/ requireHttps_agent();\n    agentkeepalive.exports.constants = /*@__PURE__*/ requireConstants();\n    return agentkeepalive.exports;\n}\nvar agentkeepaliveExports = /*@__PURE__*/ requireAgentkeepalive();\nvar HttpKeepAliveAgent = /*@__PURE__*/ getDefaultExportFromCjs(agentkeepaliveExports);\nvar fastStableStringify$1;\nvar hasRequiredFastStableStringify;\nfunction requireFastStableStringify() {\n    if (hasRequiredFastStableStringify) return fastStableStringify$1;\n    hasRequiredFastStableStringify = 1;\n    var objToString = Object.prototype.toString;\n    var objKeys = Object.keys || function(obj) {\n        var keys = [];\n        for(var name in obj){\n            keys.push(name);\n        }\n        return keys;\n    };\n    function stringify(val, isArrayProp) {\n        var i, max, str, keys, key, propVal, toStr;\n        if (val === true) {\n            return \"true\";\n        }\n        if (val === false) {\n            return \"false\";\n        }\n        switch(typeof val){\n            case \"object\":\n                if (val === null) {\n                    return null;\n                } else if (val.toJSON && typeof val.toJSON === \"function\") {\n                    return stringify(val.toJSON(), isArrayProp);\n                } else {\n                    toStr = objToString.call(val);\n                    if (toStr === \"[object Array]\") {\n                        str = \"[\";\n                        max = val.length - 1;\n                        for(i = 0; i < max; i++){\n                            str += stringify(val[i], true) + \",\";\n                        }\n                        if (max > -1) {\n                            str += stringify(val[i], true);\n                        }\n                        return str + \"]\";\n                    } else if (toStr === \"[object Object]\") {\n                        // only object is left\n                        keys = objKeys(val).sort();\n                        max = keys.length;\n                        str = \"\";\n                        i = 0;\n                        while(i < max){\n                            key = keys[i];\n                            propVal = stringify(val[key], false);\n                            if (propVal !== undefined) {\n                                if (str) {\n                                    str += \",\";\n                                }\n                                str += JSON.stringify(key) + \":\" + propVal;\n                            }\n                            i++;\n                        }\n                        return \"{\" + str + \"}\";\n                    } else {\n                        return JSON.stringify(val);\n                    }\n                }\n            case \"function\":\n            case \"undefined\":\n                return isArrayProp ? null : undefined;\n            case \"string\":\n                return JSON.stringify(val);\n            default:\n                return isFinite(val) ? val : null;\n        }\n    }\n    fastStableStringify$1 = function(val) {\n        var returnVal = stringify(val, false);\n        if (returnVal !== undefined) {\n            return \"\" + returnVal;\n        }\n    };\n    return fastStableStringify$1;\n}\nvar fastStableStringifyExports = /*@__PURE__*/ requireFastStableStringify();\nvar fastStableStringify = /*@__PURE__*/ getDefaultExportFromCjs(fastStableStringifyExports);\nconst MINIMUM_SLOT_PER_EPOCH = 32;\n// Returns the number of trailing zeros in the binary representation of self.\nfunction trailingZeros(n) {\n    let trailingZeros = 0;\n    while(n > 1){\n        n /= 2;\n        trailingZeros++;\n    }\n    return trailingZeros;\n}\n// Returns the smallest power of two greater than or equal to n\nfunction nextPowerOfTwo(n) {\n    if (n === 0) return 1;\n    n--;\n    n |= n >> 1;\n    n |= n >> 2;\n    n |= n >> 4;\n    n |= n >> 8;\n    n |= n >> 16;\n    n |= n >> 32;\n    return n + 1;\n}\n/**\n * Epoch schedule\n * (see https://docs.solana.com/terminology#epoch)\n * Can be retrieved with the {@link Connection.getEpochSchedule} method\n */ class EpochSchedule {\n    constructor(slotsPerEpoch, leaderScheduleSlotOffset, warmup, firstNormalEpoch, firstNormalSlot){\n        /** The maximum number of slots in each epoch */ this.slotsPerEpoch = void 0;\n        /** The number of slots before beginning of an epoch to calculate a leader schedule for that epoch */ this.leaderScheduleSlotOffset = void 0;\n        /** Indicates whether epochs start short and grow */ this.warmup = void 0;\n        /** The first epoch with `slotsPerEpoch` slots */ this.firstNormalEpoch = void 0;\n        /** The first slot of `firstNormalEpoch` */ this.firstNormalSlot = void 0;\n        this.slotsPerEpoch = slotsPerEpoch;\n        this.leaderScheduleSlotOffset = leaderScheduleSlotOffset;\n        this.warmup = warmup;\n        this.firstNormalEpoch = firstNormalEpoch;\n        this.firstNormalSlot = firstNormalSlot;\n    }\n    getEpoch(slot) {\n        return this.getEpochAndSlotIndex(slot)[0];\n    }\n    getEpochAndSlotIndex(slot) {\n        if (slot < this.firstNormalSlot) {\n            const epoch = trailingZeros(nextPowerOfTwo(slot + MINIMUM_SLOT_PER_EPOCH + 1)) - trailingZeros(MINIMUM_SLOT_PER_EPOCH) - 1;\n            const epochLen = this.getSlotsInEpoch(epoch);\n            const slotIndex = slot - (epochLen - MINIMUM_SLOT_PER_EPOCH);\n            return [\n                epoch,\n                slotIndex\n            ];\n        } else {\n            const normalSlotIndex = slot - this.firstNormalSlot;\n            const normalEpochIndex = Math.floor(normalSlotIndex / this.slotsPerEpoch);\n            const epoch = this.firstNormalEpoch + normalEpochIndex;\n            const slotIndex = normalSlotIndex % this.slotsPerEpoch;\n            return [\n                epoch,\n                slotIndex\n            ];\n        }\n    }\n    getFirstSlotInEpoch(epoch) {\n        if (epoch <= this.firstNormalEpoch) {\n            return (Math.pow(2, epoch) - 1) * MINIMUM_SLOT_PER_EPOCH;\n        } else {\n            return (epoch - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot;\n        }\n    }\n    getLastSlotInEpoch(epoch) {\n        return this.getFirstSlotInEpoch(epoch) + this.getSlotsInEpoch(epoch) - 1;\n    }\n    getSlotsInEpoch(epoch) {\n        if (epoch < this.firstNormalEpoch) {\n            return Math.pow(2, epoch + trailingZeros(MINIMUM_SLOT_PER_EPOCH));\n        } else {\n            return this.slotsPerEpoch;\n        }\n    }\n}\nvar fetchImpl = typeof globalThis.fetch === \"function\" ? // The Fetch API is supported experimentally in Node 17.5+ and natively in Node 18+.\nglobalThis.fetch : // Otherwise use the polyfill.\nasync function(input, init) {\n    const processedInput = typeof input === \"string\" && input.slice(0, 2) === \"//\" ? \"https:\" + input : input;\n    return await node_fetch__WEBPACK_IMPORTED_MODULE_9__[\"default\"](processedInput, init);\n};\nclass RpcWebSocketClient extends rpc_websockets__WEBPACK_IMPORTED_MODULE_10__.CommonClient {\n    constructor(address, options, generate_request_id){\n        const webSocketFactory = (url)=>{\n            const rpc = (0,rpc_websockets__WEBPACK_IMPORTED_MODULE_10__.WebSocket)(url, {\n                autoconnect: true,\n                max_reconnects: 5,\n                reconnect: true,\n                reconnect_interval: 1000,\n                ...options\n            });\n            if (\"socket\" in rpc) {\n                this.underlyingSocket = rpc.socket;\n            } else {\n                this.underlyingSocket = rpc;\n            }\n            return rpc;\n        };\n        super(webSocketFactory, address, options, generate_request_id);\n        this.underlyingSocket = void 0;\n    }\n    call(...args) {\n        const readyState = this.underlyingSocket?.readyState;\n        if (readyState === 1 /* WebSocket.OPEN */ ) {\n            return super.call(...args);\n        }\n        return Promise.reject(new Error(\"Tried to call a JSON-RPC method `\" + args[0] + \"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was \" + readyState + \")\"));\n    }\n    notify(...args) {\n        const readyState = this.underlyingSocket?.readyState;\n        if (readyState === 1 /* WebSocket.OPEN */ ) {\n            return super.notify(...args);\n        }\n        return Promise.reject(new Error(\"Tried to send a JSON-RPC notification `\" + args[0] + \"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was \" + readyState + \")\"));\n    }\n}\n/**\n * @internal\n */ /**\n * Decode account data buffer using an AccountType\n * @internal\n */ function decodeData(type, data) {\n    let decoded;\n    try {\n        decoded = type.layout.decode(data);\n    } catch (err) {\n        throw new Error(\"invalid instruction; \" + err);\n    }\n    if (decoded.typeIndex !== type.index) {\n        throw new Error(`invalid account data; account type mismatch ${decoded.typeIndex} != ${type.index}`);\n    }\n    return decoded;\n}\n/// The serialized size of lookup table metadata\nconst LOOKUP_TABLE_META_SIZE = 56;\nclass AddressLookupTableAccount {\n    constructor(args){\n        this.key = void 0;\n        this.state = void 0;\n        this.key = args.key;\n        this.state = args.state;\n    }\n    isActive() {\n        const U64_MAX = BigInt(\"0xffffffffffffffff\");\n        return this.state.deactivationSlot === U64_MAX;\n    }\n    static deserialize(accountData) {\n        const meta = decodeData(LookupTableMetaLayout, accountData);\n        const serializedAddressesLen = accountData.length - LOOKUP_TABLE_META_SIZE;\n        assert(serializedAddressesLen >= 0, \"lookup table is invalid\");\n        assert(serializedAddressesLen % 32 === 0, \"lookup table is invalid\");\n        const numSerializedAddresses = serializedAddressesLen / 32;\n        const { addresses } = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(publicKey(), numSerializedAddresses, \"addresses\")\n        ]).decode(accountData.slice(LOOKUP_TABLE_META_SIZE));\n        return {\n            deactivationSlot: meta.deactivationSlot,\n            lastExtendedSlot: meta.lastExtendedSlot,\n            lastExtendedSlotStartIndex: meta.lastExtendedStartIndex,\n            authority: meta.authority.length !== 0 ? new PublicKey(meta.authority[0]) : undefined,\n            addresses: addresses.map((address)=>new PublicKey(address))\n        };\n    }\n}\nconst LookupTableMetaLayout = {\n    index: 1,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"typeIndex\"),\n        u64(\"deactivationSlot\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"lastExtendedSlot\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"lastExtendedStartIndex\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(),\n        // option\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(publicKey(), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(), -1), \"authority\")\n    ])\n};\nconst URL_RE = /^[^:]+:\\/\\/([^:[]+|\\[[^\\]]+\\])(:\\d+)?(.*)/i;\nfunction makeWebsocketUrl(endpoint) {\n    const matches = endpoint.match(URL_RE);\n    if (matches == null) {\n        throw TypeError(`Failed to validate endpoint URL \\`${endpoint}\\``);\n    }\n    const [_, // eslint-disable-line @typescript-eslint/no-unused-vars\n    hostish, portWithColon, rest] = matches;\n    const protocol = endpoint.startsWith(\"https:\") ? \"wss:\" : \"ws:\";\n    const startPort = portWithColon == null ? null : parseInt(portWithColon.slice(1), 10);\n    const websocketPort = // Only shift the port by +1 as a convention for ws(s) only if given endpoint\n    // is explicitly specifying the endpoint port (HTTP-based RPC), assuming\n    // we're directly trying to connect to agave-validator's ws listening port.\n    // When the endpoint omits the port, we're connecting to the protocol\n    // default ports: http(80) or https(443) and it's assumed we're behind a reverse\n    // proxy which manages WebSocket upgrade and backend port redirection.\n    startPort == null ? \"\" : `:${startPort + 1}`;\n    return `${protocol}//${hostish}${websocketPort}${rest}`;\n}\nconst PublicKeyFromString = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.coerce)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.instance)(PublicKey), (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(), (value)=>new PublicKey(value));\nconst RawAccountDataResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.tuple)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"base64\")\n]);\nconst BufferFromRawAccountData = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.coerce)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.instance)(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer), RawAccountDataResult, (value)=>buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value[0], \"base64\"));\n/**\n * Attempt to use a recent blockhash for up to 30 seconds\n * @internal\n */ const BLOCKHASH_CACHE_TIMEOUT_MS = 30 * 1000;\n/**\n * HACK.\n * Copied from rpc-websockets/dist/lib/client.\n * Otherwise, `yarn build` fails with:\n * https://gist.github.com/steveluscher/c057eca81d479ef705cdb53162f9971d\n */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /**\n * @internal\n * Every subscription contains the args used to open the subscription with\n * the server, and a list of callers interested in notifications.\n */ /**\n * @internal\n * A subscription may be in various states of connectedness. Only when it is\n * fully connected will it have a server subscription id associated with it.\n * This id can be returned to the server to unsubscribe the client entirely.\n */ /**\n * A type that encapsulates a subscription's RPC method\n * names and notification (callback) signature.\n */ /**\n * @internal\n * Utility type that keeps tagged unions intact while omitting properties.\n */ /**\n * @internal\n * This type represents a single subscribable 'topic.' It's made up of:\n *\n * - The args used to open the subscription with the server,\n * - The state of the subscription, in terms of its connectedness, and\n * - The set of callbacks to call when the server publishes notifications\n *\n * This record gets indexed by `SubscriptionConfigHash` and is used to\n * set up subscriptions, fan out notifications, and track subscription state.\n */ /**\n * @internal\n */ /**\n * Extra contextual information for RPC responses\n */ /**\n * Options for sending transactions\n */ /**\n * Options for confirming transactions\n */ /**\n * Options for getConfirmedSignaturesForAddress2\n */ /**\n * Options for getSignaturesForAddress\n */ /**\n * RPC Response with extra contextual information\n */ /**\n * A strategy for confirming transactions that uses the last valid\n * block height for a given blockhash to check for transaction expiration.\n */ /**\n * A strategy for confirming durable nonce transactions.\n */ /**\n * Properties shared by all transaction confirmation strategies\n */ /**\n * This type represents all transaction confirmation strategies\n */ /* @internal */ function assertEndpointUrl(putativeUrl) {\n    if (/^https?:/.test(putativeUrl) === false) {\n        throw new TypeError(\"Endpoint URL must start with `http:` or `https:`.\");\n    }\n    return putativeUrl;\n}\n/** @internal */ function extractCommitmentFromConfig(commitmentOrConfig) {\n    let commitment;\n    let config;\n    if (typeof commitmentOrConfig === \"string\") {\n        commitment = commitmentOrConfig;\n    } else if (commitmentOrConfig) {\n        const { commitment: specifiedCommitment, ...specifiedConfig } = commitmentOrConfig;\n        commitment = specifiedCommitment;\n        config = specifiedConfig;\n    }\n    return {\n        commitment,\n        config\n    };\n}\n/**\n * @internal\n */ function applyDefaultMemcmpEncodingToFilters(filters) {\n    return filters.map((filter)=>\"memcmp\" in filter ? {\n            ...filter,\n            memcmp: {\n                ...filter.memcmp,\n                encoding: filter.memcmp.encoding ?? \"base58\"\n            }\n        } : filter);\n}\n/**\n * @internal\n */ function createRpcResult(result) {\n    return (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n            jsonrpc: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"2.0\"),\n            id: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n            result\n        }),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n            jsonrpc: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"2.0\"),\n            id: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n            error: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n                code: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.unknown)(),\n                message: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n                data: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.any)())\n            })\n        })\n    ]);\n}\nconst UnknownRpcResult = createRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.unknown)());\n/**\n * @internal\n */ function jsonRpcResult(schema) {\n    return (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.coerce)(createRpcResult(schema), UnknownRpcResult, (value)=>{\n        if (\"error\" in value) {\n            return value;\n        } else {\n            return {\n                ...value,\n                result: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(value.result, schema)\n            };\n        }\n    });\n}\n/**\n * @internal\n */ function jsonRpcResultAndContext(value) {\n    return jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        context: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n            slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n        }),\n        value\n    }));\n}\n/**\n * @internal\n */ function notificationResultAndContext(value) {\n    return (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        context: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n            slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n        }),\n        value\n    });\n}\n/**\n * @internal\n */ function versionedMessageFromResponse(version, response) {\n    if (version === 0) {\n        return new MessageV0({\n            header: response.header,\n            staticAccountKeys: response.accountKeys.map((accountKey)=>new PublicKey(accountKey)),\n            recentBlockhash: response.recentBlockhash,\n            compiledInstructions: response.instructions.map((ix)=>({\n                    programIdIndex: ix.programIdIndex,\n                    accountKeyIndexes: ix.accounts,\n                    data: bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(ix.data)\n                })),\n            addressTableLookups: response.addressTableLookups\n        });\n    } else {\n        return new Message(response);\n    }\n}\n/**\n * The level of commitment desired when querying state\n * <pre>\n *   'processed': Query the most recent block which has reached 1 confirmation by the connected node\n *   'confirmed': Query the most recent block which has reached 1 confirmation by the cluster\n *   'finalized': Query the most recent block which has been finalized by the cluster\n * </pre>\n */ // Deprecated as of v1.5.5\n/**\n * A subset of Commitment levels, which are at least optimistically confirmed\n * <pre>\n *   'confirmed': Query the most recent block which has reached 1 confirmation by the cluster\n *   'finalized': Query the most recent block which has been finalized by the cluster\n * </pre>\n */ /**\n * Filter for largest accounts query\n * <pre>\n *   'circulating':    Return the largest accounts that are part of the circulating supply\n *   'nonCirculating': Return the largest accounts that are not part of the circulating supply\n * </pre>\n */ /**\n * Configuration object for changing `getAccountInfo` query behavior\n */ /**\n * Configuration object for changing `getBalance` query behavior\n */ /**\n * Configuration object for changing `getBlock` query behavior\n */ /**\n * Configuration object for changing `getBlock` query behavior\n */ /**\n * Configuration object for changing `getStakeMinimumDelegation` query behavior\n */ /**\n * Configuration object for changing `getBlockHeight` query behavior\n */ /**\n * Configuration object for changing `getEpochInfo` query behavior\n */ /**\n * Configuration object for changing `getInflationReward` query behavior\n */ /**\n * Configuration object for changing `getLatestBlockhash` query behavior\n */ /**\n * Configuration object for changing `isBlockhashValid` query behavior\n */ /**\n * Configuration object for changing `getSlot` query behavior\n */ /**\n * Configuration object for changing `getSlotLeader` query behavior\n */ /**\n * Configuration object for changing `getTransaction` query behavior\n */ /**\n * Configuration object for changing `getTransaction` query behavior\n */ /**\n * Configuration object for changing `getLargestAccounts` query behavior\n */ /**\n * Configuration object for changing `getSupply` request behavior\n */ /**\n * Configuration object for changing query behavior\n */ /**\n * Information describing a cluster node\n */ /**\n * Information describing a vote account\n */ /**\n * A collection of cluster vote accounts\n */ /**\n * Network Inflation\n * (see https://docs.solana.com/implemented-proposals/ed_overview)\n */ const GetInflationGovernorResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    foundation: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    foundationTerm: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    initial: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    taper: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    terminal: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\n/**\n * The inflation reward for an epoch\n */ /**\n * Expected JSON RPC response for the \"getInflationReward\" message\n */ const GetInflationRewardResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    epoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    effectiveSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    amount: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    postBalance: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    commission: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()))\n}))));\n/**\n * Configuration object for changing `getRecentPrioritizationFees` query behavior\n */ /**\n * Expected JSON RPC response for the \"getRecentPrioritizationFees\" message\n */ const GetRecentPrioritizationFeesResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    prioritizationFee: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n}));\n/**\n * Expected JSON RPC response for the \"getInflationRate\" message\n */ const GetInflationRateResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    total: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    validator: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    foundation: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    epoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\n/**\n * Information about the current epoch\n */ const GetEpochInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    epoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    slotIndex: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    slotsInEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    absoluteSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    transactionCount: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n});\nconst GetEpochScheduleResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    slotsPerEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    leaderScheduleSlotOffset: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    warmup: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)(),\n    firstNormalEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    firstNormalSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\n/**\n * Leader schedule\n * (see https://docs.solana.com/terminology#leader-schedule)\n */ const GetLeaderScheduleResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.record)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(), (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()));\n/**\n * Transaction error or null\n */ const TransactionErrorResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({}),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()\n]));\n/**\n * Signature status for a transaction\n */ const SignatureStatusResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    err: TransactionErrorResult\n});\n/**\n * Transaction signature received notification\n */ const SignatureReceivedResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"receivedSignature\");\n/**\n * Version info for a node\n */ const VersionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    \"solana-core\": (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    \"feature-set\": (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n});\nconst ParsedInstructionStruct = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    program: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    programId: PublicKeyFromString,\n    parsed: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.unknown)()\n});\nconst PartiallyDecodedInstructionStruct = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    programId: PublicKeyFromString,\n    accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(PublicKeyFromString),\n    data: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()\n});\nconst SimulatedTransactionResponseStruct = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    err: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({}),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()\n    ])),\n    logs: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)())),\n    accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)(),\n        owner: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n        lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        data: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n        rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n    }))))),\n    unitsConsumed: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    returnData: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        programId: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n        data: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.tuple)([\n            (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n            (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"base64\")\n        ])\n    }))),\n    innerInstructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        index: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        instructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n            ParsedInstructionStruct,\n            PartiallyDecodedInstructionStruct\n        ]))\n    }))))\n}));\n/**\n * Metadata for a parsed confirmed transaction on the ledger\n *\n * @deprecated Deprecated since RPC v1.8.0. Please use {@link ParsedTransactionMeta} instead.\n */ /**\n * Collection of addresses loaded by a transaction using address table lookups\n */ /**\n * Metadata for a parsed transaction on the ledger\n */ /**\n * Metadata for a confirmed transaction on the ledger\n */ /**\n * A processed transaction from the RPC API\n */ /**\n * A processed transaction from the RPC API\n */ /**\n * A processed transaction message from the RPC API\n */ /**\n * A confirmed transaction on the ledger\n *\n * @deprecated Deprecated since RPC v1.8.0.\n */ /**\n * A partially decoded transaction instruction\n */ /**\n * A parsed transaction message account\n */ /**\n * A parsed transaction instruction\n */ /**\n * A parsed address table lookup\n */ /**\n * A parsed transaction message\n */ /**\n * A parsed transaction\n */ /**\n * A parsed and confirmed transaction on the ledger\n *\n * @deprecated Deprecated since RPC v1.8.0. Please use {@link ParsedTransactionWithMeta} instead.\n */ /**\n * A parsed transaction on the ledger with meta\n */ /**\n * A processed block fetched from the RPC API\n */ /**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `accounts`\n */ /**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `none`\n */ /**\n * A block with parsed transactions\n */ /**\n * A block with parsed transactions where the `transactionDetails` mode is `accounts`\n */ /**\n * A block with parsed transactions where the `transactionDetails` mode is `none`\n */ /**\n * A processed block fetched from the RPC API\n */ /**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `accounts`\n */ /**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `none`\n */ /**\n * A confirmed block on the ledger\n *\n * @deprecated Deprecated since RPC v1.8.0.\n */ /**\n * A Block on the ledger with signatures only\n */ /**\n * recent block production information\n */ /**\n * Expected JSON RPC response for the \"getBlockProduction\" message\n */ const BlockProductionResponseStruct = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    byIdentity: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.record)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(), (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())),\n    range: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        firstSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        lastSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n    })\n}));\n/**\n * A performance sample\n */ function createRpcClient(url, httpHeaders, customFetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent) {\n    const fetch = customFetch ? customFetch : fetchImpl;\n    let agent;\n    {\n        if (httpAgent == null) {\n            {\n                const agentOptions = {\n                    // One second fewer than the Solana RPC's keepalive timeout.\n                    // Read more: https://github.com/solana-labs/solana/issues/27859#issuecomment-1340097889\n                    freeSocketTimeout: 19000,\n                    keepAlive: true,\n                    maxSockets: 25\n                };\n                if (url.startsWith(\"https:\")) {\n                    agent = new agentkeepaliveExports.HttpsAgent(agentOptions);\n                } else {\n                    agent = new HttpKeepAliveAgent(agentOptions);\n                }\n            }\n        } else {\n            if (httpAgent !== false) {\n                const isHttps = url.startsWith(\"https:\");\n                if (isHttps && !(httpAgent instanceof https__WEBPACK_IMPORTED_MODULE_7__.Agent)) {\n                    throw new Error(\"The endpoint `\" + url + \"` can only be paired with an `https.Agent`. You have, instead, supplied an \" + \"`http.Agent` through `httpAgent`.\");\n                } else if (!isHttps && httpAgent instanceof https__WEBPACK_IMPORTED_MODULE_7__.Agent) {\n                    throw new Error(\"The endpoint `\" + url + \"` can only be paired with an `http.Agent`. You have, instead, supplied an \" + \"`https.Agent` through `httpAgent`.\");\n                }\n                agent = httpAgent;\n            }\n        }\n    }\n    let fetchWithMiddleware;\n    if (fetchMiddleware) {\n        fetchWithMiddleware = async (info, init)=>{\n            const modifiedFetchArgs = await new Promise((resolve, reject)=>{\n                try {\n                    fetchMiddleware(info, init, (modifiedInfo, modifiedInit)=>resolve([\n                            modifiedInfo,\n                            modifiedInit\n                        ]));\n                } catch (error) {\n                    reject(error);\n                }\n            });\n            return await fetch(...modifiedFetchArgs);\n        };\n    }\n    const clientBrowser = new (jayson_lib_client_browser__WEBPACK_IMPORTED_MODULE_8___default())(async (request, callback)=>{\n        const options = {\n            method: \"POST\",\n            body: request,\n            agent,\n            headers: Object.assign({\n                \"Content-Type\": \"application/json\"\n            }, httpHeaders || {}, COMMON_HTTP_HEADERS)\n        };\n        try {\n            let too_many_requests_retries = 5;\n            let res;\n            let waitTime = 500;\n            for(;;){\n                if (fetchWithMiddleware) {\n                    res = await fetchWithMiddleware(url, options);\n                } else {\n                    res = await fetch(url, options);\n                }\n                if (res.status !== 429 /* Too many requests */ ) {\n                    break;\n                }\n                if (disableRetryOnRateLimit === true) {\n                    break;\n                }\n                too_many_requests_retries -= 1;\n                if (too_many_requests_retries === 0) {\n                    break;\n                }\n                console.error(`Server responded with ${res.status} ${res.statusText}.  Retrying after ${waitTime}ms delay...`);\n                await sleep(waitTime);\n                waitTime *= 2;\n            }\n            const text = await res.text();\n            if (res.ok) {\n                callback(null, text);\n            } else {\n                callback(new Error(`${res.status} ${res.statusText}: ${text}`));\n            }\n        } catch (err) {\n            if (err instanceof Error) callback(err);\n        }\n    }, {});\n    return clientBrowser;\n}\nfunction createRpcRequest(client) {\n    return (method, args)=>{\n        return new Promise((resolve, reject)=>{\n            client.request(method, args, (err, response)=>{\n                if (err) {\n                    reject(err);\n                    return;\n                }\n                resolve(response);\n            });\n        });\n    };\n}\nfunction createRpcBatchRequest(client) {\n    return (requests)=>{\n        return new Promise((resolve, reject)=>{\n            // Do nothing if requests is empty\n            if (requests.length === 0) resolve([]);\n            const batch = requests.map((params)=>{\n                return client.request(params.methodName, params.args);\n            });\n            client.request(batch, (err, response)=>{\n                if (err) {\n                    reject(err);\n                    return;\n                }\n                resolve(response);\n            });\n        });\n    };\n}\n/**\n * Expected JSON RPC response for the \"getInflationGovernor\" message\n */ const GetInflationGovernorRpcResult = jsonRpcResult(GetInflationGovernorResult);\n/**\n * Expected JSON RPC response for the \"getInflationRate\" message\n */ const GetInflationRateRpcResult = jsonRpcResult(GetInflationRateResult);\n/**\n * Expected JSON RPC response for the \"getRecentPrioritizationFees\" message\n */ const GetRecentPrioritizationFeesRpcResult = jsonRpcResult(GetRecentPrioritizationFeesResult);\n/**\n * Expected JSON RPC response for the \"getEpochInfo\" message\n */ const GetEpochInfoRpcResult = jsonRpcResult(GetEpochInfoResult);\n/**\n * Expected JSON RPC response for the \"getEpochSchedule\" message\n */ const GetEpochScheduleRpcResult = jsonRpcResult(GetEpochScheduleResult);\n/**\n * Expected JSON RPC response for the \"getLeaderSchedule\" message\n */ const GetLeaderScheduleRpcResult = jsonRpcResult(GetLeaderScheduleResult);\n/**\n * Expected JSON RPC response for the \"minimumLedgerSlot\" and \"getFirstAvailableBlock\" messages\n */ const SlotRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)());\n/**\n * Supply\n */ /**\n * Expected JSON RPC response for the \"getSupply\" message\n */ const GetSupplyRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    total: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    circulating: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    nonCirculating: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    nonCirculatingAccounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(PublicKeyFromString)\n}));\n/**\n * Token amount object which returns a token amount in different formats\n * for various client use cases.\n */ /**\n * Expected JSON RPC structure for token amounts\n */ const TokenAmountResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    amount: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    uiAmount: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    decimals: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    uiAmountString: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)())\n});\n/**\n * Token address and balance.\n */ /**\n * Expected JSON RPC response for the \"getTokenLargestAccounts\" message\n */ const GetTokenLargestAccountsResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    address: PublicKeyFromString,\n    amount: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    uiAmount: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    decimals: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    uiAmountString: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)())\n})));\n/**\n * Expected JSON RPC response for the \"getTokenAccountsByOwner\" message\n */ const GetTokenAccountsByOwner = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    pubkey: PublicKeyFromString,\n    account: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)(),\n        owner: PublicKeyFromString,\n        lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        data: BufferFromRawAccountData,\n        rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n    })\n})));\nconst ParsedAccountDataResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    program: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    parsed: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.unknown)(),\n    space: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\n/**\n * Expected JSON RPC response for the \"getTokenAccountsByOwner\" message with parsed data\n */ const GetParsedTokenAccountsByOwner = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    pubkey: PublicKeyFromString,\n    account: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)(),\n        owner: PublicKeyFromString,\n        lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        data: ParsedAccountDataResult,\n        rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n    })\n})));\n/**\n * Pair of an account address and its balance\n */ /**\n * Expected JSON RPC response for the \"getLargestAccounts\" message\n */ const GetLargestAccountsRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    address: PublicKeyFromString\n})));\n/**\n * @internal\n */ const AccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)(),\n    owner: PublicKeyFromString,\n    lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    data: BufferFromRawAccountData,\n    rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\n/**\n * @internal\n */ const KeyedAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    pubkey: PublicKeyFromString,\n    account: AccountInfoResult\n});\nconst ParsedOrRawAccountData = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.coerce)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.instance)(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer),\n    ParsedAccountDataResult\n]), (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n    RawAccountDataResult,\n    ParsedAccountDataResult\n]), (value)=>{\n    if (Array.isArray(value)) {\n        return (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(value, BufferFromRawAccountData);\n    } else {\n        return value;\n    }\n});\n/**\n * @internal\n */ const ParsedAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)(),\n    owner: PublicKeyFromString,\n    lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    data: ParsedOrRawAccountData,\n    rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\nconst KeyedParsedAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    pubkey: PublicKeyFromString,\n    account: ParsedAccountInfoResult\n});\n/**\n * @internal\n */ const StakeActivationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    state: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"active\"),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"inactive\"),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"activating\"),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"deactivating\")\n    ]),\n    active: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    inactive: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\n/**\n * Expected JSON RPC response for the \"getConfirmedSignaturesForAddress2\" message\n */ const GetConfirmedSignaturesForAddress2RpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    signature: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    err: TransactionErrorResult,\n    memo: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()))\n})));\n/**\n * Expected JSON RPC response for the \"getSignaturesForAddress\" message\n */ const GetSignaturesForAddressRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    signature: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    err: TransactionErrorResult,\n    memo: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()))\n})));\n/***\n * Expected JSON RPC response for the \"accountNotification\" message\n */ const AccountNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    result: notificationResultAndContext(AccountInfoResult)\n});\n/**\n * @internal\n */ const ProgramAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    pubkey: PublicKeyFromString,\n    account: AccountInfoResult\n});\n/***\n * Expected JSON RPC response for the \"programNotification\" message\n */ const ProgramAccountNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    result: notificationResultAndContext(ProgramAccountInfoResult)\n});\n/**\n * @internal\n */ const SlotInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    parent: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    root: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\n/**\n * Expected JSON RPC response for the \"slotNotification\" message\n */ const SlotNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    result: SlotInfoResult\n});\n/**\n * Slot updates which can be used for tracking the live progress of a cluster.\n * - `\"firstShredReceived\"`: connected node received the first shred of a block.\n * Indicates that a new block that is being produced.\n * - `\"completed\"`: connected node has received all shreds of a block. Indicates\n * a block was recently produced.\n * - `\"optimisticConfirmation\"`: block was optimistically confirmed by the\n * cluster. It is not guaranteed that an optimistic confirmation notification\n * will be sent for every finalized blocks.\n * - `\"root\"`: the connected node rooted this block.\n * - `\"createdBank\"`: the connected node has started validating this block.\n * - `\"frozen\"`: the connected node has validated this block.\n * - `\"dead\"`: the connected node failed to validate this block.\n */ /**\n * @internal\n */ const SlotUpdateResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        type: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n            (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"firstShredReceived\"),\n            (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"completed\"),\n            (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"optimisticConfirmation\"),\n            (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"root\")\n        ]),\n        slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        timestamp: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n    }),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        type: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"createdBank\"),\n        parent: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        timestamp: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n    }),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        type: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"frozen\"),\n        slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        timestamp: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        stats: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n            numTransactionEntries: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n            numSuccessfulTransactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n            numFailedTransactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n            maxTransactionsPerEntry: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n        })\n    }),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        type: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"dead\"),\n        slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        timestamp: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        err: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()\n    })\n]);\n/**\n * Expected JSON RPC response for the \"slotsUpdatesNotification\" message\n */ const SlotUpdateNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    result: SlotUpdateResult\n});\n/**\n * Expected JSON RPC response for the \"signatureNotification\" message\n */ const SignatureNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    result: notificationResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n        SignatureStatusResult,\n        SignatureReceivedResult\n    ]))\n});\n/**\n * Expected JSON RPC response for the \"rootNotification\" message\n */ const RootNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    result: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\nconst ContactInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    pubkey: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    gossip: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    tpu: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    rpc: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    version: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)())\n});\nconst VoteAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    votePubkey: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    nodePubkey: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    activatedStake: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    epochVoteAccount: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)(),\n    epochCredits: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.tuple)([\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n    ])),\n    commission: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    lastVote: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    rootSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n});\n/**\n * Expected JSON RPC response for the \"getVoteAccounts\" message\n */ const GetVoteAccounts = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    current: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(VoteAccountInfoResult),\n    delinquent: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(VoteAccountInfoResult)\n}));\nconst ConfirmationStatus = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"processed\"),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"confirmed\"),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"finalized\")\n]);\nconst SignatureStatusResponse = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    confirmations: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    err: TransactionErrorResult,\n    confirmationStatus: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)(ConfirmationStatus)\n});\n/**\n * Expected JSON RPC response for the \"getSignatureStatuses\" message\n */ const GetSignatureStatusesRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(SignatureStatusResponse)));\n/**\n * Expected JSON RPC response for the \"getMinimumBalanceForRentExemption\" message\n */ const GetMinimumBalanceForRentExemptionRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)());\nconst AddressTableLookupStruct = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    accountKey: PublicKeyFromString,\n    writableIndexes: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    readonlyIndexes: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n});\nconst ConfirmedTransactionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    signatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    message: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        accountKeys: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n        header: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n            numRequiredSignatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n            numReadonlySignedAccounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n            numReadonlyUnsignedAccounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n        }),\n        instructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n            accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n            data: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n            programIdIndex: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n        })),\n        recentBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n        addressTableLookups: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(AddressTableLookupStruct))\n    })\n});\nconst AnnotatedAccountKey = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    pubkey: PublicKeyFromString,\n    signer: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)(),\n    writable: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)(),\n    source: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"transaction\"),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"lookupTable\")\n    ]))\n});\nconst ConfirmedTransactionAccountsModeResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    accountKeys: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(AnnotatedAccountKey),\n    signatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)())\n});\nconst ParsedInstructionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    parsed: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.unknown)(),\n    program: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    programId: PublicKeyFromString\n});\nconst RawInstructionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(PublicKeyFromString),\n    data: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    programId: PublicKeyFromString\n});\nconst InstructionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n    RawInstructionResult,\n    ParsedInstructionResult\n]);\nconst UnknownInstructionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        parsed: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.unknown)(),\n        program: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n        programId: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()\n    }),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n        data: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n        programId: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()\n    })\n]);\nconst ParsedOrRawInstruction = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.coerce)(InstructionResult, UnknownInstructionResult, (value)=>{\n    if (\"accounts\" in value) {\n        return (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(value, RawInstructionResult);\n    } else {\n        return (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(value, ParsedInstructionResult);\n    }\n});\n/**\n * @internal\n */ const ParsedConfirmedTransactionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    signatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    message: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        accountKeys: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(AnnotatedAccountKey),\n        instructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(ParsedOrRawInstruction),\n        recentBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n        addressTableLookups: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(AddressTableLookupStruct)))\n    })\n});\nconst TokenBalanceResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    accountIndex: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    mint: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    owner: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    programId: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    uiTokenAmount: TokenAmountResult\n});\nconst LoadedAddressesResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    writable: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(PublicKeyFromString),\n    readonly: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(PublicKeyFromString)\n});\n/**\n * @internal\n */ const ConfirmedTransactionMetaResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    err: TransactionErrorResult,\n    fee: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    innerInstructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        index: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        instructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n            accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n            data: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n            programIdIndex: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n        }))\n    })))),\n    preBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    postBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    logMessages: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()))),\n    preTokenBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(TokenBalanceResult))),\n    postTokenBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(TokenBalanceResult))),\n    loadedAddresses: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)(LoadedAddressesResult),\n    computeUnitsConsumed: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    costUnits: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n});\n/**\n * @internal\n */ const ParsedConfirmedTransactionMetaResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    err: TransactionErrorResult,\n    fee: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    innerInstructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        index: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        instructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(ParsedOrRawInstruction)\n    })))),\n    preBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    postBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    logMessages: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()))),\n    preTokenBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(TokenBalanceResult))),\n    postTokenBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(TokenBalanceResult))),\n    loadedAddresses: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)(LoadedAddressesResult),\n    computeUnitsConsumed: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    costUnits: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n});\nconst TransactionVersionStruct = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(0),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"legacy\")\n]);\n/** @internal */ const RewardsResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    pubkey: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    postBalance: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    rewardType: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    commission: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()))\n});\n/**\n * Expected JSON RPC response for the \"getBlock\" message\n */ const GetBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        transaction: ConfirmedTransactionResult,\n        meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(ConfirmedTransactionMetaResult),\n        version: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)(TransactionVersionStruct)\n    })),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n})));\n/**\n * Expected JSON RPC response for the \"getBlock\" message when `transactionDetails` is `none`\n */ const GetNoneModeBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n})));\n/**\n * Expected JSON RPC response for the \"getBlock\" message when `transactionDetails` is `accounts`\n */ const GetAccountsModeBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        transaction: ConfirmedTransactionAccountsModeResult,\n        meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(ConfirmedTransactionMetaResult),\n        version: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)(TransactionVersionStruct)\n    })),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n})));\n/**\n * Expected parsed JSON RPC response for the \"getBlock\" message\n */ const GetParsedBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        transaction: ParsedConfirmedTransactionResult,\n        meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(ParsedConfirmedTransactionMetaResult),\n        version: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)(TransactionVersionStruct)\n    })),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n})));\n/**\n * Expected parsed JSON RPC response for the \"getBlock\" message  when `transactionDetails` is `accounts`\n */ const GetParsedAccountsModeBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        transaction: ConfirmedTransactionAccountsModeResult,\n        meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(ParsedConfirmedTransactionMetaResult),\n        version: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)(TransactionVersionStruct)\n    })),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n})));\n/**\n * Expected parsed JSON RPC response for the \"getBlock\" message  when `transactionDetails` is `none`\n */ const GetParsedNoneModeBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n})));\n/**\n * Expected JSON RPC response for the \"getConfirmedBlock\" message\n *\n * @deprecated Deprecated since RPC v1.8.0. Please use {@link GetBlockRpcResult} instead.\n */ const GetConfirmedBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        transaction: ConfirmedTransactionResult,\n        meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(ConfirmedTransactionMetaResult)\n    })),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n})));\n/**\n * Expected JSON RPC response for the \"getBlock\" message\n */ const GetBlockSignaturesRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    signatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n})));\n/**\n * Expected JSON RPC response for the \"getTransaction\" message\n */ const GetTransactionRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(ConfirmedTransactionMetaResult),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())),\n    transaction: ConfirmedTransactionResult,\n    version: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)(TransactionVersionStruct)\n})));\n/**\n * Expected parsed JSON RPC response for the \"getTransaction\" message\n */ const GetParsedTransactionRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    transaction: ParsedConfirmedTransactionResult,\n    meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(ParsedConfirmedTransactionMetaResult),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())),\n    version: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)(TransactionVersionStruct)\n})));\n/**\n * Expected JSON RPC response for the \"getLatestBlockhash\" message\n */ const GetLatestBlockhashRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    lastValidBlockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n}));\n/**\n * Expected JSON RPC response for the \"isBlockhashValid\" message\n */ const IsBlockhashValidRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)());\nconst PerfSampleResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    numTransactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    numSlots: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    samplePeriodSecs: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\n/*\n * Expected JSON RPC response for \"getRecentPerformanceSamples\" message\n */ const GetRecentPerformanceSamplesRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(PerfSampleResult));\n/**\n * Expected JSON RPC response for the \"getFeeCalculatorForBlockhash\" message\n */ const GetFeeCalculatorRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    feeCalculator: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        lamportsPerSignature: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n    })\n})));\n/**\n * Expected JSON RPC response for the \"requestAirdrop\" message\n */ const RequestAirdropRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)());\n/**\n * Expected JSON RPC response for the \"sendTransaction\" message\n */ const SendTransactionRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)());\n/**\n * Information about the latest slot being processed by a node\n */ /**\n * Parsed account data\n */ /**\n * Stake Activation data\n */ /**\n * Data slice argument for getProgramAccounts\n */ /**\n * Memory comparison filter for getProgramAccounts\n */ /**\n * Data size comparison filter for getProgramAccounts\n */ /**\n * A filter object for getProgramAccounts\n */ /**\n * Configuration object for getProgramAccounts requests\n */ /**\n * Configuration object for getParsedProgramAccounts\n */ /**\n * Configuration object for getMultipleAccounts\n */ /**\n * Configuration object for `getStakeActivation`\n */ /**\n * Configuration object for `getStakeActivation`\n */ /**\n * Configuration object for `getStakeActivation`\n */ /**\n * Configuration object for `getNonce`\n */ /**\n * Configuration object for `getNonceAndContext`\n */ /**\n * Information describing an account\n */ /**\n * Account information identified by pubkey\n */ /**\n * Callback function for account change notifications\n */ /**\n * Callback function for program account change notifications\n */ /**\n * Callback function for slot change notifications\n */ /**\n * Callback function for slot update notifications\n */ /**\n * Callback function for signature status notifications\n */ /**\n * Signature status notification with transaction result\n */ /**\n * Signature received notification\n */ /**\n * Callback function for signature notifications\n */ /**\n * Signature subscription options\n */ /**\n * Callback function for root change notifications\n */ /**\n * @internal\n */ const LogsResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    err: TransactionErrorResult,\n    logs: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    signature: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()\n});\n/**\n * Logs result.\n */ /**\n * Expected JSON RPC response for the \"logsNotification\" message.\n */ const LogsNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    result: notificationResultAndContext(LogsResult),\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\n/**\n * Filter for log subscriptions.\n */ /**\n * Callback function for log notifications.\n */ /**\n * Signature result\n */ /**\n * Transaction error\n */ /**\n * Transaction confirmation status\n * <pre>\n *   'processed': Transaction landed in a block which has reached 1 confirmation by the connected node\n *   'confirmed': Transaction landed in a block which has reached 1 confirmation by the cluster\n *   'finalized': Transaction landed in a block which has been finalized by the cluster\n * </pre>\n */ /**\n * Signature status\n */ /**\n * A confirmed signature with its status\n */ /**\n * An object defining headers to be passed to the RPC server\n */ /**\n * The type of the JavaScript `fetch()` API\n */ /**\n * A callback used to augment the outgoing HTTP request\n */ /**\n * Configuration for instantiating a Connection\n */ /** @internal */ const COMMON_HTTP_HEADERS = {\n    \"solana-client\": `js/${\"1.0.0-maintenance\"}`\n};\n/**\n * A connection to a fullnode JSON RPC endpoint\n */ class Connection {\n    /**\n   * Establish a JSON RPC connection\n   *\n   * @param endpoint URL to the fullnode JSON RPC endpoint\n   * @param commitmentOrConfig optional default commitment level or optional ConnectionConfig configuration object\n   */ constructor(endpoint, _commitmentOrConfig){\n        /** @internal */ this._commitment = void 0;\n        /** @internal */ this._confirmTransactionInitialTimeout = void 0;\n        /** @internal */ this._rpcEndpoint = void 0;\n        /** @internal */ this._rpcWsEndpoint = void 0;\n        /** @internal */ this._rpcClient = void 0;\n        /** @internal */ this._rpcRequest = void 0;\n        /** @internal */ this._rpcBatchRequest = void 0;\n        /** @internal */ this._rpcWebSocket = void 0;\n        /** @internal */ this._rpcWebSocketConnected = false;\n        /** @internal */ this._rpcWebSocketHeartbeat = null;\n        /** @internal */ this._rpcWebSocketIdleTimeout = null;\n        /** @internal\n     * A number that we increment every time an active connection closes.\n     * Used to determine whether the same socket connection that was open\n     * when an async operation started is the same one that's active when\n     * its continuation fires.\n     *\n     */ this._rpcWebSocketGeneration = 0;\n        /** @internal */ this._disableBlockhashCaching = false;\n        /** @internal */ this._pollingBlockhash = false;\n        /** @internal */ this._blockhashInfo = {\n            latestBlockhash: null,\n            lastFetch: 0,\n            transactionSignatures: [],\n            simulatedSignatures: []\n        };\n        /** @internal */ this._nextClientSubscriptionId = 0;\n        /** @internal */ this._subscriptionDisposeFunctionsByClientSubscriptionId = {};\n        /** @internal */ this._subscriptionHashByClientSubscriptionId = {};\n        /** @internal */ this._subscriptionStateChangeCallbacksByHash = {};\n        /** @internal */ this._subscriptionCallbacksByServerSubscriptionId = {};\n        /** @internal */ this._subscriptionsByHash = {};\n        /**\n     * Special case.\n     * After a signature is processed, RPCs automatically dispose of the\n     * subscription on the server side. We need to track which of these\n     * subscriptions have been disposed in such a way, so that we know\n     * whether the client is dealing with a not-yet-processed signature\n     * (in which case we must tear down the server subscription) or an\n     * already-processed signature (in which case the client can simply\n     * clear out the subscription locally without telling the server).\n     *\n     * NOTE: There is a proposal to eliminate this special case, here:\n     * https://github.com/solana-labs/solana/issues/18892\n     */ /** @internal */ this._subscriptionsAutoDisposedByRpc = new Set();\n        /*\n     * Returns the current block height of the node\n     */ this.getBlockHeight = (()=>{\n            const requestPromises = {};\n            return async (commitmentOrConfig)=>{\n                const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n                const args = this._buildArgs([], commitment, undefined /* encoding */ , config);\n                const requestHash = fastStableStringify(args);\n                requestPromises[requestHash] = requestPromises[requestHash] ?? (async ()=>{\n                    try {\n                        const unsafeRes = await this._rpcRequest(\"getBlockHeight\", args);\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()));\n                        if (\"error\" in res) {\n                            throw new SolanaJSONRPCError(res.error, \"failed to get block height information\");\n                        }\n                        return res.result;\n                    } finally{\n                        delete requestPromises[requestHash];\n                    }\n                })();\n                return await requestPromises[requestHash];\n            };\n        })();\n        let wsEndpoint;\n        let httpHeaders;\n        let fetch;\n        let fetchMiddleware;\n        let disableRetryOnRateLimit;\n        let httpAgent;\n        if (_commitmentOrConfig && typeof _commitmentOrConfig === \"string\") {\n            this._commitment = _commitmentOrConfig;\n        } else if (_commitmentOrConfig) {\n            this._commitment = _commitmentOrConfig.commitment;\n            this._confirmTransactionInitialTimeout = _commitmentOrConfig.confirmTransactionInitialTimeout;\n            wsEndpoint = _commitmentOrConfig.wsEndpoint;\n            httpHeaders = _commitmentOrConfig.httpHeaders;\n            fetch = _commitmentOrConfig.fetch;\n            fetchMiddleware = _commitmentOrConfig.fetchMiddleware;\n            disableRetryOnRateLimit = _commitmentOrConfig.disableRetryOnRateLimit;\n            httpAgent = _commitmentOrConfig.httpAgent;\n        }\n        this._rpcEndpoint = assertEndpointUrl(endpoint);\n        this._rpcWsEndpoint = wsEndpoint || makeWebsocketUrl(endpoint);\n        this._rpcClient = createRpcClient(endpoint, httpHeaders, fetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent);\n        this._rpcRequest = createRpcRequest(this._rpcClient);\n        this._rpcBatchRequest = createRpcBatchRequest(this._rpcClient);\n        this._rpcWebSocket = new RpcWebSocketClient(this._rpcWsEndpoint, {\n            autoconnect: false,\n            max_reconnects: Infinity\n        });\n        this._rpcWebSocket.on(\"open\", this._wsOnOpen.bind(this));\n        this._rpcWebSocket.on(\"error\", this._wsOnError.bind(this));\n        this._rpcWebSocket.on(\"close\", this._wsOnClose.bind(this));\n        this._rpcWebSocket.on(\"accountNotification\", this._wsOnAccountNotification.bind(this));\n        this._rpcWebSocket.on(\"programNotification\", this._wsOnProgramAccountNotification.bind(this));\n        this._rpcWebSocket.on(\"slotNotification\", this._wsOnSlotNotification.bind(this));\n        this._rpcWebSocket.on(\"slotsUpdatesNotification\", this._wsOnSlotUpdatesNotification.bind(this));\n        this._rpcWebSocket.on(\"signatureNotification\", this._wsOnSignatureNotification.bind(this));\n        this._rpcWebSocket.on(\"rootNotification\", this._wsOnRootNotification.bind(this));\n        this._rpcWebSocket.on(\"logsNotification\", this._wsOnLogsNotification.bind(this));\n    }\n    /**\n   * The default commitment used for requests\n   */ get commitment() {\n        return this._commitment;\n    }\n    /**\n   * The RPC endpoint\n   */ get rpcEndpoint() {\n        return this._rpcEndpoint;\n    }\n    /**\n   * Fetch the balance for the specified public key, return with context\n   */ async getBalanceAndContext(publicKey, commitmentOrConfig) {\n        /** @internal */ const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            publicKey.toBase58()\n        ], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getBalance\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get balance for ${publicKey.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the balance for the specified public key\n   */ async getBalance(publicKey, commitmentOrConfig) {\n        return await this.getBalanceAndContext(publicKey, commitmentOrConfig).then((x)=>x.value).catch((e)=>{\n            throw new Error(\"failed to get balance of account \" + publicKey.toBase58() + \": \" + e);\n        });\n    }\n    /**\n   * Fetch the estimated production time of a block\n   */ async getBlockTime(slot) {\n        const unsafeRes = await this._rpcRequest(\"getBlockTime\", [\n            slot\n        ]);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get block time for slot ${slot}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the lowest slot that the node has information about in its ledger.\n   * This value may increase over time if the node is configured to purge older ledger data\n   */ async getMinimumLedgerSlot() {\n        const unsafeRes = await this._rpcRequest(\"minimumLedgerSlot\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get minimum ledger slot\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the slot of the lowest confirmed block that has not been purged from the ledger\n   */ async getFirstAvailableBlock() {\n        const unsafeRes = await this._rpcRequest(\"getFirstAvailableBlock\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, SlotRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get first available block\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch information about the current supply\n   */ async getSupply(config) {\n        let configArg = {};\n        if (typeof config === \"string\") {\n            configArg = {\n                commitment: config\n            };\n        } else if (config) {\n            configArg = {\n                ...config,\n                commitment: config && config.commitment || this.commitment\n            };\n        } else {\n            configArg = {\n                commitment: this.commitment\n            };\n        }\n        const unsafeRes = await this._rpcRequest(\"getSupply\", [\n            configArg\n        ]);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetSupplyRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get supply\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current supply of a token mint\n   */ async getTokenSupply(tokenMintAddress, commitment) {\n        const args = this._buildArgs([\n            tokenMintAddress.toBase58()\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getTokenSupply\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get token supply\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current balance of a token account\n   */ async getTokenAccountBalance(tokenAddress, commitment) {\n        const args = this._buildArgs([\n            tokenAddress.toBase58()\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getTokenAccountBalance\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get token account balance\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch all the token accounts owned by the specified account\n   *\n   * @return {Promise<RpcResponseAndContext<GetProgramAccountsResponse>}\n   */ async getTokenAccountsByOwner(ownerAddress, filter, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        let _args = [\n            ownerAddress.toBase58()\n        ];\n        if (\"mint\" in filter) {\n            _args.push({\n                mint: filter.mint.toBase58()\n            });\n        } else {\n            _args.push({\n                programId: filter.programId.toBase58()\n            });\n        }\n        const args = this._buildArgs(_args, commitment, \"base64\", config);\n        const unsafeRes = await this._rpcRequest(\"getTokenAccountsByOwner\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetTokenAccountsByOwner);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch parsed token accounts owned by the specified account\n   *\n   * @return {Promise<RpcResponseAndContext<Array<{pubkey: PublicKey, account: AccountInfo<ParsedAccountData>}>>>}\n   */ async getParsedTokenAccountsByOwner(ownerAddress, filter, commitment) {\n        let _args = [\n            ownerAddress.toBase58()\n        ];\n        if (\"mint\" in filter) {\n            _args.push({\n                mint: filter.mint.toBase58()\n            });\n        } else {\n            _args.push({\n                programId: filter.programId.toBase58()\n            });\n        }\n        const args = this._buildArgs(_args, commitment, \"jsonParsed\");\n        const unsafeRes = await this._rpcRequest(\"getTokenAccountsByOwner\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetParsedTokenAccountsByOwner);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the 20 largest accounts with their current balances\n   */ async getLargestAccounts(config) {\n        const arg = {\n            ...config,\n            commitment: config && config.commitment || this.commitment\n        };\n        const args = arg.filter || arg.commitment ? [\n            arg\n        ] : [];\n        const unsafeRes = await this._rpcRequest(\"getLargestAccounts\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetLargestAccountsRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get largest accounts\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the 20 largest token accounts with their current balances\n   * for a given mint.\n   */ async getTokenLargestAccounts(mintAddress, commitment) {\n        const args = this._buildArgs([\n            mintAddress.toBase58()\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getTokenLargestAccounts\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetTokenLargestAccountsResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get token largest accounts\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch all the account info for the specified public key, return with context\n   */ async getAccountInfoAndContext(publicKey, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            publicKey.toBase58()\n        ], commitment, \"base64\", config);\n        const unsafeRes = await this._rpcRequest(\"getAccountInfo\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(AccountInfoResult)));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch parsed account info for the specified public key\n   */ async getParsedAccountInfo(publicKey, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            publicKey.toBase58()\n        ], commitment, \"jsonParsed\", config);\n        const unsafeRes = await this._rpcRequest(\"getAccountInfo\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(ParsedAccountInfoResult)));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch all the account info for the specified public key\n   */ async getAccountInfo(publicKey, commitmentOrConfig) {\n        try {\n            const res = await this.getAccountInfoAndContext(publicKey, commitmentOrConfig);\n            return res.value;\n        } catch (e) {\n            throw new Error(\"failed to get info about account \" + publicKey.toBase58() + \": \" + e);\n        }\n    }\n    /**\n   * Fetch all the account info for multiple accounts specified by an array of public keys, return with context\n   */ async getMultipleParsedAccounts(publicKeys, rawConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(rawConfig);\n        const keys = publicKeys.map((key)=>key.toBase58());\n        const args = this._buildArgs([\n            keys\n        ], commitment, \"jsonParsed\", config);\n        const unsafeRes = await this._rpcRequest(\"getMultipleAccounts\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(ParsedAccountInfoResult))));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch all the account info for multiple accounts specified by an array of public keys, return with context\n   */ async getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const keys = publicKeys.map((key)=>key.toBase58());\n        const args = this._buildArgs([\n            keys\n        ], commitment, \"base64\", config);\n        const unsafeRes = await this._rpcRequest(\"getMultipleAccounts\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(AccountInfoResult))));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch all the account info for multiple accounts specified by an array of public keys\n   */ async getMultipleAccountsInfo(publicKeys, commitmentOrConfig) {\n        const res = await this.getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig);\n        return res.value;\n    }\n    /**\n   * Returns epoch activation information for a stake account that has been delegated\n   *\n   * @deprecated Deprecated since RPC v1.18; will be removed in a future version.\n   */ async getStakeActivation(publicKey, commitmentOrConfig, epoch) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            publicKey.toBase58()\n        ], commitment, undefined /* encoding */ , {\n            ...config,\n            epoch: epoch != null ? epoch : config?.epoch\n        });\n        const unsafeRes = await this._rpcRequest(\"getStakeActivation\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult(StakeActivationResult));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get Stake Activation ${publicKey.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch all the accounts owned by the specified program id\n   *\n   * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer>}>>}\n   */ // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    async getProgramAccounts(programId, configOrCommitment) {\n        const { commitment, config } = extractCommitmentFromConfig(configOrCommitment);\n        const { encoding, ...configWithoutEncoding } = config || {};\n        const args = this._buildArgs([\n            programId.toBase58()\n        ], commitment, encoding || \"base64\", {\n            ...configWithoutEncoding,\n            ...configWithoutEncoding.filters ? {\n                filters: applyDefaultMemcmpEncodingToFilters(configWithoutEncoding.filters)\n            } : null\n        });\n        const unsafeRes = await this._rpcRequest(\"getProgramAccounts\", args);\n        const baseSchema = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(KeyedAccountInfoResult);\n        const res = configWithoutEncoding.withContext === true ? (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext(baseSchema)) : (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult(baseSchema));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch and parse all the accounts owned by the specified program id\n   *\n   * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer | ParsedAccountData>}>>}\n   */ async getParsedProgramAccounts(programId, configOrCommitment) {\n        const { commitment, config } = extractCommitmentFromConfig(configOrCommitment);\n        const args = this._buildArgs([\n            programId.toBase58()\n        ], commitment, \"jsonParsed\", config);\n        const unsafeRes = await this._rpcRequest(\"getProgramAccounts\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(KeyedParsedAccountInfoResult)));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);\n        }\n        return res.result;\n    }\n    /** @deprecated Instead, call `confirmTransaction` and pass in {@link TransactionConfirmationStrategy} */ // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    async confirmTransaction(strategy, commitment) {\n        let rawSignature;\n        if (typeof strategy == \"string\") {\n            rawSignature = strategy;\n        } else {\n            const config = strategy;\n            if (config.abortSignal?.aborted) {\n                return Promise.reject(config.abortSignal.reason);\n            }\n            rawSignature = config.signature;\n        }\n        let decodedSignature;\n        try {\n            decodedSignature = bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(rawSignature);\n        } catch (err) {\n            throw new Error(\"signature must be base58 encoded: \" + rawSignature);\n        }\n        assert(decodedSignature.length === 64, \"signature has invalid length\");\n        if (typeof strategy === \"string\") {\n            return await this.confirmTransactionUsingLegacyTimeoutStrategy({\n                commitment: commitment || this.commitment,\n                signature: rawSignature\n            });\n        } else if (\"lastValidBlockHeight\" in strategy) {\n            return await this.confirmTransactionUsingBlockHeightExceedanceStrategy({\n                commitment: commitment || this.commitment,\n                strategy\n            });\n        } else {\n            return await this.confirmTransactionUsingDurableNonceStrategy({\n                commitment: commitment || this.commitment,\n                strategy\n            });\n        }\n    }\n    getCancellationPromise(signal) {\n        return new Promise((_, reject)=>{\n            if (signal == null) {\n                return;\n            }\n            if (signal.aborted) {\n                reject(signal.reason);\n            } else {\n                signal.addEventListener(\"abort\", ()=>{\n                    reject(signal.reason);\n                });\n            }\n        });\n    }\n    getTransactionConfirmationPromise({ commitment, signature }) {\n        let signatureSubscriptionId;\n        let disposeSignatureSubscriptionStateChangeObserver;\n        let done = false;\n        const confirmationPromise = new Promise((resolve, reject)=>{\n            try {\n                signatureSubscriptionId = this.onSignature(signature, (result, context)=>{\n                    signatureSubscriptionId = undefined;\n                    const response = {\n                        context,\n                        value: result\n                    };\n                    resolve({\n                        __type: TransactionStatus.PROCESSED,\n                        response\n                    });\n                }, commitment);\n                const subscriptionSetupPromise = new Promise((resolveSubscriptionSetup)=>{\n                    if (signatureSubscriptionId == null) {\n                        resolveSubscriptionSetup();\n                    } else {\n                        disposeSignatureSubscriptionStateChangeObserver = this._onSubscriptionStateChange(signatureSubscriptionId, (nextState)=>{\n                            if (nextState === \"subscribed\") {\n                                resolveSubscriptionSetup();\n                            }\n                        });\n                    }\n                });\n                (async ()=>{\n                    await subscriptionSetupPromise;\n                    if (done) return;\n                    const response = await this.getSignatureStatus(signature);\n                    if (done) return;\n                    if (response == null) {\n                        return;\n                    }\n                    const { context, value } = response;\n                    if (value == null) {\n                        return;\n                    }\n                    if (value?.err) {\n                        reject(value.err);\n                    } else {\n                        switch(commitment){\n                            case \"confirmed\":\n                            case \"single\":\n                            case \"singleGossip\":\n                                {\n                                    if (value.confirmationStatus === \"processed\") {\n                                        return;\n                                    }\n                                    break;\n                                }\n                            case \"finalized\":\n                            case \"max\":\n                            case \"root\":\n                                {\n                                    if (value.confirmationStatus === \"processed\" || value.confirmationStatus === \"confirmed\") {\n                                        return;\n                                    }\n                                    break;\n                                }\n                            // exhaust enums to ensure full coverage\n                            case \"processed\":\n                            case \"recent\":\n                        }\n                        done = true;\n                        resolve({\n                            __type: TransactionStatus.PROCESSED,\n                            response: {\n                                context,\n                                value\n                            }\n                        });\n                    }\n                })();\n            } catch (err) {\n                reject(err);\n            }\n        });\n        const abortConfirmation = ()=>{\n            if (disposeSignatureSubscriptionStateChangeObserver) {\n                disposeSignatureSubscriptionStateChangeObserver();\n                disposeSignatureSubscriptionStateChangeObserver = undefined;\n            }\n            if (signatureSubscriptionId != null) {\n                this.removeSignatureListener(signatureSubscriptionId);\n                signatureSubscriptionId = undefined;\n            }\n        };\n        return {\n            abortConfirmation,\n            confirmationPromise\n        };\n    }\n    async confirmTransactionUsingBlockHeightExceedanceStrategy({ commitment, strategy: { abortSignal, lastValidBlockHeight, signature } }) {\n        let done = false;\n        const expiryPromise = new Promise((resolve)=>{\n            const checkBlockHeight = async ()=>{\n                try {\n                    const blockHeight = await this.getBlockHeight(commitment);\n                    return blockHeight;\n                } catch (_e) {\n                    return -1;\n                }\n            };\n            (async ()=>{\n                let currentBlockHeight = await checkBlockHeight();\n                if (done) return;\n                while(currentBlockHeight <= lastValidBlockHeight){\n                    await sleep(1000);\n                    if (done) return;\n                    currentBlockHeight = await checkBlockHeight();\n                    if (done) return;\n                }\n                resolve({\n                    __type: TransactionStatus.BLOCKHEIGHT_EXCEEDED\n                });\n            })();\n        });\n        const { abortConfirmation, confirmationPromise } = this.getTransactionConfirmationPromise({\n            commitment,\n            signature\n        });\n        const cancellationPromise = this.getCancellationPromise(abortSignal);\n        let result;\n        try {\n            const outcome = await Promise.race([\n                cancellationPromise,\n                confirmationPromise,\n                expiryPromise\n            ]);\n            if (outcome.__type === TransactionStatus.PROCESSED) {\n                result = outcome.response;\n            } else {\n                throw new TransactionExpiredBlockheightExceededError(signature);\n            }\n        } finally{\n            done = true;\n            abortConfirmation();\n        }\n        return result;\n    }\n    async confirmTransactionUsingDurableNonceStrategy({ commitment, strategy: { abortSignal, minContextSlot, nonceAccountPubkey, nonceValue, signature } }) {\n        let done = false;\n        const expiryPromise = new Promise((resolve)=>{\n            let currentNonceValue = nonceValue;\n            let lastCheckedSlot = null;\n            const getCurrentNonceValue = async ()=>{\n                try {\n                    const { context, value: nonceAccount } = await this.getNonceAndContext(nonceAccountPubkey, {\n                        commitment,\n                        minContextSlot\n                    });\n                    lastCheckedSlot = context.slot;\n                    return nonceAccount?.nonce;\n                } catch (e) {\n                    // If for whatever reason we can't reach/read the nonce\n                    // account, just keep using the last-known value.\n                    return currentNonceValue;\n                }\n            };\n            (async ()=>{\n                currentNonceValue = await getCurrentNonceValue();\n                if (done) return;\n                while(true // eslint-disable-line no-constant-condition\n                ){\n                    if (nonceValue !== currentNonceValue) {\n                        resolve({\n                            __type: TransactionStatus.NONCE_INVALID,\n                            slotInWhichNonceDidAdvance: lastCheckedSlot\n                        });\n                        return;\n                    }\n                    await sleep(2000);\n                    if (done) return;\n                    currentNonceValue = await getCurrentNonceValue();\n                    if (done) return;\n                }\n            })();\n        });\n        const { abortConfirmation, confirmationPromise } = this.getTransactionConfirmationPromise({\n            commitment,\n            signature\n        });\n        const cancellationPromise = this.getCancellationPromise(abortSignal);\n        let result;\n        try {\n            const outcome = await Promise.race([\n                cancellationPromise,\n                confirmationPromise,\n                expiryPromise\n            ]);\n            if (outcome.__type === TransactionStatus.PROCESSED) {\n                result = outcome.response;\n            } else {\n                // Double check that the transaction is indeed unconfirmed.\n                let signatureStatus;\n                while(true // eslint-disable-line no-constant-condition\n                ){\n                    const status = await this.getSignatureStatus(signature);\n                    if (status == null) {\n                        break;\n                    }\n                    if (status.context.slot < (outcome.slotInWhichNonceDidAdvance ?? minContextSlot)) {\n                        await sleep(400);\n                        continue;\n                    }\n                    signatureStatus = status;\n                    break;\n                }\n                if (signatureStatus?.value) {\n                    const commitmentForStatus = commitment || \"finalized\";\n                    const { confirmationStatus } = signatureStatus.value;\n                    switch(commitmentForStatus){\n                        case \"processed\":\n                        case \"recent\":\n                            if (confirmationStatus !== \"processed\" && confirmationStatus !== \"confirmed\" && confirmationStatus !== \"finalized\") {\n                                throw new TransactionExpiredNonceInvalidError(signature);\n                            }\n                            break;\n                        case \"confirmed\":\n                        case \"single\":\n                        case \"singleGossip\":\n                            if (confirmationStatus !== \"confirmed\" && confirmationStatus !== \"finalized\") {\n                                throw new TransactionExpiredNonceInvalidError(signature);\n                            }\n                            break;\n                        case \"finalized\":\n                        case \"max\":\n                        case \"root\":\n                            if (confirmationStatus !== \"finalized\") {\n                                throw new TransactionExpiredNonceInvalidError(signature);\n                            }\n                            break;\n                        default:\n                            // Exhaustive switch.\n                            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                            ((_)=>{})(commitmentForStatus);\n                    }\n                    result = {\n                        context: signatureStatus.context,\n                        value: {\n                            err: signatureStatus.value.err\n                        }\n                    };\n                } else {\n                    throw new TransactionExpiredNonceInvalidError(signature);\n                }\n            }\n        } finally{\n            done = true;\n            abortConfirmation();\n        }\n        return result;\n    }\n    async confirmTransactionUsingLegacyTimeoutStrategy({ commitment, signature }) {\n        let timeoutId;\n        const expiryPromise = new Promise((resolve)=>{\n            let timeoutMs = this._confirmTransactionInitialTimeout || 60 * 1000;\n            switch(commitment){\n                case \"processed\":\n                case \"recent\":\n                case \"single\":\n                case \"confirmed\":\n                case \"singleGossip\":\n                    {\n                        timeoutMs = this._confirmTransactionInitialTimeout || 30 * 1000;\n                        break;\n                    }\n            }\n            timeoutId = setTimeout(()=>resolve({\n                    __type: TransactionStatus.TIMED_OUT,\n                    timeoutMs\n                }), timeoutMs);\n        });\n        const { abortConfirmation, confirmationPromise } = this.getTransactionConfirmationPromise({\n            commitment,\n            signature\n        });\n        let result;\n        try {\n            const outcome = await Promise.race([\n                confirmationPromise,\n                expiryPromise\n            ]);\n            if (outcome.__type === TransactionStatus.PROCESSED) {\n                result = outcome.response;\n            } else {\n                throw new TransactionExpiredTimeoutError(signature, outcome.timeoutMs / 1000);\n            }\n        } finally{\n            clearTimeout(timeoutId);\n            abortConfirmation();\n        }\n        return result;\n    }\n    /**\n   * Return the list of nodes that are currently participating in the cluster\n   */ async getClusterNodes() {\n        const unsafeRes = await this._rpcRequest(\"getClusterNodes\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(ContactInfoResult)));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get cluster nodes\");\n        }\n        return res.result;\n    }\n    /**\n   * Return the list of nodes that are currently participating in the cluster\n   */ async getVoteAccounts(commitment) {\n        const args = this._buildArgs([], commitment);\n        const unsafeRes = await this._rpcRequest(\"getVoteAccounts\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetVoteAccounts);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get vote accounts\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current slot that the node is processing\n   */ async getSlot(commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getSlot\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get slot\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current slot leader of the cluster\n   */ async getSlotLeader(commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getSlotLeader\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get slot leader\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch `limit` number of slot leaders starting from `startSlot`\n   *\n   * @param startSlot fetch slot leaders starting from this slot\n   * @param limit number of slot leaders to return\n   */ async getSlotLeaders(startSlot, limit) {\n        const args = [\n            startSlot,\n            limit\n        ];\n        const unsafeRes = await this._rpcRequest(\"getSlotLeaders\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(PublicKeyFromString)));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get slot leaders\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current status of a signature\n   */ async getSignatureStatus(signature, config) {\n        const { context, value: values } = await this.getSignatureStatuses([\n            signature\n        ], config);\n        assert(values.length === 1);\n        const value = values[0];\n        return {\n            context,\n            value\n        };\n    }\n    /**\n   * Fetch the current statuses of a batch of signatures\n   */ async getSignatureStatuses(signatures, config) {\n        const params = [\n            signatures\n        ];\n        if (config) {\n            params.push(config);\n        }\n        const unsafeRes = await this._rpcRequest(\"getSignatureStatuses\", params);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetSignatureStatusesRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get signature status\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current transaction count of the cluster\n   */ async getTransactionCount(commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getTransactionCount\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get transaction count\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current total currency supply of the cluster in lamports\n   *\n   * @deprecated Deprecated since RPC v1.2.8. Please use {@link getSupply} instead.\n   */ async getTotalSupply(commitment) {\n        const result = await this.getSupply({\n            commitment,\n            excludeNonCirculatingAccountsList: true\n        });\n        return result.value.total;\n    }\n    /**\n   * Fetch the cluster InflationGovernor parameters\n   */ async getInflationGovernor(commitment) {\n        const args = this._buildArgs([], commitment);\n        const unsafeRes = await this._rpcRequest(\"getInflationGovernor\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetInflationGovernorRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get inflation\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the inflation reward for a list of addresses for an epoch\n   */ async getInflationReward(addresses, epoch, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            addresses.map((pubkey)=>pubkey.toBase58())\n        ], commitment, undefined /* encoding */ , {\n            ...config,\n            epoch: epoch != null ? epoch : config?.epoch\n        });\n        const unsafeRes = await this._rpcRequest(\"getInflationReward\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetInflationRewardResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get inflation reward\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the specific inflation values for the current epoch\n   */ async getInflationRate() {\n        const unsafeRes = await this._rpcRequest(\"getInflationRate\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetInflationRateRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get inflation rate\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the Epoch Info parameters\n   */ async getEpochInfo(commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getEpochInfo\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetEpochInfoRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get epoch info\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the Epoch Schedule parameters\n   */ async getEpochSchedule() {\n        const unsafeRes = await this._rpcRequest(\"getEpochSchedule\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetEpochScheduleRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get epoch schedule\");\n        }\n        const epochSchedule = res.result;\n        return new EpochSchedule(epochSchedule.slotsPerEpoch, epochSchedule.leaderScheduleSlotOffset, epochSchedule.warmup, epochSchedule.firstNormalEpoch, epochSchedule.firstNormalSlot);\n    }\n    /**\n   * Fetch the leader schedule for the current epoch\n   * @return {Promise<RpcResponseAndContext<LeaderSchedule>>}\n   */ async getLeaderSchedule() {\n        const unsafeRes = await this._rpcRequest(\"getLeaderSchedule\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetLeaderScheduleRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get leader schedule\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the minimum balance needed to exempt an account of `dataLength`\n   * size from rent\n   */ async getMinimumBalanceForRentExemption(dataLength, commitment) {\n        const args = this._buildArgs([\n            dataLength\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getMinimumBalanceForRentExemption\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetMinimumBalanceForRentExemptionRpcResult);\n        if (\"error\" in res) {\n            console.warn(\"Unable to fetch minimum balance for rent exemption\");\n            return 0;\n        }\n        return res.result;\n    }\n    /**\n   * Fetch a recent blockhash from the cluster, return with context\n   * @return {Promise<RpcResponseAndContext<{blockhash: Blockhash, feeCalculator: FeeCalculator}>>}\n   *\n   * @deprecated Deprecated since RPC v1.9.0. Please use {@link getLatestBlockhash} instead.\n   */ async getRecentBlockhashAndContext(commitment) {\n        const { context, value: { blockhash } } = await this.getLatestBlockhashAndContext(commitment);\n        const feeCalculator = {\n            get lamportsPerSignature () {\n                throw new Error(\"The capability to fetch `lamportsPerSignature` using the `getRecentBlockhash` API is \" + \"no longer offered by the network. Use the `getFeeForMessage` API to obtain the fee \" + \"for a given message.\");\n            },\n            toJSON () {\n                return {};\n            }\n        };\n        return {\n            context,\n            value: {\n                blockhash,\n                feeCalculator\n            }\n        };\n    }\n    /**\n   * Fetch recent performance samples\n   * @return {Promise<Array<PerfSample>>}\n   */ async getRecentPerformanceSamples(limit) {\n        const unsafeRes = await this._rpcRequest(\"getRecentPerformanceSamples\", limit ? [\n            limit\n        ] : []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetRecentPerformanceSamplesRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get recent performance samples\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the fee calculator for a recent blockhash from the cluster, return with context\n   *\n   * @deprecated Deprecated since RPC v1.9.0. Please use {@link getFeeForMessage} instead.\n   */ async getFeeCalculatorForBlockhash(blockhash, commitment) {\n        const args = this._buildArgs([\n            blockhash\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getFeeCalculatorForBlockhash\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetFeeCalculatorRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get fee calculator\");\n        }\n        const { context, value } = res.result;\n        return {\n            context,\n            value: value !== null ? value.feeCalculator : null\n        };\n    }\n    /**\n   * Fetch the fee for a message from the cluster, return with context\n   */ async getFeeForMessage(message, commitment) {\n        const wireMessage = toBuffer(message.serialize()).toString(\"base64\");\n        const args = this._buildArgs([\n            wireMessage\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getFeeForMessage\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get fee for message\");\n        }\n        if (res.result === null) {\n            throw new Error(\"invalid blockhash\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch a list of prioritization fees from recent blocks.\n   */ async getRecentPrioritizationFees(config) {\n        const accounts = config?.lockedWritableAccounts?.map((key)=>key.toBase58());\n        const args = accounts?.length ? [\n            accounts\n        ] : [];\n        const unsafeRes = await this._rpcRequest(\"getRecentPrioritizationFees\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetRecentPrioritizationFeesRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get recent prioritization fees\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch a recent blockhash from the cluster\n   * @return {Promise<{blockhash: Blockhash, feeCalculator: FeeCalculator}>}\n   *\n   * @deprecated Deprecated since RPC v1.8.0. Please use {@link getLatestBlockhash} instead.\n   */ async getRecentBlockhash(commitment) {\n        try {\n            const res = await this.getRecentBlockhashAndContext(commitment);\n            return res.value;\n        } catch (e) {\n            throw new Error(\"failed to get recent blockhash: \" + e);\n        }\n    }\n    /**\n   * Fetch the latest blockhash from the cluster\n   * @return {Promise<BlockhashWithExpiryBlockHeight>}\n   */ async getLatestBlockhash(commitmentOrConfig) {\n        try {\n            const res = await this.getLatestBlockhashAndContext(commitmentOrConfig);\n            return res.value;\n        } catch (e) {\n            throw new Error(\"failed to get recent blockhash: \" + e);\n        }\n    }\n    /**\n   * Fetch the latest blockhash from the cluster\n   * @return {Promise<BlockhashWithExpiryBlockHeight>}\n   */ async getLatestBlockhashAndContext(commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getLatestBlockhash\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetLatestBlockhashRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get latest blockhash\");\n        }\n        return res.result;\n    }\n    /**\n   * Returns whether a blockhash is still valid or not\n   */ async isBlockhashValid(blockhash, rawConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(rawConfig);\n        const args = this._buildArgs([\n            blockhash\n        ], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"isBlockhashValid\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, IsBlockhashValidRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to determine if the blockhash `\" + blockhash + \"`is valid\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the node version\n   */ async getVersion() {\n        const unsafeRes = await this._rpcRequest(\"getVersion\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult(VersionResult));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get version\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the genesis hash\n   */ async getGenesisHash() {\n        const unsafeRes = await this._rpcRequest(\"getGenesisHash\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get genesis hash\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch a processed block from the cluster.\n   *\n   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by\n   * setting the `maxSupportedTransactionVersion` property.\n   */ /**\n   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by\n   * setting the `maxSupportedTransactionVersion` property.\n   */ // eslint-disable-next-line no-dupe-class-members\n    /**\n   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by\n   * setting the `maxSupportedTransactionVersion` property.\n   */ // eslint-disable-next-line no-dupe-class-members\n    /**\n   * Fetch a processed block from the cluster.\n   */ // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    /**\n   * Fetch a processed block from the cluster.\n   */ // eslint-disable-next-line no-dupe-class-members\n    async getBlock(slot, rawConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(rawConfig);\n        const args = this._buildArgsAtLeastConfirmed([\n            slot\n        ], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getBlock\", args);\n        try {\n            switch(config?.transactionDetails){\n                case \"accounts\":\n                    {\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetAccountsModeBlockRpcResult);\n                        if (\"error\" in res) {\n                            throw res.error;\n                        }\n                        return res.result;\n                    }\n                case \"none\":\n                    {\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetNoneModeBlockRpcResult);\n                        if (\"error\" in res) {\n                            throw res.error;\n                        }\n                        return res.result;\n                    }\n                default:\n                    {\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetBlockRpcResult);\n                        if (\"error\" in res) {\n                            throw res.error;\n                        }\n                        const { result } = res;\n                        return result ? {\n                            ...result,\n                            transactions: result.transactions.map(({ transaction, meta, version })=>({\n                                    meta,\n                                    transaction: {\n                                        ...transaction,\n                                        message: versionedMessageFromResponse(version, transaction.message)\n                                    },\n                                    version\n                                }))\n                        } : null;\n                    }\n            }\n        } catch (e) {\n            throw new SolanaJSONRPCError(e, \"failed to get confirmed block\");\n        }\n    }\n    /**\n   * Fetch parsed transaction details for a confirmed or finalized block\n   */ // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    async getParsedBlock(slot, rawConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(rawConfig);\n        const args = this._buildArgsAtLeastConfirmed([\n            slot\n        ], commitment, \"jsonParsed\", config);\n        const unsafeRes = await this._rpcRequest(\"getBlock\", args);\n        try {\n            switch(config?.transactionDetails){\n                case \"accounts\":\n                    {\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetParsedAccountsModeBlockRpcResult);\n                        if (\"error\" in res) {\n                            throw res.error;\n                        }\n                        return res.result;\n                    }\n                case \"none\":\n                    {\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetParsedNoneModeBlockRpcResult);\n                        if (\"error\" in res) {\n                            throw res.error;\n                        }\n                        return res.result;\n                    }\n                default:\n                    {\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetParsedBlockRpcResult);\n                        if (\"error\" in res) {\n                            throw res.error;\n                        }\n                        return res.result;\n                    }\n            }\n        } catch (e) {\n            throw new SolanaJSONRPCError(e, \"failed to get block\");\n        }\n    }\n    /*\n   * Returns recent block production information from the current or previous epoch\n   */ async getBlockProduction(configOrCommitment) {\n        let extra;\n        let commitment;\n        if (typeof configOrCommitment === \"string\") {\n            commitment = configOrCommitment;\n        } else if (configOrCommitment) {\n            const { commitment: c, ...rest } = configOrCommitment;\n            commitment = c;\n            extra = rest;\n        }\n        const args = this._buildArgs([], commitment, \"base64\", extra);\n        const unsafeRes = await this._rpcRequest(\"getBlockProduction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, BlockProductionResponseStruct);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get block production information\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch a confirmed or finalized transaction from the cluster.\n   *\n   * @deprecated Instead, call `getTransaction` using a\n   * `GetVersionedTransactionConfig` by setting the\n   * `maxSupportedTransactionVersion` property.\n   */ /**\n   * Fetch a confirmed or finalized transaction from the cluster.\n   */ // eslint-disable-next-line no-dupe-class-members\n    /**\n   * Fetch a confirmed or finalized transaction from the cluster.\n   */ // eslint-disable-next-line no-dupe-class-members\n    async getTransaction(signature, rawConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(rawConfig);\n        const args = this._buildArgsAtLeastConfirmed([\n            signature\n        ], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getTransaction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetTransactionRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get transaction\");\n        }\n        const result = res.result;\n        if (!result) return result;\n        return {\n            ...result,\n            transaction: {\n                ...result.transaction,\n                message: versionedMessageFromResponse(result.version, result.transaction.message)\n            }\n        };\n    }\n    /**\n   * Fetch parsed transaction details for a confirmed or finalized transaction\n   */ async getParsedTransaction(signature, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgsAtLeastConfirmed([\n            signature\n        ], commitment, \"jsonParsed\", config);\n        const unsafeRes = await this._rpcRequest(\"getTransaction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetParsedTransactionRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get transaction\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch parsed transaction details for a batch of confirmed transactions\n   */ async getParsedTransactions(signatures, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const batch = signatures.map((signature)=>{\n            const args = this._buildArgsAtLeastConfirmed([\n                signature\n            ], commitment, \"jsonParsed\", config);\n            return {\n                methodName: \"getTransaction\",\n                args\n            };\n        });\n        const unsafeRes = await this._rpcBatchRequest(batch);\n        const res = unsafeRes.map((unsafeRes)=>{\n            const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetParsedTransactionRpcResult);\n            if (\"error\" in res) {\n                throw new SolanaJSONRPCError(res.error, \"failed to get transactions\");\n            }\n            return res.result;\n        });\n        return res;\n    }\n    /**\n   * Fetch transaction details for a batch of confirmed transactions.\n   * Similar to {@link getParsedTransactions} but returns a {@link TransactionResponse}.\n   *\n   * @deprecated Instead, call `getTransactions` using a\n   * `GetVersionedTransactionConfig` by setting the\n   * `maxSupportedTransactionVersion` property.\n   */ /**\n   * Fetch transaction details for a batch of confirmed transactions.\n   * Similar to {@link getParsedTransactions} but returns a {@link\n   * VersionedTransactionResponse}.\n   */ // eslint-disable-next-line no-dupe-class-members\n    /**\n   * Fetch transaction details for a batch of confirmed transactions.\n   * Similar to {@link getParsedTransactions} but returns a {@link\n   * VersionedTransactionResponse}.\n   */ // eslint-disable-next-line no-dupe-class-members\n    async getTransactions(signatures, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const batch = signatures.map((signature)=>{\n            const args = this._buildArgsAtLeastConfirmed([\n                signature\n            ], commitment, undefined /* encoding */ , config);\n            return {\n                methodName: \"getTransaction\",\n                args\n            };\n        });\n        const unsafeRes = await this._rpcBatchRequest(batch);\n        const res = unsafeRes.map((unsafeRes)=>{\n            const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetTransactionRpcResult);\n            if (\"error\" in res) {\n                throw new SolanaJSONRPCError(res.error, \"failed to get transactions\");\n            }\n            const result = res.result;\n            if (!result) return result;\n            return {\n                ...result,\n                transaction: {\n                    ...result.transaction,\n                    message: versionedMessageFromResponse(result.version, result.transaction.message)\n                }\n            };\n        });\n        return res;\n    }\n    /**\n   * Fetch a list of Transactions and transaction statuses from the cluster\n   * for a confirmed block.\n   *\n   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getBlock} instead.\n   */ async getConfirmedBlock(slot, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            slot\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getBlock\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetConfirmedBlockRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get confirmed block\");\n        }\n        const result = res.result;\n        if (!result) {\n            throw new Error(\"Confirmed block \" + slot + \" not found\");\n        }\n        const block = {\n            ...result,\n            transactions: result.transactions.map(({ transaction, meta })=>{\n                const message = new Message(transaction.message);\n                return {\n                    meta,\n                    transaction: {\n                        ...transaction,\n                        message\n                    }\n                };\n            })\n        };\n        return {\n            ...block,\n            transactions: block.transactions.map(({ transaction, meta })=>{\n                return {\n                    meta,\n                    transaction: Transaction.populate(transaction.message, transaction.signatures)\n                };\n            })\n        };\n    }\n    /**\n   * Fetch confirmed blocks between two slots\n   */ async getBlocks(startSlot, endSlot, commitment) {\n        const args = this._buildArgsAtLeastConfirmed(endSlot !== undefined ? [\n            startSlot,\n            endSlot\n        ] : [\n            startSlot\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getBlocks\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get blocks\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch a list of Signatures from the cluster for a block, excluding rewards\n   */ async getBlockSignatures(slot, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            slot\n        ], commitment, undefined, {\n            transactionDetails: \"signatures\",\n            rewards: false\n        });\n        const unsafeRes = await this._rpcRequest(\"getBlock\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetBlockSignaturesRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get block\");\n        }\n        const result = res.result;\n        if (!result) {\n            throw new Error(\"Block \" + slot + \" not found\");\n        }\n        return result;\n    }\n    /**\n   * Fetch a list of Signatures from the cluster for a confirmed block, excluding rewards\n   *\n   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getBlockSignatures} instead.\n   */ async getConfirmedBlockSignatures(slot, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            slot\n        ], commitment, undefined, {\n            transactionDetails: \"signatures\",\n            rewards: false\n        });\n        const unsafeRes = await this._rpcRequest(\"getBlock\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetBlockSignaturesRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get confirmed block\");\n        }\n        const result = res.result;\n        if (!result) {\n            throw new Error(\"Confirmed block \" + slot + \" not found\");\n        }\n        return result;\n    }\n    /**\n   * Fetch a transaction details for a confirmed transaction\n   *\n   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getTransaction} instead.\n   */ async getConfirmedTransaction(signature, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            signature\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getTransaction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetTransactionRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get transaction\");\n        }\n        const result = res.result;\n        if (!result) return result;\n        const message = new Message(result.transaction.message);\n        const signatures = result.transaction.signatures;\n        return {\n            ...result,\n            transaction: Transaction.populate(message, signatures)\n        };\n    }\n    /**\n   * Fetch parsed transaction details for a confirmed transaction\n   *\n   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getParsedTransaction} instead.\n   */ async getParsedConfirmedTransaction(signature, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            signature\n        ], commitment, \"jsonParsed\");\n        const unsafeRes = await this._rpcRequest(\"getTransaction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetParsedTransactionRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get confirmed transaction\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch parsed transaction details for a batch of confirmed transactions\n   *\n   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getParsedTransactions} instead.\n   */ async getParsedConfirmedTransactions(signatures, commitment) {\n        const batch = signatures.map((signature)=>{\n            const args = this._buildArgsAtLeastConfirmed([\n                signature\n            ], commitment, \"jsonParsed\");\n            return {\n                methodName: \"getTransaction\",\n                args\n            };\n        });\n        const unsafeRes = await this._rpcBatchRequest(batch);\n        const res = unsafeRes.map((unsafeRes)=>{\n            const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetParsedTransactionRpcResult);\n            if (\"error\" in res) {\n                throw new SolanaJSONRPCError(res.error, \"failed to get confirmed transactions\");\n            }\n            return res.result;\n        });\n        return res;\n    }\n    /**\n   * Fetch a list of all the confirmed signatures for transactions involving an address\n   * within a specified slot range. Max range allowed is 10,000 slots.\n   *\n   * @deprecated Deprecated since RPC v1.3. Please use {@link getConfirmedSignaturesForAddress2} instead.\n   *\n   * @param address queried address\n   * @param startSlot start slot, inclusive\n   * @param endSlot end slot, inclusive\n   */ async getConfirmedSignaturesForAddress(address, startSlot, endSlot) {\n        let options = {};\n        let firstAvailableBlock = await this.getFirstAvailableBlock();\n        while(!(\"until\" in options)){\n            startSlot--;\n            if (startSlot <= 0 || startSlot < firstAvailableBlock) {\n                break;\n            }\n            try {\n                const block = await this.getConfirmedBlockSignatures(startSlot, \"finalized\");\n                if (block.signatures.length > 0) {\n                    options.until = block.signatures[block.signatures.length - 1].toString();\n                }\n            } catch (err) {\n                if (err instanceof Error && err.message.includes(\"skipped\")) {\n                    continue;\n                } else {\n                    throw err;\n                }\n            }\n        }\n        let highestConfirmedRoot = await this.getSlot(\"finalized\");\n        while(!(\"before\" in options)){\n            endSlot++;\n            if (endSlot > highestConfirmedRoot) {\n                break;\n            }\n            try {\n                const block = await this.getConfirmedBlockSignatures(endSlot);\n                if (block.signatures.length > 0) {\n                    options.before = block.signatures[block.signatures.length - 1].toString();\n                }\n            } catch (err) {\n                if (err instanceof Error && err.message.includes(\"skipped\")) {\n                    continue;\n                } else {\n                    throw err;\n                }\n            }\n        }\n        const confirmedSignatureInfo = await this.getConfirmedSignaturesForAddress2(address, options);\n        return confirmedSignatureInfo.map((info)=>info.signature);\n    }\n    /**\n   * Returns confirmed signatures for transactions involving an\n   * address backwards in time from the provided signature or most recent confirmed block\n   *\n   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getSignaturesForAddress} instead.\n   */ async getConfirmedSignaturesForAddress2(address, options, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            address.toBase58()\n        ], commitment, undefined, options);\n        const unsafeRes = await this._rpcRequest(\"getConfirmedSignaturesForAddress2\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetConfirmedSignaturesForAddress2RpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get confirmed signatures for address\");\n        }\n        return res.result;\n    }\n    /**\n   * Returns confirmed signatures for transactions involving an\n   * address backwards in time from the provided signature or most recent confirmed block\n   *\n   *\n   * @param address queried address\n   * @param options\n   */ async getSignaturesForAddress(address, options, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            address.toBase58()\n        ], commitment, undefined, options);\n        const unsafeRes = await this._rpcRequest(\"getSignaturesForAddress\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetSignaturesForAddressRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get signatures for address\");\n        }\n        return res.result;\n    }\n    async getAddressLookupTable(accountKey, config) {\n        const { context, value: accountInfo } = await this.getAccountInfoAndContext(accountKey, config);\n        let value = null;\n        if (accountInfo !== null) {\n            value = new AddressLookupTableAccount({\n                key: accountKey,\n                state: AddressLookupTableAccount.deserialize(accountInfo.data)\n            });\n        }\n        return {\n            context,\n            value\n        };\n    }\n    /**\n   * Fetch the contents of a Nonce account from the cluster, return with context\n   */ async getNonceAndContext(nonceAccount, commitmentOrConfig) {\n        const { context, value: accountInfo } = await this.getAccountInfoAndContext(nonceAccount, commitmentOrConfig);\n        let value = null;\n        if (accountInfo !== null) {\n            value = NonceAccount.fromAccountData(accountInfo.data);\n        }\n        return {\n            context,\n            value\n        };\n    }\n    /**\n   * Fetch the contents of a Nonce account from the cluster\n   */ async getNonce(nonceAccount, commitmentOrConfig) {\n        return await this.getNonceAndContext(nonceAccount, commitmentOrConfig).then((x)=>x.value).catch((e)=>{\n            throw new Error(\"failed to get nonce for account \" + nonceAccount.toBase58() + \": \" + e);\n        });\n    }\n    /**\n   * Request an allocation of lamports to the specified address\n   *\n   * ```typescript\n   * import { Connection, PublicKey, LAMPORTS_PER_SOL } from \"@solana/web3.js\";\n   *\n   * (async () => {\n   *   const connection = new Connection(\"https://api.testnet.solana.com\", \"confirmed\");\n   *   const myAddress = new PublicKey(\"2nr1bHFT86W9tGnyvmYW4vcHKsQB3sVQfnddasz4kExM\");\n   *   const signature = await connection.requestAirdrop(myAddress, LAMPORTS_PER_SOL);\n   *   await connection.confirmTransaction(signature);\n   * })();\n   * ```\n   */ async requestAirdrop(to, lamports) {\n        const unsafeRes = await this._rpcRequest(\"requestAirdrop\", [\n            to.toBase58(),\n            lamports\n        ]);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, RequestAirdropRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `airdrop to ${to.toBase58()} failed`);\n        }\n        return res.result;\n    }\n    /**\n   * @internal\n   */ async _blockhashWithExpiryBlockHeight(disableCache) {\n        if (!disableCache) {\n            // Wait for polling to finish\n            while(this._pollingBlockhash){\n                await sleep(100);\n            }\n            const timeSinceFetch = Date.now() - this._blockhashInfo.lastFetch;\n            const expired = timeSinceFetch >= BLOCKHASH_CACHE_TIMEOUT_MS;\n            if (this._blockhashInfo.latestBlockhash !== null && !expired) {\n                return this._blockhashInfo.latestBlockhash;\n            }\n        }\n        return await this._pollNewBlockhash();\n    }\n    /**\n   * @internal\n   */ async _pollNewBlockhash() {\n        this._pollingBlockhash = true;\n        try {\n            const startTime = Date.now();\n            const cachedLatestBlockhash = this._blockhashInfo.latestBlockhash;\n            const cachedBlockhash = cachedLatestBlockhash ? cachedLatestBlockhash.blockhash : null;\n            for(let i = 0; i < 50; i++){\n                const latestBlockhash = await this.getLatestBlockhash(\"finalized\");\n                if (cachedBlockhash !== latestBlockhash.blockhash) {\n                    this._blockhashInfo = {\n                        latestBlockhash,\n                        lastFetch: Date.now(),\n                        transactionSignatures: [],\n                        simulatedSignatures: []\n                    };\n                    return latestBlockhash;\n                }\n                // Sleep for approximately half a slot\n                await sleep(MS_PER_SLOT / 2);\n            }\n            throw new Error(`Unable to obtain a new blockhash after ${Date.now() - startTime}ms`);\n        } finally{\n            this._pollingBlockhash = false;\n        }\n    }\n    /**\n   * get the stake minimum delegation\n   */ async getStakeMinimumDelegation(config) {\n        const { commitment, config: configArg } = extractCommitmentFromConfig(config);\n        const args = this._buildArgs([], commitment, \"base64\", configArg);\n        const unsafeRes = await this._rpcRequest(\"getStakeMinimumDelegation\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get stake minimum delegation`);\n        }\n        return res.result;\n    }\n    /**\n   * Simulate a transaction\n   *\n   * @deprecated Instead, call {@link simulateTransaction} with {@link\n   * VersionedTransaction} and {@link SimulateTransactionConfig} parameters\n   */ /**\n   * Simulate a transaction\n   */ // eslint-disable-next-line no-dupe-class-members\n    /**\n   * Simulate a transaction\n   */ // eslint-disable-next-line no-dupe-class-members\n    async simulateTransaction(transactionOrMessage, configOrSigners, includeAccounts) {\n        if (\"message\" in transactionOrMessage) {\n            const versionedTx = transactionOrMessage;\n            const wireTransaction = versionedTx.serialize();\n            const encodedTransaction = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(wireTransaction).toString(\"base64\");\n            if (Array.isArray(configOrSigners) || includeAccounts !== undefined) {\n                throw new Error(\"Invalid arguments\");\n            }\n            const config = configOrSigners || {};\n            config.encoding = \"base64\";\n            if (!(\"commitment\" in config)) {\n                config.commitment = this.commitment;\n            }\n            if (configOrSigners && typeof configOrSigners === \"object\" && \"innerInstructions\" in configOrSigners) {\n                config.innerInstructions = configOrSigners.innerInstructions;\n            }\n            const args = [\n                encodedTransaction,\n                config\n            ];\n            const unsafeRes = await this._rpcRequest(\"simulateTransaction\", args);\n            const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, SimulatedTransactionResponseStruct);\n            if (\"error\" in res) {\n                throw new Error(\"failed to simulate transaction: \" + res.error.message);\n            }\n            return res.result;\n        }\n        let transaction;\n        if (transactionOrMessage instanceof Transaction) {\n            let originalTx = transactionOrMessage;\n            transaction = new Transaction();\n            transaction.feePayer = originalTx.feePayer;\n            transaction.instructions = transactionOrMessage.instructions;\n            transaction.nonceInfo = originalTx.nonceInfo;\n            transaction.signatures = originalTx.signatures;\n        } else {\n            transaction = Transaction.populate(transactionOrMessage);\n            // HACK: this function relies on mutating the populated transaction\n            transaction._message = transaction._json = undefined;\n        }\n        if (configOrSigners !== undefined && !Array.isArray(configOrSigners)) {\n            throw new Error(\"Invalid arguments\");\n        }\n        const signers = configOrSigners;\n        if (transaction.nonceInfo && signers) {\n            transaction.sign(...signers);\n        } else {\n            let disableCache = this._disableBlockhashCaching;\n            for(;;){\n                const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);\n                transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;\n                transaction.recentBlockhash = latestBlockhash.blockhash;\n                if (!signers) break;\n                transaction.sign(...signers);\n                if (!transaction.signature) {\n                    throw new Error(\"!signature\"); // should never happen\n                }\n                const signature = transaction.signature.toString(\"base64\");\n                if (!this._blockhashInfo.simulatedSignatures.includes(signature) && !this._blockhashInfo.transactionSignatures.includes(signature)) {\n                    // The signature of this transaction has not been seen before with the\n                    // current recentBlockhash, all done. Let's break\n                    this._blockhashInfo.simulatedSignatures.push(signature);\n                    break;\n                } else {\n                    // This transaction would be treated as duplicate (its derived signature\n                    // matched to one of already recorded signatures).\n                    // So, we must fetch a new blockhash for a different signature by disabling\n                    // our cache not to wait for the cache expiration (BLOCKHASH_CACHE_TIMEOUT_MS).\n                    disableCache = true;\n                }\n            }\n        }\n        const message = transaction._compile();\n        const signData = message.serialize();\n        const wireTransaction = transaction._serialize(signData);\n        const encodedTransaction = wireTransaction.toString(\"base64\");\n        const config = {\n            encoding: \"base64\",\n            commitment: this.commitment\n        };\n        if (includeAccounts) {\n            const addresses = (Array.isArray(includeAccounts) ? includeAccounts : message.nonProgramIds()).map((key)=>key.toBase58());\n            config[\"accounts\"] = {\n                encoding: \"base64\",\n                addresses\n            };\n        }\n        if (signers) {\n            config.sigVerify = true;\n        }\n        if (configOrSigners && typeof configOrSigners === \"object\" && \"innerInstructions\" in configOrSigners) {\n            config.innerInstructions = configOrSigners.innerInstructions;\n        }\n        const args = [\n            encodedTransaction,\n            config\n        ];\n        const unsafeRes = await this._rpcRequest(\"simulateTransaction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, SimulatedTransactionResponseStruct);\n        if (\"error\" in res) {\n            let logs;\n            if (\"data\" in res.error) {\n                logs = res.error.data.logs;\n                if (logs && Array.isArray(logs)) {\n                    const traceIndent = \"\\n    \";\n                    const logTrace = traceIndent + logs.join(traceIndent);\n                    console.error(res.error.message, logTrace);\n                }\n            }\n            throw new SendTransactionError({\n                action: \"simulate\",\n                signature: \"\",\n                transactionMessage: res.error.message,\n                logs: logs\n            });\n        }\n        return res.result;\n    }\n    /**\n   * Sign and send a transaction\n   *\n   * @deprecated Instead, call {@link sendTransaction} with a {@link\n   * VersionedTransaction}\n   */ /**\n   * Send a signed transaction\n   */ // eslint-disable-next-line no-dupe-class-members\n    /**\n   * Sign and send a transaction\n   */ // eslint-disable-next-line no-dupe-class-members\n    async sendTransaction(transaction, signersOrOptions, options) {\n        if (\"version\" in transaction) {\n            if (signersOrOptions && Array.isArray(signersOrOptions)) {\n                throw new Error(\"Invalid arguments\");\n            }\n            const wireTransaction = transaction.serialize();\n            return await this.sendRawTransaction(wireTransaction, signersOrOptions);\n        }\n        if (signersOrOptions === undefined || !Array.isArray(signersOrOptions)) {\n            throw new Error(\"Invalid arguments\");\n        }\n        const signers = signersOrOptions;\n        if (transaction.nonceInfo) {\n            transaction.sign(...signers);\n        } else {\n            let disableCache = this._disableBlockhashCaching;\n            for(;;){\n                const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);\n                transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;\n                transaction.recentBlockhash = latestBlockhash.blockhash;\n                transaction.sign(...signers);\n                if (!transaction.signature) {\n                    throw new Error(\"!signature\"); // should never happen\n                }\n                const signature = transaction.signature.toString(\"base64\");\n                if (!this._blockhashInfo.transactionSignatures.includes(signature)) {\n                    // The signature of this transaction has not been seen before with the\n                    // current recentBlockhash, all done. Let's break\n                    this._blockhashInfo.transactionSignatures.push(signature);\n                    break;\n                } else {\n                    // This transaction would be treated as duplicate (its derived signature\n                    // matched to one of already recorded signatures).\n                    // So, we must fetch a new blockhash for a different signature by disabling\n                    // our cache not to wait for the cache expiration (BLOCKHASH_CACHE_TIMEOUT_MS).\n                    disableCache = true;\n                }\n            }\n        }\n        const wireTransaction = transaction.serialize();\n        return await this.sendRawTransaction(wireTransaction, options);\n    }\n    /**\n   * Send a transaction that has already been signed and serialized into the\n   * wire format\n   */ async sendRawTransaction(rawTransaction, options) {\n        const encodedTransaction = toBuffer(rawTransaction).toString(\"base64\");\n        const result = await this.sendEncodedTransaction(encodedTransaction, options);\n        return result;\n    }\n    /**\n   * Send a transaction that has already been signed, serialized into the\n   * wire format, and encoded as a base64 string\n   */ async sendEncodedTransaction(encodedTransaction, options) {\n        const config = {\n            encoding: \"base64\"\n        };\n        const skipPreflight = options && options.skipPreflight;\n        const preflightCommitment = skipPreflight === true ? \"processed\" // FIXME Remove when https://github.com/anza-xyz/agave/pull/483 is deployed.\n         : options && options.preflightCommitment || this.commitment;\n        if (options && options.maxRetries != null) {\n            config.maxRetries = options.maxRetries;\n        }\n        if (options && options.minContextSlot != null) {\n            config.minContextSlot = options.minContextSlot;\n        }\n        if (skipPreflight) {\n            config.skipPreflight = skipPreflight;\n        }\n        if (preflightCommitment) {\n            config.preflightCommitment = preflightCommitment;\n        }\n        const args = [\n            encodedTransaction,\n            config\n        ];\n        const unsafeRes = await this._rpcRequest(\"sendTransaction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, SendTransactionRpcResult);\n        if (\"error\" in res) {\n            let logs = undefined;\n            if (\"data\" in res.error) {\n                logs = res.error.data.logs;\n            }\n            throw new SendTransactionError({\n                action: skipPreflight ? \"send\" : \"simulate\",\n                signature: \"\",\n                transactionMessage: res.error.message,\n                logs: logs\n            });\n        }\n        return res.result;\n    }\n    /**\n   * @internal\n   */ _wsOnOpen() {\n        this._rpcWebSocketConnected = true;\n        this._rpcWebSocketHeartbeat = setInterval(()=>{\n            // Ping server every 5s to prevent idle timeouts\n            (async ()=>{\n                try {\n                    await this._rpcWebSocket.notify(\"ping\");\n                // eslint-disable-next-line no-empty\n                } catch  {}\n            })();\n        }, 5000);\n        this._updateSubscriptions();\n    }\n    /**\n   * @internal\n   */ _wsOnError(err) {\n        this._rpcWebSocketConnected = false;\n        console.error(\"ws error:\", err.message);\n    }\n    /**\n   * @internal\n   */ _wsOnClose(code) {\n        this._rpcWebSocketConnected = false;\n        this._rpcWebSocketGeneration = (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER;\n        if (this._rpcWebSocketIdleTimeout) {\n            clearTimeout(this._rpcWebSocketIdleTimeout);\n            this._rpcWebSocketIdleTimeout = null;\n        }\n        if (this._rpcWebSocketHeartbeat) {\n            clearInterval(this._rpcWebSocketHeartbeat);\n            this._rpcWebSocketHeartbeat = null;\n        }\n        if (code === 1000) {\n            // explicit close, check if any subscriptions have been made since close\n            this._updateSubscriptions();\n            return;\n        }\n        // implicit close, prepare subscriptions for auto-reconnect\n        this._subscriptionCallbacksByServerSubscriptionId = {};\n        Object.entries(this._subscriptionsByHash).forEach(([hash, subscription])=>{\n            this._setSubscription(hash, {\n                ...subscription,\n                state: \"pending\"\n            });\n        });\n    }\n    /**\n   * @internal\n   */ _setSubscription(hash, nextSubscription) {\n        const prevState = this._subscriptionsByHash[hash]?.state;\n        this._subscriptionsByHash[hash] = nextSubscription;\n        if (prevState !== nextSubscription.state) {\n            const stateChangeCallbacks = this._subscriptionStateChangeCallbacksByHash[hash];\n            if (stateChangeCallbacks) {\n                stateChangeCallbacks.forEach((cb)=>{\n                    try {\n                        cb(nextSubscription.state);\n                    // eslint-disable-next-line no-empty\n                    } catch  {}\n                });\n            }\n        }\n    }\n    /**\n   * @internal\n   */ _onSubscriptionStateChange(clientSubscriptionId, callback) {\n        const hash = this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];\n        if (hash == null) {\n            return ()=>{};\n        }\n        const stateChangeCallbacks = this._subscriptionStateChangeCallbacksByHash[hash] ||= new Set();\n        stateChangeCallbacks.add(callback);\n        return ()=>{\n            stateChangeCallbacks.delete(callback);\n            if (stateChangeCallbacks.size === 0) {\n                delete this._subscriptionStateChangeCallbacksByHash[hash];\n            }\n        };\n    }\n    /**\n   * @internal\n   */ async _updateSubscriptions() {\n        if (Object.keys(this._subscriptionsByHash).length === 0) {\n            if (this._rpcWebSocketConnected) {\n                this._rpcWebSocketConnected = false;\n                this._rpcWebSocketIdleTimeout = setTimeout(()=>{\n                    this._rpcWebSocketIdleTimeout = null;\n                    try {\n                        this._rpcWebSocket.close();\n                    } catch (err) {\n                        // swallow error if socket has already been closed.\n                        if (err instanceof Error) {\n                            console.log(`Error when closing socket connection: ${err.message}`);\n                        }\n                    }\n                }, 500);\n            }\n            return;\n        }\n        if (this._rpcWebSocketIdleTimeout !== null) {\n            clearTimeout(this._rpcWebSocketIdleTimeout);\n            this._rpcWebSocketIdleTimeout = null;\n            this._rpcWebSocketConnected = true;\n        }\n        if (!this._rpcWebSocketConnected) {\n            this._rpcWebSocket.connect();\n            return;\n        }\n        const activeWebSocketGeneration = this._rpcWebSocketGeneration;\n        const isCurrentConnectionStillActive = ()=>{\n            return activeWebSocketGeneration === this._rpcWebSocketGeneration;\n        };\n        await Promise.all(// Don't be tempted to change this to `Object.entries`. We call\n        // `_updateSubscriptions` recursively when processing the state,\n        // so it's important that we look up the *current* version of\n        // each subscription, every time we process a hash.\n        Object.keys(this._subscriptionsByHash).map(async (hash)=>{\n            const subscription = this._subscriptionsByHash[hash];\n            if (subscription === undefined) {\n                // This entry has since been deleted. Skip.\n                return;\n            }\n            switch(subscription.state){\n                case \"pending\":\n                case \"unsubscribed\":\n                    if (subscription.callbacks.size === 0) {\n                        /**\n             * You can end up here when:\n             *\n             * - a subscription has recently unsubscribed\n             *   without having new callbacks added to it\n             *   while the unsubscribe was in flight, or\n             * - when a pending subscription has its\n             *   listeners removed before a request was\n             *   sent to the server.\n             *\n             * Being that nobody is interested in this\n             * subscription any longer, delete it.\n             */ delete this._subscriptionsByHash[hash];\n                        if (subscription.state === \"unsubscribed\") {\n                            delete this._subscriptionCallbacksByServerSubscriptionId[subscription.serverSubscriptionId];\n                        }\n                        await this._updateSubscriptions();\n                        return;\n                    }\n                    await (async ()=>{\n                        const { args, method } = subscription;\n                        try {\n                            this._setSubscription(hash, {\n                                ...subscription,\n                                state: \"subscribing\"\n                            });\n                            const serverSubscriptionId = await this._rpcWebSocket.call(method, args);\n                            this._setSubscription(hash, {\n                                ...subscription,\n                                serverSubscriptionId,\n                                state: \"subscribed\"\n                            });\n                            this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId] = subscription.callbacks;\n                            await this._updateSubscriptions();\n                        } catch (e) {\n                            console.error(`Received ${e instanceof Error ? \"\" : \"JSON-RPC \"}error calling \\`${method}\\``, {\n                                args,\n                                error: e\n                            });\n                            if (!isCurrentConnectionStillActive()) {\n                                return;\n                            }\n                            // TODO: Maybe add an 'errored' state or a retry limit?\n                            this._setSubscription(hash, {\n                                ...subscription,\n                                state: \"pending\"\n                            });\n                            await this._updateSubscriptions();\n                        }\n                    })();\n                    break;\n                case \"subscribed\":\n                    if (subscription.callbacks.size === 0) {\n                        // By the time we successfully set up a subscription\n                        // with the server, the client stopped caring about it.\n                        // Tear it down now.\n                        await (async ()=>{\n                            const { serverSubscriptionId, unsubscribeMethod } = subscription;\n                            if (this._subscriptionsAutoDisposedByRpc.has(serverSubscriptionId)) {\n                                /**\n                 * Special case.\n                 * If we're dealing with a subscription that has been auto-\n                 * disposed by the RPC, then we can skip the RPC call to\n                 * tear down the subscription here.\n                 *\n                 * NOTE: There is a proposal to eliminate this special case, here:\n                 * https://github.com/solana-labs/solana/issues/18892\n                 */ this._subscriptionsAutoDisposedByRpc.delete(serverSubscriptionId);\n                            } else {\n                                this._setSubscription(hash, {\n                                    ...subscription,\n                                    state: \"unsubscribing\"\n                                });\n                                this._setSubscription(hash, {\n                                    ...subscription,\n                                    state: \"unsubscribing\"\n                                });\n                                try {\n                                    await this._rpcWebSocket.call(unsubscribeMethod, [\n                                        serverSubscriptionId\n                                    ]);\n                                } catch (e) {\n                                    if (e instanceof Error) {\n                                        console.error(`${unsubscribeMethod} error:`, e.message);\n                                    }\n                                    if (!isCurrentConnectionStillActive()) {\n                                        return;\n                                    }\n                                    // TODO: Maybe add an 'errored' state or a retry limit?\n                                    this._setSubscription(hash, {\n                                        ...subscription,\n                                        state: \"subscribed\"\n                                    });\n                                    await this._updateSubscriptions();\n                                    return;\n                                }\n                            }\n                            this._setSubscription(hash, {\n                                ...subscription,\n                                state: \"unsubscribed\"\n                            });\n                            await this._updateSubscriptions();\n                        })();\n                    }\n                    break;\n            }\n        }));\n    }\n    /**\n   * @internal\n   */ _handleServerNotification(serverSubscriptionId, callbackArgs) {\n        const callbacks = this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId];\n        if (callbacks === undefined) {\n            return;\n        }\n        callbacks.forEach((cb)=>{\n            try {\n                cb(// I failed to find a way to convince TypeScript that `cb` is of type\n                // `TCallback` which is certainly compatible with `Parameters<TCallback>`.\n                // See https://github.com/microsoft/TypeScript/issues/47615\n                // @ts-ignore\n                ...callbackArgs);\n            } catch (e) {\n                console.error(e);\n            }\n        });\n    }\n    /**\n   * @internal\n   */ _wsOnAccountNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(notification, AccountNotificationResult);\n        this._handleServerNotification(subscription, [\n            result.value,\n            result.context\n        ]);\n    }\n    /**\n   * @internal\n   */ _makeSubscription(subscriptionConfig, /**\n   * When preparing `args` for a call to `_makeSubscription`, be sure\n   * to carefully apply a default `commitment` property, if necessary.\n   *\n   * - If the user supplied a `commitment` use that.\n   * - Otherwise, if the `Connection::commitment` is set, use that.\n   * - Otherwise, set it to the RPC server default: `finalized`.\n   *\n   * This is extremely important to ensure that these two fundamentally\n   * identical subscriptions produce the same identifying hash:\n   *\n   * - A subscription made without specifying a commitment.\n   * - A subscription made where the commitment specified is the same\n   *   as the default applied to the subscription above.\n   *\n   * Example; these two subscriptions must produce the same hash:\n   *\n   * - An `accountSubscribe` subscription for `'PUBKEY'`\n   * - An `accountSubscribe` subscription for `'PUBKEY'` with commitment\n   *   `'finalized'`.\n   *\n   * See the 'making a subscription with defaulted params omitted' test\n   * in `connection-subscriptions.ts` for more.\n   */ args) {\n        const clientSubscriptionId = this._nextClientSubscriptionId++;\n        const hash = fastStableStringify([\n            subscriptionConfig.method,\n            args\n        ]);\n        const existingSubscription = this._subscriptionsByHash[hash];\n        if (existingSubscription === undefined) {\n            this._subscriptionsByHash[hash] = {\n                ...subscriptionConfig,\n                args,\n                callbacks: new Set([\n                    subscriptionConfig.callback\n                ]),\n                state: \"pending\"\n            };\n        } else {\n            existingSubscription.callbacks.add(subscriptionConfig.callback);\n        }\n        this._subscriptionHashByClientSubscriptionId[clientSubscriptionId] = hash;\n        this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId] = async ()=>{\n            delete this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];\n            delete this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];\n            const subscription = this._subscriptionsByHash[hash];\n            assert(subscription !== undefined, `Could not find a \\`Subscription\\` when tearing down client subscription #${clientSubscriptionId}`);\n            subscription.callbacks.delete(subscriptionConfig.callback);\n            await this._updateSubscriptions();\n        };\n        this._updateSubscriptions();\n        return clientSubscriptionId;\n    }\n    /**\n   * Register a callback to be invoked whenever the specified account changes\n   *\n   * @param publicKey Public key of the account to monitor\n   * @param callback Function to invoke whenever the account is changed\n   * @param config\n   * @return subscription id\n   */ /** @deprecated Instead, pass in an {@link AccountSubscriptionConfig} */ // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    onAccountChange(publicKey, callback, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            publicKey.toBase58()\n        ], commitment || this._commitment || \"finalized\", // Apply connection/server default.\n        \"base64\", config);\n        return this._makeSubscription({\n            callback,\n            method: \"accountSubscribe\",\n            unsubscribeMethod: \"accountUnsubscribe\"\n        }, args);\n    }\n    /**\n   * Deregister an account notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */ async removeAccountChangeListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"account change\");\n    }\n    /**\n   * @internal\n   */ _wsOnProgramAccountNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(notification, ProgramAccountNotificationResult);\n        this._handleServerNotification(subscription, [\n            {\n                accountId: result.value.pubkey,\n                accountInfo: result.value.account\n            },\n            result.context\n        ]);\n    }\n    /**\n   * Register a callback to be invoked whenever accounts owned by the\n   * specified program change\n   *\n   * @param programId Public key of the program to monitor\n   * @param callback Function to invoke whenever the account is changed\n   * @param config\n   * @return subscription id\n   */ /** @deprecated Instead, pass in a {@link ProgramAccountSubscriptionConfig} */ // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    onProgramAccountChange(programId, callback, commitmentOrConfig, maybeFilters) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            programId.toBase58()\n        ], commitment || this._commitment || \"finalized\", // Apply connection/server default.\n        \"base64\" /* encoding */ , config ? config : maybeFilters ? {\n            filters: applyDefaultMemcmpEncodingToFilters(maybeFilters)\n        } : undefined /* extra */ );\n        return this._makeSubscription({\n            callback,\n            method: \"programSubscribe\",\n            unsubscribeMethod: \"programUnsubscribe\"\n        }, args);\n    }\n    /**\n   * Deregister an account notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */ async removeProgramAccountChangeListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"program account change\");\n    }\n    /**\n   * Registers a callback to be invoked whenever logs are emitted.\n   */ onLogs(filter, callback, commitment) {\n        const args = this._buildArgs([\n            typeof filter === \"object\" ? {\n                mentions: [\n                    filter.toString()\n                ]\n            } : filter\n        ], commitment || this._commitment || \"finalized\" // Apply connection/server default.\n        );\n        return this._makeSubscription({\n            callback,\n            method: \"logsSubscribe\",\n            unsubscribeMethod: \"logsUnsubscribe\"\n        }, args);\n    }\n    /**\n   * Deregister a logs callback.\n   *\n   * @param clientSubscriptionId client subscription id to deregister.\n   */ async removeOnLogsListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"logs\");\n    }\n    /**\n   * @internal\n   */ _wsOnLogsNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(notification, LogsNotificationResult);\n        this._handleServerNotification(subscription, [\n            result.value,\n            result.context\n        ]);\n    }\n    /**\n   * @internal\n   */ _wsOnSlotNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(notification, SlotNotificationResult);\n        this._handleServerNotification(subscription, [\n            result\n        ]);\n    }\n    /**\n   * Register a callback to be invoked upon slot changes\n   *\n   * @param callback Function to invoke whenever the slot changes\n   * @return subscription id\n   */ onSlotChange(callback) {\n        return this._makeSubscription({\n            callback,\n            method: \"slotSubscribe\",\n            unsubscribeMethod: \"slotUnsubscribe\"\n        }, []);\n    }\n    /**\n   * Deregister a slot notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */ async removeSlotChangeListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"slot change\");\n    }\n    /**\n   * @internal\n   */ _wsOnSlotUpdatesNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(notification, SlotUpdateNotificationResult);\n        this._handleServerNotification(subscription, [\n            result\n        ]);\n    }\n    /**\n   * Register a callback to be invoked upon slot updates. {@link SlotUpdate}'s\n   * may be useful to track live progress of a cluster.\n   *\n   * @param callback Function to invoke whenever the slot updates\n   * @return subscription id\n   */ onSlotUpdate(callback) {\n        return this._makeSubscription({\n            callback,\n            method: \"slotsUpdatesSubscribe\",\n            unsubscribeMethod: \"slotsUpdatesUnsubscribe\"\n        }, []);\n    }\n    /**\n   * Deregister a slot update notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */ async removeSlotUpdateListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"slot update\");\n    }\n    /**\n   * @internal\n   */ async _unsubscribeClientSubscription(clientSubscriptionId, subscriptionName) {\n        const dispose = this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];\n        if (dispose) {\n            await dispose();\n        } else {\n            console.warn(\"Ignored unsubscribe request because an active subscription with id \" + `\\`${clientSubscriptionId}\\` for '${subscriptionName}' events ` + \"could not be found.\");\n        }\n    }\n    _buildArgs(args, override, encoding, extra) {\n        const commitment = override || this._commitment;\n        if (commitment || encoding || extra) {\n            let options = {};\n            if (encoding) {\n                options.encoding = encoding;\n            }\n            if (commitment) {\n                options.commitment = commitment;\n            }\n            if (extra) {\n                options = Object.assign(options, extra);\n            }\n            args.push(options);\n        }\n        return args;\n    }\n    /**\n   * @internal\n   */ _buildArgsAtLeastConfirmed(args, override, encoding, extra) {\n        const commitment = override || this._commitment;\n        if (commitment && ![\n            \"confirmed\",\n            \"finalized\"\n        ].includes(commitment)) {\n            throw new Error(\"Using Connection with default commitment: `\" + this._commitment + \"`, but method requires at least `confirmed`\");\n        }\n        return this._buildArgs(args, override, encoding, extra);\n    }\n    /**\n   * @internal\n   */ _wsOnSignatureNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(notification, SignatureNotificationResult);\n        if (result.value !== \"receivedSignature\") {\n            /**\n       * Special case.\n       * After a signature is processed, RPCs automatically dispose of the\n       * subscription on the server side. We need to track which of these\n       * subscriptions have been disposed in such a way, so that we know\n       * whether the client is dealing with a not-yet-processed signature\n       * (in which case we must tear down the server subscription) or an\n       * already-processed signature (in which case the client can simply\n       * clear out the subscription locally without telling the server).\n       *\n       * NOTE: There is a proposal to eliminate this special case, here:\n       * https://github.com/solana-labs/solana/issues/18892\n       */ this._subscriptionsAutoDisposedByRpc.add(subscription);\n        }\n        this._handleServerNotification(subscription, result.value === \"receivedSignature\" ? [\n            {\n                type: \"received\"\n            },\n            result.context\n        ] : [\n            {\n                type: \"status\",\n                result: result.value\n            },\n            result.context\n        ]);\n    }\n    /**\n   * Register a callback to be invoked upon signature updates\n   *\n   * @param signature Transaction signature string in base 58\n   * @param callback Function to invoke on signature notifications\n   * @param commitment Specify the commitment level signature must reach before notification\n   * @return subscription id\n   */ onSignature(signature, callback, commitment) {\n        const args = this._buildArgs([\n            signature\n        ], commitment || this._commitment || \"finalized\" // Apply connection/server default.\n        );\n        const clientSubscriptionId = this._makeSubscription({\n            callback: (notification, context)=>{\n                if (notification.type === \"status\") {\n                    callback(notification.result, context);\n                    // Signatures subscriptions are auto-removed by the RPC service\n                    // so no need to explicitly send an unsubscribe message.\n                    try {\n                        this.removeSignatureListener(clientSubscriptionId);\n                    // eslint-disable-next-line no-empty\n                    } catch (_err) {\n                    // Already removed.\n                    }\n                }\n            },\n            method: \"signatureSubscribe\",\n            unsubscribeMethod: \"signatureUnsubscribe\"\n        }, args);\n        return clientSubscriptionId;\n    }\n    /**\n   * Register a callback to be invoked when a transaction is\n   * received and/or processed.\n   *\n   * @param signature Transaction signature string in base 58\n   * @param callback Function to invoke on signature notifications\n   * @param options Enable received notifications and set the commitment\n   *   level that signature must reach before notification\n   * @return subscription id\n   */ onSignatureWithOptions(signature, callback, options) {\n        const { commitment, ...extra } = {\n            ...options,\n            commitment: options && options.commitment || this._commitment || \"finalized\" // Apply connection/server default.\n        };\n        const args = this._buildArgs([\n            signature\n        ], commitment, undefined /* encoding */ , extra);\n        const clientSubscriptionId = this._makeSubscription({\n            callback: (notification, context)=>{\n                callback(notification, context);\n                // Signatures subscriptions are auto-removed by the RPC service\n                // so no need to explicitly send an unsubscribe message.\n                try {\n                    this.removeSignatureListener(clientSubscriptionId);\n                // eslint-disable-next-line no-empty\n                } catch (_err) {\n                // Already removed.\n                }\n            },\n            method: \"signatureSubscribe\",\n            unsubscribeMethod: \"signatureUnsubscribe\"\n        }, args);\n        return clientSubscriptionId;\n    }\n    /**\n   * Deregister a signature notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */ async removeSignatureListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"signature result\");\n    }\n    /**\n   * @internal\n   */ _wsOnRootNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(notification, RootNotificationResult);\n        this._handleServerNotification(subscription, [\n            result\n        ]);\n    }\n    /**\n   * Register a callback to be invoked upon root changes\n   *\n   * @param callback Function to invoke whenever the root changes\n   * @return subscription id\n   */ onRootChange(callback) {\n        return this._makeSubscription({\n            callback,\n            method: \"rootSubscribe\",\n            unsubscribeMethod: \"rootUnsubscribe\"\n        }, []);\n    }\n    /**\n   * Deregister a root notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */ async removeRootChangeListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"root change\");\n    }\n}\n/**\n * Keypair signer interface\n */ /**\n * An account keypair used for signing transactions.\n */ class Keypair {\n    /**\n   * Create a new keypair instance.\n   * Generate random keypair if no {@link Ed25519Keypair} is provided.\n   *\n   * @param {Ed25519Keypair} keypair ed25519 keypair\n   */ constructor(keypair){\n        this._keypair = void 0;\n        this._keypair = keypair ?? generateKeypair();\n    }\n    /**\n   * Generate a new random keypair\n   *\n   * @returns {Keypair} Keypair\n   */ static generate() {\n        return new Keypair(generateKeypair());\n    }\n    /**\n   * Create a keypair from a raw secret key byte array.\n   *\n   * This method should only be used to recreate a keypair from a previously\n   * generated secret key. Generating keypairs from a random seed should be done\n   * with the {@link Keypair.fromSeed} method.\n   *\n   * @throws error if the provided secret key is invalid and validation is not skipped.\n   *\n   * @param secretKey secret key byte array\n   * @param options skip secret key validation\n   *\n   * @returns {Keypair} Keypair\n   */ static fromSecretKey(secretKey, options) {\n        if (secretKey.byteLength !== 64) {\n            throw new Error(\"bad secret key size\");\n        }\n        const publicKey = secretKey.slice(32, 64);\n        if (!options || !options.skipValidation) {\n            const privateScalar = secretKey.slice(0, 32);\n            const computedPublicKey = getPublicKey(privateScalar);\n            for(let ii = 0; ii < 32; ii++){\n                if (publicKey[ii] !== computedPublicKey[ii]) {\n                    throw new Error(\"provided secretKey is invalid\");\n                }\n            }\n        }\n        return new Keypair({\n            publicKey,\n            secretKey\n        });\n    }\n    /**\n   * Generate a keypair from a 32 byte seed.\n   *\n   * @param seed seed byte array\n   *\n   * @returns {Keypair} Keypair\n   */ static fromSeed(seed) {\n        const publicKey = getPublicKey(seed);\n        const secretKey = new Uint8Array(64);\n        secretKey.set(seed);\n        secretKey.set(publicKey, 32);\n        return new Keypair({\n            publicKey,\n            secretKey\n        });\n    }\n    /**\n   * The public key for this keypair\n   *\n   * @returns {PublicKey} PublicKey\n   */ get publicKey() {\n        return new PublicKey(this._keypair.publicKey);\n    }\n    /**\n   * The raw secret key for this keypair\n   * @returns {Uint8Array} Secret key in an array of Uint8 bytes\n   */ get secretKey() {\n        return new Uint8Array(this._keypair.secretKey);\n    }\n}\n/**\n * An enumeration of valid LookupTableInstructionType's\n */ /**\n * An enumeration of valid address lookup table InstructionType's\n * @internal\n */ const LOOKUP_TABLE_INSTRUCTION_LAYOUTS = Object.freeze({\n    CreateLookupTable: {\n        index: 0,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            u64(\"recentSlot\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"bumpSeed\")\n        ])\n    },\n    FreezeLookupTable: {\n        index: 1,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    ExtendLookupTable: {\n        index: 2,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            u64(),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(publicKey(), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(), -8), \"addresses\")\n        ])\n    },\n    DeactivateLookupTable: {\n        index: 3,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    CloseLookupTable: {\n        index: 4,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    }\n});\nclass AddressLookupTableInstruction {\n    /**\n   * @internal\n   */ constructor(){}\n    static decodeInstructionType(instruction) {\n        this.checkProgramId(instruction.programId);\n        const instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\");\n        const index = instructionTypeLayout.decode(instruction.data);\n        let type;\n        for (const [layoutType, layout] of Object.entries(LOOKUP_TABLE_INSTRUCTION_LAYOUTS)){\n            if (layout.index == index) {\n                type = layoutType;\n                break;\n            }\n        }\n        if (!type) {\n            throw new Error(\"Invalid Instruction. Should be a LookupTable Instruction\");\n        }\n        return type;\n    }\n    static decodeCreateLookupTable(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeysLength(instruction.keys, 4);\n        const { recentSlot } = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable, instruction.data);\n        return {\n            authority: instruction.keys[1].pubkey,\n            payer: instruction.keys[2].pubkey,\n            recentSlot: Number(recentSlot)\n        };\n    }\n    static decodeExtendLookupTable(instruction) {\n        this.checkProgramId(instruction.programId);\n        if (instruction.keys.length < 2) {\n            throw new Error(`invalid instruction; found ${instruction.keys.length} keys, expected at least 2`);\n        }\n        const { addresses } = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable, instruction.data);\n        return {\n            lookupTable: instruction.keys[0].pubkey,\n            authority: instruction.keys[1].pubkey,\n            payer: instruction.keys.length > 2 ? instruction.keys[2].pubkey : undefined,\n            addresses: addresses.map((buffer)=>new PublicKey(buffer))\n        };\n    }\n    static decodeCloseLookupTable(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeysLength(instruction.keys, 3);\n        return {\n            lookupTable: instruction.keys[0].pubkey,\n            authority: instruction.keys[1].pubkey,\n            recipient: instruction.keys[2].pubkey\n        };\n    }\n    static decodeFreezeLookupTable(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeysLength(instruction.keys, 2);\n        return {\n            lookupTable: instruction.keys[0].pubkey,\n            authority: instruction.keys[1].pubkey\n        };\n    }\n    static decodeDeactivateLookupTable(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeysLength(instruction.keys, 2);\n        return {\n            lookupTable: instruction.keys[0].pubkey,\n            authority: instruction.keys[1].pubkey\n        };\n    }\n    /**\n   * @internal\n   */ static checkProgramId(programId) {\n        if (!programId.equals(AddressLookupTableProgram.programId)) {\n            throw new Error(\"invalid instruction; programId is not AddressLookupTable Program\");\n        }\n    }\n    /**\n   * @internal\n   */ static checkKeysLength(keys, expectedLength) {\n        if (keys.length < expectedLength) {\n            throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);\n        }\n    }\n}\nclass AddressLookupTableProgram {\n    /**\n   * @internal\n   */ constructor(){}\n    static createLookupTable(params) {\n        const [lookupTableAddress, bumpSeed] = PublicKey.findProgramAddressSync([\n            params.authority.toBuffer(),\n            (0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_13__.getU64Encoder)().encode(params.recentSlot)\n        ], this.programId);\n        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable;\n        const data = encodeData(type, {\n            recentSlot: BigInt(params.recentSlot),\n            bumpSeed: bumpSeed\n        });\n        const keys = [\n            {\n                pubkey: lookupTableAddress,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: params.authority,\n                isSigner: true,\n                isWritable: false\n            },\n            {\n                pubkey: params.payer,\n                isSigner: true,\n                isWritable: true\n            },\n            {\n                pubkey: SystemProgram.programId,\n                isSigner: false,\n                isWritable: false\n            }\n        ];\n        return [\n            new TransactionInstruction({\n                programId: this.programId,\n                keys: keys,\n                data: data\n            }),\n            lookupTableAddress\n        ];\n    }\n    static freezeLookupTable(params) {\n        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.FreezeLookupTable;\n        const data = encodeData(type);\n        const keys = [\n            {\n                pubkey: params.lookupTable,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: params.authority,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        return new TransactionInstruction({\n            programId: this.programId,\n            keys: keys,\n            data: data\n        });\n    }\n    static extendLookupTable(params) {\n        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable;\n        const data = encodeData(type, {\n            addresses: params.addresses.map((addr)=>addr.toBytes())\n        });\n        const keys = [\n            {\n                pubkey: params.lookupTable,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: params.authority,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        if (params.payer) {\n            keys.push({\n                pubkey: params.payer,\n                isSigner: true,\n                isWritable: true\n            }, {\n                pubkey: SystemProgram.programId,\n                isSigner: false,\n                isWritable: false\n            });\n        }\n        return new TransactionInstruction({\n            programId: this.programId,\n            keys: keys,\n            data: data\n        });\n    }\n    static deactivateLookupTable(params) {\n        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.DeactivateLookupTable;\n        const data = encodeData(type);\n        const keys = [\n            {\n                pubkey: params.lookupTable,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: params.authority,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        return new TransactionInstruction({\n            programId: this.programId,\n            keys: keys,\n            data: data\n        });\n    }\n    static closeLookupTable(params) {\n        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CloseLookupTable;\n        const data = encodeData(type);\n        const keys = [\n            {\n                pubkey: params.lookupTable,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: params.authority,\n                isSigner: true,\n                isWritable: false\n            },\n            {\n                pubkey: params.recipient,\n                isSigner: false,\n                isWritable: true\n            }\n        ];\n        return new TransactionInstruction({\n            programId: this.programId,\n            keys: keys,\n            data: data\n        });\n    }\n}\nAddressLookupTableProgram.programId = new PublicKey(\"AddressLookupTab1e1111111111111111111111111\");\n/**\n * Compute Budget Instruction class\n */ class ComputeBudgetInstruction {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Decode a compute budget instruction and retrieve the instruction type.\n   */ static decodeInstructionType(instruction) {\n        this.checkProgramId(instruction.programId);\n        const instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"instruction\");\n        const typeIndex = instructionTypeLayout.decode(instruction.data);\n        let type;\n        for (const [ixType, layout] of Object.entries(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS)){\n            if (layout.index == typeIndex) {\n                type = ixType;\n                break;\n            }\n        }\n        if (!type) {\n            throw new Error(\"Instruction type incorrect; not a ComputeBudgetInstruction\");\n        }\n        return type;\n    }\n    /**\n   * Decode request units compute budget instruction and retrieve the instruction params.\n   */ static decodeRequestUnits(instruction) {\n        this.checkProgramId(instruction.programId);\n        const { units, additionalFee } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits, instruction.data);\n        return {\n            units,\n            additionalFee\n        };\n    }\n    /**\n   * Decode request heap frame compute budget instruction and retrieve the instruction params.\n   */ static decodeRequestHeapFrame(instruction) {\n        this.checkProgramId(instruction.programId);\n        const { bytes } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame, instruction.data);\n        return {\n            bytes\n        };\n    }\n    /**\n   * Decode set compute unit limit compute budget instruction and retrieve the instruction params.\n   */ static decodeSetComputeUnitLimit(instruction) {\n        this.checkProgramId(instruction.programId);\n        const { units } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit, instruction.data);\n        return {\n            units\n        };\n    }\n    /**\n   * Decode set compute unit price compute budget instruction and retrieve the instruction params.\n   */ static decodeSetComputeUnitPrice(instruction) {\n        this.checkProgramId(instruction.programId);\n        const { microLamports } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice, instruction.data);\n        return {\n            microLamports\n        };\n    }\n    /**\n   * @internal\n   */ static checkProgramId(programId) {\n        if (!programId.equals(ComputeBudgetProgram.programId)) {\n            throw new Error(\"invalid instruction; programId is not ComputeBudgetProgram\");\n        }\n    }\n}\n/**\n * An enumeration of valid ComputeBudgetInstructionType's\n */ /**\n * Request units instruction params\n */ /**\n * Request heap frame instruction params\n */ /**\n * Set compute unit limit instruction params\n */ /**\n * Set compute unit price instruction params\n */ /**\n * An enumeration of valid ComputeBudget InstructionType's\n * @internal\n */ const COMPUTE_BUDGET_INSTRUCTION_LAYOUTS = Object.freeze({\n    RequestUnits: {\n        index: 0,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"units\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"additionalFee\")\n        ])\n    },\n    RequestHeapFrame: {\n        index: 1,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"bytes\")\n        ])\n    },\n    SetComputeUnitLimit: {\n        index: 2,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"units\")\n        ])\n    },\n    SetComputeUnitPrice: {\n        index: 3,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"instruction\"),\n            u64(\"microLamports\")\n        ])\n    }\n});\n/**\n * Factory class for transaction instructions to interact with the Compute Budget program\n */ class ComputeBudgetProgram {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Public key that identifies the Compute Budget program\n   */ /**\n   * @deprecated Instead, call {@link setComputeUnitLimit} and/or {@link setComputeUnitPrice}\n   */ static requestUnits(params) {\n        const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits;\n        const data = encodeData(type, params);\n        return new TransactionInstruction({\n            keys: [],\n            programId: this.programId,\n            data\n        });\n    }\n    static requestHeapFrame(params) {\n        const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame;\n        const data = encodeData(type, params);\n        return new TransactionInstruction({\n            keys: [],\n            programId: this.programId,\n            data\n        });\n    }\n    static setComputeUnitLimit(params) {\n        const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit;\n        const data = encodeData(type, params);\n        return new TransactionInstruction({\n            keys: [],\n            programId: this.programId,\n            data\n        });\n    }\n    static setComputeUnitPrice(params) {\n        const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice;\n        const data = encodeData(type, {\n            microLamports: BigInt(params.microLamports)\n        });\n        return new TransactionInstruction({\n            keys: [],\n            programId: this.programId,\n            data\n        });\n    }\n}\nComputeBudgetProgram.programId = new PublicKey(\"ComputeBudget111111111111111111111111111111\");\nconst PRIVATE_KEY_BYTES$1 = 64;\nconst PUBLIC_KEY_BYTES$1 = 32;\nconst SIGNATURE_BYTES = 64;\n/**\n * Params for creating an ed25519 instruction using a public key\n */ /**\n * Params for creating an ed25519 instruction using a private key\n */ const ED25519_INSTRUCTION_LAYOUT = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"numSignatures\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"padding\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"signatureOffset\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"signatureInstructionIndex\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"publicKeyOffset\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"publicKeyInstructionIndex\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"messageDataOffset\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"messageDataSize\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"messageInstructionIndex\")\n]);\nclass Ed25519Program {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Public key that identifies the ed25519 program\n   */ /**\n   * Create an ed25519 instruction with a public key and signature. The\n   * public key must be a buffer that is 32 bytes long, and the signature\n   * must be a buffer of 64 bytes.\n   */ static createInstructionWithPublicKey(params) {\n        const { publicKey, message, signature, instructionIndex } = params;\n        assert(publicKey.length === PUBLIC_KEY_BYTES$1, `Public Key must be ${PUBLIC_KEY_BYTES$1} bytes but received ${publicKey.length} bytes`);\n        assert(signature.length === SIGNATURE_BYTES, `Signature must be ${SIGNATURE_BYTES} bytes but received ${signature.length} bytes`);\n        const publicKeyOffset = ED25519_INSTRUCTION_LAYOUT.span;\n        const signatureOffset = publicKeyOffset + publicKey.length;\n        const messageDataOffset = signatureOffset + signature.length;\n        const numSignatures = 1;\n        const instructionData = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(messageDataOffset + message.length);\n        const index = instructionIndex == null ? 0xffff // An index of `u16::MAX` makes it default to the current instruction.\n         : instructionIndex;\n        ED25519_INSTRUCTION_LAYOUT.encode({\n            numSignatures,\n            padding: 0,\n            signatureOffset,\n            signatureInstructionIndex: index,\n            publicKeyOffset,\n            publicKeyInstructionIndex: index,\n            messageDataOffset,\n            messageDataSize: message.length,\n            messageInstructionIndex: index\n        }, instructionData);\n        instructionData.fill(publicKey, publicKeyOffset);\n        instructionData.fill(signature, signatureOffset);\n        instructionData.fill(message, messageDataOffset);\n        return new TransactionInstruction({\n            keys: [],\n            programId: Ed25519Program.programId,\n            data: instructionData\n        });\n    }\n    /**\n   * Create an ed25519 instruction with a private key. The private key\n   * must be a buffer that is 64 bytes long.\n   */ static createInstructionWithPrivateKey(params) {\n        const { privateKey, message, instructionIndex } = params;\n        assert(privateKey.length === PRIVATE_KEY_BYTES$1, `Private key must be ${PRIVATE_KEY_BYTES$1} bytes but received ${privateKey.length} bytes`);\n        try {\n            const keypair = Keypair.fromSecretKey(privateKey);\n            const publicKey = keypair.publicKey.toBytes();\n            const signature = sign(message, keypair.secretKey);\n            return this.createInstructionWithPublicKey({\n                publicKey,\n                message,\n                signature,\n                instructionIndex\n            });\n        } catch (error) {\n            throw new Error(`Error creating instruction; ${error}`);\n        }\n    }\n}\nEd25519Program.programId = new PublicKey(\"Ed25519SigVerify111111111111111111111111111\");\nconst ecdsaSign = (msgHash, privKey)=>{\n    const signature = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_15__.secp256k1.sign(msgHash, privKey);\n    return [\n        signature.toCompactRawBytes(),\n        signature.recovery\n    ];\n};\n_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_15__.secp256k1.utils.isValidPrivateKey;\nconst publicKeyCreate = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_15__.secp256k1.getPublicKey;\nconst PRIVATE_KEY_BYTES = 32;\nconst ETHEREUM_ADDRESS_BYTES = 20;\nconst PUBLIC_KEY_BYTES = 64;\nconst SIGNATURE_OFFSETS_SERIALIZED_SIZE = 11;\n/**\n * Params for creating an secp256k1 instruction using a public key\n */ /**\n * Params for creating an secp256k1 instruction using an Ethereum address\n */ /**\n * Params for creating an secp256k1 instruction using a private key\n */ const SECP256K1_INSTRUCTION_LAYOUT = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"numSignatures\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"signatureOffset\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"signatureInstructionIndex\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"ethAddressOffset\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"ethAddressInstructionIndex\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"messageDataOffset\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"messageDataSize\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"messageInstructionIndex\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(20, \"ethAddress\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(64, \"signature\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"recoveryId\")\n]);\nclass Secp256k1Program {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Public key that identifies the secp256k1 program\n   */ /**\n   * Construct an Ethereum address from a secp256k1 public key buffer.\n   * @param {Buffer} publicKey a 64 byte secp256k1 public key buffer\n   */ static publicKeyToEthAddress(publicKey) {\n        assert(publicKey.length === PUBLIC_KEY_BYTES, `Public key must be ${PUBLIC_KEY_BYTES} bytes but received ${publicKey.length} bytes`);\n        try {\n            return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from((0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_16__.keccak_256)(toBuffer(publicKey))).slice(-ETHEREUM_ADDRESS_BYTES);\n        } catch (error) {\n            throw new Error(`Error constructing Ethereum address: ${error}`);\n        }\n    }\n    /**\n   * Create an secp256k1 instruction with a public key. The public key\n   * must be a buffer that is 64 bytes long.\n   */ static createInstructionWithPublicKey(params) {\n        const { publicKey, message, signature, recoveryId, instructionIndex } = params;\n        return Secp256k1Program.createInstructionWithEthAddress({\n            ethAddress: Secp256k1Program.publicKeyToEthAddress(publicKey),\n            message,\n            signature,\n            recoveryId,\n            instructionIndex\n        });\n    }\n    /**\n   * Create an secp256k1 instruction with an Ethereum address. The address\n   * must be a hex string or a buffer that is 20 bytes long.\n   */ static createInstructionWithEthAddress(params) {\n        const { ethAddress: rawAddress, message, signature, recoveryId, instructionIndex = 0 } = params;\n        let ethAddress;\n        if (typeof rawAddress === \"string\") {\n            if (rawAddress.startsWith(\"0x\")) {\n                ethAddress = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(rawAddress.substr(2), \"hex\");\n            } else {\n                ethAddress = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(rawAddress, \"hex\");\n            }\n        } else {\n            ethAddress = rawAddress;\n        }\n        assert(ethAddress.length === ETHEREUM_ADDRESS_BYTES, `Address must be ${ETHEREUM_ADDRESS_BYTES} bytes but received ${ethAddress.length} bytes`);\n        const dataStart = 1 + SIGNATURE_OFFSETS_SERIALIZED_SIZE;\n        const ethAddressOffset = dataStart;\n        const signatureOffset = dataStart + ethAddress.length;\n        const messageDataOffset = signatureOffset + signature.length + 1;\n        const numSignatures = 1;\n        const instructionData = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(SECP256K1_INSTRUCTION_LAYOUT.span + message.length);\n        SECP256K1_INSTRUCTION_LAYOUT.encode({\n            numSignatures,\n            signatureOffset,\n            signatureInstructionIndex: instructionIndex,\n            ethAddressOffset,\n            ethAddressInstructionIndex: instructionIndex,\n            messageDataOffset,\n            messageDataSize: message.length,\n            messageInstructionIndex: instructionIndex,\n            signature: toBuffer(signature),\n            ethAddress: toBuffer(ethAddress),\n            recoveryId\n        }, instructionData);\n        instructionData.fill(toBuffer(message), SECP256K1_INSTRUCTION_LAYOUT.span);\n        return new TransactionInstruction({\n            keys: [],\n            programId: Secp256k1Program.programId,\n            data: instructionData\n        });\n    }\n    /**\n   * Create an secp256k1 instruction with a private key. The private key\n   * must be a buffer that is 32 bytes long.\n   */ static createInstructionWithPrivateKey(params) {\n        const { privateKey: pkey, message, instructionIndex } = params;\n        assert(pkey.length === PRIVATE_KEY_BYTES, `Private key must be ${PRIVATE_KEY_BYTES} bytes but received ${pkey.length} bytes`);\n        try {\n            const privateKey = toBuffer(pkey);\n            const publicKey = publicKeyCreate(privateKey, false).slice(1); // throw away leading byte\n            const messageHash = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from((0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_16__.keccak_256)(toBuffer(message)));\n            const [signature, recoveryId] = ecdsaSign(messageHash, privateKey);\n            return this.createInstructionWithPublicKey({\n                publicKey,\n                message,\n                signature,\n                recoveryId,\n                instructionIndex\n            });\n        } catch (error) {\n            throw new Error(`Error creating instruction; ${error}`);\n        }\n    }\n}\nSecp256k1Program.programId = new PublicKey(\"KeccakSecp256k11111111111111111111111111111\");\nvar _Lockup;\n/**\n * Address of the stake config account which configures the rate\n * of stake warmup and cooldown as well as the slashing penalty.\n */ const STAKE_CONFIG_ID = new PublicKey(\"StakeConfig11111111111111111111111111111111\");\n/**\n * Stake account authority info\n */ class Authorized {\n    /**\n   * Create a new Authorized object\n   * @param staker the stake authority\n   * @param withdrawer the withdraw authority\n   */ constructor(staker, withdrawer){\n        /** stake authority */ this.staker = void 0;\n        /** withdraw authority */ this.withdrawer = void 0;\n        this.staker = staker;\n        this.withdrawer = withdrawer;\n    }\n}\n/**\n * Stake account lockup info\n */ class Lockup {\n    /**\n   * Create a new Lockup object\n   */ constructor(unixTimestamp, epoch, custodian){\n        /** Unix timestamp of lockup expiration */ this.unixTimestamp = void 0;\n        /** Epoch of lockup expiration */ this.epoch = void 0;\n        /** Lockup custodian authority */ this.custodian = void 0;\n        this.unixTimestamp = unixTimestamp;\n        this.epoch = epoch;\n        this.custodian = custodian;\n    }\n}\n_Lockup = Lockup;\nLockup.default = new _Lockup(0, 0, PublicKey.default);\n/**\n * Create stake account transaction params\n */ /**\n * Create stake account with seed transaction params\n */ /**\n * Initialize stake instruction params\n */ /**\n * Delegate stake instruction params\n */ /**\n * Authorize stake instruction params\n */ /**\n * Authorize stake instruction params using a derived key\n */ /**\n * Split stake instruction params\n */ /**\n * Split with seed transaction params\n */ /**\n * Withdraw stake instruction params\n */ /**\n * Deactivate stake instruction params\n */ /**\n * Merge stake instruction params\n */ /**\n * Stake Instruction class\n */ class StakeInstruction {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Decode a stake instruction and retrieve the instruction type.\n   */ static decodeInstructionType(instruction) {\n        this.checkProgramId(instruction.programId);\n        const instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\");\n        const typeIndex = instructionTypeLayout.decode(instruction.data);\n        let type;\n        for (const [ixType, layout] of Object.entries(STAKE_INSTRUCTION_LAYOUTS)){\n            if (layout.index == typeIndex) {\n                type = ixType;\n                break;\n            }\n        }\n        if (!type) {\n            throw new Error(\"Instruction type incorrect; not a StakeInstruction\");\n        }\n        return type;\n    }\n    /**\n   * Decode a initialize stake instruction and retrieve the instruction params.\n   */ static decodeInitialize(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 2);\n        const { authorized, lockup } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Initialize, instruction.data);\n        return {\n            stakePubkey: instruction.keys[0].pubkey,\n            authorized: new Authorized(new PublicKey(authorized.staker), new PublicKey(authorized.withdrawer)),\n            lockup: new Lockup(lockup.unixTimestamp, lockup.epoch, new PublicKey(lockup.custodian))\n        };\n    }\n    /**\n   * Decode a delegate stake instruction and retrieve the instruction params.\n   */ static decodeDelegate(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 6);\n        decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Delegate, instruction.data);\n        return {\n            stakePubkey: instruction.keys[0].pubkey,\n            votePubkey: instruction.keys[1].pubkey,\n            authorizedPubkey: instruction.keys[5].pubkey\n        };\n    }\n    /**\n   * Decode an authorize stake instruction and retrieve the instruction params.\n   */ static decodeAuthorize(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { newAuthorized, stakeAuthorizationType } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Authorize, instruction.data);\n        const o = {\n            stakePubkey: instruction.keys[0].pubkey,\n            authorizedPubkey: instruction.keys[2].pubkey,\n            newAuthorizedPubkey: new PublicKey(newAuthorized),\n            stakeAuthorizationType: {\n                index: stakeAuthorizationType\n            }\n        };\n        if (instruction.keys.length > 3) {\n            o.custodianPubkey = instruction.keys[3].pubkey;\n        }\n        return o;\n    }\n    /**\n   * Decode an authorize-with-seed stake instruction and retrieve the instruction params.\n   */ static decodeAuthorizeWithSeed(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 2);\n        const { newAuthorized, stakeAuthorizationType, authoritySeed, authorityOwner } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data);\n        const o = {\n            stakePubkey: instruction.keys[0].pubkey,\n            authorityBase: instruction.keys[1].pubkey,\n            authoritySeed: authoritySeed,\n            authorityOwner: new PublicKey(authorityOwner),\n            newAuthorizedPubkey: new PublicKey(newAuthorized),\n            stakeAuthorizationType: {\n                index: stakeAuthorizationType\n            }\n        };\n        if (instruction.keys.length > 3) {\n            o.custodianPubkey = instruction.keys[3].pubkey;\n        }\n        return o;\n    }\n    /**\n   * Decode a split stake instruction and retrieve the instruction params.\n   */ static decodeSplit(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { lamports } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Split, instruction.data);\n        return {\n            stakePubkey: instruction.keys[0].pubkey,\n            splitStakePubkey: instruction.keys[1].pubkey,\n            authorizedPubkey: instruction.keys[2].pubkey,\n            lamports\n        };\n    }\n    /**\n   * Decode a merge stake instruction and retrieve the instruction params.\n   */ static decodeMerge(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Merge, instruction.data);\n        return {\n            stakePubkey: instruction.keys[0].pubkey,\n            sourceStakePubKey: instruction.keys[1].pubkey,\n            authorizedPubkey: instruction.keys[4].pubkey\n        };\n    }\n    /**\n   * Decode a withdraw stake instruction and retrieve the instruction params.\n   */ static decodeWithdraw(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 5);\n        const { lamports } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data);\n        const o = {\n            stakePubkey: instruction.keys[0].pubkey,\n            toPubkey: instruction.keys[1].pubkey,\n            authorizedPubkey: instruction.keys[4].pubkey,\n            lamports\n        };\n        if (instruction.keys.length > 5) {\n            o.custodianPubkey = instruction.keys[5].pubkey;\n        }\n        return o;\n    }\n    /**\n   * Decode a deactivate stake instruction and retrieve the instruction params.\n   */ static decodeDeactivate(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Deactivate, instruction.data);\n        return {\n            stakePubkey: instruction.keys[0].pubkey,\n            authorizedPubkey: instruction.keys[2].pubkey\n        };\n    }\n    /**\n   * @internal\n   */ static checkProgramId(programId) {\n        if (!programId.equals(StakeProgram.programId)) {\n            throw new Error(\"invalid instruction; programId is not StakeProgram\");\n        }\n    }\n    /**\n   * @internal\n   */ static checkKeyLength(keys, expectedLength) {\n        if (keys.length < expectedLength) {\n            throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);\n        }\n    }\n}\n/**\n * An enumeration of valid StakeInstructionType's\n */ /**\n * An enumeration of valid stake InstructionType's\n * @internal\n */ const STAKE_INSTRUCTION_LAYOUTS = Object.freeze({\n    Initialize: {\n        index: 0,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            authorized(),\n            lockup()\n        ])\n    },\n    Authorize: {\n        index: 1,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"newAuthorized\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"stakeAuthorizationType\")\n        ])\n    },\n    Delegate: {\n        index: 2,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    Split: {\n        index: 3,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"lamports\")\n        ])\n    },\n    Withdraw: {\n        index: 4,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"lamports\")\n        ])\n    },\n    Deactivate: {\n        index: 5,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    Merge: {\n        index: 7,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    AuthorizeWithSeed: {\n        index: 8,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"newAuthorized\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"stakeAuthorizationType\"),\n            rustString(\"authoritySeed\"),\n            publicKey(\"authorityOwner\")\n        ])\n    }\n});\n/**\n * Stake authorization type\n */ /**\n * An enumeration of valid StakeAuthorizationLayout's\n */ const StakeAuthorizationLayout = Object.freeze({\n    Staker: {\n        index: 0\n    },\n    Withdrawer: {\n        index: 1\n    }\n});\n/**\n * Factory class for transactions to interact with the Stake program\n */ class StakeProgram {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Public key that identifies the Stake program\n   */ /**\n   * Generate an Initialize instruction to add to a Stake Create transaction\n   */ static initialize(params) {\n        const { stakePubkey, authorized, lockup: maybeLockup } = params;\n        const lockup = maybeLockup || Lockup.default;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Initialize;\n        const data = encodeData(type, {\n            authorized: {\n                staker: toBuffer(authorized.staker.toBuffer()),\n                withdrawer: toBuffer(authorized.withdrawer.toBuffer())\n            },\n            lockup: {\n                unixTimestamp: lockup.unixTimestamp,\n                epoch: lockup.epoch,\n                custodian: toBuffer(lockup.custodian.toBuffer())\n            }\n        });\n        const instructionData = {\n            keys: [\n                {\n                    pubkey: stakePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_RENT_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        };\n        return new TransactionInstruction(instructionData);\n    }\n    /**\n   * Generate a Transaction that creates a new Stake account at\n   *   an address generated with `from`, a seed, and the Stake programId\n   */ static createAccountWithSeed(params) {\n        const transaction = new Transaction();\n        transaction.add(SystemProgram.createAccountWithSeed({\n            fromPubkey: params.fromPubkey,\n            newAccountPubkey: params.stakePubkey,\n            basePubkey: params.basePubkey,\n            seed: params.seed,\n            lamports: params.lamports,\n            space: this.space,\n            programId: this.programId\n        }));\n        const { stakePubkey, authorized, lockup } = params;\n        return transaction.add(this.initialize({\n            stakePubkey,\n            authorized,\n            lockup\n        }));\n    }\n    /**\n   * Generate a Transaction that creates a new Stake account\n   */ static createAccount(params) {\n        const transaction = new Transaction();\n        transaction.add(SystemProgram.createAccount({\n            fromPubkey: params.fromPubkey,\n            newAccountPubkey: params.stakePubkey,\n            lamports: params.lamports,\n            space: this.space,\n            programId: this.programId\n        }));\n        const { stakePubkey, authorized, lockup } = params;\n        return transaction.add(this.initialize({\n            stakePubkey,\n            authorized,\n            lockup\n        }));\n    }\n    /**\n   * Generate a Transaction that delegates Stake tokens to a validator\n   * Vote PublicKey. This transaction can also be used to redelegate Stake\n   * to a new validator Vote PublicKey.\n   */ static delegate(params) {\n        const { stakePubkey, authorizedPubkey, votePubkey } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Delegate;\n        const data = encodeData(type);\n        return new Transaction().add({\n            keys: [\n                {\n                    pubkey: stakePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: votePubkey,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: SYSVAR_CLOCK_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: STAKE_CONFIG_ID,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a Transaction that authorizes a new PublicKey as Staker\n   * or Withdrawer on the Stake account.\n   */ static authorize(params) {\n        const { stakePubkey, authorizedPubkey, newAuthorizedPubkey, stakeAuthorizationType, custodianPubkey } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Authorize;\n        const data = encodeData(type, {\n            newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n            stakeAuthorizationType: stakeAuthorizationType.index\n        });\n        const keys = [\n            {\n                pubkey: stakePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: SYSVAR_CLOCK_PUBKEY,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: authorizedPubkey,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        if (custodianPubkey) {\n            keys.push({\n                pubkey: custodianPubkey,\n                isSigner: true,\n                isWritable: false\n            });\n        }\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a Transaction that authorizes a new PublicKey as Staker\n   * or Withdrawer on the Stake account.\n   */ static authorizeWithSeed(params) {\n        const { stakePubkey, authorityBase, authoritySeed, authorityOwner, newAuthorizedPubkey, stakeAuthorizationType, custodianPubkey } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;\n        const data = encodeData(type, {\n            newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n            stakeAuthorizationType: stakeAuthorizationType.index,\n            authoritySeed: authoritySeed,\n            authorityOwner: toBuffer(authorityOwner.toBuffer())\n        });\n        const keys = [\n            {\n                pubkey: stakePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: authorityBase,\n                isSigner: true,\n                isWritable: false\n            },\n            {\n                pubkey: SYSVAR_CLOCK_PUBKEY,\n                isSigner: false,\n                isWritable: false\n            }\n        ];\n        if (custodianPubkey) {\n            keys.push({\n                pubkey: custodianPubkey,\n                isSigner: true,\n                isWritable: false\n            });\n        }\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * @internal\n   */ static splitInstruction(params) {\n        const { stakePubkey, authorizedPubkey, splitStakePubkey, lamports } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Split;\n        const data = encodeData(type, {\n            lamports\n        });\n        return new TransactionInstruction({\n            keys: [\n                {\n                    pubkey: stakePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: splitStakePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a Transaction that splits Stake tokens into another stake account\n   */ static split(params, // Compute the cost of allocating the new stake account in lamports\n    rentExemptReserve) {\n        const transaction = new Transaction();\n        transaction.add(SystemProgram.createAccount({\n            fromPubkey: params.authorizedPubkey,\n            newAccountPubkey: params.splitStakePubkey,\n            lamports: rentExemptReserve,\n            space: this.space,\n            programId: this.programId\n        }));\n        return transaction.add(this.splitInstruction(params));\n    }\n    /**\n   * Generate a Transaction that splits Stake tokens into another account\n   * derived from a base public key and seed\n   */ static splitWithSeed(params, // If this stake account is new, compute the cost of allocating it in lamports\n    rentExemptReserve) {\n        const { stakePubkey, authorizedPubkey, splitStakePubkey, basePubkey, seed, lamports } = params;\n        const transaction = new Transaction();\n        transaction.add(SystemProgram.allocate({\n            accountPubkey: splitStakePubkey,\n            basePubkey,\n            seed,\n            space: this.space,\n            programId: this.programId\n        }));\n        if (rentExemptReserve && rentExemptReserve > 0) {\n            transaction.add(SystemProgram.transfer({\n                fromPubkey: params.authorizedPubkey,\n                toPubkey: splitStakePubkey,\n                lamports: rentExemptReserve\n            }));\n        }\n        return transaction.add(this.splitInstruction({\n            stakePubkey,\n            authorizedPubkey,\n            splitStakePubkey,\n            lamports\n        }));\n    }\n    /**\n   * Generate a Transaction that merges Stake accounts.\n   */ static merge(params) {\n        const { stakePubkey, sourceStakePubKey, authorizedPubkey } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Merge;\n        const data = encodeData(type);\n        return new Transaction().add({\n            keys: [\n                {\n                    pubkey: stakePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: sourceStakePubKey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_CLOCK_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a Transaction that withdraws deactivated Stake tokens.\n   */ static withdraw(params) {\n        const { stakePubkey, authorizedPubkey, toPubkey, lamports, custodianPubkey } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Withdraw;\n        const data = encodeData(type, {\n            lamports\n        });\n        const keys = [\n            {\n                pubkey: stakePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: toPubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: SYSVAR_CLOCK_PUBKEY,\n                isSigner: false,\n                isWritable: false\n            },\n            {\n                pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,\n                isSigner: false,\n                isWritable: false\n            },\n            {\n                pubkey: authorizedPubkey,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        if (custodianPubkey) {\n            keys.push({\n                pubkey: custodianPubkey,\n                isSigner: true,\n                isWritable: false\n            });\n        }\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a Transaction that deactivates Stake tokens.\n   */ static deactivate(params) {\n        const { stakePubkey, authorizedPubkey } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Deactivate;\n        const data = encodeData(type);\n        return new Transaction().add({\n            keys: [\n                {\n                    pubkey: stakePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_CLOCK_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n}\nStakeProgram.programId = new PublicKey(\"Stake11111111111111111111111111111111111111\");\n/**\n * Max space of a Stake account\n *\n * This is generated from the solana-stake-program StakeState struct as\n * `StakeStateV2::size_of()`:\n * https://docs.rs/solana-stake-program/latest/solana_stake_program/stake_state/enum.StakeStateV2.html\n */ StakeProgram.space = 200;\n/**\n * Vote account info\n */ class VoteInit {\n    /** [0, 100] */ constructor(nodePubkey, authorizedVoter, authorizedWithdrawer, commission){\n        this.nodePubkey = void 0;\n        this.authorizedVoter = void 0;\n        this.authorizedWithdrawer = void 0;\n        this.commission = void 0;\n        this.nodePubkey = nodePubkey;\n        this.authorizedVoter = authorizedVoter;\n        this.authorizedWithdrawer = authorizedWithdrawer;\n        this.commission = commission;\n    }\n}\n/**\n * Create vote account transaction params\n */ /**\n * InitializeAccount instruction params\n */ /**\n * Authorize instruction params\n */ /**\n * AuthorizeWithSeed instruction params\n */ /**\n * Withdraw from vote account transaction params\n */ /**\n * Update validator identity (node pubkey) vote account instruction params.\n */ /**\n * Vote Instruction class\n */ class VoteInstruction {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Decode a vote instruction and retrieve the instruction type.\n   */ static decodeInstructionType(instruction) {\n        this.checkProgramId(instruction.programId);\n        const instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\");\n        const typeIndex = instructionTypeLayout.decode(instruction.data);\n        let type;\n        for (const [ixType, layout] of Object.entries(VOTE_INSTRUCTION_LAYOUTS)){\n            if (layout.index == typeIndex) {\n                type = ixType;\n                break;\n            }\n        }\n        if (!type) {\n            throw new Error(\"Instruction type incorrect; not a VoteInstruction\");\n        }\n        return type;\n    }\n    /**\n   * Decode an initialize vote instruction and retrieve the instruction params.\n   */ static decodeInitializeAccount(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 4);\n        const { voteInit } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.InitializeAccount, instruction.data);\n        return {\n            votePubkey: instruction.keys[0].pubkey,\n            nodePubkey: instruction.keys[3].pubkey,\n            voteInit: new VoteInit(new PublicKey(voteInit.nodePubkey), new PublicKey(voteInit.authorizedVoter), new PublicKey(voteInit.authorizedWithdrawer), voteInit.commission)\n        };\n    }\n    /**\n   * Decode an authorize instruction and retrieve the instruction params.\n   */ static decodeAuthorize(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { newAuthorized, voteAuthorizationType } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Authorize, instruction.data);\n        return {\n            votePubkey: instruction.keys[0].pubkey,\n            authorizedPubkey: instruction.keys[2].pubkey,\n            newAuthorizedPubkey: new PublicKey(newAuthorized),\n            voteAuthorizationType: {\n                index: voteAuthorizationType\n            }\n        };\n    }\n    /**\n   * Decode an authorize instruction and retrieve the instruction params.\n   */ static decodeAuthorizeWithSeed(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { voteAuthorizeWithSeedArgs: { currentAuthorityDerivedKeyOwnerPubkey, currentAuthorityDerivedKeySeed, newAuthorized, voteAuthorizationType } } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data);\n        return {\n            currentAuthorityDerivedKeyBasePubkey: instruction.keys[2].pubkey,\n            currentAuthorityDerivedKeyOwnerPubkey: new PublicKey(currentAuthorityDerivedKeyOwnerPubkey),\n            currentAuthorityDerivedKeySeed: currentAuthorityDerivedKeySeed,\n            newAuthorizedPubkey: new PublicKey(newAuthorized),\n            voteAuthorizationType: {\n                index: voteAuthorizationType\n            },\n            votePubkey: instruction.keys[0].pubkey\n        };\n    }\n    /**\n   * Decode a withdraw instruction and retrieve the instruction params.\n   */ static decodeWithdraw(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { lamports } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data);\n        return {\n            votePubkey: instruction.keys[0].pubkey,\n            authorizedWithdrawerPubkey: instruction.keys[2].pubkey,\n            lamports,\n            toPubkey: instruction.keys[1].pubkey\n        };\n    }\n    /**\n   * @internal\n   */ static checkProgramId(programId) {\n        if (!programId.equals(VoteProgram.programId)) {\n            throw new Error(\"invalid instruction; programId is not VoteProgram\");\n        }\n    }\n    /**\n   * @internal\n   */ static checkKeyLength(keys, expectedLength) {\n        if (keys.length < expectedLength) {\n            throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);\n        }\n    }\n}\n/**\n * An enumeration of valid VoteInstructionType's\n */ /** @internal */ const VOTE_INSTRUCTION_LAYOUTS = Object.freeze({\n    InitializeAccount: {\n        index: 0,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            voteInit()\n        ])\n    },\n    Authorize: {\n        index: 1,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"newAuthorized\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"voteAuthorizationType\")\n        ])\n    },\n    Withdraw: {\n        index: 3,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"lamports\")\n        ])\n    },\n    UpdateValidatorIdentity: {\n        index: 4,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    AuthorizeWithSeed: {\n        index: 10,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            voteAuthorizeWithSeedArgs()\n        ])\n    }\n});\n/**\n * VoteAuthorize type\n */ /**\n * An enumeration of valid VoteAuthorization layouts.\n */ const VoteAuthorizationLayout = Object.freeze({\n    Voter: {\n        index: 0\n    },\n    Withdrawer: {\n        index: 1\n    }\n});\n/**\n * Factory class for transactions to interact with the Vote program\n */ class VoteProgram {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Public key that identifies the Vote program\n   */ /**\n   * Generate an Initialize instruction.\n   */ static initializeAccount(params) {\n        const { votePubkey, nodePubkey, voteInit } = params;\n        const type = VOTE_INSTRUCTION_LAYOUTS.InitializeAccount;\n        const data = encodeData(type, {\n            voteInit: {\n                nodePubkey: toBuffer(voteInit.nodePubkey.toBuffer()),\n                authorizedVoter: toBuffer(voteInit.authorizedVoter.toBuffer()),\n                authorizedWithdrawer: toBuffer(voteInit.authorizedWithdrawer.toBuffer()),\n                commission: voteInit.commission\n            }\n        });\n        const instructionData = {\n            keys: [\n                {\n                    pubkey: votePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_RENT_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: SYSVAR_CLOCK_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: nodePubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        };\n        return new TransactionInstruction(instructionData);\n    }\n    /**\n   * Generate a transaction that creates a new Vote account.\n   */ static createAccount(params) {\n        const transaction = new Transaction();\n        transaction.add(SystemProgram.createAccount({\n            fromPubkey: params.fromPubkey,\n            newAccountPubkey: params.votePubkey,\n            lamports: params.lamports,\n            space: this.space,\n            programId: this.programId\n        }));\n        return transaction.add(this.initializeAccount({\n            votePubkey: params.votePubkey,\n            nodePubkey: params.voteInit.nodePubkey,\n            voteInit: params.voteInit\n        }));\n    }\n    /**\n   * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account.\n   */ static authorize(params) {\n        const { votePubkey, authorizedPubkey, newAuthorizedPubkey, voteAuthorizationType } = params;\n        const type = VOTE_INSTRUCTION_LAYOUTS.Authorize;\n        const data = encodeData(type, {\n            newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n            voteAuthorizationType: voteAuthorizationType.index\n        });\n        const keys = [\n            {\n                pubkey: votePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: SYSVAR_CLOCK_PUBKEY,\n                isSigner: false,\n                isWritable: false\n            },\n            {\n                pubkey: authorizedPubkey,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account\n   * where the current Voter or Withdrawer authority is a derived key.\n   */ static authorizeWithSeed(params) {\n        const { currentAuthorityDerivedKeyBasePubkey, currentAuthorityDerivedKeyOwnerPubkey, currentAuthorityDerivedKeySeed, newAuthorizedPubkey, voteAuthorizationType, votePubkey } = params;\n        const type = VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;\n        const data = encodeData(type, {\n            voteAuthorizeWithSeedArgs: {\n                currentAuthorityDerivedKeyOwnerPubkey: toBuffer(currentAuthorityDerivedKeyOwnerPubkey.toBuffer()),\n                currentAuthorityDerivedKeySeed: currentAuthorityDerivedKeySeed,\n                newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n                voteAuthorizationType: voteAuthorizationType.index\n            }\n        });\n        const keys = [\n            {\n                pubkey: votePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: SYSVAR_CLOCK_PUBKEY,\n                isSigner: false,\n                isWritable: false\n            },\n            {\n                pubkey: currentAuthorityDerivedKeyBasePubkey,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction to withdraw from a Vote account.\n   */ static withdraw(params) {\n        const { votePubkey, authorizedWithdrawerPubkey, lamports, toPubkey } = params;\n        const type = VOTE_INSTRUCTION_LAYOUTS.Withdraw;\n        const data = encodeData(type, {\n            lamports\n        });\n        const keys = [\n            {\n                pubkey: votePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: toPubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: authorizedWithdrawerPubkey,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction to withdraw safely from a Vote account.\n   *\n   * This function was created as a safeguard for vote accounts running validators, `safeWithdraw`\n   * checks that the withdraw amount will not exceed the specified balance while leaving enough left\n   * to cover rent. If you wish to close the vote account by withdrawing the full amount, call the\n   * `withdraw` method directly.\n   */ static safeWithdraw(params, currentVoteAccountBalance, rentExemptMinimum) {\n        if (params.lamports > currentVoteAccountBalance - rentExemptMinimum) {\n            throw new Error(\"Withdraw will leave vote account with insufficient funds.\");\n        }\n        return VoteProgram.withdraw(params);\n    }\n    /**\n   * Generate a transaction to update the validator identity (node pubkey) of a Vote account.\n   */ static updateValidatorIdentity(params) {\n        const { votePubkey, authorizedWithdrawerPubkey, nodePubkey } = params;\n        const type = VOTE_INSTRUCTION_LAYOUTS.UpdateValidatorIdentity;\n        const data = encodeData(type);\n        const keys = [\n            {\n                pubkey: votePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: nodePubkey,\n                isSigner: true,\n                isWritable: false\n            },\n            {\n                pubkey: authorizedWithdrawerPubkey,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n}\nVoteProgram.programId = new PublicKey(\"Vote111111111111111111111111111111111111111\");\n/**\n * Max space of a Vote account\n *\n * This is generated from the solana-vote-program VoteState struct as\n * `VoteState::size_of()`:\n * https://docs.rs/solana-vote-program/1.9.5/solana_vote_program/vote_state/struct.VoteState.html#method.size_of\n *\n * KEEP IN SYNC WITH `VoteState::size_of()` in https://github.com/solana-labs/solana/blob/a474cb24b9238f5edcc982f65c0b37d4a1046f7e/sdk/program/src/vote/state/mod.rs#L340-L342\n */ VoteProgram.space = 3762;\nconst VALIDATOR_INFO_KEY = new PublicKey(\"Va1idator1nfo111111111111111111111111111111\");\n/**\n * @internal\n */ /**\n * Info used to identity validators.\n */ const InfoString = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    name: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    website: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    details: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    iconUrl: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    keybaseUsername: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)())\n});\n/**\n * ValidatorInfo class\n */ class ValidatorInfo {\n    /**\n   * Construct a valid ValidatorInfo\n   *\n   * @param key validator public key\n   * @param info validator information\n   */ constructor(key, info){\n        /**\n     * validator public key\n     */ this.key = void 0;\n        /**\n     * validator information\n     */ this.info = void 0;\n        this.key = key;\n        this.info = info;\n    }\n    /**\n   * Deserialize ValidatorInfo from the config account data. Exactly two config\n   * keys are required in the data.\n   *\n   * @param buffer config account data\n   * @return null if info was not found\n   */ static fromConfigData(buffer) {\n        let byteArray = [\n            ...buffer\n        ];\n        const configKeyCount = decodeLength(byteArray);\n        if (configKeyCount !== 2) return null;\n        const configKeys = [];\n        for(let i = 0; i < 2; i++){\n            const publicKey = new PublicKey(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));\n            const isSigner = guardedShift(byteArray) === 1;\n            configKeys.push({\n                publicKey,\n                isSigner\n            });\n        }\n        if (configKeys[0].publicKey.equals(VALIDATOR_INFO_KEY)) {\n            if (configKeys[1].isSigner) {\n                const rawInfo = rustString().decode(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(byteArray));\n                const info = JSON.parse(rawInfo);\n                (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.assert)(info, InfoString);\n                return new ValidatorInfo(configKeys[1].publicKey, info);\n            }\n        }\n        return null;\n    }\n}\nconst VOTE_PROGRAM_ID = new PublicKey(\"Vote111111111111111111111111111111111111111\");\n/**\n * History of how many credits earned by the end of each epoch\n */ /**\n * See https://github.com/solana-labs/solana/blob/8a12ed029cfa38d4a45400916c2463fb82bbec8c/programs/vote_api/src/vote_state.rs#L68-L88\n *\n * @internal\n */ const VoteAccountLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n    publicKey(\"nodePubkey\"),\n    publicKey(\"authorizedWithdrawer\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"commission\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(),\n    // votes.length\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"slot\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"confirmationCount\")\n    ]), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(), -8), \"votes\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"rootSlotValid\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"rootSlot\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(),\n    // authorizedVoters.length\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"epoch\"),\n        publicKey(\"authorizedVoter\")\n    ]), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(), -8), \"authorizedVoters\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            publicKey(\"authorizedPubkey\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"epochOfLastAuthorizedSwitch\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"targetEpoch\")\n        ]), 32, \"buf\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"idx\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"isEmpty\")\n    ], \"priorVoters\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(),\n    // epochCredits.length\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"epoch\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"credits\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"prevCredits\")\n    ]), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(), -8), \"epochCredits\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"slot\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"timestamp\")\n    ], \"lastTimestamp\")\n]);\n/**\n * VoteAccount class\n */ class VoteAccount {\n    /**\n   * @internal\n   */ constructor(args){\n        this.nodePubkey = void 0;\n        this.authorizedWithdrawer = void 0;\n        this.commission = void 0;\n        this.rootSlot = void 0;\n        this.votes = void 0;\n        this.authorizedVoters = void 0;\n        this.priorVoters = void 0;\n        this.epochCredits = void 0;\n        this.lastTimestamp = void 0;\n        this.nodePubkey = args.nodePubkey;\n        this.authorizedWithdrawer = args.authorizedWithdrawer;\n        this.commission = args.commission;\n        this.rootSlot = args.rootSlot;\n        this.votes = args.votes;\n        this.authorizedVoters = args.authorizedVoters;\n        this.priorVoters = args.priorVoters;\n        this.epochCredits = args.epochCredits;\n        this.lastTimestamp = args.lastTimestamp;\n    }\n    /**\n   * Deserialize VoteAccount from the account data.\n   *\n   * @param buffer account data\n   * @return VoteAccount\n   */ static fromAccountData(buffer) {\n        const versionOffset = 4;\n        const va = VoteAccountLayout.decode(toBuffer(buffer), versionOffset);\n        let rootSlot = va.rootSlot;\n        if (!va.rootSlotValid) {\n            rootSlot = null;\n        }\n        return new VoteAccount({\n            nodePubkey: new PublicKey(va.nodePubkey),\n            authorizedWithdrawer: new PublicKey(va.authorizedWithdrawer),\n            commission: va.commission,\n            votes: va.votes,\n            rootSlot,\n            authorizedVoters: va.authorizedVoters.map(parseAuthorizedVoter),\n            priorVoters: getPriorVoters(va.priorVoters),\n            epochCredits: va.epochCredits,\n            lastTimestamp: va.lastTimestamp\n        });\n    }\n}\nfunction parseAuthorizedVoter({ authorizedVoter, epoch }) {\n    return {\n        epoch,\n        authorizedVoter: new PublicKey(authorizedVoter)\n    };\n}\nfunction parsePriorVoters({ authorizedPubkey, epochOfLastAuthorizedSwitch, targetEpoch }) {\n    return {\n        authorizedPubkey: new PublicKey(authorizedPubkey),\n        epochOfLastAuthorizedSwitch,\n        targetEpoch\n    };\n}\nfunction getPriorVoters({ buf, idx, isEmpty }) {\n    if (isEmpty) {\n        return [];\n    }\n    return [\n        ...buf.slice(idx + 1).map(parsePriorVoters),\n        ...buf.slice(0, idx).map(parsePriorVoters)\n    ];\n}\nconst endpoint = {\n    http: {\n        devnet: \"http://api.devnet.solana.com\",\n        testnet: \"http://api.testnet.solana.com\",\n        \"mainnet-beta\": \"http://api.mainnet-beta.solana.com/\"\n    },\n    https: {\n        devnet: \"https://api.devnet.solana.com\",\n        testnet: \"https://api.testnet.solana.com\",\n        \"mainnet-beta\": \"https://api.mainnet-beta.solana.com/\"\n    }\n};\n/**\n * Retrieves the RPC API URL for the specified cluster\n * @param {Cluster} [cluster=\"devnet\"] - The cluster name of the RPC API URL to use. Possible options: 'devnet' | 'testnet' | 'mainnet-beta'\n * @param {boolean} [tls=\"http\"] - Use TLS when connecting to cluster.\n *\n * @returns {string} URL string of the RPC endpoint\n */ function clusterApiUrl(cluster, tls) {\n    const key = tls === false ? \"http\" : \"https\";\n    if (!cluster) {\n        return endpoint[key][\"devnet\"];\n    }\n    const url = endpoint[key][cluster];\n    if (!url) {\n        throw new Error(`Unknown ${key} cluster: ${cluster}`);\n    }\n    return url;\n}\n/**\n * Send and confirm a raw transaction\n *\n * If `commitment` option is not specified, defaults to 'max' commitment.\n *\n * @param {Connection} connection\n * @param {Buffer} rawTransaction\n * @param {TransactionConfirmationStrategy} confirmationStrategy\n * @param {ConfirmOptions} [options]\n * @returns {Promise<TransactionSignature>}\n */ /**\n * @deprecated Calling `sendAndConfirmRawTransaction()` without a `confirmationStrategy`\n * is no longer supported and will be removed in a future version.\n */ // eslint-disable-next-line no-redeclare\n// eslint-disable-next-line no-redeclare\nasync function sendAndConfirmRawTransaction(connection, rawTransaction, confirmationStrategyOrConfirmOptions, maybeConfirmOptions) {\n    let confirmationStrategy;\n    let options;\n    if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, \"lastValidBlockHeight\")) {\n        confirmationStrategy = confirmationStrategyOrConfirmOptions;\n        options = maybeConfirmOptions;\n    } else if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, \"nonceValue\")) {\n        confirmationStrategy = confirmationStrategyOrConfirmOptions;\n        options = maybeConfirmOptions;\n    } else {\n        options = confirmationStrategyOrConfirmOptions;\n    }\n    const sendOptions = options && {\n        skipPreflight: options.skipPreflight,\n        preflightCommitment: options.preflightCommitment || options.commitment,\n        minContextSlot: options.minContextSlot\n    };\n    const signature = await connection.sendRawTransaction(rawTransaction, sendOptions);\n    const commitment = options && options.commitment;\n    const confirmationPromise = confirmationStrategy ? connection.confirmTransaction(confirmationStrategy, commitment) : connection.confirmTransaction(signature, commitment);\n    const status = (await confirmationPromise).value;\n    if (status.err) {\n        if (signature != null) {\n            throw new SendTransactionError({\n                action: sendOptions?.skipPreflight ? \"send\" : \"simulate\",\n                signature: signature,\n                transactionMessage: `Status: (${JSON.stringify(status)})`\n            });\n        }\n        throw new Error(`Raw transaction ${signature} failed (${JSON.stringify(status)})`);\n    }\n    return signature;\n}\n/**\n * There are 1-billion lamports in one SOL\n */ const LAMPORTS_PER_SOL = 1000000000;\n //# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL2xpYi9pbmRleC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBZ0M7QUFDZ0I7QUFDekI7QUFDQztBQUNzQjtBQUN1QjtBQUNmO0FBQ1Q7QUFDdUI7QUFDdEM7QUFDRTtBQUNZO0FBQ3NJO0FBQ2hJO0FBQ1Y7QUFDaUI7QUFDVDtBQUNJO0FBRXBEOzs7O0NBSUMsR0FFRDs7Q0FFQyxHQUVELE1BQU13QyxxQkFBcUJ2QywyREFBT0EsQ0FBQ3dDLEtBQUssQ0FBQ0MsZ0JBQWdCO0FBQ3pELE1BQU1DLGtCQUFrQjtJQUN0QixNQUFNQyxnQkFBZ0IzQywyREFBT0EsQ0FBQ3dDLEtBQUssQ0FBQ0MsZ0JBQWdCO0lBQ3BELE1BQU1HLFlBQVlDLGFBQWFGO0lBQy9CLE1BQU1HLFlBQVksSUFBSUMsV0FBVztJQUNqQ0QsVUFBVUUsR0FBRyxDQUFDTDtJQUNkRyxVQUFVRSxHQUFHLENBQUNKLFdBQVc7SUFDekIsT0FBTztRQUNMQTtRQUNBRTtJQUNGO0FBQ0Y7QUFDQSxNQUFNRCxlQUFlN0MsMkRBQU9BLENBQUM2QyxZQUFZO0FBQ3pDLFNBQVNJLFVBQVVMLFNBQVM7SUFDMUIsSUFBSTtRQUNGNUMsMkRBQU9BLENBQUNrRCxhQUFhLENBQUNDLE9BQU8sQ0FBQ1A7UUFDOUIsT0FBTztJQUNULEVBQUUsT0FBTTtRQUNOLE9BQU87SUFDVDtBQUNGO0FBQ0EsTUFBTVEsT0FBTyxDQUFDQyxTQUFTUCxZQUFjOUMsMkRBQU9BLENBQUNvRCxJQUFJLENBQUNDLFNBQVNQLFVBQVVRLEtBQUssQ0FBQyxHQUFHO0FBQzlFLE1BQU1DLFNBQVN2RCwyREFBT0EsQ0FBQ3VELE1BQU07QUFFN0IsTUFBTUMsV0FBV0MsQ0FBQUE7SUFDZixJQUFJMUQs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QUFXQTtnQkFDWDZULG9CQUFvQixDQUFDLFNBQVMsRUFBRTlGLEtBQUtDLFNBQVMsQ0FBQzBJLFFBQVEsQ0FBQyxDQUFDO1lBQzNEO1FBQ0Y7UUFDQSxNQUFNLElBQUl0YSxNQUFNLENBQUMsZ0JBQWdCLEVBQUU0RCxVQUFVLFNBQVMsRUFBRStOLEtBQUtDLFNBQVMsQ0FBQzBJLFFBQVEsQ0FBQyxDQUFDO0lBQ25GO0lBQ0EsT0FBTzFXO0FBQ1Q7QUFFQTs7Q0FFQyxHQUNELE1BQU1zMkMsbUJBQW1CO0FBRTZnRCxDQUN0aUQscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2tyLWRvbWFpbi13YXRjaGVyLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2ViMy5qcy9saWIvaW5kZXguZXNtLmpzPzhmYTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQnVmZmVyIH0gZnJvbSAnYnVmZmVyJztcbmltcG9ydCB7IGVkMjU1MTkgfSBmcm9tICdAbm9ibGUvY3VydmVzL2VkMjU1MTknO1xuaW1wb3J0IEJOIGZyb20gJ2JuLmpzJztcbmltcG9ydCBiczU4IGZyb20gJ2JzNTgnO1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEyNTYnO1xuaW1wb3J0IHsgc2VyaWFsaXplLCBkZXNlcmlhbGl6ZSwgZGVzZXJpYWxpemVVbmNoZWNrZWQgfSBmcm9tICdib3JzaCc7XG5pbXBvcnQgKiBhcyBCdWZmZXJMYXlvdXQgZnJvbSAnQHNvbGFuYS9idWZmZXItbGF5b3V0JztcbmltcG9ydCB7IGJsb2IgfSBmcm9tICdAc29sYW5hL2J1ZmZlci1sYXlvdXQnO1xuaW1wb3J0IHsgZ2V0VTY0Q29kZWMsIGdldFU2NEVuY29kZXIgfSBmcm9tICdAc29sYW5hL2NvZGVjcy1udW1iZXJzJztcbmltcG9ydCByZXF1aXJlJCQwIGZyb20gJ3V0aWwnO1xuaW1wb3J0IHJlcXVpcmUkJDAkMSBmcm9tICdodHRwJztcbmltcG9ydCByZXF1aXJlJCQwJDIsIHsgQWdlbnQgfSBmcm9tICdodHRwcyc7XG5pbXBvcnQgeyBjb2VyY2UsIGluc3RhbmNlLCBzdHJpbmcsIHR1cGxlLCBsaXRlcmFsLCB1bmtub3duLCB0eXBlLCBudW1iZXIsIGFycmF5LCBudWxsYWJsZSwgb3B0aW9uYWwsIGJvb2xlYW4sIHJlY29yZCwgdW5pb24sIGNyZWF0ZSwgYW55LCBhc3NlcnQgYXMgYXNzZXJ0JDEgfSBmcm9tICdzdXBlcnN0cnVjdCc7XG5pbXBvcnQgUnBjQ2xpZW50IGZyb20gJ2pheXNvbi9saWIvY2xpZW50L2Jyb3dzZXInO1xuaW1wb3J0ICogYXMgbm9kZUZldGNoIGZyb20gJ25vZGUtZmV0Y2gnO1xuaW1wb3J0IHsgQ29tbW9uQ2xpZW50LCBXZWJTb2NrZXQgfSBmcm9tICdycGMtd2Vic29ja2V0cyc7XG5pbXBvcnQgeyBrZWNjYWtfMjU2IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEzJztcbmltcG9ydCB7IHNlY3AyNTZrMSB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxJztcblxuLyoqXG4gKiBBIDY0IGJ5dGUgc2VjcmV0IGtleSwgdGhlIGZpcnN0IDMyIGJ5dGVzIG9mIHdoaWNoIGlzIHRoZVxuICogcHJpdmF0ZSBzY2FsYXIgYW5kIHRoZSBsYXN0IDMyIGJ5dGVzIGlzIHRoZSBwdWJsaWMga2V5LlxuICogUmVhZCBtb3JlOiBodHRwczovL2Jsb2cubW96aWxsYS5vcmcvd2FybmVyLzIwMTEvMTEvMjkvZWQyNTUxOS1rZXlzL1xuICovXG5cbi8qKlxuICogRWQyNTUxOSBLZXlwYWlyXG4gKi9cblxuY29uc3QgZ2VuZXJhdGVQcml2YXRlS2V5ID0gZWQyNTUxOS51dGlscy5yYW5kb21Qcml2YXRlS2V5O1xuY29uc3QgZ2VuZXJhdGVLZXlwYWlyID0gKCkgPT4ge1xuICBjb25zdCBwcml2YXRlU2NhbGFyID0gZWQyNTUxOS51dGlscy5yYW5kb21Qcml2YXRlS2V5KCk7XG4gIGNvbnN0IHB1YmxpY0tleSA9IGdldFB1YmxpY0tleShwcml2YXRlU2NhbGFyKTtcbiAgY29uc3Qgc2VjcmV0S2V5ID0gbmV3IFVpbnQ4QXJyYXkoNjQpO1xuICBzZWNyZXRLZXkuc2V0KHByaXZhdGVTY2FsYXIpO1xuICBzZWNyZXRLZXkuc2V0KHB1YmxpY0tleSwgMzIpO1xuICByZXR1cm4ge1xuICAgIHB1YmxpY0tleSxcbiAgICBzZWNyZXRLZXlcbiAgfTtcbn07XG5jb25zdCBnZXRQdWJsaWNLZXkgPSBlZDI1NTE5LmdldFB1YmxpY0tleTtcbmZ1bmN0aW9uIGlzT25DdXJ2ZShwdWJsaWNLZXkpIHtcbiAgdHJ5IHtcbiAgICBlZDI1NTE5LkV4dGVuZGVkUG9pbnQuZnJvbUhleChwdWJsaWNLZXkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmNvbnN0IHNpZ24gPSAobWVzc2FnZSwgc2VjcmV0S2V5KSA9PiBlZDI1NTE5LnNpZ24obWVzc2FnZSwgc2VjcmV0S2V5LnNsaWNlKDAsIDMyKSk7XG5jb25zdCB2ZXJpZnkgPSBlZDI1NTE5LnZlcmlmeTtcblxuY29uc3QgdG9CdWZmZXIgPSBhcnIgPT4ge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGFycikpIHtcbiAgICByZXR1cm4gYXJyO1xuICB9IGVsc2UgaWYgKGFyciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oYXJyKTtcbiAgfVxufTtcblxuLy8gQ2xhc3Mgd3JhcHBpbmcgYSBwbGFpbiBvYmplY3RcbmNsYXNzIFN0cnVjdCB7XG4gIGNvbnN0cnVjdG9yKHByb3BlcnRpZXMpIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHByb3BlcnRpZXMpO1xuICB9XG4gIGVuY29kZSgpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oc2VyaWFsaXplKFNPTEFOQV9TQ0hFTUEsIHRoaXMpKTtcbiAgfVxuICBzdGF0aWMgZGVjb2RlKGRhdGEpIHtcbiAgICByZXR1cm4gZGVzZXJpYWxpemUoU09MQU5BX1NDSEVNQSwgdGhpcywgZGF0YSk7XG4gIH1cbiAgc3RhdGljIGRlY29kZVVuY2hlY2tlZChkYXRhKSB7XG4gICAgcmV0dXJuIGRlc2VyaWFsaXplVW5jaGVja2VkKFNPTEFOQV9TQ0hFTUEsIHRoaXMsIGRhdGEpO1xuICB9XG59XG5cbi8vIENsYXNzIHJlcHJlc2VudGluZyBhIFJ1c3QtY29tcGF0aWJsZSBlbnVtLCBzaW5jZSBlbnVtcyBhcmUgb25seSBzdHJpbmdzIG9yXG4vLyBudW1iZXJzIGluIHB1cmUgSlNcbmNsYXNzIEVudW0gZXh0ZW5kcyBTdHJ1Y3Qge1xuICBjb25zdHJ1Y3Rvcihwcm9wZXJ0aWVzKSB7XG4gICAgc3VwZXIocHJvcGVydGllcyk7XG4gICAgdGhpcy5lbnVtID0gJyc7XG4gICAgaWYgKE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbnVtIGNhbiBvbmx5IHRha2Ugc2luZ2xlIHZhbHVlJyk7XG4gICAgfVxuICAgIE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLm1hcChrZXkgPT4ge1xuICAgICAgdGhpcy5lbnVtID0ga2V5O1xuICAgIH0pO1xuICB9XG59XG5jb25zdCBTT0xBTkFfU0NIRU1BID0gbmV3IE1hcCgpO1xuXG52YXIgX1B1YmxpY0tleTtcblxuLyoqXG4gKiBNYXhpbXVtIGxlbmd0aCBvZiBkZXJpdmVkIHB1YmtleSBzZWVkXG4gKi9cbmNvbnN0IE1BWF9TRUVEX0xFTkdUSCA9IDMyO1xuXG4vKipcbiAqIFNpemUgb2YgcHVibGljIGtleSBpbiBieXRlc1xuICovXG5jb25zdCBQVUJMSUNfS0VZX0xFTkdUSCA9IDMyO1xuXG4vKipcbiAqIFZhbHVlIHRvIGJlIGNvbnZlcnRlZCBpbnRvIHB1YmxpYyBrZXlcbiAqL1xuXG4vKipcbiAqIEpTT04gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIFB1YmxpY0tleSBjbGFzc1xuICovXG5cbmZ1bmN0aW9uIGlzUHVibGljS2V5RGF0YSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUuX2JuICE9PSB1bmRlZmluZWQ7XG59XG5cbi8vIGxvY2FsIGNvdW50ZXIgdXNlZCBieSBQdWJsaWNLZXkudW5pcXVlKClcbmxldCB1bmlxdWVQdWJsaWNLZXlDb3VudGVyID0gMTtcblxuLyoqXG4gKiBBIHB1YmxpYyBrZXlcbiAqL1xuY2xhc3MgUHVibGljS2V5IGV4dGVuZHMgU3RydWN0IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBQdWJsaWNLZXkgb2JqZWN0XG4gICAqIEBwYXJhbSB2YWx1ZSBlZDI1NTE5IHB1YmxpYyBrZXkgYXMgYnVmZmVyIG9yIGJhc2UtNTggZW5jb2RlZCBzdHJpbmdcbiAgICovXG4gIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgc3VwZXIoe30pO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9ibiA9IHZvaWQgMDtcbiAgICBpZiAoaXNQdWJsaWNLZXlEYXRhKHZhbHVlKSkge1xuICAgICAgdGhpcy5fYm4gPSB2YWx1ZS5fYm47XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIGFzc3VtZSBiYXNlIDU4IGVuY29kaW5nIGJ5IGRlZmF1bHRcbiAgICAgICAgY29uc3QgZGVjb2RlZCA9IGJzNTguZGVjb2RlKHZhbHVlKTtcbiAgICAgICAgaWYgKGRlY29kZWQubGVuZ3RoICE9IFBVQkxJQ19LRVlfTEVOR1RIKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHB1YmxpYyBrZXkgaW5wdXRgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9ibiA9IG5ldyBCTihkZWNvZGVkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2JuID0gbmV3IEJOKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9ibi5ieXRlTGVuZ3RoKCkgPiBQVUJMSUNfS0VZX0xFTkdUSCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcHVibGljIGtleSBpbnB1dGApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdW5pcXVlIFB1YmxpY0tleSBmb3IgdGVzdHMgYW5kIGJlbmNobWFya3MgdXNpbmcgYSBjb3VudGVyXG4gICAqL1xuICBzdGF0aWMgdW5pcXVlKCkge1xuICAgIGNvbnN0IGtleSA9IG5ldyBQdWJsaWNLZXkodW5pcXVlUHVibGljS2V5Q291bnRlcik7XG4gICAgdW5pcXVlUHVibGljS2V5Q291bnRlciArPSAxO1xuICAgIHJldHVybiBuZXcgUHVibGljS2V5KGtleS50b0J1ZmZlcigpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZhdWx0IHB1YmxpYyBrZXkgdmFsdWUuIFRoZSBiYXNlNTgtZW5jb2RlZCBzdHJpbmcgcmVwcmVzZW50YXRpb24gaXMgYWxsIG9uZXMgKGFzIHNlZW4gYmVsb3cpXG4gICAqIFRoZSB1bmRlcmx5aW5nIEJOIG51bWJlciBpcyAzMiBieXRlcyB0aGF0IGFyZSBhbGwgemVyb3NcbiAgICovXG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0d28gcHVibGljS2V5cyBhcmUgZXF1YWxcbiAgICovXG4gIGVxdWFscyhwdWJsaWNLZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fYm4uZXEocHVibGljS2V5Ll9ibik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBiYXNlLTU4IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwdWJsaWMga2V5XG4gICAqL1xuICB0b0Jhc2U1OCgpIHtcbiAgICByZXR1cm4gYnM1OC5lbmNvZGUodGhpcy50b0J5dGVzKCkpO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b0Jhc2U1OCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgYnl0ZSBhcnJheSByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHVibGljIGtleSBpbiBiaWcgZW5kaWFuXG4gICAqL1xuICB0b0J5dGVzKCkge1xuICAgIGNvbnN0IGJ1ZiA9IHRoaXMudG9CdWZmZXIoKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmLmJ1ZmZlciwgYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlTGVuZ3RoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIEJ1ZmZlciByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHVibGljIGtleSBpbiBiaWcgZW5kaWFuXG4gICAqL1xuICB0b0J1ZmZlcigpIHtcbiAgICBjb25zdCBiID0gdGhpcy5fYm4udG9BcnJheUxpa2UoQnVmZmVyKTtcbiAgICBpZiAoYi5sZW5ndGggPT09IFBVQkxJQ19LRVlfTEVOR1RIKSB7XG4gICAgICByZXR1cm4gYjtcbiAgICB9XG4gICAgY29uc3QgemVyb1BhZCA9IEJ1ZmZlci5hbGxvYygzMik7XG4gICAgYi5jb3B5KHplcm9QYWQsIDMyIC0gYi5sZW5ndGgpO1xuICAgIHJldHVybiB6ZXJvUGFkO1xuICB9XG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICByZXR1cm4gYFB1YmxpY0tleSgke3RoaXMudG9TdHJpbmcoKX0pYDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGJhc2UtNTggcmVwcmVzZW50YXRpb24gb2YgdGhlIHB1YmxpYyBrZXlcbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnRvQmFzZTU4KCk7XG4gIH1cblxuICAvKipcbiAgICogRGVyaXZlIGEgcHVibGljIGtleSBmcm9tIGFub3RoZXIga2V5LCBhIHNlZWQsIGFuZCBhIHByb2dyYW0gSUQuXG4gICAqIFRoZSBwcm9ncmFtIElEIHdpbGwgYWxzbyBzZXJ2ZSBhcyB0aGUgb3duZXIgb2YgdGhlIHB1YmxpYyBrZXksIGdpdmluZ1xuICAgKiBpdCBwZXJtaXNzaW9uIHRvIHdyaXRlIGRhdGEgdG8gdGhlIGFjY291bnQuXG4gICAqL1xuICAvKiBlc2xpbnQtZGlzYWJsZSByZXF1aXJlLWF3YWl0ICovXG4gIHN0YXRpYyBhc3luYyBjcmVhdGVXaXRoU2VlZChmcm9tUHVibGljS2V5LCBzZWVkLCBwcm9ncmFtSWQpIHtcbiAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuY29uY2F0KFtmcm9tUHVibGljS2V5LnRvQnVmZmVyKCksIEJ1ZmZlci5mcm9tKHNlZWQpLCBwcm9ncmFtSWQudG9CdWZmZXIoKV0pO1xuICAgIGNvbnN0IHB1YmxpY0tleUJ5dGVzID0gc2hhMjU2KGJ1ZmZlcik7XG4gICAgcmV0dXJuIG5ldyBQdWJsaWNLZXkocHVibGljS2V5Qnl0ZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcml2ZSBhIHByb2dyYW0gYWRkcmVzcyBmcm9tIHNlZWRzIGFuZCBhIHByb2dyYW0gSUQuXG4gICAqL1xuICAvKiBlc2xpbnQtZGlzYWJsZSByZXF1aXJlLWF3YWl0ICovXG4gIHN0YXRpYyBjcmVhdGVQcm9ncmFtQWRkcmVzc1N5bmMoc2VlZHMsIHByb2dyYW1JZCkge1xuICAgIGxldCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMCk7XG4gICAgc2VlZHMuZm9yRWFjaChmdW5jdGlvbiAoc2VlZCkge1xuICAgICAgaWYgKHNlZWQubGVuZ3RoID4gTUFYX1NFRURfTEVOR1RIKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE1heCBzZWVkIGxlbmd0aCBleGNlZWRlZGApO1xuICAgICAgfVxuICAgICAgYnVmZmVyID0gQnVmZmVyLmNvbmNhdChbYnVmZmVyLCB0b0J1ZmZlcihzZWVkKV0pO1xuICAgIH0pO1xuICAgIGJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQoW2J1ZmZlciwgcHJvZ3JhbUlkLnRvQnVmZmVyKCksIEJ1ZmZlci5mcm9tKCdQcm9ncmFtRGVyaXZlZEFkZHJlc3MnKV0pO1xuICAgIGNvbnN0IHB1YmxpY0tleUJ5dGVzID0gc2hhMjU2KGJ1ZmZlcik7XG4gICAgaWYgKGlzT25DdXJ2ZShwdWJsaWNLZXlCeXRlcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzZWVkcywgYWRkcmVzcyBtdXN0IGZhbGwgb2ZmIHRoZSBjdXJ2ZWApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFB1YmxpY0tleShwdWJsaWNLZXlCeXRlcyk7XG4gIH1cblxuICAvKipcbiAgICogQXN5bmMgdmVyc2lvbiBvZiBjcmVhdGVQcm9ncmFtQWRkcmVzc1N5bmNcbiAgICogRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgY3JlYXRlUHJvZ3JhbUFkZHJlc3NTeW5jfSBpbnN0ZWFkXG4gICAqL1xuICAvKiBlc2xpbnQtZGlzYWJsZSByZXF1aXJlLWF3YWl0ICovXG4gIHN0YXRpYyBhc3luYyBjcmVhdGVQcm9ncmFtQWRkcmVzcyhzZWVkcywgcHJvZ3JhbUlkKSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlUHJvZ3JhbUFkZHJlc3NTeW5jKHNlZWRzLCBwcm9ncmFtSWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgYSB2YWxpZCBwcm9ncmFtIGFkZHJlc3NcbiAgICpcbiAgICogVmFsaWQgcHJvZ3JhbSBhZGRyZXNzZXMgbXVzdCBmYWxsIG9mZiB0aGUgZWQyNTUxOSBjdXJ2ZS4gIFRoaXMgZnVuY3Rpb25cbiAgICogaXRlcmF0ZXMgYSBub25jZSB1bnRpbCBpdCBmaW5kcyBvbmUgdGhhdCB3aGVuIGNvbWJpbmVkIHdpdGggdGhlIHNlZWRzXG4gICAqIHJlc3VsdHMgaW4gYSB2YWxpZCBwcm9ncmFtIGFkZHJlc3MuXG4gICAqL1xuICBzdGF0aWMgZmluZFByb2dyYW1BZGRyZXNzU3luYyhzZWVkcywgcHJvZ3JhbUlkKSB7XG4gICAgbGV0IG5vbmNlID0gMjU1O1xuICAgIGxldCBhZGRyZXNzO1xuICAgIHdoaWxlIChub25jZSAhPSAwKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBzZWVkc1dpdGhOb25jZSA9IHNlZWRzLmNvbmNhdChCdWZmZXIuZnJvbShbbm9uY2VdKSk7XG4gICAgICAgIGFkZHJlc3MgPSB0aGlzLmNyZWF0ZVByb2dyYW1BZGRyZXNzU3luYyhzZWVkc1dpdGhOb25jZSwgcHJvZ3JhbUlkKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgVHlwZUVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIG5vbmNlLS07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFthZGRyZXNzLCBub25jZV07XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGZpbmQgYSB2aWFibGUgcHJvZ3JhbSBhZGRyZXNzIG5vbmNlYCk7XG4gIH1cblxuICAvKipcbiAgICogQXN5bmMgdmVyc2lvbiBvZiBmaW5kUHJvZ3JhbUFkZHJlc3NTeW5jXG4gICAqIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIGZpbmRQcm9ncmFtQWRkcmVzc1N5bmN9IGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBhc3luYyBmaW5kUHJvZ3JhbUFkZHJlc3Moc2VlZHMsIHByb2dyYW1JZCkge1xuICAgIHJldHVybiB0aGlzLmZpbmRQcm9ncmFtQWRkcmVzc1N5bmMoc2VlZHMsIHByb2dyYW1JZCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgdGhhdCBhIHB1YmtleSBpcyBvbiB0aGUgZWQyNTUxOSBjdXJ2ZS5cbiAgICovXG4gIHN0YXRpYyBpc09uQ3VydmUocHVia2V5RGF0YSkge1xuICAgIGNvbnN0IHB1YmtleSA9IG5ldyBQdWJsaWNLZXkocHVia2V5RGF0YSk7XG4gICAgcmV0dXJuIGlzT25DdXJ2ZShwdWJrZXkudG9CeXRlcygpKTtcbiAgfVxufVxuX1B1YmxpY0tleSA9IFB1YmxpY0tleTtcblB1YmxpY0tleS5kZWZhdWx0ID0gbmV3IF9QdWJsaWNLZXkoJzExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5TT0xBTkFfU0NIRU1BLnNldChQdWJsaWNLZXksIHtcbiAga2luZDogJ3N0cnVjdCcsXG4gIGZpZWxkczogW1snX2JuJywgJ3UyNTYnXV1cbn0pO1xuXG4vKipcbiAqIEFuIGFjY291bnQga2V5IHBhaXIgKHB1YmxpYyBhbmQgc2VjcmV0IGtleXMpLlxuICpcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHYxLjEwLjAsIHBsZWFzZSB1c2Uge0BsaW5rIEtleXBhaXJ9IGluc3RlYWQuXG4gKi9cbmNsYXNzIEFjY291bnQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IEFjY291bnQgb2JqZWN0XG4gICAqXG4gICAqIElmIHRoZSBzZWNyZXRLZXkgcGFyYW1ldGVyIGlzIG5vdCBwcm92aWRlZCBhIG5ldyBrZXkgcGFpciBpcyByYW5kb21seVxuICAgKiBjcmVhdGVkIGZvciB0aGUgYWNjb3VudFxuICAgKlxuICAgKiBAcGFyYW0gc2VjcmV0S2V5IFNlY3JldCBrZXkgZm9yIHRoZSBhY2NvdW50XG4gICAqL1xuICBjb25zdHJ1Y3RvcihzZWNyZXRLZXkpIHtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcHVibGljS2V5ID0gdm9pZCAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9zZWNyZXRLZXkgPSB2b2lkIDA7XG4gICAgaWYgKHNlY3JldEtleSkge1xuICAgICAgY29uc3Qgc2VjcmV0S2V5QnVmZmVyID0gdG9CdWZmZXIoc2VjcmV0S2V5KTtcbiAgICAgIGlmIChzZWNyZXRLZXkubGVuZ3RoICE9PSA2NCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBzZWNyZXQga2V5IHNpemUnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3B1YmxpY0tleSA9IHNlY3JldEtleUJ1ZmZlci5zbGljZSgzMiwgNjQpO1xuICAgICAgdGhpcy5fc2VjcmV0S2V5ID0gc2VjcmV0S2V5QnVmZmVyLnNsaWNlKDAsIDMyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc2VjcmV0S2V5ID0gdG9CdWZmZXIoZ2VuZXJhdGVQcml2YXRlS2V5KCkpO1xuICAgICAgdGhpcy5fcHVibGljS2V5ID0gdG9CdWZmZXIoZ2V0UHVibGljS2V5KHRoaXMuX3NlY3JldEtleSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgcHVibGljIGtleSBmb3IgdGhpcyBhY2NvdW50XG4gICAqL1xuICBnZXQgcHVibGljS2V5KCkge1xuICAgIHJldHVybiBuZXcgUHVibGljS2V5KHRoaXMuX3B1YmxpY0tleSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlICoqdW5lbmNyeXB0ZWQqKiBzZWNyZXQga2V5IGZvciB0aGlzIGFjY291bnQuIFRoZSBmaXJzdCAzMiBieXRlc1xuICAgKiBpcyB0aGUgcHJpdmF0ZSBzY2FsYXIgYW5kIHRoZSBsYXN0IDMyIGJ5dGVzIGlzIHRoZSBwdWJsaWMga2V5LlxuICAgKiBSZWFkIG1vcmU6IGh0dHBzOi8vYmxvZy5tb3ppbGxhLm9yZy93YXJuZXIvMjAxMS8xMS8yOS9lZDI1NTE5LWtleXMvXG4gICAqL1xuICBnZXQgc2VjcmV0S2V5KCkge1xuICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFt0aGlzLl9zZWNyZXRLZXksIHRoaXMuX3B1YmxpY0tleV0sIDY0KTtcbiAgfVxufVxuXG5jb25zdCBCUEZfTE9BREVSX0RFUFJFQ0FURURfUFJPR1JBTV9JRCA9IG5ldyBQdWJsaWNLZXkoJ0JQRkxvYWRlcjExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcblxuLyoqXG4gKiBNYXhpbXVtIG92ZXItdGhlLXdpcmUgc2l6ZSBvZiBhIFRyYW5zYWN0aW9uXG4gKlxuICogMTI4MCBpcyBJUHY2IG1pbmltdW0gTVRVXG4gKiA0MCBieXRlcyBpcyB0aGUgc2l6ZSBvZiB0aGUgSVB2NiBoZWFkZXJcbiAqIDggYnl0ZXMgaXMgdGhlIHNpemUgb2YgdGhlIGZyYWdtZW50IGhlYWRlclxuICovXG5jb25zdCBQQUNLRVRfREFUQV9TSVpFID0gMTI4MCAtIDQwIC0gODtcbmNvbnN0IFZFUlNJT05fUFJFRklYX01BU0sgPSAweDdmO1xuY29uc3QgU0lHTkFUVVJFX0xFTkdUSF9JTl9CWVRFUyA9IDY0O1xuXG5jbGFzcyBUcmFuc2FjdGlvbkV4cGlyZWRCbG9ja2hlaWdodEV4Y2VlZGVkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHNpZ25hdHVyZSkge1xuICAgIHN1cGVyKGBTaWduYXR1cmUgJHtzaWduYXR1cmV9IGhhcyBleHBpcmVkOiBibG9jayBoZWlnaHQgZXhjZWVkZWQuYCk7XG4gICAgdGhpcy5zaWduYXR1cmUgPSB2b2lkIDA7XG4gICAgdGhpcy5zaWduYXR1cmUgPSBzaWduYXR1cmU7XG4gIH1cbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2FjdGlvbkV4cGlyZWRCbG9ja2hlaWdodEV4Y2VlZGVkRXJyb3IucHJvdG90eXBlLCAnbmFtZScsIHtcbiAgdmFsdWU6ICdUcmFuc2FjdGlvbkV4cGlyZWRCbG9ja2hlaWdodEV4Y2VlZGVkRXJyb3InXG59KTtcbmNsYXNzIFRyYW5zYWN0aW9uRXhwaXJlZFRpbWVvdXRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3Ioc2lnbmF0dXJlLCB0aW1lb3V0U2Vjb25kcykge1xuICAgIHN1cGVyKGBUcmFuc2FjdGlvbiB3YXMgbm90IGNvbmZpcm1lZCBpbiAke3RpbWVvdXRTZWNvbmRzLnRvRml4ZWQoMil9IHNlY29uZHMuIEl0IGlzIGAgKyAndW5rbm93biBpZiBpdCBzdWNjZWVkZWQgb3IgZmFpbGVkLiBDaGVjayBzaWduYXR1cmUgJyArIGAke3NpZ25hdHVyZX0gdXNpbmcgdGhlIFNvbGFuYSBFeHBsb3JlciBvciBDTEkgdG9vbHMuYCk7XG4gICAgdGhpcy5zaWduYXR1cmUgPSB2b2lkIDA7XG4gICAgdGhpcy5zaWduYXR1cmUgPSBzaWduYXR1cmU7XG4gIH1cbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2FjdGlvbkV4cGlyZWRUaW1lb3V0RXJyb3IucHJvdG90eXBlLCAnbmFtZScsIHtcbiAgdmFsdWU6ICdUcmFuc2FjdGlvbkV4cGlyZWRUaW1lb3V0RXJyb3InXG59KTtcbmNsYXNzIFRyYW5zYWN0aW9uRXhwaXJlZE5vbmNlSW52YWxpZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihzaWduYXR1cmUpIHtcbiAgICBzdXBlcihgU2lnbmF0dXJlICR7c2lnbmF0dXJlfSBoYXMgZXhwaXJlZDogdGhlIG5vbmNlIGlzIG5vIGxvbmdlciB2YWxpZC5gKTtcbiAgICB0aGlzLnNpZ25hdHVyZSA9IHZvaWQgMDtcbiAgICB0aGlzLnNpZ25hdHVyZSA9IHNpZ25hdHVyZTtcbiAgfVxufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYW5zYWN0aW9uRXhwaXJlZE5vbmNlSW52YWxpZEVycm9yLnByb3RvdHlwZSwgJ25hbWUnLCB7XG4gIHZhbHVlOiAnVHJhbnNhY3Rpb25FeHBpcmVkTm9uY2VJbnZhbGlkRXJyb3InXG59KTtcblxuY2xhc3MgTWVzc2FnZUFjY291bnRLZXlzIHtcbiAgY29uc3RydWN0b3Ioc3RhdGljQWNjb3VudEtleXMsIGFjY291bnRLZXlzRnJvbUxvb2t1cHMpIHtcbiAgICB0aGlzLnN0YXRpY0FjY291bnRLZXlzID0gdm9pZCAwO1xuICAgIHRoaXMuYWNjb3VudEtleXNGcm9tTG9va3VwcyA9IHZvaWQgMDtcbiAgICB0aGlzLnN0YXRpY0FjY291bnRLZXlzID0gc3RhdGljQWNjb3VudEtleXM7XG4gICAgdGhpcy5hY2NvdW50S2V5c0Zyb21Mb29rdXBzID0gYWNjb3VudEtleXNGcm9tTG9va3VwcztcbiAgfVxuICBrZXlTZWdtZW50cygpIHtcbiAgICBjb25zdCBrZXlTZWdtZW50cyA9IFt0aGlzLnN0YXRpY0FjY291bnRLZXlzXTtcbiAgICBpZiAodGhpcy5hY2NvdW50S2V5c0Zyb21Mb29rdXBzKSB7XG4gICAgICBrZXlTZWdtZW50cy5wdXNoKHRoaXMuYWNjb3VudEtleXNGcm9tTG9va3Vwcy53cml0YWJsZSk7XG4gICAgICBrZXlTZWdtZW50cy5wdXNoKHRoaXMuYWNjb3VudEtleXNGcm9tTG9va3Vwcy5yZWFkb25seSk7XG4gICAgfVxuICAgIHJldHVybiBrZXlTZWdtZW50cztcbiAgfVxuICBnZXQoaW5kZXgpIHtcbiAgICBmb3IgKGNvbnN0IGtleVNlZ21lbnQgb2YgdGhpcy5rZXlTZWdtZW50cygpKSB7XG4gICAgICBpZiAoaW5kZXggPCBrZXlTZWdtZW50Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4ga2V5U2VnbWVudFtpbmRleF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmRleCAtPSBrZXlTZWdtZW50Lmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGdldCBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMua2V5U2VnbWVudHMoKS5mbGF0KCkubGVuZ3RoO1xuICB9XG4gIGNvbXBpbGVJbnN0cnVjdGlvbnMoaW5zdHJ1Y3Rpb25zKSB7XG4gICAgLy8gQmFpbCBlYXJseSBpZiBhbnkgYWNjb3VudCBpbmRleGVzIHdvdWxkIG92ZXJmbG93IGEgdThcbiAgICBjb25zdCBVOF9NQVggPSAyNTU7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gVThfTUFYICsgMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY2NvdW50IGluZGV4IG92ZXJmbG93IGVuY291bnRlcmVkIGR1cmluZyBjb21waWxhdGlvbicpO1xuICAgIH1cbiAgICBjb25zdCBrZXlJbmRleE1hcCA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmtleVNlZ21lbnRzKCkuZmxhdCgpLmZvckVhY2goKGtleSwgaW5kZXgpID0+IHtcbiAgICAgIGtleUluZGV4TWFwLnNldChrZXkudG9CYXNlNTgoKSwgaW5kZXgpO1xuICAgIH0pO1xuICAgIGNvbnN0IGZpbmRLZXlJbmRleCA9IGtleSA9PiB7XG4gICAgICBjb25zdCBrZXlJbmRleCA9IGtleUluZGV4TWFwLmdldChrZXkudG9CYXNlNTgoKSk7XG4gICAgICBpZiAoa2V5SW5kZXggPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKCdFbmNvdW50ZXJlZCBhbiB1bmtub3duIGluc3RydWN0aW9uIGFjY291bnQga2V5IGR1cmluZyBjb21waWxhdGlvbicpO1xuICAgICAgcmV0dXJuIGtleUluZGV4O1xuICAgIH07XG4gICAgcmV0dXJuIGluc3RydWN0aW9ucy5tYXAoaW5zdHJ1Y3Rpb24gPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJvZ3JhbUlkSW5kZXg6IGZpbmRLZXlJbmRleChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpLFxuICAgICAgICBhY2NvdW50S2V5SW5kZXhlczogaW5zdHJ1Y3Rpb24ua2V5cy5tYXAobWV0YSA9PiBmaW5kS2V5SW5kZXgobWV0YS5wdWJrZXkpKSxcbiAgICAgICAgZGF0YTogaW5zdHJ1Y3Rpb24uZGF0YVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIExheW91dCBmb3IgYSBwdWJsaWMga2V5XG4gKi9cbmNvbnN0IHB1YmxpY0tleSA9IChwcm9wZXJ0eSA9ICdwdWJsaWNLZXknKSA9PiB7XG4gIHJldHVybiBCdWZmZXJMYXlvdXQuYmxvYigzMiwgcHJvcGVydHkpO1xufTtcblxuLyoqXG4gKiBMYXlvdXQgZm9yIGEgc2lnbmF0dXJlXG4gKi9cbmNvbnN0IHNpZ25hdHVyZSA9IChwcm9wZXJ0eSA9ICdzaWduYXR1cmUnKSA9PiB7XG4gIHJldHVybiBCdWZmZXJMYXlvdXQuYmxvYig2NCwgcHJvcGVydHkpO1xufTtcbi8qKlxuICogTGF5b3V0IGZvciBhIFJ1c3QgU3RyaW5nIHR5cGVcbiAqL1xuY29uc3QgcnVzdFN0cmluZyA9IChwcm9wZXJ0eSA9ICdzdHJpbmcnKSA9PiB7XG4gIGNvbnN0IHJzbCA9IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2xlbmd0aCcpLCBCdWZmZXJMYXlvdXQudTMyKCdsZW5ndGhQYWRkaW5nJyksIEJ1ZmZlckxheW91dC5ibG9iKEJ1ZmZlckxheW91dC5vZmZzZXQoQnVmZmVyTGF5b3V0LnUzMigpLCAtOCksICdjaGFycycpXSwgcHJvcGVydHkpO1xuICBjb25zdCBfZGVjb2RlID0gcnNsLmRlY29kZS5iaW5kKHJzbCk7XG4gIGNvbnN0IF9lbmNvZGUgPSByc2wuZW5jb2RlLmJpbmQocnNsKTtcbiAgY29uc3QgcnNsU2hpbSA9IHJzbDtcbiAgcnNsU2hpbS5kZWNvZGUgPSAoYiwgb2Zmc2V0KSA9PiB7XG4gICAgY29uc3QgZGF0YSA9IF9kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgICByZXR1cm4gZGF0YVsnY2hhcnMnXS50b1N0cmluZygpO1xuICB9O1xuICByc2xTaGltLmVuY29kZSA9IChzdHIsIGIsIG9mZnNldCkgPT4ge1xuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICBjaGFyczogQnVmZmVyLmZyb20oc3RyLCAndXRmOCcpXG4gICAgfTtcbiAgICByZXR1cm4gX2VuY29kZShkYXRhLCBiLCBvZmZzZXQpO1xuICB9O1xuICByc2xTaGltLmFsbG9jID0gc3RyID0+IHtcbiAgICByZXR1cm4gQnVmZmVyTGF5b3V0LnUzMigpLnNwYW4gKyBCdWZmZXJMYXlvdXQudTMyKCkuc3BhbiArIEJ1ZmZlci5mcm9tKHN0ciwgJ3V0ZjgnKS5sZW5ndGg7XG4gIH07XG4gIHJldHVybiByc2xTaGltO1xufTtcblxuLyoqXG4gKiBMYXlvdXQgZm9yIGFuIEF1dGhvcml6ZWQgb2JqZWN0XG4gKi9cbmNvbnN0IGF1dGhvcml6ZWQgPSAocHJvcGVydHkgPSAnYXV0aG9yaXplZCcpID0+IHtcbiAgcmV0dXJuIEJ1ZmZlckxheW91dC5zdHJ1Y3QoW3B1YmxpY0tleSgnc3Rha2VyJyksIHB1YmxpY0tleSgnd2l0aGRyYXdlcicpXSwgcHJvcGVydHkpO1xufTtcblxuLyoqXG4gKiBMYXlvdXQgZm9yIGEgTG9ja3VwIG9iamVjdFxuICovXG5jb25zdCBsb2NrdXAgPSAocHJvcGVydHkgPSAnbG9ja3VwJykgPT4ge1xuICByZXR1cm4gQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0Lm5zNjQoJ3VuaXhUaW1lc3RhbXAnKSwgQnVmZmVyTGF5b3V0Lm5zNjQoJ2Vwb2NoJyksIHB1YmxpY0tleSgnY3VzdG9kaWFuJyldLCBwcm9wZXJ0eSk7XG59O1xuXG4vKipcbiAqICBMYXlvdXQgZm9yIGEgVm90ZUluaXQgb2JqZWN0XG4gKi9cbmNvbnN0IHZvdGVJbml0ID0gKHByb3BlcnR5ID0gJ3ZvdGVJbml0JykgPT4ge1xuICByZXR1cm4gQnVmZmVyTGF5b3V0LnN0cnVjdChbcHVibGljS2V5KCdub2RlUHVia2V5JyksIHB1YmxpY0tleSgnYXV0aG9yaXplZFZvdGVyJyksIHB1YmxpY0tleSgnYXV0aG9yaXplZFdpdGhkcmF3ZXInKSwgQnVmZmVyTGF5b3V0LnU4KCdjb21taXNzaW9uJyldLCBwcm9wZXJ0eSk7XG59O1xuXG4vKipcbiAqICBMYXlvdXQgZm9yIGEgVm90ZUF1dGhvcml6ZVdpdGhTZWVkQXJncyBvYmplY3RcbiAqL1xuY29uc3Qgdm90ZUF1dGhvcml6ZVdpdGhTZWVkQXJncyA9IChwcm9wZXJ0eSA9ICd2b3RlQXV0aG9yaXplV2l0aFNlZWRBcmdzJykgPT4ge1xuICByZXR1cm4gQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMigndm90ZUF1dGhvcml6YXRpb25UeXBlJyksIHB1YmxpY0tleSgnY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlPd25lclB1YmtleScpLCBydXN0U3RyaW5nKCdjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleVNlZWQnKSwgcHVibGljS2V5KCduZXdBdXRob3JpemVkJyldLCBwcm9wZXJ0eSk7XG59O1xuZnVuY3Rpb24gZ2V0QWxsb2ModHlwZSwgZmllbGRzKSB7XG4gIGNvbnN0IGdldEl0ZW1BbGxvYyA9IGl0ZW0gPT4ge1xuICAgIGlmIChpdGVtLnNwYW4gPj0gMCkge1xuICAgICAgcmV0dXJuIGl0ZW0uc3BhbjtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBpdGVtLmFsbG9jID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gaXRlbS5hbGxvYyhmaWVsZHNbaXRlbS5wcm9wZXJ0eV0pO1xuICAgIH0gZWxzZSBpZiAoJ2NvdW50JyBpbiBpdGVtICYmICdlbGVtZW50TGF5b3V0JyBpbiBpdGVtKSB7XG4gICAgICBjb25zdCBmaWVsZCA9IGZpZWxkc1tpdGVtLnByb3BlcnR5XTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGZpZWxkKSkge1xuICAgICAgICByZXR1cm4gZmllbGQubGVuZ3RoICogZ2V0SXRlbUFsbG9jKGl0ZW0uZWxlbWVudExheW91dCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgnZmllbGRzJyBpbiBpdGVtKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgYFN0cnVjdHVyZWAgd2hvc2Ugc2l6ZSBuZWVkcyB0byBiZSByZWN1cnNpdmVseSBtZWFzdXJlZC5cbiAgICAgIHJldHVybiBnZXRBbGxvYyh7XG4gICAgICAgIGxheW91dDogaXRlbVxuICAgICAgfSwgZmllbGRzW2l0ZW0ucHJvcGVydHldKTtcbiAgICB9XG4gICAgLy8gQ291bGRuJ3QgZGV0ZXJtaW5lIGFsbG9jYXRlZCBzaXplIG9mIGxheW91dFxuICAgIHJldHVybiAwO1xuICB9O1xuICBsZXQgYWxsb2MgPSAwO1xuICB0eXBlLmxheW91dC5maWVsZHMuZm9yRWFjaChpdGVtID0+IHtcbiAgICBhbGxvYyArPSBnZXRJdGVtQWxsb2MoaXRlbSk7XG4gIH0pO1xuICByZXR1cm4gYWxsb2M7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUxlbmd0aChieXRlcykge1xuICBsZXQgbGVuID0gMDtcbiAgbGV0IHNpemUgPSAwO1xuICBmb3IgKDs7KSB7XG4gICAgbGV0IGVsZW0gPSBieXRlcy5zaGlmdCgpO1xuICAgIGxlbiB8PSAoZWxlbSAmIDB4N2YpIDw8IHNpemUgKiA3O1xuICAgIHNpemUgKz0gMTtcbiAgICBpZiAoKGVsZW0gJiAweDgwKSA9PT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBsZW47XG59XG5mdW5jdGlvbiBlbmNvZGVMZW5ndGgoYnl0ZXMsIGxlbikge1xuICBsZXQgcmVtX2xlbiA9IGxlbjtcbiAgZm9yICg7Oykge1xuICAgIGxldCBlbGVtID0gcmVtX2xlbiAmIDB4N2Y7XG4gICAgcmVtX2xlbiA+Pj0gNztcbiAgICBpZiAocmVtX2xlbiA9PSAwKSB7XG4gICAgICBieXRlcy5wdXNoKGVsZW0pO1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW0gfD0gMHg4MDtcbiAgICAgIGJ5dGVzLnB1c2goZWxlbSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydCAoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UgfHwgJ0Fzc2VydGlvbiBmYWlsZWQnKTtcbiAgfVxufVxuXG5jbGFzcyBDb21waWxlZEtleXMge1xuICBjb25zdHJ1Y3RvcihwYXllciwga2V5TWV0YU1hcCkge1xuICAgIHRoaXMucGF5ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5rZXlNZXRhTWFwID0gdm9pZCAwO1xuICAgIHRoaXMucGF5ZXIgPSBwYXllcjtcbiAgICB0aGlzLmtleU1ldGFNYXAgPSBrZXlNZXRhTWFwO1xuICB9XG4gIHN0YXRpYyBjb21waWxlKGluc3RydWN0aW9ucywgcGF5ZXIpIHtcbiAgICBjb25zdCBrZXlNZXRhTWFwID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGdldE9ySW5zZXJ0RGVmYXVsdCA9IHB1YmtleSA9PiB7XG4gICAgICBjb25zdCBhZGRyZXNzID0gcHVia2V5LnRvQmFzZTU4KCk7XG4gICAgICBsZXQga2V5TWV0YSA9IGtleU1ldGFNYXAuZ2V0KGFkZHJlc3MpO1xuICAgICAgaWYgKGtleU1ldGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBrZXlNZXRhID0ge1xuICAgICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICBpc0ludm9rZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIGtleU1ldGFNYXAuc2V0KGFkZHJlc3MsIGtleU1ldGEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGtleU1ldGE7XG4gICAgfTtcbiAgICBjb25zdCBwYXllcktleU1ldGEgPSBnZXRPckluc2VydERlZmF1bHQocGF5ZXIpO1xuICAgIHBheWVyS2V5TWV0YS5pc1NpZ25lciA9IHRydWU7XG4gICAgcGF5ZXJLZXlNZXRhLmlzV3JpdGFibGUgPSB0cnVlO1xuICAgIGZvciAoY29uc3QgaXggb2YgaW5zdHJ1Y3Rpb25zKSB7XG4gICAgICBnZXRPckluc2VydERlZmF1bHQoaXgucHJvZ3JhbUlkKS5pc0ludm9rZWQgPSB0cnVlO1xuICAgICAgZm9yIChjb25zdCBhY2NvdW50TWV0YSBvZiBpeC5rZXlzKSB7XG4gICAgICAgIGNvbnN0IGtleU1ldGEgPSBnZXRPckluc2VydERlZmF1bHQoYWNjb3VudE1ldGEucHVia2V5KTtcbiAgICAgICAga2V5TWV0YS5pc1NpZ25lciB8fD0gYWNjb3VudE1ldGEuaXNTaWduZXI7XG4gICAgICAgIGtleU1ldGEuaXNXcml0YWJsZSB8fD0gYWNjb3VudE1ldGEuaXNXcml0YWJsZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBDb21waWxlZEtleXMocGF5ZXIsIGtleU1ldGFNYXApO1xuICB9XG4gIGdldE1lc3NhZ2VDb21wb25lbnRzKCkge1xuICAgIGNvbnN0IG1hcEVudHJpZXMgPSBbLi4udGhpcy5rZXlNZXRhTWFwLmVudHJpZXMoKV07XG4gICAgYXNzZXJ0KG1hcEVudHJpZXMubGVuZ3RoIDw9IDI1NiwgJ01heCBzdGF0aWMgYWNjb3VudCBrZXlzIGxlbmd0aCBleGNlZWRlZCcpO1xuICAgIGNvbnN0IHdyaXRhYmxlU2lnbmVycyA9IG1hcEVudHJpZXMuZmlsdGVyKChbLCBtZXRhXSkgPT4gbWV0YS5pc1NpZ25lciAmJiBtZXRhLmlzV3JpdGFibGUpO1xuICAgIGNvbnN0IHJlYWRvbmx5U2lnbmVycyA9IG1hcEVudHJpZXMuZmlsdGVyKChbLCBtZXRhXSkgPT4gbWV0YS5pc1NpZ25lciAmJiAhbWV0YS5pc1dyaXRhYmxlKTtcbiAgICBjb25zdCB3cml0YWJsZU5vblNpZ25lcnMgPSBtYXBFbnRyaWVzLmZpbHRlcigoWywgbWV0YV0pID0+ICFtZXRhLmlzU2lnbmVyICYmIG1ldGEuaXNXcml0YWJsZSk7XG4gICAgY29uc3QgcmVhZG9ubHlOb25TaWduZXJzID0gbWFwRW50cmllcy5maWx0ZXIoKFssIG1ldGFdKSA9PiAhbWV0YS5pc1NpZ25lciAmJiAhbWV0YS5pc1dyaXRhYmxlKTtcbiAgICBjb25zdCBoZWFkZXIgPSB7XG4gICAgICBudW1SZXF1aXJlZFNpZ25hdHVyZXM6IHdyaXRhYmxlU2lnbmVycy5sZW5ndGggKyByZWFkb25seVNpZ25lcnMubGVuZ3RoLFxuICAgICAgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50czogcmVhZG9ubHlTaWduZXJzLmxlbmd0aCxcbiAgICAgIG51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50czogcmVhZG9ubHlOb25TaWduZXJzLmxlbmd0aFxuICAgIH07XG5cbiAgICAvLyBzYW5pdHkgY2hlY2tzXG4gICAge1xuICAgICAgYXNzZXJ0KHdyaXRhYmxlU2lnbmVycy5sZW5ndGggPiAwLCAnRXhwZWN0ZWQgYXQgbGVhc3Qgb25lIHdyaXRhYmxlIHNpZ25lciBrZXknKTtcbiAgICAgIGNvbnN0IFtwYXllckFkZHJlc3NdID0gd3JpdGFibGVTaWduZXJzWzBdO1xuICAgICAgYXNzZXJ0KHBheWVyQWRkcmVzcyA9PT0gdGhpcy5wYXllci50b0Jhc2U1OCgpLCAnRXhwZWN0ZWQgZmlyc3Qgd3JpdGFibGUgc2lnbmVyIGtleSB0byBiZSB0aGUgZmVlIHBheWVyJyk7XG4gICAgfVxuICAgIGNvbnN0IHN0YXRpY0FjY291bnRLZXlzID0gWy4uLndyaXRhYmxlU2lnbmVycy5tYXAoKFthZGRyZXNzXSkgPT4gbmV3IFB1YmxpY0tleShhZGRyZXNzKSksIC4uLnJlYWRvbmx5U2lnbmVycy5tYXAoKFthZGRyZXNzXSkgPT4gbmV3IFB1YmxpY0tleShhZGRyZXNzKSksIC4uLndyaXRhYmxlTm9uU2lnbmVycy5tYXAoKFthZGRyZXNzXSkgPT4gbmV3IFB1YmxpY0tleShhZGRyZXNzKSksIC4uLnJlYWRvbmx5Tm9uU2lnbmVycy5tYXAoKFthZGRyZXNzXSkgPT4gbmV3IFB1YmxpY0tleShhZGRyZXNzKSldO1xuICAgIHJldHVybiBbaGVhZGVyLCBzdGF0aWNBY2NvdW50S2V5c107XG4gIH1cbiAgZXh0cmFjdFRhYmxlTG9va3VwKGxvb2t1cFRhYmxlKSB7XG4gICAgY29uc3QgW3dyaXRhYmxlSW5kZXhlcywgZHJhaW5lZFdyaXRhYmxlS2V5c10gPSB0aGlzLmRyYWluS2V5c0ZvdW5kSW5Mb29rdXBUYWJsZShsb29rdXBUYWJsZS5zdGF0ZS5hZGRyZXNzZXMsIGtleU1ldGEgPT4gIWtleU1ldGEuaXNTaWduZXIgJiYgIWtleU1ldGEuaXNJbnZva2VkICYmIGtleU1ldGEuaXNXcml0YWJsZSk7XG4gICAgY29uc3QgW3JlYWRvbmx5SW5kZXhlcywgZHJhaW5lZFJlYWRvbmx5S2V5c10gPSB0aGlzLmRyYWluS2V5c0ZvdW5kSW5Mb29rdXBUYWJsZShsb29rdXBUYWJsZS5zdGF0ZS5hZGRyZXNzZXMsIGtleU1ldGEgPT4gIWtleU1ldGEuaXNTaWduZXIgJiYgIWtleU1ldGEuaXNJbnZva2VkICYmICFrZXlNZXRhLmlzV3JpdGFibGUpO1xuXG4gICAgLy8gRG9uJ3QgZXh0cmFjdCBsb29rdXAgaWYgbm8ga2V5cyB3ZXJlIGZvdW5kXG4gICAgaWYgKHdyaXRhYmxlSW5kZXhlcy5sZW5ndGggPT09IDAgJiYgcmVhZG9ubHlJbmRleGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gW3tcbiAgICAgIGFjY291bnRLZXk6IGxvb2t1cFRhYmxlLmtleSxcbiAgICAgIHdyaXRhYmxlSW5kZXhlcyxcbiAgICAgIHJlYWRvbmx5SW5kZXhlc1xuICAgIH0sIHtcbiAgICAgIHdyaXRhYmxlOiBkcmFpbmVkV3JpdGFibGVLZXlzLFxuICAgICAgcmVhZG9ubHk6IGRyYWluZWRSZWFkb25seUtleXNcbiAgICB9XTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZHJhaW5LZXlzRm91bmRJbkxvb2t1cFRhYmxlKGxvb2t1cFRhYmxlRW50cmllcywga2V5TWV0YUZpbHRlcikge1xuICAgIGNvbnN0IGxvb2t1cFRhYmxlSW5kZXhlcyA9IG5ldyBBcnJheSgpO1xuICAgIGNvbnN0IGRyYWluZWRLZXlzID0gbmV3IEFycmF5KCk7XG4gICAgZm9yIChjb25zdCBbYWRkcmVzcywga2V5TWV0YV0gb2YgdGhpcy5rZXlNZXRhTWFwLmVudHJpZXMoKSkge1xuICAgICAgaWYgKGtleU1ldGFGaWx0ZXIoa2V5TWV0YSkpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gbmV3IFB1YmxpY0tleShhZGRyZXNzKTtcbiAgICAgICAgY29uc3QgbG9va3VwVGFibGVJbmRleCA9IGxvb2t1cFRhYmxlRW50cmllcy5maW5kSW5kZXgoZW50cnkgPT4gZW50cnkuZXF1YWxzKGtleSkpO1xuICAgICAgICBpZiAobG9va3VwVGFibGVJbmRleCA+PSAwKSB7XG4gICAgICAgICAgYXNzZXJ0KGxvb2t1cFRhYmxlSW5kZXggPCAyNTYsICdNYXggbG9va3VwIHRhYmxlIGluZGV4IGV4Y2VlZGVkJyk7XG4gICAgICAgICAgbG9va3VwVGFibGVJbmRleGVzLnB1c2gobG9va3VwVGFibGVJbmRleCk7XG4gICAgICAgICAgZHJhaW5lZEtleXMucHVzaChrZXkpO1xuICAgICAgICAgIHRoaXMua2V5TWV0YU1hcC5kZWxldGUoYWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtsb29rdXBUYWJsZUluZGV4ZXMsIGRyYWluZWRLZXlzXTtcbiAgfVxufVxuXG5jb25zdCBFTkRfT0ZfQlVGRkVSX0VSUk9SX01FU1NBR0UgPSAnUmVhY2hlZCBlbmQgb2YgYnVmZmVyIHVuZXhwZWN0ZWRseSc7XG5cbi8qKlxuICogRGVsZWdhdGVzIHRvIGBBcnJheSNzaGlmdGAsIGJ1dCB0aHJvd3MgaWYgdGhlIGFycmF5IGlzIHplcm8tbGVuZ3RoLlxuICovXG5mdW5jdGlvbiBndWFyZGVkU2hpZnQoYnl0ZUFycmF5KSB7XG4gIGlmIChieXRlQXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKEVORF9PRl9CVUZGRVJfRVJST1JfTUVTU0FHRSk7XG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheS5zaGlmdCgpO1xufVxuXG4vKipcbiAqIERlbGVnYXRlcyB0byBgQXJyYXkjc3BsaWNlYCwgYnV0IHRocm93cyBpZiB0aGUgc2VjdGlvbiBiZWluZyBzcGxpY2VkIG91dCBleHRlbmRzIHBhc3QgdGhlIGVuZCBvZlxuICogdGhlIGFycmF5LlxuICovXG5mdW5jdGlvbiBndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgLi4uYXJncykge1xuICBjb25zdCBbc3RhcnRdID0gYXJncztcbiAgaWYgKGFyZ3MubGVuZ3RoID09PSAyIC8vIEltcGxpZXMgdGhhdCBgZGVsZXRlQ291bnRgIHdhcyBzdXBwbGllZFxuICA/IHN0YXJ0ICsgKGFyZ3NbMV0gPz8gMCkgPiBieXRlQXJyYXkubGVuZ3RoIDogc3RhcnQgPj0gYnl0ZUFycmF5Lmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihFTkRfT0ZfQlVGRkVSX0VSUk9SX01FU1NBR0UpO1xuICB9XG4gIHJldHVybiBieXRlQXJyYXkuc3BsaWNlKC4uLmFyZ3MpO1xufVxuXG4vKipcbiAqIEFuIGluc3RydWN0aW9uIHRvIGV4ZWN1dGUgYnkgYSBwcm9ncmFtXG4gKlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHByb2dyYW1JZEluZGV4XG4gKiBAcHJvcGVydHkge251bWJlcltdfSBhY2NvdW50c1xuICogQHByb3BlcnR5IHtzdHJpbmd9IGRhdGFcbiAqL1xuXG4vKipcbiAqIE1lc3NhZ2UgY29uc3RydWN0b3IgYXJndW1lbnRzXG4gKi9cblxuLyoqXG4gKiBMaXN0IG9mIGluc3RydWN0aW9ucyB0byBiZSBwcm9jZXNzZWQgYXRvbWljYWxseVxuICovXG5jbGFzcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoYXJncykge1xuICAgIHRoaXMuaGVhZGVyID0gdm9pZCAwO1xuICAgIHRoaXMuYWNjb3VudEtleXMgPSB2b2lkIDA7XG4gICAgdGhpcy5yZWNlbnRCbG9ja2hhc2ggPSB2b2lkIDA7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMgPSB2b2lkIDA7XG4gICAgdGhpcy5pbmRleFRvUHJvZ3JhbUlkcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmhlYWRlciA9IGFyZ3MuaGVhZGVyO1xuICAgIHRoaXMuYWNjb3VudEtleXMgPSBhcmdzLmFjY291bnRLZXlzLm1hcChhY2NvdW50ID0+IG5ldyBQdWJsaWNLZXkoYWNjb3VudCkpO1xuICAgIHRoaXMucmVjZW50QmxvY2toYXNoID0gYXJncy5yZWNlbnRCbG9ja2hhc2g7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMgPSBhcmdzLmluc3RydWN0aW9ucztcbiAgICB0aGlzLmluc3RydWN0aW9ucy5mb3JFYWNoKGl4ID0+IHRoaXMuaW5kZXhUb1Byb2dyYW1JZHMuc2V0KGl4LnByb2dyYW1JZEluZGV4LCB0aGlzLmFjY291bnRLZXlzW2l4LnByb2dyYW1JZEluZGV4XSkpO1xuICB9XG4gIGdldCB2ZXJzaW9uKCkge1xuICAgIHJldHVybiAnbGVnYWN5JztcbiAgfVxuICBnZXQgc3RhdGljQWNjb3VudEtleXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWNjb3VudEtleXM7XG4gIH1cbiAgZ2V0IGNvbXBpbGVkSW5zdHJ1Y3Rpb25zKCkge1xuICAgIHJldHVybiB0aGlzLmluc3RydWN0aW9ucy5tYXAoaXggPT4gKHtcbiAgICAgIHByb2dyYW1JZEluZGV4OiBpeC5wcm9ncmFtSWRJbmRleCxcbiAgICAgIGFjY291bnRLZXlJbmRleGVzOiBpeC5hY2NvdW50cyxcbiAgICAgIGRhdGE6IGJzNTguZGVjb2RlKGl4LmRhdGEpXG4gICAgfSkpO1xuICB9XG4gIGdldCBhZGRyZXNzVGFibGVMb29rdXBzKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBnZXRBY2NvdW50S2V5cygpIHtcbiAgICByZXR1cm4gbmV3IE1lc3NhZ2VBY2NvdW50S2V5cyh0aGlzLnN0YXRpY0FjY291bnRLZXlzKTtcbiAgfVxuICBzdGF0aWMgY29tcGlsZShhcmdzKSB7XG4gICAgY29uc3QgY29tcGlsZWRLZXlzID0gQ29tcGlsZWRLZXlzLmNvbXBpbGUoYXJncy5pbnN0cnVjdGlvbnMsIGFyZ3MucGF5ZXJLZXkpO1xuICAgIGNvbnN0IFtoZWFkZXIsIHN0YXRpY0FjY291bnRLZXlzXSA9IGNvbXBpbGVkS2V5cy5nZXRNZXNzYWdlQ29tcG9uZW50cygpO1xuICAgIGNvbnN0IGFjY291bnRLZXlzID0gbmV3IE1lc3NhZ2VBY2NvdW50S2V5cyhzdGF0aWNBY2NvdW50S2V5cyk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25zID0gYWNjb3VudEtleXMuY29tcGlsZUluc3RydWN0aW9ucyhhcmdzLmluc3RydWN0aW9ucykubWFwKGl4ID0+ICh7XG4gICAgICBwcm9ncmFtSWRJbmRleDogaXgucHJvZ3JhbUlkSW5kZXgsXG4gICAgICBhY2NvdW50czogaXguYWNjb3VudEtleUluZGV4ZXMsXG4gICAgICBkYXRhOiBiczU4LmVuY29kZShpeC5kYXRhKVxuICAgIH0pKTtcbiAgICByZXR1cm4gbmV3IE1lc3NhZ2Uoe1xuICAgICAgaGVhZGVyLFxuICAgICAgYWNjb3VudEtleXM6IHN0YXRpY0FjY291bnRLZXlzLFxuICAgICAgcmVjZW50QmxvY2toYXNoOiBhcmdzLnJlY2VudEJsb2NraGFzaCxcbiAgICAgIGluc3RydWN0aW9uc1xuICAgIH0pO1xuICB9XG4gIGlzQWNjb3VudFNpZ25lcihpbmRleCkge1xuICAgIHJldHVybiBpbmRleCA8IHRoaXMuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcztcbiAgfVxuICBpc0FjY291bnRXcml0YWJsZShpbmRleCkge1xuICAgIGNvbnN0IG51bVNpZ25lZEFjY291bnRzID0gdGhpcy5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzO1xuICAgIGlmIChpbmRleCA+PSB0aGlzLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXMpIHtcbiAgICAgIGNvbnN0IHVuc2lnbmVkQWNjb3VudEluZGV4ID0gaW5kZXggLSBudW1TaWduZWRBY2NvdW50cztcbiAgICAgIGNvbnN0IG51bVVuc2lnbmVkQWNjb3VudHMgPSB0aGlzLmFjY291bnRLZXlzLmxlbmd0aCAtIG51bVNpZ25lZEFjY291bnRzO1xuICAgICAgY29uc3QgbnVtV3JpdGFibGVVbnNpZ25lZEFjY291bnRzID0gbnVtVW5zaWduZWRBY2NvdW50cyAtIHRoaXMuaGVhZGVyLm51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50cztcbiAgICAgIHJldHVybiB1bnNpZ25lZEFjY291bnRJbmRleCA8IG51bVdyaXRhYmxlVW5zaWduZWRBY2NvdW50cztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbnVtV3JpdGFibGVTaWduZWRBY2NvdW50cyA9IG51bVNpZ25lZEFjY291bnRzIC0gdGhpcy5oZWFkZXIubnVtUmVhZG9ubHlTaWduZWRBY2NvdW50cztcbiAgICAgIHJldHVybiBpbmRleCA8IG51bVdyaXRhYmxlU2lnbmVkQWNjb3VudHM7XG4gICAgfVxuICB9XG4gIGlzUHJvZ3JhbUlkKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXhUb1Byb2dyYW1JZHMuaGFzKGluZGV4KTtcbiAgfVxuICBwcm9ncmFtSWRzKCkge1xuICAgIHJldHVybiBbLi4udGhpcy5pbmRleFRvUHJvZ3JhbUlkcy52YWx1ZXMoKV07XG4gIH1cbiAgbm9uUHJvZ3JhbUlkcygpIHtcbiAgICByZXR1cm4gdGhpcy5hY2NvdW50S2V5cy5maWx0ZXIoKF8sIGluZGV4KSA9PiAhdGhpcy5pc1Byb2dyYW1JZChpbmRleCkpO1xuICB9XG4gIHNlcmlhbGl6ZSgpIHtcbiAgICBjb25zdCBudW1LZXlzID0gdGhpcy5hY2NvdW50S2V5cy5sZW5ndGg7XG4gICAgbGV0IGtleUNvdW50ID0gW107XG4gICAgZW5jb2RlTGVuZ3RoKGtleUNvdW50LCBudW1LZXlzKTtcbiAgICBjb25zdCBpbnN0cnVjdGlvbnMgPSB0aGlzLmluc3RydWN0aW9ucy5tYXAoaW5zdHJ1Y3Rpb24gPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBhY2NvdW50cyxcbiAgICAgICAgcHJvZ3JhbUlkSW5kZXhcbiAgICAgIH0gPSBpbnN0cnVjdGlvbjtcbiAgICAgIGNvbnN0IGRhdGEgPSBBcnJheS5mcm9tKGJzNTguZGVjb2RlKGluc3RydWN0aW9uLmRhdGEpKTtcbiAgICAgIGxldCBrZXlJbmRpY2VzQ291bnQgPSBbXTtcbiAgICAgIGVuY29kZUxlbmd0aChrZXlJbmRpY2VzQ291bnQsIGFjY291bnRzLmxlbmd0aCk7XG4gICAgICBsZXQgZGF0YUNvdW50ID0gW107XG4gICAgICBlbmNvZGVMZW5ndGgoZGF0YUNvdW50LCBkYXRhLmxlbmd0aCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm9ncmFtSWRJbmRleCxcbiAgICAgICAga2V5SW5kaWNlc0NvdW50OiBCdWZmZXIuZnJvbShrZXlJbmRpY2VzQ291bnQpLFxuICAgICAgICBrZXlJbmRpY2VzOiBhY2NvdW50cyxcbiAgICAgICAgZGF0YUxlbmd0aDogQnVmZmVyLmZyb20oZGF0YUNvdW50KSxcbiAgICAgICAgZGF0YVxuICAgICAgfTtcbiAgICB9KTtcbiAgICBsZXQgaW5zdHJ1Y3Rpb25Db3VudCA9IFtdO1xuICAgIGVuY29kZUxlbmd0aChpbnN0cnVjdGlvbkNvdW50LCBpbnN0cnVjdGlvbnMubGVuZ3RoKTtcbiAgICBsZXQgaW5zdHJ1Y3Rpb25CdWZmZXIgPSBCdWZmZXIuYWxsb2MoUEFDS0VUX0RBVEFfU0laRSk7XG4gICAgQnVmZmVyLmZyb20oaW5zdHJ1Y3Rpb25Db3VudCkuY29weShpbnN0cnVjdGlvbkJ1ZmZlcik7XG4gICAgbGV0IGluc3RydWN0aW9uQnVmZmVyTGVuZ3RoID0gaW5zdHJ1Y3Rpb25Db3VudC5sZW5ndGg7XG4gICAgaW5zdHJ1Y3Rpb25zLmZvckVhY2goaW5zdHJ1Y3Rpb24gPT4ge1xuICAgICAgY29uc3QgaW5zdHJ1Y3Rpb25MYXlvdXQgPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTgoJ3Byb2dyYW1JZEluZGV4JyksIEJ1ZmZlckxheW91dC5ibG9iKGluc3RydWN0aW9uLmtleUluZGljZXNDb3VudC5sZW5ndGgsICdrZXlJbmRpY2VzQ291bnQnKSwgQnVmZmVyTGF5b3V0LnNlcShCdWZmZXJMYXlvdXQudTgoJ2tleUluZGV4JyksIGluc3RydWN0aW9uLmtleUluZGljZXMubGVuZ3RoLCAna2V5SW5kaWNlcycpLCBCdWZmZXJMYXlvdXQuYmxvYihpbnN0cnVjdGlvbi5kYXRhTGVuZ3RoLmxlbmd0aCwgJ2RhdGFMZW5ndGgnKSwgQnVmZmVyTGF5b3V0LnNlcShCdWZmZXJMYXlvdXQudTgoJ3VzZXJkYXR1bScpLCBpbnN0cnVjdGlvbi5kYXRhLmxlbmd0aCwgJ2RhdGEnKV0pO1xuICAgICAgY29uc3QgbGVuZ3RoID0gaW5zdHJ1Y3Rpb25MYXlvdXQuZW5jb2RlKGluc3RydWN0aW9uLCBpbnN0cnVjdGlvbkJ1ZmZlciwgaW5zdHJ1Y3Rpb25CdWZmZXJMZW5ndGgpO1xuICAgICAgaW5zdHJ1Y3Rpb25CdWZmZXJMZW5ndGggKz0gbGVuZ3RoO1xuICAgIH0pO1xuICAgIGluc3RydWN0aW9uQnVmZmVyID0gaW5zdHJ1Y3Rpb25CdWZmZXIuc2xpY2UoMCwgaW5zdHJ1Y3Rpb25CdWZmZXJMZW5ndGgpO1xuICAgIGNvbnN0IHNpZ25EYXRhTGF5b3V0ID0gQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LmJsb2IoMSwgJ251bVJlcXVpcmVkU2lnbmF0dXJlcycpLCBCdWZmZXJMYXlvdXQuYmxvYigxLCAnbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50cycpLCBCdWZmZXJMYXlvdXQuYmxvYigxLCAnbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzJyksIEJ1ZmZlckxheW91dC5ibG9iKGtleUNvdW50Lmxlbmd0aCwgJ2tleUNvdW50JyksIEJ1ZmZlckxheW91dC5zZXEocHVibGljS2V5KCdrZXknKSwgbnVtS2V5cywgJ2tleXMnKSwgcHVibGljS2V5KCdyZWNlbnRCbG9ja2hhc2gnKV0pO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0ge1xuICAgICAgbnVtUmVxdWlyZWRTaWduYXR1cmVzOiBCdWZmZXIuZnJvbShbdGhpcy5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzXSksXG4gICAgICBudW1SZWFkb25seVNpZ25lZEFjY291bnRzOiBCdWZmZXIuZnJvbShbdGhpcy5oZWFkZXIubnVtUmVhZG9ubHlTaWduZWRBY2NvdW50c10pLFxuICAgICAgbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzOiBCdWZmZXIuZnJvbShbdGhpcy5oZWFkZXIubnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzXSksXG4gICAgICBrZXlDb3VudDogQnVmZmVyLmZyb20oa2V5Q291bnQpLFxuICAgICAga2V5czogdGhpcy5hY2NvdW50S2V5cy5tYXAoa2V5ID0+IHRvQnVmZmVyKGtleS50b0J5dGVzKCkpKSxcbiAgICAgIHJlY2VudEJsb2NraGFzaDogYnM1OC5kZWNvZGUodGhpcy5yZWNlbnRCbG9ja2hhc2gpXG4gICAgfTtcbiAgICBsZXQgc2lnbkRhdGEgPSBCdWZmZXIuYWxsb2MoMjA0OCk7XG4gICAgY29uc3QgbGVuZ3RoID0gc2lnbkRhdGFMYXlvdXQuZW5jb2RlKHRyYW5zYWN0aW9uLCBzaWduRGF0YSk7XG4gICAgaW5zdHJ1Y3Rpb25CdWZmZXIuY29weShzaWduRGF0YSwgbGVuZ3RoKTtcbiAgICByZXR1cm4gc2lnbkRhdGEuc2xpY2UoMCwgbGVuZ3RoICsgaW5zdHJ1Y3Rpb25CdWZmZXIubGVuZ3RoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBjb21waWxlZCBtZXNzYWdlIGludG8gYSBNZXNzYWdlIG9iamVjdC5cbiAgICovXG4gIHN0YXRpYyBmcm9tKGJ1ZmZlcikge1xuICAgIC8vIFNsaWNlIHVwIHdpcmUgZGF0YVxuICAgIGxldCBieXRlQXJyYXkgPSBbLi4uYnVmZmVyXTtcbiAgICBjb25zdCBudW1SZXF1aXJlZFNpZ25hdHVyZXMgPSBndWFyZGVkU2hpZnQoYnl0ZUFycmF5KTtcbiAgICBpZiAobnVtUmVxdWlyZWRTaWduYXR1cmVzICE9PSAobnVtUmVxdWlyZWRTaWduYXR1cmVzICYgVkVSU0lPTl9QUkVGSVhfTUFTSykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVmVyc2lvbmVkIG1lc3NhZ2VzIG11c3QgYmUgZGVzZXJpYWxpemVkIHdpdGggVmVyc2lvbmVkTWVzc2FnZS5kZXNlcmlhbGl6ZSgpJyk7XG4gICAgfVxuICAgIGNvbnN0IG51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHMgPSBndWFyZGVkU2hpZnQoYnl0ZUFycmF5KTtcbiAgICBjb25zdCBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHMgPSBndWFyZGVkU2hpZnQoYnl0ZUFycmF5KTtcbiAgICBjb25zdCBhY2NvdW50Q291bnQgPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICBsZXQgYWNjb3VudEtleXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFjY291bnRDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBhY2NvdW50ID0gZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIDAsIFBVQkxJQ19LRVlfTEVOR1RIKTtcbiAgICAgIGFjY291bnRLZXlzLnB1c2gobmV3IFB1YmxpY0tleShCdWZmZXIuZnJvbShhY2NvdW50KSkpO1xuICAgIH1cbiAgICBjb25zdCByZWNlbnRCbG9ja2hhc2ggPSBndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgUFVCTElDX0tFWV9MRU5HVEgpO1xuICAgIGNvbnN0IGluc3RydWN0aW9uQ291bnQgPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICBsZXQgaW5zdHJ1Y3Rpb25zID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnN0cnVjdGlvbkNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHByb2dyYW1JZEluZGV4ID0gZ3VhcmRlZFNoaWZ0KGJ5dGVBcnJheSk7XG4gICAgICBjb25zdCBhY2NvdW50Q291bnQgPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICAgIGNvbnN0IGFjY291bnRzID0gZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIDAsIGFjY291bnRDb3VudCk7XG4gICAgICBjb25zdCBkYXRhTGVuZ3RoID0gZGVjb2RlTGVuZ3RoKGJ5dGVBcnJheSk7XG4gICAgICBjb25zdCBkYXRhU2xpY2UgPSBndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgZGF0YUxlbmd0aCk7XG4gICAgICBjb25zdCBkYXRhID0gYnM1OC5lbmNvZGUoQnVmZmVyLmZyb20oZGF0YVNsaWNlKSk7XG4gICAgICBpbnN0cnVjdGlvbnMucHVzaCh7XG4gICAgICAgIHByb2dyYW1JZEluZGV4LFxuICAgICAgICBhY2NvdW50cyxcbiAgICAgICAgZGF0YVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2VBcmdzID0ge1xuICAgICAgaGVhZGVyOiB7XG4gICAgICAgIG51bVJlcXVpcmVkU2lnbmF0dXJlcyxcbiAgICAgICAgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50cyxcbiAgICAgICAgbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzXG4gICAgICB9LFxuICAgICAgcmVjZW50QmxvY2toYXNoOiBiczU4LmVuY29kZShCdWZmZXIuZnJvbShyZWNlbnRCbG9ja2hhc2gpKSxcbiAgICAgIGFjY291bnRLZXlzLFxuICAgICAgaW5zdHJ1Y3Rpb25zXG4gICAgfTtcbiAgICByZXR1cm4gbmV3IE1lc3NhZ2UobWVzc2FnZUFyZ3MpO1xuICB9XG59XG5cbi8qKlxuICogTWVzc2FnZSBjb25zdHJ1Y3RvciBhcmd1bWVudHNcbiAqL1xuXG5jbGFzcyBNZXNzYWdlVjAge1xuICBjb25zdHJ1Y3RvcihhcmdzKSB7XG4gICAgdGhpcy5oZWFkZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5zdGF0aWNBY2NvdW50S2V5cyA9IHZvaWQgMDtcbiAgICB0aGlzLnJlY2VudEJsb2NraGFzaCA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbXBpbGVkSW5zdHJ1Y3Rpb25zID0gdm9pZCAwO1xuICAgIHRoaXMuYWRkcmVzc1RhYmxlTG9va3VwcyA9IHZvaWQgMDtcbiAgICB0aGlzLmhlYWRlciA9IGFyZ3MuaGVhZGVyO1xuICAgIHRoaXMuc3RhdGljQWNjb3VudEtleXMgPSBhcmdzLnN0YXRpY0FjY291bnRLZXlzO1xuICAgIHRoaXMucmVjZW50QmxvY2toYXNoID0gYXJncy5yZWNlbnRCbG9ja2hhc2g7XG4gICAgdGhpcy5jb21waWxlZEluc3RydWN0aW9ucyA9IGFyZ3MuY29tcGlsZWRJbnN0cnVjdGlvbnM7XG4gICAgdGhpcy5hZGRyZXNzVGFibGVMb29rdXBzID0gYXJncy5hZGRyZXNzVGFibGVMb29rdXBzO1xuICB9XG4gIGdldCB2ZXJzaW9uKCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGdldCBudW1BY2NvdW50S2V5c0Zyb21Mb29rdXBzKCkge1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgZm9yIChjb25zdCBsb29rdXAgb2YgdGhpcy5hZGRyZXNzVGFibGVMb29rdXBzKSB7XG4gICAgICBjb3VudCArPSBsb29rdXAucmVhZG9ubHlJbmRleGVzLmxlbmd0aCArIGxvb2t1cC53cml0YWJsZUluZGV4ZXMubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gY291bnQ7XG4gIH1cbiAgZ2V0QWNjb3VudEtleXMoYXJncykge1xuICAgIGxldCBhY2NvdW50S2V5c0Zyb21Mb29rdXBzO1xuICAgIGlmIChhcmdzICYmICdhY2NvdW50S2V5c0Zyb21Mb29rdXBzJyBpbiBhcmdzICYmIGFyZ3MuYWNjb3VudEtleXNGcm9tTG9va3Vwcykge1xuICAgICAgaWYgKHRoaXMubnVtQWNjb3VudEtleXNGcm9tTG9va3VwcyAhPSBhcmdzLmFjY291bnRLZXlzRnJvbUxvb2t1cHMud3JpdGFibGUubGVuZ3RoICsgYXJncy5hY2NvdW50S2V5c0Zyb21Mb29rdXBzLnJlYWRvbmx5Lmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBnZXQgYWNjb3VudCBrZXlzIGJlY2F1c2Ugb2YgYSBtaXNtYXRjaCBpbiB0aGUgbnVtYmVyIG9mIGFjY291bnQga2V5cyBmcm9tIGxvb2t1cHMnKTtcbiAgICAgIH1cbiAgICAgIGFjY291bnRLZXlzRnJvbUxvb2t1cHMgPSBhcmdzLmFjY291bnRLZXlzRnJvbUxvb2t1cHM7XG4gICAgfSBlbHNlIGlmIChhcmdzICYmICdhZGRyZXNzTG9va3VwVGFibGVBY2NvdW50cycgaW4gYXJncyAmJiBhcmdzLmFkZHJlc3NMb29rdXBUYWJsZUFjY291bnRzKSB7XG4gICAgICBhY2NvdW50S2V5c0Zyb21Mb29rdXBzID0gdGhpcy5yZXNvbHZlQWRkcmVzc1RhYmxlTG9va3VwcyhhcmdzLmFkZHJlc3NMb29rdXBUYWJsZUFjY291bnRzKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuYWRkcmVzc1RhYmxlTG9va3Vwcy5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBnZXQgYWNjb3VudCBrZXlzIGJlY2F1c2UgYWRkcmVzcyB0YWJsZSBsb29rdXBzIHdlcmUgbm90IHJlc29sdmVkJyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTWVzc2FnZUFjY291bnRLZXlzKHRoaXMuc3RhdGljQWNjb3VudEtleXMsIGFjY291bnRLZXlzRnJvbUxvb2t1cHMpO1xuICB9XG4gIGlzQWNjb3VudFNpZ25lcihpbmRleCkge1xuICAgIHJldHVybiBpbmRleCA8IHRoaXMuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcztcbiAgfVxuICBpc0FjY291bnRXcml0YWJsZShpbmRleCkge1xuICAgIGNvbnN0IG51bVNpZ25lZEFjY291bnRzID0gdGhpcy5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzO1xuICAgIGNvbnN0IG51bVN0YXRpY0FjY291bnRLZXlzID0gdGhpcy5zdGF0aWNBY2NvdW50S2V5cy5sZW5ndGg7XG4gICAgaWYgKGluZGV4ID49IG51bVN0YXRpY0FjY291bnRLZXlzKSB7XG4gICAgICBjb25zdCBsb29rdXBBY2NvdW50S2V5c0luZGV4ID0gaW5kZXggLSBudW1TdGF0aWNBY2NvdW50S2V5cztcbiAgICAgIGNvbnN0IG51bVdyaXRhYmxlTG9va3VwQWNjb3VudEtleXMgPSB0aGlzLmFkZHJlc3NUYWJsZUxvb2t1cHMucmVkdWNlKChjb3VudCwgbG9va3VwKSA9PiBjb3VudCArIGxvb2t1cC53cml0YWJsZUluZGV4ZXMubGVuZ3RoLCAwKTtcbiAgICAgIHJldHVybiBsb29rdXBBY2NvdW50S2V5c0luZGV4IDwgbnVtV3JpdGFibGVMb29rdXBBY2NvdW50S2V5cztcbiAgICB9IGVsc2UgaWYgKGluZGV4ID49IHRoaXMuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcykge1xuICAgICAgY29uc3QgdW5zaWduZWRBY2NvdW50SW5kZXggPSBpbmRleCAtIG51bVNpZ25lZEFjY291bnRzO1xuICAgICAgY29uc3QgbnVtVW5zaWduZWRBY2NvdW50cyA9IG51bVN0YXRpY0FjY291bnRLZXlzIC0gbnVtU2lnbmVkQWNjb3VudHM7XG4gICAgICBjb25zdCBudW1Xcml0YWJsZVVuc2lnbmVkQWNjb3VudHMgPSBudW1VbnNpZ25lZEFjY291bnRzIC0gdGhpcy5oZWFkZXIubnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzO1xuICAgICAgcmV0dXJuIHVuc2lnbmVkQWNjb3VudEluZGV4IDwgbnVtV3JpdGFibGVVbnNpZ25lZEFjY291bnRzO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBudW1Xcml0YWJsZVNpZ25lZEFjY291bnRzID0gbnVtU2lnbmVkQWNjb3VudHMgLSB0aGlzLmhlYWRlci5udW1SZWFkb25seVNpZ25lZEFjY291bnRzO1xuICAgICAgcmV0dXJuIGluZGV4IDwgbnVtV3JpdGFibGVTaWduZWRBY2NvdW50cztcbiAgICB9XG4gIH1cbiAgcmVzb2x2ZUFkZHJlc3NUYWJsZUxvb2t1cHMoYWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudHMpIHtcbiAgICBjb25zdCBhY2NvdW50S2V5c0Zyb21Mb29rdXBzID0ge1xuICAgICAgd3JpdGFibGU6IFtdLFxuICAgICAgcmVhZG9ubHk6IFtdXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IHRhYmxlTG9va3VwIG9mIHRoaXMuYWRkcmVzc1RhYmxlTG9va3Vwcykge1xuICAgICAgY29uc3QgdGFibGVBY2NvdW50ID0gYWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudHMuZmluZChhY2NvdW50ID0+IGFjY291bnQua2V5LmVxdWFscyh0YWJsZUxvb2t1cC5hY2NvdW50S2V5KSk7XG4gICAgICBpZiAoIXRhYmxlQWNjb3VudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmaW5kIGFkZHJlc3MgbG9va3VwIHRhYmxlIGFjY291bnQgZm9yIHRhYmxlIGtleSAke3RhYmxlTG9va3VwLmFjY291bnRLZXkudG9CYXNlNTgoKX1gKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgaW5kZXggb2YgdGFibGVMb29rdXAud3JpdGFibGVJbmRleGVzKSB7XG4gICAgICAgIGlmIChpbmRleCA8IHRhYmxlQWNjb3VudC5zdGF0ZS5hZGRyZXNzZXMubGVuZ3RoKSB7XG4gICAgICAgICAgYWNjb3VudEtleXNGcm9tTG9va3Vwcy53cml0YWJsZS5wdXNoKHRhYmxlQWNjb3VudC5zdGF0ZS5hZGRyZXNzZXNbaW5kZXhdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmaW5kIGFkZHJlc3MgZm9yIGluZGV4ICR7aW5kZXh9IGluIGFkZHJlc3MgbG9va3VwIHRhYmxlICR7dGFibGVMb29rdXAuYWNjb3VudEtleS50b0Jhc2U1OCgpfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGluZGV4IG9mIHRhYmxlTG9va3VwLnJlYWRvbmx5SW5kZXhlcykge1xuICAgICAgICBpZiAoaW5kZXggPCB0YWJsZUFjY291bnQuc3RhdGUuYWRkcmVzc2VzLmxlbmd0aCkge1xuICAgICAgICAgIGFjY291bnRLZXlzRnJvbUxvb2t1cHMucmVhZG9ubHkucHVzaCh0YWJsZUFjY291bnQuc3RhdGUuYWRkcmVzc2VzW2luZGV4XSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmluZCBhZGRyZXNzIGZvciBpbmRleCAke2luZGV4fSBpbiBhZGRyZXNzIGxvb2t1cCB0YWJsZSAke3RhYmxlTG9va3VwLmFjY291bnRLZXkudG9CYXNlNTgoKX1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYWNjb3VudEtleXNGcm9tTG9va3VwcztcbiAgfVxuICBzdGF0aWMgY29tcGlsZShhcmdzKSB7XG4gICAgY29uc3QgY29tcGlsZWRLZXlzID0gQ29tcGlsZWRLZXlzLmNvbXBpbGUoYXJncy5pbnN0cnVjdGlvbnMsIGFyZ3MucGF5ZXJLZXkpO1xuICAgIGNvbnN0IGFkZHJlc3NUYWJsZUxvb2t1cHMgPSBuZXcgQXJyYXkoKTtcbiAgICBjb25zdCBhY2NvdW50S2V5c0Zyb21Mb29rdXBzID0ge1xuICAgICAgd3JpdGFibGU6IG5ldyBBcnJheSgpLFxuICAgICAgcmVhZG9ubHk6IG5ldyBBcnJheSgpXG4gICAgfTtcbiAgICBjb25zdCBsb29rdXBUYWJsZUFjY291bnRzID0gYXJncy5hZGRyZXNzTG9va3VwVGFibGVBY2NvdW50cyB8fCBbXTtcbiAgICBmb3IgKGNvbnN0IGxvb2t1cFRhYmxlIG9mIGxvb2t1cFRhYmxlQWNjb3VudHMpIHtcbiAgICAgIGNvbnN0IGV4dHJhY3RSZXN1bHQgPSBjb21waWxlZEtleXMuZXh0cmFjdFRhYmxlTG9va3VwKGxvb2t1cFRhYmxlKTtcbiAgICAgIGlmIChleHRyYWN0UmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgW2FkZHJlc3NUYWJsZUxvb2t1cCwge1xuICAgICAgICAgIHdyaXRhYmxlLFxuICAgICAgICAgIHJlYWRvbmx5XG4gICAgICAgIH1dID0gZXh0cmFjdFJlc3VsdDtcbiAgICAgICAgYWRkcmVzc1RhYmxlTG9va3Vwcy5wdXNoKGFkZHJlc3NUYWJsZUxvb2t1cCk7XG4gICAgICAgIGFjY291bnRLZXlzRnJvbUxvb2t1cHMud3JpdGFibGUucHVzaCguLi53cml0YWJsZSk7XG4gICAgICAgIGFjY291bnRLZXlzRnJvbUxvb2t1cHMucmVhZG9ubHkucHVzaCguLi5yZWFkb25seSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IFtoZWFkZXIsIHN0YXRpY0FjY291bnRLZXlzXSA9IGNvbXBpbGVkS2V5cy5nZXRNZXNzYWdlQ29tcG9uZW50cygpO1xuICAgIGNvbnN0IGFjY291bnRLZXlzID0gbmV3IE1lc3NhZ2VBY2NvdW50S2V5cyhzdGF0aWNBY2NvdW50S2V5cywgYWNjb3VudEtleXNGcm9tTG9va3Vwcyk7XG4gICAgY29uc3QgY29tcGlsZWRJbnN0cnVjdGlvbnMgPSBhY2NvdW50S2V5cy5jb21waWxlSW5zdHJ1Y3Rpb25zKGFyZ3MuaW5zdHJ1Y3Rpb25zKTtcbiAgICByZXR1cm4gbmV3IE1lc3NhZ2VWMCh7XG4gICAgICBoZWFkZXIsXG4gICAgICBzdGF0aWNBY2NvdW50S2V5cyxcbiAgICAgIHJlY2VudEJsb2NraGFzaDogYXJncy5yZWNlbnRCbG9ja2hhc2gsXG4gICAgICBjb21waWxlZEluc3RydWN0aW9ucyxcbiAgICAgIGFkZHJlc3NUYWJsZUxvb2t1cHNcbiAgICB9KTtcbiAgfVxuICBzZXJpYWxpemUoKSB7XG4gICAgY29uc3QgZW5jb2RlZFN0YXRpY0FjY291bnRLZXlzTGVuZ3RoID0gQXJyYXkoKTtcbiAgICBlbmNvZGVMZW5ndGgoZW5jb2RlZFN0YXRpY0FjY291bnRLZXlzTGVuZ3RoLCB0aGlzLnN0YXRpY0FjY291bnRLZXlzLmxlbmd0aCk7XG4gICAgY29uc3Qgc2VyaWFsaXplZEluc3RydWN0aW9ucyA9IHRoaXMuc2VyaWFsaXplSW5zdHJ1Y3Rpb25zKCk7XG4gICAgY29uc3QgZW5jb2RlZEluc3RydWN0aW9uc0xlbmd0aCA9IEFycmF5KCk7XG4gICAgZW5jb2RlTGVuZ3RoKGVuY29kZWRJbnN0cnVjdGlvbnNMZW5ndGgsIHRoaXMuY29tcGlsZWRJbnN0cnVjdGlvbnMubGVuZ3RoKTtcbiAgICBjb25zdCBzZXJpYWxpemVkQWRkcmVzc1RhYmxlTG9va3VwcyA9IHRoaXMuc2VyaWFsaXplQWRkcmVzc1RhYmxlTG9va3VwcygpO1xuICAgIGNvbnN0IGVuY29kZWRBZGRyZXNzVGFibGVMb29rdXBzTGVuZ3RoID0gQXJyYXkoKTtcbiAgICBlbmNvZGVMZW5ndGgoZW5jb2RlZEFkZHJlc3NUYWJsZUxvb2t1cHNMZW5ndGgsIHRoaXMuYWRkcmVzc1RhYmxlTG9va3Vwcy5sZW5ndGgpO1xuICAgIGNvbnN0IG1lc3NhZ2VMYXlvdXQgPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTgoJ3ByZWZpeCcpLCBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTgoJ251bVJlcXVpcmVkU2lnbmF0dXJlcycpLCBCdWZmZXJMYXlvdXQudTgoJ251bVJlYWRvbmx5U2lnbmVkQWNjb3VudHMnKSwgQnVmZmVyTGF5b3V0LnU4KCdudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHMnKV0sICdoZWFkZXInKSwgQnVmZmVyTGF5b3V0LmJsb2IoZW5jb2RlZFN0YXRpY0FjY291bnRLZXlzTGVuZ3RoLmxlbmd0aCwgJ3N0YXRpY0FjY291bnRLZXlzTGVuZ3RoJyksIEJ1ZmZlckxheW91dC5zZXEocHVibGljS2V5KCksIHRoaXMuc3RhdGljQWNjb3VudEtleXMubGVuZ3RoLCAnc3RhdGljQWNjb3VudEtleXMnKSwgcHVibGljS2V5KCdyZWNlbnRCbG9ja2hhc2gnKSwgQnVmZmVyTGF5b3V0LmJsb2IoZW5jb2RlZEluc3RydWN0aW9uc0xlbmd0aC5sZW5ndGgsICdpbnN0cnVjdGlvbnNMZW5ndGgnKSwgQnVmZmVyTGF5b3V0LmJsb2Ioc2VyaWFsaXplZEluc3RydWN0aW9ucy5sZW5ndGgsICdzZXJpYWxpemVkSW5zdHJ1Y3Rpb25zJyksIEJ1ZmZlckxheW91dC5ibG9iKGVuY29kZWRBZGRyZXNzVGFibGVMb29rdXBzTGVuZ3RoLmxlbmd0aCwgJ2FkZHJlc3NUYWJsZUxvb2t1cHNMZW5ndGgnKSwgQnVmZmVyTGF5b3V0LmJsb2Ioc2VyaWFsaXplZEFkZHJlc3NUYWJsZUxvb2t1cHMubGVuZ3RoLCAnc2VyaWFsaXplZEFkZHJlc3NUYWJsZUxvb2t1cHMnKV0pO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRNZXNzYWdlID0gbmV3IFVpbnQ4QXJyYXkoUEFDS0VUX0RBVEFfU0laRSk7XG4gICAgY29uc3QgTUVTU0FHRV9WRVJTSU9OXzBfUFJFRklYID0gMSA8PCA3O1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRNZXNzYWdlTGVuZ3RoID0gbWVzc2FnZUxheW91dC5lbmNvZGUoe1xuICAgICAgcHJlZml4OiBNRVNTQUdFX1ZFUlNJT05fMF9QUkVGSVgsXG4gICAgICBoZWFkZXI6IHRoaXMuaGVhZGVyLFxuICAgICAgc3RhdGljQWNjb3VudEtleXNMZW5ndGg6IG5ldyBVaW50OEFycmF5KGVuY29kZWRTdGF0aWNBY2NvdW50S2V5c0xlbmd0aCksXG4gICAgICBzdGF0aWNBY2NvdW50S2V5czogdGhpcy5zdGF0aWNBY2NvdW50S2V5cy5tYXAoa2V5ID0+IGtleS50b0J5dGVzKCkpLFxuICAgICAgcmVjZW50QmxvY2toYXNoOiBiczU4LmRlY29kZSh0aGlzLnJlY2VudEJsb2NraGFzaCksXG4gICAgICBpbnN0cnVjdGlvbnNMZW5ndGg6IG5ldyBVaW50OEFycmF5KGVuY29kZWRJbnN0cnVjdGlvbnNMZW5ndGgpLFxuICAgICAgc2VyaWFsaXplZEluc3RydWN0aW9ucyxcbiAgICAgIGFkZHJlc3NUYWJsZUxvb2t1cHNMZW5ndGg6IG5ldyBVaW50OEFycmF5KGVuY29kZWRBZGRyZXNzVGFibGVMb29rdXBzTGVuZ3RoKSxcbiAgICAgIHNlcmlhbGl6ZWRBZGRyZXNzVGFibGVMb29rdXBzXG4gICAgfSwgc2VyaWFsaXplZE1lc3NhZ2UpO1xuICAgIHJldHVybiBzZXJpYWxpemVkTWVzc2FnZS5zbGljZSgwLCBzZXJpYWxpemVkTWVzc2FnZUxlbmd0aCk7XG4gIH1cbiAgc2VyaWFsaXplSW5zdHJ1Y3Rpb25zKCkge1xuICAgIGxldCBzZXJpYWxpemVkTGVuZ3RoID0gMDtcbiAgICBjb25zdCBzZXJpYWxpemVkSW5zdHJ1Y3Rpb25zID0gbmV3IFVpbnQ4QXJyYXkoUEFDS0VUX0RBVEFfU0laRSk7XG4gICAgZm9yIChjb25zdCBpbnN0cnVjdGlvbiBvZiB0aGlzLmNvbXBpbGVkSW5zdHJ1Y3Rpb25zKSB7XG4gICAgICBjb25zdCBlbmNvZGVkQWNjb3VudEtleUluZGV4ZXNMZW5ndGggPSBBcnJheSgpO1xuICAgICAgZW5jb2RlTGVuZ3RoKGVuY29kZWRBY2NvdW50S2V5SW5kZXhlc0xlbmd0aCwgaW5zdHJ1Y3Rpb24uYWNjb3VudEtleUluZGV4ZXMubGVuZ3RoKTtcbiAgICAgIGNvbnN0IGVuY29kZWREYXRhTGVuZ3RoID0gQXJyYXkoKTtcbiAgICAgIGVuY29kZUxlbmd0aChlbmNvZGVkRGF0YUxlbmd0aCwgaW5zdHJ1Y3Rpb24uZGF0YS5sZW5ndGgpO1xuICAgICAgY29uc3QgaW5zdHJ1Y3Rpb25MYXlvdXQgPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTgoJ3Byb2dyYW1JZEluZGV4JyksIEJ1ZmZlckxheW91dC5ibG9iKGVuY29kZWRBY2NvdW50S2V5SW5kZXhlc0xlbmd0aC5sZW5ndGgsICdlbmNvZGVkQWNjb3VudEtleUluZGV4ZXNMZW5ndGgnKSwgQnVmZmVyTGF5b3V0LnNlcShCdWZmZXJMYXlvdXQudTgoKSwgaW5zdHJ1Y3Rpb24uYWNjb3VudEtleUluZGV4ZXMubGVuZ3RoLCAnYWNjb3VudEtleUluZGV4ZXMnKSwgQnVmZmVyTGF5b3V0LmJsb2IoZW5jb2RlZERhdGFMZW5ndGgubGVuZ3RoLCAnZW5jb2RlZERhdGFMZW5ndGgnKSwgQnVmZmVyTGF5b3V0LmJsb2IoaW5zdHJ1Y3Rpb24uZGF0YS5sZW5ndGgsICdkYXRhJyldKTtcbiAgICAgIHNlcmlhbGl6ZWRMZW5ndGggKz0gaW5zdHJ1Y3Rpb25MYXlvdXQuZW5jb2RlKHtcbiAgICAgICAgcHJvZ3JhbUlkSW5kZXg6IGluc3RydWN0aW9uLnByb2dyYW1JZEluZGV4LFxuICAgICAgICBlbmNvZGVkQWNjb3VudEtleUluZGV4ZXNMZW5ndGg6IG5ldyBVaW50OEFycmF5KGVuY29kZWRBY2NvdW50S2V5SW5kZXhlc0xlbmd0aCksXG4gICAgICAgIGFjY291bnRLZXlJbmRleGVzOiBpbnN0cnVjdGlvbi5hY2NvdW50S2V5SW5kZXhlcyxcbiAgICAgICAgZW5jb2RlZERhdGFMZW5ndGg6IG5ldyBVaW50OEFycmF5KGVuY29kZWREYXRhTGVuZ3RoKSxcbiAgICAgICAgZGF0YTogaW5zdHJ1Y3Rpb24uZGF0YVxuICAgICAgfSwgc2VyaWFsaXplZEluc3RydWN0aW9ucywgc2VyaWFsaXplZExlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiBzZXJpYWxpemVkSW5zdHJ1Y3Rpb25zLnNsaWNlKDAsIHNlcmlhbGl6ZWRMZW5ndGgpO1xuICB9XG4gIHNlcmlhbGl6ZUFkZHJlc3NUYWJsZUxvb2t1cHMoKSB7XG4gICAgbGV0IHNlcmlhbGl6ZWRMZW5ndGggPSAwO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRBZGRyZXNzVGFibGVMb29rdXBzID0gbmV3IFVpbnQ4QXJyYXkoUEFDS0VUX0RBVEFfU0laRSk7XG4gICAgZm9yIChjb25zdCBsb29rdXAgb2YgdGhpcy5hZGRyZXNzVGFibGVMb29rdXBzKSB7XG4gICAgICBjb25zdCBlbmNvZGVkV3JpdGFibGVJbmRleGVzTGVuZ3RoID0gQXJyYXkoKTtcbiAgICAgIGVuY29kZUxlbmd0aChlbmNvZGVkV3JpdGFibGVJbmRleGVzTGVuZ3RoLCBsb29rdXAud3JpdGFibGVJbmRleGVzLmxlbmd0aCk7XG4gICAgICBjb25zdCBlbmNvZGVkUmVhZG9ubHlJbmRleGVzTGVuZ3RoID0gQXJyYXkoKTtcbiAgICAgIGVuY29kZUxlbmd0aChlbmNvZGVkUmVhZG9ubHlJbmRleGVzTGVuZ3RoLCBsb29rdXAucmVhZG9ubHlJbmRleGVzLmxlbmd0aCk7XG4gICAgICBjb25zdCBhZGRyZXNzVGFibGVMb29rdXBMYXlvdXQgPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtwdWJsaWNLZXkoJ2FjY291bnRLZXknKSwgQnVmZmVyTGF5b3V0LmJsb2IoZW5jb2RlZFdyaXRhYmxlSW5kZXhlc0xlbmd0aC5sZW5ndGgsICdlbmNvZGVkV3JpdGFibGVJbmRleGVzTGVuZ3RoJyksIEJ1ZmZlckxheW91dC5zZXEoQnVmZmVyTGF5b3V0LnU4KCksIGxvb2t1cC53cml0YWJsZUluZGV4ZXMubGVuZ3RoLCAnd3JpdGFibGVJbmRleGVzJyksIEJ1ZmZlckxheW91dC5ibG9iKGVuY29kZWRSZWFkb25seUluZGV4ZXNMZW5ndGgubGVuZ3RoLCAnZW5jb2RlZFJlYWRvbmx5SW5kZXhlc0xlbmd0aCcpLCBCdWZmZXJMYXlvdXQuc2VxKEJ1ZmZlckxheW91dC51OCgpLCBsb29rdXAucmVhZG9ubHlJbmRleGVzLmxlbmd0aCwgJ3JlYWRvbmx5SW5kZXhlcycpXSk7XG4gICAgICBzZXJpYWxpemVkTGVuZ3RoICs9IGFkZHJlc3NUYWJsZUxvb2t1cExheW91dC5lbmNvZGUoe1xuICAgICAgICBhY2NvdW50S2V5OiBsb29rdXAuYWNjb3VudEtleS50b0J5dGVzKCksXG4gICAgICAgIGVuY29kZWRXcml0YWJsZUluZGV4ZXNMZW5ndGg6IG5ldyBVaW50OEFycmF5KGVuY29kZWRXcml0YWJsZUluZGV4ZXNMZW5ndGgpLFxuICAgICAgICB3cml0YWJsZUluZGV4ZXM6IGxvb2t1cC53cml0YWJsZUluZGV4ZXMsXG4gICAgICAgIGVuY29kZWRSZWFkb25seUluZGV4ZXNMZW5ndGg6IG5ldyBVaW50OEFycmF5KGVuY29kZWRSZWFkb25seUluZGV4ZXNMZW5ndGgpLFxuICAgICAgICByZWFkb25seUluZGV4ZXM6IGxvb2t1cC5yZWFkb25seUluZGV4ZXNcbiAgICAgIH0sIHNlcmlhbGl6ZWRBZGRyZXNzVGFibGVMb29rdXBzLCBzZXJpYWxpemVkTGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWRBZGRyZXNzVGFibGVMb29rdXBzLnNsaWNlKDAsIHNlcmlhbGl6ZWRMZW5ndGgpO1xuICB9XG4gIHN0YXRpYyBkZXNlcmlhbGl6ZShzZXJpYWxpemVkTWVzc2FnZSkge1xuICAgIGxldCBieXRlQXJyYXkgPSBbLi4uc2VyaWFsaXplZE1lc3NhZ2VdO1xuICAgIGNvbnN0IHByZWZpeCA9IGd1YXJkZWRTaGlmdChieXRlQXJyYXkpO1xuICAgIGNvbnN0IG1hc2tlZFByZWZpeCA9IHByZWZpeCAmIFZFUlNJT05fUFJFRklYX01BU0s7XG4gICAgYXNzZXJ0KHByZWZpeCAhPT0gbWFza2VkUHJlZml4LCBgRXhwZWN0ZWQgdmVyc2lvbmVkIG1lc3NhZ2UgYnV0IHJlY2VpdmVkIGxlZ2FjeSBtZXNzYWdlYCk7XG4gICAgY29uc3QgdmVyc2lvbiA9IG1hc2tlZFByZWZpeDtcbiAgICBhc3NlcnQodmVyc2lvbiA9PT0gMCwgYEV4cGVjdGVkIHZlcnNpb25lZCBtZXNzYWdlIHdpdGggdmVyc2lvbiAwIGJ1dCBmb3VuZCB2ZXJzaW9uICR7dmVyc2lvbn1gKTtcbiAgICBjb25zdCBoZWFkZXIgPSB7XG4gICAgICBudW1SZXF1aXJlZFNpZ25hdHVyZXM6IGd1YXJkZWRTaGlmdChieXRlQXJyYXkpLFxuICAgICAgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50czogZ3VhcmRlZFNoaWZ0KGJ5dGVBcnJheSksXG4gICAgICBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHM6IGd1YXJkZWRTaGlmdChieXRlQXJyYXkpXG4gICAgfTtcbiAgICBjb25zdCBzdGF0aWNBY2NvdW50S2V5cyA9IFtdO1xuICAgIGNvbnN0IHN0YXRpY0FjY291bnRLZXlzTGVuZ3RoID0gZGVjb2RlTGVuZ3RoKGJ5dGVBcnJheSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0aWNBY2NvdW50S2V5c0xlbmd0aDsgaSsrKSB7XG4gICAgICBzdGF0aWNBY2NvdW50S2V5cy5wdXNoKG5ldyBQdWJsaWNLZXkoZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIDAsIFBVQkxJQ19LRVlfTEVOR1RIKSkpO1xuICAgIH1cbiAgICBjb25zdCByZWNlbnRCbG9ja2hhc2ggPSBiczU4LmVuY29kZShndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgUFVCTElDX0tFWV9MRU5HVEgpKTtcbiAgICBjb25zdCBpbnN0cnVjdGlvbkNvdW50ID0gZGVjb2RlTGVuZ3RoKGJ5dGVBcnJheSk7XG4gICAgY29uc3QgY29tcGlsZWRJbnN0cnVjdGlvbnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluc3RydWN0aW9uQ291bnQ7IGkrKykge1xuICAgICAgY29uc3QgcHJvZ3JhbUlkSW5kZXggPSBndWFyZGVkU2hpZnQoYnl0ZUFycmF5KTtcbiAgICAgIGNvbnN0IGFjY291bnRLZXlJbmRleGVzTGVuZ3RoID0gZGVjb2RlTGVuZ3RoKGJ5dGVBcnJheSk7XG4gICAgICBjb25zdCBhY2NvdW50S2V5SW5kZXhlcyA9IGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAwLCBhY2NvdW50S2V5SW5kZXhlc0xlbmd0aCk7XG4gICAgICBjb25zdCBkYXRhTGVuZ3RoID0gZGVjb2RlTGVuZ3RoKGJ5dGVBcnJheSk7XG4gICAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIDAsIGRhdGFMZW5ndGgpKTtcbiAgICAgIGNvbXBpbGVkSW5zdHJ1Y3Rpb25zLnB1c2goe1xuICAgICAgICBwcm9ncmFtSWRJbmRleCxcbiAgICAgICAgYWNjb3VudEtleUluZGV4ZXMsXG4gICAgICAgIGRhdGFcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBhZGRyZXNzVGFibGVMb29rdXBzQ291bnQgPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICBjb25zdCBhZGRyZXNzVGFibGVMb29rdXBzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhZGRyZXNzVGFibGVMb29rdXBzQ291bnQ7IGkrKykge1xuICAgICAgY29uc3QgYWNjb3VudEtleSA9IG5ldyBQdWJsaWNLZXkoZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIDAsIFBVQkxJQ19LRVlfTEVOR1RIKSk7XG4gICAgICBjb25zdCB3cml0YWJsZUluZGV4ZXNMZW5ndGggPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICAgIGNvbnN0IHdyaXRhYmxlSW5kZXhlcyA9IGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAwLCB3cml0YWJsZUluZGV4ZXNMZW5ndGgpO1xuICAgICAgY29uc3QgcmVhZG9ubHlJbmRleGVzTGVuZ3RoID0gZGVjb2RlTGVuZ3RoKGJ5dGVBcnJheSk7XG4gICAgICBjb25zdCByZWFkb25seUluZGV4ZXMgPSBndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgcmVhZG9ubHlJbmRleGVzTGVuZ3RoKTtcbiAgICAgIGFkZHJlc3NUYWJsZUxvb2t1cHMucHVzaCh7XG4gICAgICAgIGFjY291bnRLZXksXG4gICAgICAgIHdyaXRhYmxlSW5kZXhlcyxcbiAgICAgICAgcmVhZG9ubHlJbmRleGVzXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBNZXNzYWdlVjAoe1xuICAgICAgaGVhZGVyLFxuICAgICAgc3RhdGljQWNjb3VudEtleXMsXG4gICAgICByZWNlbnRCbG9ja2hhc2gsXG4gICAgICBjb21waWxlZEluc3RydWN0aW9ucyxcbiAgICAgIGFkZHJlc3NUYWJsZUxvb2t1cHNcbiAgICB9KTtcbiAgfVxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5jb25zdCBWZXJzaW9uZWRNZXNzYWdlID0ge1xuICBkZXNlcmlhbGl6ZU1lc3NhZ2VWZXJzaW9uKHNlcmlhbGl6ZWRNZXNzYWdlKSB7XG4gICAgY29uc3QgcHJlZml4ID0gc2VyaWFsaXplZE1lc3NhZ2VbMF07XG4gICAgY29uc3QgbWFza2VkUHJlZml4ID0gcHJlZml4ICYgVkVSU0lPTl9QUkVGSVhfTUFTSztcblxuICAgIC8vIGlmIHRoZSBoaWdoZXN0IGJpdCBvZiB0aGUgcHJlZml4IGlzIG5vdCBzZXQsIHRoZSBtZXNzYWdlIGlzIG5vdCB2ZXJzaW9uZWRcbiAgICBpZiAobWFza2VkUHJlZml4ID09PSBwcmVmaXgpIHtcbiAgICAgIHJldHVybiAnbGVnYWN5JztcbiAgICB9XG5cbiAgICAvLyB0aGUgbG93ZXIgNyBiaXRzIG9mIHRoZSBwcmVmaXggaW5kaWNhdGUgdGhlIG1lc3NhZ2UgdmVyc2lvblxuICAgIHJldHVybiBtYXNrZWRQcmVmaXg7XG4gIH0sXG4gIGRlc2VyaWFsaXplOiBzZXJpYWxpemVkTWVzc2FnZSA9PiB7XG4gICAgY29uc3QgdmVyc2lvbiA9IFZlcnNpb25lZE1lc3NhZ2UuZGVzZXJpYWxpemVNZXNzYWdlVmVyc2lvbihzZXJpYWxpemVkTWVzc2FnZSk7XG4gICAgaWYgKHZlcnNpb24gPT09ICdsZWdhY3knKSB7XG4gICAgICByZXR1cm4gTWVzc2FnZS5mcm9tKHNlcmlhbGl6ZWRNZXNzYWdlKTtcbiAgICB9XG4gICAgaWYgKHZlcnNpb24gPT09IDApIHtcbiAgICAgIHJldHVybiBNZXNzYWdlVjAuZGVzZXJpYWxpemUoc2VyaWFsaXplZE1lc3NhZ2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRyYW5zYWN0aW9uIG1lc3NhZ2UgdmVyc2lvbiAke3ZlcnNpb259IGRlc2VyaWFsaXphdGlvbiBpcyBub3Qgc3VwcG9ydGVkYCk7XG4gICAgfVxuICB9XG59O1xuXG4vKiogQGludGVybmFsICovXG5cbi8qKlxuICogVHJhbnNhY3Rpb24gc2lnbmF0dXJlIGFzIGJhc2UtNTggZW5jb2RlZCBzdHJpbmdcbiAqL1xuXG5sZXQgVHJhbnNhY3Rpb25TdGF0dXMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKFRyYW5zYWN0aW9uU3RhdHVzKSB7XG4gIFRyYW5zYWN0aW9uU3RhdHVzW1RyYW5zYWN0aW9uU3RhdHVzW1wiQkxPQ0tIRUlHSFRfRVhDRUVERURcIl0gPSAwXSA9IFwiQkxPQ0tIRUlHSFRfRVhDRUVERURcIjtcbiAgVHJhbnNhY3Rpb25TdGF0dXNbVHJhbnNhY3Rpb25TdGF0dXNbXCJQUk9DRVNTRURcIl0gPSAxXSA9IFwiUFJPQ0VTU0VEXCI7XG4gIFRyYW5zYWN0aW9uU3RhdHVzW1RyYW5zYWN0aW9uU3RhdHVzW1wiVElNRURfT1VUXCJdID0gMl0gPSBcIlRJTUVEX09VVFwiO1xuICBUcmFuc2FjdGlvblN0YXR1c1tUcmFuc2FjdGlvblN0YXR1c1tcIk5PTkNFX0lOVkFMSURcIl0gPSAzXSA9IFwiTk9OQ0VfSU5WQUxJRFwiO1xuICByZXR1cm4gVHJhbnNhY3Rpb25TdGF0dXM7XG59KHt9KTtcblxuLyoqXG4gKiBEZWZhdWx0IChlbXB0eSkgc2lnbmF0dXJlXG4gKi9cbmNvbnN0IERFRkFVTFRfU0lHTkFUVVJFID0gQnVmZmVyLmFsbG9jKFNJR05BVFVSRV9MRU5HVEhfSU5fQllURVMpLmZpbGwoMCk7XG5cbi8qKlxuICogQWNjb3VudCBtZXRhZGF0YSB1c2VkIHRvIGRlZmluZSBpbnN0cnVjdGlvbnNcbiAqL1xuXG4vKipcbiAqIExpc3Qgb2YgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbiBvYmplY3QgZmllbGRzIHRoYXQgbWF5IGJlIGluaXRpYWxpemVkIGF0IGNvbnN0cnVjdGlvblxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIFRyYW5zYWN0aW9uLnNlcmlhbGl6ZSgpXG4gKi9cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG4vKipcbiAqIFRyYW5zYWN0aW9uIEluc3RydWN0aW9uIGNsYXNzXG4gKi9cbmNsYXNzIFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24ge1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgLyoqXG4gICAgICogUHVibGljIGtleXMgdG8gaW5jbHVkZSBpbiB0aGlzIHRyYW5zYWN0aW9uXG4gICAgICogQm9vbGVhbiByZXByZXNlbnRzIHdoZXRoZXIgdGhpcyBwdWJrZXkgbmVlZHMgdG8gc2lnbiB0aGUgdHJhbnNhY3Rpb25cbiAgICAgKi9cbiAgICB0aGlzLmtleXMgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogUHJvZ3JhbSBJZCB0byBleGVjdXRlXG4gICAgICovXG4gICAgdGhpcy5wcm9ncmFtSWQgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogUHJvZ3JhbSBpbnB1dFxuICAgICAqL1xuICAgIHRoaXMuZGF0YSA9IEJ1ZmZlci5hbGxvYygwKTtcbiAgICB0aGlzLnByb2dyYW1JZCA9IG9wdHMucHJvZ3JhbUlkO1xuICAgIHRoaXMua2V5cyA9IG9wdHMua2V5cztcbiAgICBpZiAob3B0cy5kYXRhKSB7XG4gICAgICB0aGlzLmRhdGEgPSBvcHRzLmRhdGE7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBrZXlzOiB0aGlzLmtleXMubWFwKCh7XG4gICAgICAgIHB1YmtleSxcbiAgICAgICAgaXNTaWduZXIsXG4gICAgICAgIGlzV3JpdGFibGVcbiAgICAgIH0pID0+ICh7XG4gICAgICAgIHB1YmtleTogcHVia2V5LnRvSlNPTigpLFxuICAgICAgICBpc1NpZ25lcixcbiAgICAgICAgaXNXcml0YWJsZVxuICAgICAgfSkpLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZC50b0pTT04oKSxcbiAgICAgIGRhdGE6IFsuLi50aGlzLmRhdGFdXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFBhaXIgb2Ygc2lnbmF0dXJlIGFuZCBjb3JyZXNwb25kaW5nIHB1YmxpYyBrZXlcbiAqL1xuXG4vKipcbiAqIExpc3Qgb2YgVHJhbnNhY3Rpb24gb2JqZWN0IGZpZWxkcyB0aGF0IG1heSBiZSBpbml0aWFsaXplZCBhdCBjb25zdHJ1Y3Rpb25cbiAqL1xuXG4vLyBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eTsgYW4gdW5mb3J0dW5hdGUgY29uc2VxdWVuY2Ugb2YgYmVpbmdcbi8vIGZvcmNlZCB0byBvdmVyLWV4cG9ydCB0eXBlcyBieSB0aGUgZG9jdW1lbnRhdGlvbiBnZW5lcmF0b3IuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3NvbGFuYS1sYWJzL3NvbGFuYS9wdWxsLzI1ODIwXG5cbi8qKlxuICogQmxvY2toYXNoLWJhc2VkIHRyYW5zYWN0aW9ucyBoYXZlIGEgbGlmZXRpbWUgdGhhdCBhcmUgZGVmaW5lZCBieVxuICogdGhlIGJsb2NraGFzaCB0aGV5IGluY2x1ZGUuIEFueSB0cmFuc2FjdGlvbiB3aG9zZSBibG9ja2hhc2ggaXNcbiAqIHRvbyBvbGQgd2lsbCBiZSByZWplY3RlZC5cbiAqL1xuXG4vKipcbiAqIFVzZSB0aGVzZSBvcHRpb25zIHRvIGNvbnN0cnVjdCBhIGR1cmFibGUgbm9uY2UgdHJhbnNhY3Rpb24uXG4gKi9cblxuLyoqXG4gKiBOb25jZSBpbmZvcm1hdGlvbiB0byBiZSB1c2VkIHRvIGJ1aWxkIGFuIG9mZmxpbmUgVHJhbnNhY3Rpb24uXG4gKi9cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG4vKipcbiAqIFRyYW5zYWN0aW9uIGNsYXNzXG4gKi9cbmNsYXNzIFRyYW5zYWN0aW9uIHtcbiAgLyoqXG4gICAqIFRoZSBmaXJzdCAocGF5ZXIpIFRyYW5zYWN0aW9uIHNpZ25hdHVyZVxuICAgKlxuICAgKiBAcmV0dXJucyB7QnVmZmVyIHwgbnVsbH0gQnVmZmVyIG9mIHBheWVyJ3Mgc2lnbmF0dXJlXG4gICAqL1xuICBnZXQgc2lnbmF0dXJlKCkge1xuICAgIGlmICh0aGlzLnNpZ25hdHVyZXMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2lnbmF0dXJlc1swXS5zaWduYXR1cmU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0cmFuc2FjdGlvbiBmZWUgcGF5ZXJcbiAgICovXG5cbiAgLy8gQ29uc3RydWN0IGEgdHJhbnNhY3Rpb24gd2l0aCBhIGJsb2NraGFzaCBhbmQgbGFzdFZhbGlkQmxvY2tIZWlnaHRcblxuICAvLyBDb25zdHJ1Y3QgYSB0cmFuc2FjdGlvbiB1c2luZyBhIGR1cmFibGUgbm9uY2VcblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgYFRyYW5zYWN0aW9uQ3RvckZpZWxkc2AgaGFzIGJlZW4gZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uXG4gICAqIFBsZWFzZSBzdXBwbHkgYSBgVHJhbnNhY3Rpb25CbG9ja2hhc2hDdG9yYCBpbnN0ZWFkLlxuICAgKi9cblxuICAvKipcbiAgICogQ29uc3RydWN0IGFuIGVtcHR5IFRyYW5zYWN0aW9uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgLyoqXG4gICAgICogU2lnbmF0dXJlcyBmb3IgdGhlIHRyYW5zYWN0aW9uLiAgVHlwaWNhbGx5IGNyZWF0ZWQgYnkgaW52b2tpbmcgdGhlXG4gICAgICogYHNpZ24oKWAgbWV0aG9kXG4gICAgICovXG4gICAgdGhpcy5zaWduYXR1cmVzID0gW107XG4gICAgdGhpcy5mZWVQYXllciA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBUaGUgaW5zdHJ1Y3Rpb25zIHRvIGF0b21pY2FsbHkgZXhlY3V0ZVxuICAgICAqL1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zID0gW107XG4gICAgLyoqXG4gICAgICogQSByZWNlbnQgdHJhbnNhY3Rpb24gaWQuIE11c3QgYmUgcG9wdWxhdGVkIGJ5IHRoZSBjYWxsZXJcbiAgICAgKi9cbiAgICB0aGlzLnJlY2VudEJsb2NraGFzaCA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiB0aGUgbGFzdCBibG9jayBjaGFpbiBjYW4gYWR2YW5jZSB0byBiZWZvcmUgdHggaXMgZGVjbGFyZWQgZXhwaXJlZFxuICAgICAqICovXG4gICAgdGhpcy5sYXN0VmFsaWRCbG9ja0hlaWdodCA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBPcHRpb25hbCBOb25jZSBpbmZvcm1hdGlvbi4gSWYgcG9wdWxhdGVkLCB0cmFuc2FjdGlvbiB3aWxsIHVzZSBhIGR1cmFibGVcbiAgICAgKiBOb25jZSBoYXNoIGluc3RlYWQgb2YgYSByZWNlbnRCbG9ja2hhc2guIE11c3QgYmUgcG9wdWxhdGVkIGJ5IHRoZSBjYWxsZXJcbiAgICAgKi9cbiAgICB0aGlzLm5vbmNlSW5mbyA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBJZiB0aGlzIGlzIGEgbm9uY2UgdHJhbnNhY3Rpb24gdGhpcyByZXByZXNlbnRzIHRoZSBtaW5pbXVtIHNsb3QgZnJvbSB3aGljaFxuICAgICAqIHRvIGV2YWx1YXRlIGlmIHRoZSBub25jZSBoYXMgYWR2YW5jZWQgd2hlbiBhdHRlbXB0aW5nIHRvIGNvbmZpcm0gdGhlXG4gICAgICogdHJhbnNhY3Rpb24uIFRoaXMgcHJvdGVjdHMgYWdhaW5zdCBhIGNhc2Ugd2hlcmUgdGhlIHRyYW5zYWN0aW9uIGNvbmZpcm1hdGlvblxuICAgICAqIGxvZ2ljIGxvYWRzIHRoZSBub25jZSBhY2NvdW50IGZyb20gYW4gb2xkIHNsb3QgYW5kIGFzc3VtZXMgdGhlIG1pc21hdGNoIGluXG4gICAgICogbm9uY2UgdmFsdWUgaW1wbGllcyB0aGF0IHRoZSBub25jZSBoYXMgYmVlbiBhZHZhbmNlZC5cbiAgICAgKi9cbiAgICB0aGlzLm1pbk5vbmNlQ29udGV4dFNsb3QgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5fbWVzc2FnZSA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLl9qc29uID0gdm9pZCAwO1xuICAgIGlmICghb3B0cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAob3B0cy5mZWVQYXllcikge1xuICAgICAgdGhpcy5mZWVQYXllciA9IG9wdHMuZmVlUGF5ZXI7XG4gICAgfVxuICAgIGlmIChvcHRzLnNpZ25hdHVyZXMpIHtcbiAgICAgIHRoaXMuc2lnbmF0dXJlcyA9IG9wdHMuc2lnbmF0dXJlcztcbiAgICB9XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRzLCAnbm9uY2VJbmZvJykpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbWluQ29udGV4dFNsb3QsXG4gICAgICAgIG5vbmNlSW5mb1xuICAgICAgfSA9IG9wdHM7XG4gICAgICB0aGlzLm1pbk5vbmNlQ29udGV4dFNsb3QgPSBtaW5Db250ZXh0U2xvdDtcbiAgICAgIHRoaXMubm9uY2VJbmZvID0gbm9uY2VJbmZvO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdHMsICdsYXN0VmFsaWRCbG9ja0hlaWdodCcpKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGJsb2NraGFzaCxcbiAgICAgICAgbGFzdFZhbGlkQmxvY2tIZWlnaHRcbiAgICAgIH0gPSBvcHRzO1xuICAgICAgdGhpcy5yZWNlbnRCbG9ja2hhc2ggPSBibG9ja2hhc2g7XG4gICAgICB0aGlzLmxhc3RWYWxpZEJsb2NrSGVpZ2h0ID0gbGFzdFZhbGlkQmxvY2tIZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVjZW50QmxvY2toYXNoLFxuICAgICAgICBub25jZUluZm9cbiAgICAgIH0gPSBvcHRzO1xuICAgICAgaWYgKG5vbmNlSW5mbykge1xuICAgICAgICB0aGlzLm5vbmNlSW5mbyA9IG5vbmNlSW5mbztcbiAgICAgIH1cbiAgICAgIHRoaXMucmVjZW50QmxvY2toYXNoID0gcmVjZW50QmxvY2toYXNoO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVjZW50QmxvY2toYXNoOiB0aGlzLnJlY2VudEJsb2NraGFzaCB8fCBudWxsLFxuICAgICAgZmVlUGF5ZXI6IHRoaXMuZmVlUGF5ZXIgPyB0aGlzLmZlZVBheWVyLnRvSlNPTigpIDogbnVsbCxcbiAgICAgIG5vbmNlSW5mbzogdGhpcy5ub25jZUluZm8gPyB7XG4gICAgICAgIG5vbmNlOiB0aGlzLm5vbmNlSW5mby5ub25jZSxcbiAgICAgICAgbm9uY2VJbnN0cnVjdGlvbjogdGhpcy5ub25jZUluZm8ubm9uY2VJbnN0cnVjdGlvbi50b0pTT04oKVxuICAgICAgfSA6IG51bGwsXG4gICAgICBpbnN0cnVjdGlvbnM6IHRoaXMuaW5zdHJ1Y3Rpb25zLm1hcChpbnN0cnVjdGlvbiA9PiBpbnN0cnVjdGlvbi50b0pTT04oKSksXG4gICAgICBzaWduZXJzOiB0aGlzLnNpZ25hdHVyZXMubWFwKCh7XG4gICAgICAgIHB1YmxpY0tleVxuICAgICAgfSkgPT4ge1xuICAgICAgICByZXR1cm4gcHVibGljS2V5LnRvSlNPTigpO1xuICAgICAgfSlcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBvbmUgb3IgbW9yZSBpbnN0cnVjdGlvbnMgdG8gdGhpcyBUcmFuc2FjdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PCBUcmFuc2FjdGlvbiB8IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24gfCBUcmFuc2FjdGlvbkluc3RydWN0aW9uQ3RvckZpZWxkcyA+fSBpdGVtcyAtIEluc3RydWN0aW9ucyB0byBhZGQgdG8gdGhlIFRyYW5zYWN0aW9uXG4gICAqL1xuICBhZGQoLi4uaXRlbXMpIHtcbiAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGluc3RydWN0aW9ucycpO1xuICAgIH1cbiAgICBpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgaWYgKCdpbnN0cnVjdGlvbnMnIGluIGl0ZW0pIHtcbiAgICAgICAgdGhpcy5pbnN0cnVjdGlvbnMgPSB0aGlzLmluc3RydWN0aW9ucy5jb25jYXQoaXRlbS5pbnN0cnVjdGlvbnMpO1xuICAgICAgfSBlbHNlIGlmICgnZGF0YScgaW4gaXRlbSAmJiAncHJvZ3JhbUlkJyBpbiBpdGVtICYmICdrZXlzJyBpbiBpdGVtKSB7XG4gICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goaXRlbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKGl0ZW0pKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21waWxlIHRyYW5zYWN0aW9uIGRhdGFcbiAgICovXG4gIGNvbXBpbGVNZXNzYWdlKCkge1xuICAgIGlmICh0aGlzLl9tZXNzYWdlICYmIEpTT04uc3RyaW5naWZ5KHRoaXMudG9KU09OKCkpID09PSBKU09OLnN0cmluZ2lmeSh0aGlzLl9qc29uKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX21lc3NhZ2U7XG4gICAgfVxuICAgIGxldCByZWNlbnRCbG9ja2hhc2g7XG4gICAgbGV0IGluc3RydWN0aW9ucztcbiAgICBpZiAodGhpcy5ub25jZUluZm8pIHtcbiAgICAgIHJlY2VudEJsb2NraGFzaCA9IHRoaXMubm9uY2VJbmZvLm5vbmNlO1xuICAgICAgaWYgKHRoaXMuaW5zdHJ1Y3Rpb25zWzBdICE9IHRoaXMubm9uY2VJbmZvLm5vbmNlSW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgaW5zdHJ1Y3Rpb25zID0gW3RoaXMubm9uY2VJbmZvLm5vbmNlSW5zdHJ1Y3Rpb24sIC4uLnRoaXMuaW5zdHJ1Y3Rpb25zXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluc3RydWN0aW9ucyA9IHRoaXMuaW5zdHJ1Y3Rpb25zO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZWNlbnRCbG9ja2hhc2ggPSB0aGlzLnJlY2VudEJsb2NraGFzaDtcbiAgICAgIGluc3RydWN0aW9ucyA9IHRoaXMuaW5zdHJ1Y3Rpb25zO1xuICAgIH1cbiAgICBpZiAoIXJlY2VudEJsb2NraGFzaCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc2FjdGlvbiByZWNlbnRCbG9ja2hhc2ggcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgaWYgKGluc3RydWN0aW9ucy5sZW5ndGggPCAxKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ05vIGluc3RydWN0aW9ucyBwcm92aWRlZCcpO1xuICAgIH1cbiAgICBsZXQgZmVlUGF5ZXI7XG4gICAgaWYgKHRoaXMuZmVlUGF5ZXIpIHtcbiAgICAgIGZlZVBheWVyID0gdGhpcy5mZWVQYXllcjtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc2lnbmF0dXJlcy5sZW5ndGggPiAwICYmIHRoaXMuc2lnbmF0dXJlc1swXS5wdWJsaWNLZXkpIHtcbiAgICAgIC8vIFVzZSBpbXBsaWNpdCBmZWUgcGF5ZXJcbiAgICAgIGZlZVBheWVyID0gdGhpcy5zaWduYXR1cmVzWzBdLnB1YmxpY0tleTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc2FjdGlvbiBmZWUgcGF5ZXIgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnN0cnVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChpbnN0cnVjdGlvbnNbaV0ucHJvZ3JhbUlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUcmFuc2FjdGlvbiBpbnN0cnVjdGlvbiBpbmRleCAke2l9IGhhcyB1bmRlZmluZWQgcHJvZ3JhbSBpZGApO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwcm9ncmFtSWRzID0gW107XG4gICAgY29uc3QgYWNjb3VudE1ldGFzID0gW107XG4gICAgaW5zdHJ1Y3Rpb25zLmZvckVhY2goaW5zdHJ1Y3Rpb24gPT4ge1xuICAgICAgaW5zdHJ1Y3Rpb24ua2V5cy5mb3JFYWNoKGFjY291bnRNZXRhID0+IHtcbiAgICAgICAgYWNjb3VudE1ldGFzLnB1c2goe1xuICAgICAgICAgIC4uLmFjY291bnRNZXRhXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBwcm9ncmFtSWQgPSBpbnN0cnVjdGlvbi5wcm9ncmFtSWQudG9TdHJpbmcoKTtcbiAgICAgIGlmICghcHJvZ3JhbUlkcy5pbmNsdWRlcyhwcm9ncmFtSWQpKSB7XG4gICAgICAgIHByb2dyYW1JZHMucHVzaChwcm9ncmFtSWQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQXBwZW5kIHByb2dyYW1JRCBhY2NvdW50IG1ldGFzXG4gICAgcHJvZ3JhbUlkcy5mb3JFYWNoKHByb2dyYW1JZCA9PiB7XG4gICAgICBhY2NvdW50TWV0YXMucHVzaCh7XG4gICAgICAgIHB1YmtleTogbmV3IFB1YmxpY0tleShwcm9ncmFtSWQpLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIEN1bGwgZHVwbGljYXRlIGFjY291bnQgbWV0YXNcbiAgICBjb25zdCB1bmlxdWVNZXRhcyA9IFtdO1xuICAgIGFjY291bnRNZXRhcy5mb3JFYWNoKGFjY291bnRNZXRhID0+IHtcbiAgICAgIGNvbnN0IHB1YmtleVN0cmluZyA9IGFjY291bnRNZXRhLnB1YmtleS50b1N0cmluZygpO1xuICAgICAgY29uc3QgdW5pcXVlSW5kZXggPSB1bmlxdWVNZXRhcy5maW5kSW5kZXgoeCA9PiB7XG4gICAgICAgIHJldHVybiB4LnB1YmtleS50b1N0cmluZygpID09PSBwdWJrZXlTdHJpbmc7XG4gICAgICB9KTtcbiAgICAgIGlmICh1bmlxdWVJbmRleCA+IC0xKSB7XG4gICAgICAgIHVuaXF1ZU1ldGFzW3VuaXF1ZUluZGV4XS5pc1dyaXRhYmxlID0gdW5pcXVlTWV0YXNbdW5pcXVlSW5kZXhdLmlzV3JpdGFibGUgfHwgYWNjb3VudE1ldGEuaXNXcml0YWJsZTtcbiAgICAgICAgdW5pcXVlTWV0YXNbdW5pcXVlSW5kZXhdLmlzU2lnbmVyID0gdW5pcXVlTWV0YXNbdW5pcXVlSW5kZXhdLmlzU2lnbmVyIHx8IGFjY291bnRNZXRhLmlzU2lnbmVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdW5pcXVlTWV0YXMucHVzaChhY2NvdW50TWV0YSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBTb3J0LiBQcmlvcml0aXppbmcgZmlyc3QgYnkgc2lnbmVyLCB0aGVuIGJ5IHdyaXRhYmxlXG4gICAgdW5pcXVlTWV0YXMuc29ydChmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgaWYgKHguaXNTaWduZXIgIT09IHkuaXNTaWduZXIpIHtcbiAgICAgICAgLy8gU2lnbmVycyBhbHdheXMgY29tZSBiZWZvcmUgbm9uLXNpZ25lcnNcbiAgICAgICAgcmV0dXJuIHguaXNTaWduZXIgPyAtMSA6IDE7XG4gICAgICB9XG4gICAgICBpZiAoeC5pc1dyaXRhYmxlICE9PSB5LmlzV3JpdGFibGUpIHtcbiAgICAgICAgLy8gV3JpdGFibGUgYWNjb3VudHMgYWx3YXlzIGNvbWUgYmVmb3JlIHJlYWQtb25seSBhY2NvdW50c1xuICAgICAgICByZXR1cm4geC5pc1dyaXRhYmxlID8gLTEgOiAxO1xuICAgICAgfVxuICAgICAgLy8gT3RoZXJ3aXNlLCBzb3J0IGJ5IHB1YmtleSwgc3RyaW5nd2lzZS5cbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIGxvY2FsZU1hdGNoZXI6ICdiZXN0IGZpdCcsXG4gICAgICAgIHVzYWdlOiAnc29ydCcsXG4gICAgICAgIHNlbnNpdGl2aXR5OiAndmFyaWFudCcsXG4gICAgICAgIGlnbm9yZVB1bmN0dWF0aW9uOiBmYWxzZSxcbiAgICAgICAgbnVtZXJpYzogZmFsc2UsXG4gICAgICAgIGNhc2VGaXJzdDogJ2xvd2VyJ1xuICAgICAgfTtcbiAgICAgIHJldHVybiB4LnB1YmtleS50b0Jhc2U1OCgpLmxvY2FsZUNvbXBhcmUoeS5wdWJrZXkudG9CYXNlNTgoKSwgJ2VuJywgb3B0aW9ucyk7XG4gICAgfSk7XG5cbiAgICAvLyBNb3ZlIGZlZSBwYXllciB0byB0aGUgZnJvbnRcbiAgICBjb25zdCBmZWVQYXllckluZGV4ID0gdW5pcXVlTWV0YXMuZmluZEluZGV4KHggPT4ge1xuICAgICAgcmV0dXJuIHgucHVia2V5LmVxdWFscyhmZWVQYXllcik7XG4gICAgfSk7XG4gICAgaWYgKGZlZVBheWVySW5kZXggPiAtMSkge1xuICAgICAgY29uc3QgW3BheWVyTWV0YV0gPSB1bmlxdWVNZXRhcy5zcGxpY2UoZmVlUGF5ZXJJbmRleCwgMSk7XG4gICAgICBwYXllck1ldGEuaXNTaWduZXIgPSB0cnVlO1xuICAgICAgcGF5ZXJNZXRhLmlzV3JpdGFibGUgPSB0cnVlO1xuICAgICAgdW5pcXVlTWV0YXMudW5zaGlmdChwYXllck1ldGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1bmlxdWVNZXRhcy51bnNoaWZ0KHtcbiAgICAgICAgcHVia2V5OiBmZWVQYXllcixcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIERpc2FsbG93IHVua25vd24gc2lnbmVyc1xuICAgIGZvciAoY29uc3Qgc2lnbmF0dXJlIG9mIHRoaXMuc2lnbmF0dXJlcykge1xuICAgICAgY29uc3QgdW5pcXVlSW5kZXggPSB1bmlxdWVNZXRhcy5maW5kSW5kZXgoeCA9PiB7XG4gICAgICAgIHJldHVybiB4LnB1YmtleS5lcXVhbHMoc2lnbmF0dXJlLnB1YmxpY0tleSk7XG4gICAgICB9KTtcbiAgICAgIGlmICh1bmlxdWVJbmRleCA+IC0xKSB7XG4gICAgICAgIGlmICghdW5pcXVlTWV0YXNbdW5pcXVlSW5kZXhdLmlzU2lnbmVyKSB7XG4gICAgICAgICAgdW5pcXVlTWV0YXNbdW5pcXVlSW5kZXhdLmlzU2lnbmVyID0gdHJ1ZTtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1RyYW5zYWN0aW9uIHJlZmVyZW5jZXMgYSBzaWduYXR1cmUgdGhhdCBpcyB1bm5lY2Vzc2FyeSwgJyArICdvbmx5IHRoZSBmZWUgcGF5ZXIgYW5kIGluc3RydWN0aW9uIHNpZ25lciBhY2NvdW50cyBzaG91bGQgc2lnbiBhIHRyYW5zYWN0aW9uLiAnICsgJ1RoaXMgYmVoYXZpb3IgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCB0aHJvdyBhbiBlcnJvciBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIHJlbGVhc2UuJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biBzaWduZXI6ICR7c2lnbmF0dXJlLnB1YmxpY0tleS50b1N0cmluZygpfWApO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgbnVtUmVxdWlyZWRTaWduYXR1cmVzID0gMDtcbiAgICBsZXQgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50cyA9IDA7XG4gICAgbGV0IG51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50cyA9IDA7XG5cbiAgICAvLyBTcGxpdCBvdXQgc2lnbmluZyBmcm9tIG5vbi1zaWduaW5nIGtleXMgYW5kIGNvdW50IGhlYWRlciB2YWx1ZXNcbiAgICBjb25zdCBzaWduZWRLZXlzID0gW107XG4gICAgY29uc3QgdW5zaWduZWRLZXlzID0gW107XG4gICAgdW5pcXVlTWV0YXMuZm9yRWFjaCgoe1xuICAgICAgcHVia2V5LFxuICAgICAgaXNTaWduZXIsXG4gICAgICBpc1dyaXRhYmxlXG4gICAgfSkgPT4ge1xuICAgICAgaWYgKGlzU2lnbmVyKSB7XG4gICAgICAgIHNpZ25lZEtleXMucHVzaChwdWJrZXkudG9TdHJpbmcoKSk7XG4gICAgICAgIG51bVJlcXVpcmVkU2lnbmF0dXJlcyArPSAxO1xuICAgICAgICBpZiAoIWlzV3JpdGFibGUpIHtcbiAgICAgICAgICBudW1SZWFkb25seVNpZ25lZEFjY291bnRzICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVuc2lnbmVkS2V5cy5wdXNoKHB1YmtleS50b1N0cmluZygpKTtcbiAgICAgICAgaWYgKCFpc1dyaXRhYmxlKSB7XG4gICAgICAgICAgbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBhY2NvdW50S2V5cyA9IHNpZ25lZEtleXMuY29uY2F0KHVuc2lnbmVkS2V5cyk7XG4gICAgY29uc3QgY29tcGlsZWRJbnN0cnVjdGlvbnMgPSBpbnN0cnVjdGlvbnMubWFwKGluc3RydWN0aW9uID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGF0YSxcbiAgICAgICAgcHJvZ3JhbUlkXG4gICAgICB9ID0gaW5zdHJ1Y3Rpb247XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm9ncmFtSWRJbmRleDogYWNjb3VudEtleXMuaW5kZXhPZihwcm9ncmFtSWQudG9TdHJpbmcoKSksXG4gICAgICAgIGFjY291bnRzOiBpbnN0cnVjdGlvbi5rZXlzLm1hcChtZXRhID0+IGFjY291bnRLZXlzLmluZGV4T2YobWV0YS5wdWJrZXkudG9TdHJpbmcoKSkpLFxuICAgICAgICBkYXRhOiBiczU4LmVuY29kZShkYXRhKVxuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb21waWxlZEluc3RydWN0aW9ucy5mb3JFYWNoKGluc3RydWN0aW9uID0+IHtcbiAgICAgIGFzc2VydChpbnN0cnVjdGlvbi5wcm9ncmFtSWRJbmRleCA+PSAwKTtcbiAgICAgIGluc3RydWN0aW9uLmFjY291bnRzLmZvckVhY2goa2V5SW5kZXggPT4gYXNzZXJ0KGtleUluZGV4ID49IDApKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IE1lc3NhZ2Uoe1xuICAgICAgaGVhZGVyOiB7XG4gICAgICAgIG51bVJlcXVpcmVkU2lnbmF0dXJlcyxcbiAgICAgICAgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50cyxcbiAgICAgICAgbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzXG4gICAgICB9LFxuICAgICAgYWNjb3VudEtleXMsXG4gICAgICByZWNlbnRCbG9ja2hhc2gsXG4gICAgICBpbnN0cnVjdGlvbnM6IGNvbXBpbGVkSW5zdHJ1Y3Rpb25zXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfY29tcGlsZSgpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5jb21waWxlTWVzc2FnZSgpO1xuICAgIGNvbnN0IHNpZ25lZEtleXMgPSBtZXNzYWdlLmFjY291bnRLZXlzLnNsaWNlKDAsIG1lc3NhZ2UuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcyk7XG4gICAgaWYgKHRoaXMuc2lnbmF0dXJlcy5sZW5ndGggPT09IHNpZ25lZEtleXMubGVuZ3RoKSB7XG4gICAgICBjb25zdCB2YWxpZCA9IHRoaXMuc2lnbmF0dXJlcy5ldmVyeSgocGFpciwgaW5kZXgpID0+IHtcbiAgICAgICAgcmV0dXJuIHNpZ25lZEtleXNbaW5kZXhdLmVxdWFscyhwYWlyLnB1YmxpY0tleSk7XG4gICAgICB9KTtcbiAgICAgIGlmICh2YWxpZCkgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIHRoaXMuc2lnbmF0dXJlcyA9IHNpZ25lZEtleXMubWFwKHB1YmxpY0tleSA9PiAoe1xuICAgICAgc2lnbmF0dXJlOiBudWxsLFxuICAgICAgcHVibGljS2V5XG4gICAgfSkpO1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIGJ1ZmZlciBvZiB0aGUgVHJhbnNhY3Rpb24gZGF0YSB0aGF0IG5lZWQgdG8gYmUgY292ZXJlZCBieSBzaWduYXR1cmVzXG4gICAqL1xuICBzZXJpYWxpemVNZXNzYWdlKCkge1xuICAgIHJldHVybiB0aGlzLl9jb21waWxlKCkuc2VyaWFsaXplKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBlc3RpbWF0ZWQgZmVlIGFzc29jaWF0ZWQgd2l0aCBhIHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7Q29ubmVjdGlvbn0gY29ubmVjdGlvbiBDb25uZWN0aW9uIHRvIFJQQyBFbmRwb2ludC5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8bnVtYmVyIHwgbnVsbD59IFRoZSBlc3RpbWF0ZWQgZmVlIGZvciB0aGUgdHJhbnNhY3Rpb25cbiAgICovXG4gIGFzeW5jIGdldEVzdGltYXRlZEZlZShjb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuIChhd2FpdCBjb25uZWN0aW9uLmdldEZlZUZvck1lc3NhZ2UodGhpcy5jb21waWxlTWVzc2FnZSgpKSkudmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogU3BlY2lmeSB0aGUgcHVibGljIGtleXMgd2hpY2ggd2lsbCBiZSB1c2VkIHRvIHNpZ24gdGhlIFRyYW5zYWN0aW9uLlxuICAgKiBUaGUgZmlyc3Qgc2lnbmVyIHdpbGwgYmUgdXNlZCBhcyB0aGUgdHJhbnNhY3Rpb24gZmVlIHBheWVyIGFjY291bnQuXG4gICAqXG4gICAqIFNpZ25hdHVyZXMgY2FuIGJlIGFkZGVkIHdpdGggZWl0aGVyIGBwYXJ0aWFsU2lnbmAgb3IgYGFkZFNpZ25hdHVyZWBcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSB2MC44NC4wLiBPbmx5IHRoZSBmZWUgcGF5ZXIgbmVlZHMgdG8gYmVcbiAgICogc3BlY2lmaWVkIGFuZCBpdCBjYW4gYmUgc2V0IGluIHRoZSBUcmFuc2FjdGlvbiBjb25zdHJ1Y3RvciBvciB3aXRoIHRoZVxuICAgKiBgZmVlUGF5ZXJgIHByb3BlcnR5LlxuICAgKi9cbiAgc2V0U2lnbmVycyguLi5zaWduZXJzKSB7XG4gICAgaWYgKHNpZ25lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHNpZ25lcnMnKTtcbiAgICB9XG4gICAgY29uc3Qgc2VlbiA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLnNpZ25hdHVyZXMgPSBzaWduZXJzLmZpbHRlcihwdWJsaWNLZXkgPT4ge1xuICAgICAgY29uc3Qga2V5ID0gcHVibGljS2V5LnRvU3RyaW5nKCk7XG4gICAgICBpZiAoc2Vlbi5oYXMoa2V5KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWVuLmFkZChrZXkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KS5tYXAocHVibGljS2V5ID0+ICh7XG4gICAgICBzaWduYXR1cmU6IG51bGwsXG4gICAgICBwdWJsaWNLZXlcbiAgICB9KSk7XG4gIH1cblxuICAvKipcbiAgICogU2lnbiB0aGUgVHJhbnNhY3Rpb24gd2l0aCB0aGUgc3BlY2lmaWVkIHNpZ25lcnMuIE11bHRpcGxlIHNpZ25hdHVyZXMgbWF5XG4gICAqIGJlIGFwcGxpZWQgdG8gYSBUcmFuc2FjdGlvbi4gVGhlIGZpcnN0IHNpZ25hdHVyZSBpcyBjb25zaWRlcmVkIFwicHJpbWFyeVwiXG4gICAqIGFuZCBpcyB1c2VkIGlkZW50aWZ5IGFuZCBjb25maXJtIHRyYW5zYWN0aW9ucy5cbiAgICpcbiAgICogSWYgdGhlIFRyYW5zYWN0aW9uIGBmZWVQYXllcmAgaXMgbm90IHNldCwgdGhlIGZpcnN0IHNpZ25lciB3aWxsIGJlIHVzZWRcbiAgICogYXMgdGhlIHRyYW5zYWN0aW9uIGZlZSBwYXllciBhY2NvdW50LlxuICAgKlxuICAgKiBUcmFuc2FjdGlvbiBmaWVsZHMgc2hvdWxkIG5vdCBiZSBtb2RpZmllZCBhZnRlciB0aGUgZmlyc3QgY2FsbCB0byBgc2lnbmAsXG4gICAqIGFzIGRvaW5nIHNvIG1heSBpbnZhbGlkYXRlIHRoZSBzaWduYXR1cmUgYW5kIGNhdXNlIHRoZSBUcmFuc2FjdGlvbiB0byBiZVxuICAgKiByZWplY3RlZC5cbiAgICpcbiAgICogVGhlIFRyYW5zYWN0aW9uIG11c3QgYmUgYXNzaWduZWQgYSB2YWxpZCBgcmVjZW50QmxvY2toYXNoYCBiZWZvcmUgaW52b2tpbmcgdGhpcyBtZXRob2RcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxTaWduZXI+fSBzaWduZXJzIEFycmF5IG9mIHNpZ25lcnMgdGhhdCB3aWxsIHNpZ24gdGhlIHRyYW5zYWN0aW9uXG4gICAqL1xuICBzaWduKC4uLnNpZ25lcnMpIHtcbiAgICBpZiAoc2lnbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc2lnbmVycycpO1xuICAgIH1cblxuICAgIC8vIERlZHVwZSBzaWduZXJzXG4gICAgY29uc3Qgc2VlbiA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCB1bmlxdWVTaWduZXJzID0gW107XG4gICAgZm9yIChjb25zdCBzaWduZXIgb2Ygc2lnbmVycykge1xuICAgICAgY29uc3Qga2V5ID0gc2lnbmVyLnB1YmxpY0tleS50b1N0cmluZygpO1xuICAgICAgaWYgKHNlZW4uaGFzKGtleSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWVuLmFkZChrZXkpO1xuICAgICAgICB1bmlxdWVTaWduZXJzLnB1c2goc2lnbmVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zaWduYXR1cmVzID0gdW5pcXVlU2lnbmVycy5tYXAoc2lnbmVyID0+ICh7XG4gICAgICBzaWduYXR1cmU6IG51bGwsXG4gICAgICBwdWJsaWNLZXk6IHNpZ25lci5wdWJsaWNLZXlcbiAgICB9KSk7XG4gICAgY29uc3QgbWVzc2FnZSA9IHRoaXMuX2NvbXBpbGUoKTtcbiAgICB0aGlzLl9wYXJ0aWFsU2lnbihtZXNzYWdlLCAuLi51bmlxdWVTaWduZXJzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJ0aWFsbHkgc2lnbiBhIHRyYW5zYWN0aW9uIHdpdGggdGhlIHNwZWNpZmllZCBhY2NvdW50cy4gQWxsIGFjY291bnRzIG11c3RcbiAgICogY29ycmVzcG9uZCB0byBlaXRoZXIgdGhlIGZlZSBwYXllciBvciBhIHNpZ25lciBhY2NvdW50IGluIHRoZSB0cmFuc2FjdGlvblxuICAgKiBpbnN0cnVjdGlvbnMuXG4gICAqXG4gICAqIEFsbCB0aGUgY2F2ZWF0cyBmcm9tIHRoZSBgc2lnbmAgbWV0aG9kIGFwcGx5IHRvIGBwYXJ0aWFsU2lnbmBcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxTaWduZXI+fSBzaWduZXJzIEFycmF5IG9mIHNpZ25lcnMgdGhhdCB3aWxsIHNpZ24gdGhlIHRyYW5zYWN0aW9uXG4gICAqL1xuICBwYXJ0aWFsU2lnbiguLi5zaWduZXJzKSB7XG4gICAgaWYgKHNpZ25lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHNpZ25lcnMnKTtcbiAgICB9XG5cbiAgICAvLyBEZWR1cGUgc2lnbmVyc1xuICAgIGNvbnN0IHNlZW4gPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgdW5pcXVlU2lnbmVycyA9IFtdO1xuICAgIGZvciAoY29uc3Qgc2lnbmVyIG9mIHNpZ25lcnMpIHtcbiAgICAgIGNvbnN0IGtleSA9IHNpZ25lci5wdWJsaWNLZXkudG9TdHJpbmcoKTtcbiAgICAgIGlmIChzZWVuLmhhcyhrZXkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2Vlbi5hZGQoa2V5KTtcbiAgICAgICAgdW5pcXVlU2lnbmVycy5wdXNoKHNpZ25lcik7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLl9jb21waWxlKCk7XG4gICAgdGhpcy5fcGFydGlhbFNpZ24obWVzc2FnZSwgLi4udW5pcXVlU2lnbmVycyk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfcGFydGlhbFNpZ24obWVzc2FnZSwgLi4uc2lnbmVycykge1xuICAgIGNvbnN0IHNpZ25EYXRhID0gbWVzc2FnZS5zZXJpYWxpemUoKTtcbiAgICBzaWduZXJzLmZvckVhY2goc2lnbmVyID0+IHtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHNpZ24oc2lnbkRhdGEsIHNpZ25lci5zZWNyZXRLZXkpO1xuICAgICAgdGhpcy5fYWRkU2lnbmF0dXJlKHNpZ25lci5wdWJsaWNLZXksIHRvQnVmZmVyKHNpZ25hdHVyZSkpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhbiBleHRlcm5hbGx5IGNyZWF0ZWQgc2lnbmF0dXJlIHRvIGEgdHJhbnNhY3Rpb24uIFRoZSBwdWJsaWMga2V5XG4gICAqIG11c3QgY29ycmVzcG9uZCB0byBlaXRoZXIgdGhlIGZlZSBwYXllciBvciBhIHNpZ25lciBhY2NvdW50IGluIHRoZSB0cmFuc2FjdGlvblxuICAgKiBpbnN0cnVjdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7UHVibGljS2V5fSBwdWJrZXkgUHVibGljIGtleSB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIHRyYW5zYWN0aW9uLlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gc2lnbmF0dXJlIEFuIGV4dGVybmFsbHkgY3JlYXRlZCBzaWduYXR1cmUgdG8gYWRkIHRvIHRoZSB0cmFuc2FjdGlvbi5cbiAgICovXG4gIGFkZFNpZ25hdHVyZShwdWJrZXksIHNpZ25hdHVyZSkge1xuICAgIHRoaXMuX2NvbXBpbGUoKTsgLy8gRW5zdXJlIHNpZ25hdHVyZXMgYXJyYXkgaXMgcG9wdWxhdGVkXG4gICAgdGhpcy5fYWRkU2lnbmF0dXJlKHB1YmtleSwgc2lnbmF0dXJlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9hZGRTaWduYXR1cmUocHVia2V5LCBzaWduYXR1cmUpIHtcbiAgICBhc3NlcnQoc2lnbmF0dXJlLmxlbmd0aCA9PT0gNjQpO1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5zaWduYXR1cmVzLmZpbmRJbmRleChzaWdwYWlyID0+IHB1YmtleS5lcXVhbHMoc2lncGFpci5wdWJsaWNLZXkpKTtcbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gc2lnbmVyOiAke3B1YmtleS50b1N0cmluZygpfWApO1xuICAgIH1cbiAgICB0aGlzLnNpZ25hdHVyZXNbaW5kZXhdLnNpZ25hdHVyZSA9IEJ1ZmZlci5mcm9tKHNpZ25hdHVyZSk7XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZ5IHNpZ25hdHVyZXMgb2YgYSBUcmFuc2FjdGlvblxuICAgKiBPcHRpb25hbCBwYXJhbWV0ZXIgc3BlY2lmaWVzIGlmIHdlJ3JlIGV4cGVjdGluZyBhIGZ1bGx5IHNpZ25lZCBUcmFuc2FjdGlvbiBvciBhIHBhcnRpYWxseSBzaWduZWQgb25lLlxuICAgKiBJZiBubyBib29sZWFuIGlzIHByb3ZpZGVkLCB3ZSBleHBlY3QgYSBmdWxseSBzaWduZWQgVHJhbnNhY3Rpb24gYnkgZGVmYXVsdC5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbcmVxdWlyZUFsbFNpZ25hdHVyZXM9dHJ1ZV0gUmVxdWlyZSBhIGZ1bGx5IHNpZ25lZCBUcmFuc2FjdGlvblxuICAgKi9cbiAgdmVyaWZ5U2lnbmF0dXJlcyhyZXF1aXJlQWxsU2lnbmF0dXJlcyA9IHRydWUpIHtcbiAgICBjb25zdCBzaWduYXR1cmVFcnJvcnMgPSB0aGlzLl9nZXRNZXNzYWdlU2lnbmVkbmVzc0Vycm9ycyh0aGlzLnNlcmlhbGl6ZU1lc3NhZ2UoKSwgcmVxdWlyZUFsbFNpZ25hdHVyZXMpO1xuICAgIHJldHVybiAhc2lnbmF0dXJlRXJyb3JzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2dldE1lc3NhZ2VTaWduZWRuZXNzRXJyb3JzKG1lc3NhZ2UsIHJlcXVpcmVBbGxTaWduYXR1cmVzKSB7XG4gICAgY29uc3QgZXJyb3JzID0ge307XG4gICAgZm9yIChjb25zdCB7XG4gICAgICBzaWduYXR1cmUsXG4gICAgICBwdWJsaWNLZXlcbiAgICB9IG9mIHRoaXMuc2lnbmF0dXJlcykge1xuICAgICAgaWYgKHNpZ25hdHVyZSA9PT0gbnVsbCkge1xuICAgICAgICBpZiAocmVxdWlyZUFsbFNpZ25hdHVyZXMpIHtcbiAgICAgICAgICAoZXJyb3JzLm1pc3NpbmcgfHw9IFtdKS5wdXNoKHB1YmxpY0tleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdmVyaWZ5KHNpZ25hdHVyZSwgbWVzc2FnZSwgcHVibGljS2V5LnRvQnl0ZXMoKSkpIHtcbiAgICAgICAgICAoZXJyb3JzLmludmFsaWQgfHw9IFtdKS5wdXNoKHB1YmxpY0tleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVycm9ycy5pbnZhbGlkIHx8IGVycm9ycy5taXNzaW5nID8gZXJyb3JzIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZSB0aGUgVHJhbnNhY3Rpb24gaW4gdGhlIHdpcmUgZm9ybWF0LlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gW2NvbmZpZ10gQ29uZmlnIG9mIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJucyB7QnVmZmVyfSBTaWduYXR1cmUgb2YgdHJhbnNhY3Rpb24gaW4gd2lyZSBmb3JtYXQuXG4gICAqL1xuICBzZXJpYWxpemUoY29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVxdWlyZUFsbFNpZ25hdHVyZXMsXG4gICAgICB2ZXJpZnlTaWduYXR1cmVzXG4gICAgfSA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgcmVxdWlyZUFsbFNpZ25hdHVyZXM6IHRydWUsXG4gICAgICB2ZXJpZnlTaWduYXR1cmVzOiB0cnVlXG4gICAgfSwgY29uZmlnKTtcbiAgICBjb25zdCBzaWduRGF0YSA9IHRoaXMuc2VyaWFsaXplTWVzc2FnZSgpO1xuICAgIGlmICh2ZXJpZnlTaWduYXR1cmVzKSB7XG4gICAgICBjb25zdCBzaWdFcnJvcnMgPSB0aGlzLl9nZXRNZXNzYWdlU2lnbmVkbmVzc0Vycm9ycyhzaWduRGF0YSwgcmVxdWlyZUFsbFNpZ25hdHVyZXMpO1xuICAgICAgaWYgKHNpZ0Vycm9ycykge1xuICAgICAgICBsZXQgZXJyb3JNZXNzYWdlID0gJ1NpZ25hdHVyZSB2ZXJpZmljYXRpb24gZmFpbGVkLic7XG4gICAgICAgIGlmIChzaWdFcnJvcnMuaW52YWxpZCkge1xuICAgICAgICAgIGVycm9yTWVzc2FnZSArPSBgXFxuSW52YWxpZCBzaWduYXR1cmUgZm9yIHB1YmxpYyBrZXkke3NpZ0Vycm9ycy5pbnZhbGlkLmxlbmd0aCA9PT0gMSA/ICcnIDogJyhzKSd9IFtcXGAke3NpZ0Vycm9ycy5pbnZhbGlkLm1hcChwID0+IHAudG9CYXNlNTgoKSkuam9pbignYCwgYCcpfVxcYF0uYDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2lnRXJyb3JzLm1pc3NpbmcpIHtcbiAgICAgICAgICBlcnJvck1lc3NhZ2UgKz0gYFxcbk1pc3Npbmcgc2lnbmF0dXJlIGZvciBwdWJsaWMga2V5JHtzaWdFcnJvcnMubWlzc2luZy5sZW5ndGggPT09IDEgPyAnJyA6ICcocyknfSBbXFxgJHtzaWdFcnJvcnMubWlzc2luZy5tYXAocCA9PiBwLnRvQmFzZTU4KCkpLmpvaW4oJ2AsIGAnKX1cXGBdLmA7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zZXJpYWxpemUoc2lnbkRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3NlcmlhbGl6ZShzaWduRGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHNpZ25hdHVyZXNcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBzaWduYXR1cmVDb3VudCA9IFtdO1xuICAgIGVuY29kZUxlbmd0aChzaWduYXR1cmVDb3VudCwgc2lnbmF0dXJlcy5sZW5ndGgpO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uTGVuZ3RoID0gc2lnbmF0dXJlQ291bnQubGVuZ3RoICsgc2lnbmF0dXJlcy5sZW5ndGggKiA2NCArIHNpZ25EYXRhLmxlbmd0aDtcbiAgICBjb25zdCB3aXJlVHJhbnNhY3Rpb24gPSBCdWZmZXIuYWxsb2ModHJhbnNhY3Rpb25MZW5ndGgpO1xuICAgIGFzc2VydChzaWduYXR1cmVzLmxlbmd0aCA8IDI1Nik7XG4gICAgQnVmZmVyLmZyb20oc2lnbmF0dXJlQ291bnQpLmNvcHkod2lyZVRyYW5zYWN0aW9uLCAwKTtcbiAgICBzaWduYXR1cmVzLmZvckVhY2goKHtcbiAgICAgIHNpZ25hdHVyZVxuICAgIH0sIGluZGV4KSA9PiB7XG4gICAgICBpZiAoc2lnbmF0dXJlICE9PSBudWxsKSB7XG4gICAgICAgIGFzc2VydChzaWduYXR1cmUubGVuZ3RoID09PSA2NCwgYHNpZ25hdHVyZSBoYXMgaW52YWxpZCBsZW5ndGhgKTtcbiAgICAgICAgQnVmZmVyLmZyb20oc2lnbmF0dXJlKS5jb3B5KHdpcmVUcmFuc2FjdGlvbiwgc2lnbmF0dXJlQ291bnQubGVuZ3RoICsgaW5kZXggKiA2NCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgc2lnbkRhdGEuY29weSh3aXJlVHJhbnNhY3Rpb24sIHNpZ25hdHVyZUNvdW50Lmxlbmd0aCArIHNpZ25hdHVyZXMubGVuZ3RoICogNjQpO1xuICAgIGFzc2VydCh3aXJlVHJhbnNhY3Rpb24ubGVuZ3RoIDw9IFBBQ0tFVF9EQVRBX1NJWkUsIGBUcmFuc2FjdGlvbiB0b28gbGFyZ2U6ICR7d2lyZVRyYW5zYWN0aW9uLmxlbmd0aH0gPiAke1BBQ0tFVF9EQVRBX1NJWkV9YCk7XG4gICAgcmV0dXJuIHdpcmVUcmFuc2FjdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXByZWNhdGVkIG1ldGhvZFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldCBrZXlzKCkge1xuICAgIGFzc2VydCh0aGlzLmluc3RydWN0aW9ucy5sZW5ndGggPT09IDEpO1xuICAgIHJldHVybiB0aGlzLmluc3RydWN0aW9uc1swXS5rZXlzLm1hcChrZXlPYmogPT4ga2V5T2JqLnB1YmtleSk7XG4gIH1cblxuICAvKipcbiAgICogRGVwcmVjYXRlZCBtZXRob2RcbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXQgcHJvZ3JhbUlkKCkge1xuICAgIGFzc2VydCh0aGlzLmluc3RydWN0aW9ucy5sZW5ndGggPT09IDEpO1xuICAgIHJldHVybiB0aGlzLmluc3RydWN0aW9uc1swXS5wcm9ncmFtSWQ7XG4gIH1cblxuICAvKipcbiAgICogRGVwcmVjYXRlZCBtZXRob2RcbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXQgZGF0YSgpIHtcbiAgICBhc3NlcnQodGhpcy5pbnN0cnVjdGlvbnMubGVuZ3RoID09PSAxKTtcbiAgICByZXR1cm4gdGhpcy5pbnN0cnVjdGlvbnNbMF0uZGF0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBhIHdpcmUgdHJhbnNhY3Rpb24gaW50byBhIFRyYW5zYWN0aW9uIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXIgfCBVaW50OEFycmF5IHwgQXJyYXk8bnVtYmVyPn0gYnVmZmVyIFNpZ25hdHVyZSBvZiB3aXJlIFRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvbn0gVHJhbnNhY3Rpb24gYXNzb2NpYXRlZCB3aXRoIHRoZSBzaWduYXR1cmVcbiAgICovXG4gIHN0YXRpYyBmcm9tKGJ1ZmZlcikge1xuICAgIC8vIFNsaWNlIHVwIHdpcmUgZGF0YVxuICAgIGxldCBieXRlQXJyYXkgPSBbLi4uYnVmZmVyXTtcbiAgICBjb25zdCBzaWduYXR1cmVDb3VudCA9IGRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgIGxldCBzaWduYXR1cmVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaWduYXR1cmVDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgU0lHTkFUVVJFX0xFTkdUSF9JTl9CWVRFUyk7XG4gICAgICBzaWduYXR1cmVzLnB1c2goYnM1OC5lbmNvZGUoQnVmZmVyLmZyb20oc2lnbmF0dXJlKSkpO1xuICAgIH1cbiAgICByZXR1cm4gVHJhbnNhY3Rpb24ucG9wdWxhdGUoTWVzc2FnZS5mcm9tKGJ5dGVBcnJheSksIHNpZ25hdHVyZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBvcHVsYXRlIFRyYW5zYWN0aW9uIG9iamVjdCBmcm9tIG1lc3NhZ2UgYW5kIHNpZ25hdHVyZXNcbiAgICpcbiAgICogQHBhcmFtIHtNZXNzYWdlfSBtZXNzYWdlIE1lc3NhZ2Ugb2YgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBzaWduYXR1cmVzIExpc3Qgb2Ygc2lnbmF0dXJlcyB0byBhc3NpZ24gdG8gdGhlIHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvbn0gVGhlIHBvcHVsYXRlZCBUcmFuc2FjdGlvblxuICAgKi9cbiAgc3RhdGljIHBvcHVsYXRlKG1lc3NhZ2UsIHNpZ25hdHVyZXMgPSBbXSkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgdHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoID0gbWVzc2FnZS5yZWNlbnRCbG9ja2hhc2g7XG4gICAgaWYgKG1lc3NhZ2UuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcyA+IDApIHtcbiAgICAgIHRyYW5zYWN0aW9uLmZlZVBheWVyID0gbWVzc2FnZS5hY2NvdW50S2V5c1swXTtcbiAgICB9XG4gICAgc2lnbmF0dXJlcy5mb3JFYWNoKChzaWduYXR1cmUsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBzaWdQdWJrZXlQYWlyID0ge1xuICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZSA9PSBiczU4LmVuY29kZShERUZBVUxUX1NJR05BVFVSRSkgPyBudWxsIDogYnM1OC5kZWNvZGUoc2lnbmF0dXJlKSxcbiAgICAgICAgcHVibGljS2V5OiBtZXNzYWdlLmFjY291bnRLZXlzW2luZGV4XVxuICAgICAgfTtcbiAgICAgIHRyYW5zYWN0aW9uLnNpZ25hdHVyZXMucHVzaChzaWdQdWJrZXlQYWlyKTtcbiAgICB9KTtcbiAgICBtZXNzYWdlLmluc3RydWN0aW9ucy5mb3JFYWNoKGluc3RydWN0aW9uID0+IHtcbiAgICAgIGNvbnN0IGtleXMgPSBpbnN0cnVjdGlvbi5hY2NvdW50cy5tYXAoYWNjb3VudCA9PiB7XG4gICAgICAgIGNvbnN0IHB1YmtleSA9IG1lc3NhZ2UuYWNjb3VudEtleXNbYWNjb3VudF07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcHVia2V5LFxuICAgICAgICAgIGlzU2lnbmVyOiB0cmFuc2FjdGlvbi5zaWduYXR1cmVzLnNvbWUoa2V5T2JqID0+IGtleU9iai5wdWJsaWNLZXkudG9TdHJpbmcoKSA9PT0gcHVia2V5LnRvU3RyaW5nKCkpIHx8IG1lc3NhZ2UuaXNBY2NvdW50U2lnbmVyKGFjY291bnQpLFxuICAgICAgICAgIGlzV3JpdGFibGU6IG1lc3NhZ2UuaXNBY2NvdW50V3JpdGFibGUoYWNjb3VudClcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgdHJhbnNhY3Rpb24uaW5zdHJ1Y3Rpb25zLnB1c2gobmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAgICBrZXlzLFxuICAgICAgICBwcm9ncmFtSWQ6IG1lc3NhZ2UuYWNjb3VudEtleXNbaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkSW5kZXhdLFxuICAgICAgICBkYXRhOiBiczU4LmRlY29kZShpbnN0cnVjdGlvbi5kYXRhKVxuICAgICAgfSkpO1xuICAgIH0pO1xuICAgIHRyYW5zYWN0aW9uLl9tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0cmFuc2FjdGlvbi5fanNvbiA9IHRyYW5zYWN0aW9uLnRvSlNPTigpO1xuICAgIHJldHVybiB0cmFuc2FjdGlvbjtcbiAgfVxufVxuXG5jbGFzcyBUcmFuc2FjdGlvbk1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihhcmdzKSB7XG4gICAgdGhpcy5wYXllcktleSA9IHZvaWQgMDtcbiAgICB0aGlzLmluc3RydWN0aW9ucyA9IHZvaWQgMDtcbiAgICB0aGlzLnJlY2VudEJsb2NraGFzaCA9IHZvaWQgMDtcbiAgICB0aGlzLnBheWVyS2V5ID0gYXJncy5wYXllcktleTtcbiAgICB0aGlzLmluc3RydWN0aW9ucyA9IGFyZ3MuaW5zdHJ1Y3Rpb25zO1xuICAgIHRoaXMucmVjZW50QmxvY2toYXNoID0gYXJncy5yZWNlbnRCbG9ja2hhc2g7XG4gIH1cbiAgc3RhdGljIGRlY29tcGlsZShtZXNzYWdlLCBhcmdzKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGVhZGVyLFxuICAgICAgY29tcGlsZWRJbnN0cnVjdGlvbnMsXG4gICAgICByZWNlbnRCbG9ja2hhc2hcbiAgICB9ID0gbWVzc2FnZTtcbiAgICBjb25zdCB7XG4gICAgICBudW1SZXF1aXJlZFNpZ25hdHVyZXMsXG4gICAgICBudW1SZWFkb25seVNpZ25lZEFjY291bnRzLFxuICAgICAgbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzXG4gICAgfSA9IGhlYWRlcjtcbiAgICBjb25zdCBudW1Xcml0YWJsZVNpZ25lZEFjY291bnRzID0gbnVtUmVxdWlyZWRTaWduYXR1cmVzIC0gbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50cztcbiAgICBhc3NlcnQobnVtV3JpdGFibGVTaWduZWRBY2NvdW50cyA+IDAsICdNZXNzYWdlIGhlYWRlciBpcyBpbnZhbGlkJyk7XG4gICAgY29uc3QgbnVtV3JpdGFibGVVbnNpZ25lZEFjY291bnRzID0gbWVzc2FnZS5zdGF0aWNBY2NvdW50S2V5cy5sZW5ndGggLSBudW1SZXF1aXJlZFNpZ25hdHVyZXMgLSBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHM7XG4gICAgYXNzZXJ0KG51bVdyaXRhYmxlVW5zaWduZWRBY2NvdW50cyA+PSAwLCAnTWVzc2FnZSBoZWFkZXIgaXMgaW52YWxpZCcpO1xuICAgIGNvbnN0IGFjY291bnRLZXlzID0gbWVzc2FnZS5nZXRBY2NvdW50S2V5cyhhcmdzKTtcbiAgICBjb25zdCBwYXllcktleSA9IGFjY291bnRLZXlzLmdldCgwKTtcbiAgICBpZiAocGF5ZXJLZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZGVjb21waWxlIG1lc3NhZ2UgYmVjYXVzZSBubyBhY2NvdW50IGtleXMgd2VyZSBmb3VuZCcpO1xuICAgIH1cbiAgICBjb25zdCBpbnN0cnVjdGlvbnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGNvbXBpbGVkSXggb2YgY29tcGlsZWRJbnN0cnVjdGlvbnMpIHtcbiAgICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICAgIGZvciAoY29uc3Qga2V5SW5kZXggb2YgY29tcGlsZWRJeC5hY2NvdW50S2V5SW5kZXhlcykge1xuICAgICAgICBjb25zdCBwdWJrZXkgPSBhY2NvdW50S2V5cy5nZXQoa2V5SW5kZXgpO1xuICAgICAgICBpZiAocHVia2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmaW5kIGtleSBmb3IgYWNjb3VudCBrZXkgaW5kZXggJHtrZXlJbmRleH1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc1NpZ25lciA9IGtleUluZGV4IDwgbnVtUmVxdWlyZWRTaWduYXR1cmVzO1xuICAgICAgICBsZXQgaXNXcml0YWJsZTtcbiAgICAgICAgaWYgKGlzU2lnbmVyKSB7XG4gICAgICAgICAgaXNXcml0YWJsZSA9IGtleUluZGV4IDwgbnVtV3JpdGFibGVTaWduZWRBY2NvdW50cztcbiAgICAgICAgfSBlbHNlIGlmIChrZXlJbmRleCA8IGFjY291bnRLZXlzLnN0YXRpY0FjY291bnRLZXlzLmxlbmd0aCkge1xuICAgICAgICAgIGlzV3JpdGFibGUgPSBrZXlJbmRleCAtIG51bVJlcXVpcmVkU2lnbmF0dXJlcyA8IG51bVdyaXRhYmxlVW5zaWduZWRBY2NvdW50cztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpc1dyaXRhYmxlID0ga2V5SW5kZXggLSBhY2NvdW50S2V5cy5zdGF0aWNBY2NvdW50S2V5cy5sZW5ndGggPFxuICAgICAgICAgIC8vIGFjY291bnRLZXlzRnJvbUxvb2t1cHMgY2Fubm90IGJlIHVuZGVmaW5lZCBiZWNhdXNlIHdlIGFscmVhZHkgZm91bmQgYSBwdWJrZXkgZm9yIHRoaXMgaW5kZXggYWJvdmVcbiAgICAgICAgICBhY2NvdW50S2V5cy5hY2NvdW50S2V5c0Zyb21Mb29rdXBzLndyaXRhYmxlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBrZXlzLnB1c2goe1xuICAgICAgICAgIHB1YmtleSxcbiAgICAgICAgICBpc1NpZ25lcjoga2V5SW5kZXggPCBoZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzLFxuICAgICAgICAgIGlzV3JpdGFibGVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCBwcm9ncmFtSWQgPSBhY2NvdW50S2V5cy5nZXQoY29tcGlsZWRJeC5wcm9ncmFtSWRJbmRleCk7XG4gICAgICBpZiAocHJvZ3JhbUlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmluZCBwcm9ncmFtIGlkIGZvciBwcm9ncmFtIGlkIGluZGV4ICR7Y29tcGlsZWRJeC5wcm9ncmFtSWRJbmRleH1gKTtcbiAgICAgIH1cbiAgICAgIGluc3RydWN0aW9ucy5wdXNoKG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgICAgcHJvZ3JhbUlkLFxuICAgICAgICBkYXRhOiB0b0J1ZmZlcihjb21waWxlZEl4LmRhdGEpLFxuICAgICAgICBrZXlzXG4gICAgICB9KSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25NZXNzYWdlKHtcbiAgICAgIHBheWVyS2V5LFxuICAgICAgaW5zdHJ1Y3Rpb25zLFxuICAgICAgcmVjZW50QmxvY2toYXNoXG4gICAgfSk7XG4gIH1cbiAgY29tcGlsZVRvTGVnYWN5TWVzc2FnZSgpIHtcbiAgICByZXR1cm4gTWVzc2FnZS5jb21waWxlKHtcbiAgICAgIHBheWVyS2V5OiB0aGlzLnBheWVyS2V5LFxuICAgICAgcmVjZW50QmxvY2toYXNoOiB0aGlzLnJlY2VudEJsb2NraGFzaCxcbiAgICAgIGluc3RydWN0aW9uczogdGhpcy5pbnN0cnVjdGlvbnNcbiAgICB9KTtcbiAgfVxuICBjb21waWxlVG9WME1lc3NhZ2UoYWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudHMpIHtcbiAgICByZXR1cm4gTWVzc2FnZVYwLmNvbXBpbGUoe1xuICAgICAgcGF5ZXJLZXk6IHRoaXMucGF5ZXJLZXksXG4gICAgICByZWNlbnRCbG9ja2hhc2g6IHRoaXMucmVjZW50QmxvY2toYXNoLFxuICAgICAgaW5zdHJ1Y3Rpb25zOiB0aGlzLmluc3RydWN0aW9ucyxcbiAgICAgIGFkZHJlc3NMb29rdXBUYWJsZUFjY291bnRzXG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBWZXJzaW9uZWQgdHJhbnNhY3Rpb24gY2xhc3NcbiAqL1xuY2xhc3MgVmVyc2lvbmVkVHJhbnNhY3Rpb24ge1xuICBnZXQgdmVyc2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlLnZlcnNpb247XG4gIH1cbiAgY29uc3RydWN0b3IobWVzc2FnZSwgc2lnbmF0dXJlcykge1xuICAgIHRoaXMuc2lnbmF0dXJlcyA9IHZvaWQgMDtcbiAgICB0aGlzLm1lc3NhZ2UgPSB2b2lkIDA7XG4gICAgaWYgKHNpZ25hdHVyZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYXNzZXJ0KHNpZ25hdHVyZXMubGVuZ3RoID09PSBtZXNzYWdlLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXMsICdFeHBlY3RlZCBzaWduYXR1cmVzIGxlbmd0aCB0byBiZSBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIHJlcXVpcmVkIHNpZ25hdHVyZXMnKTtcbiAgICAgIHRoaXMuc2lnbmF0dXJlcyA9IHNpZ25hdHVyZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGRlZmF1bHRTaWduYXR1cmVzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lc3NhZ2UuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlczsgaSsrKSB7XG4gICAgICAgIGRlZmF1bHRTaWduYXR1cmVzLnB1c2gobmV3IFVpbnQ4QXJyYXkoU0lHTkFUVVJFX0xFTkdUSF9JTl9CWVRFUykpO1xuICAgICAgfVxuICAgICAgdGhpcy5zaWduYXR1cmVzID0gZGVmYXVsdFNpZ25hdHVyZXM7XG4gICAgfVxuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIH1cbiAgc2VyaWFsaXplKCkge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRNZXNzYWdlID0gdGhpcy5tZXNzYWdlLnNlcmlhbGl6ZSgpO1xuICAgIGNvbnN0IGVuY29kZWRTaWduYXR1cmVzTGVuZ3RoID0gQXJyYXkoKTtcbiAgICBlbmNvZGVMZW5ndGgoZW5jb2RlZFNpZ25hdHVyZXNMZW5ndGgsIHRoaXMuc2lnbmF0dXJlcy5sZW5ndGgpO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uTGF5b3V0ID0gQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LmJsb2IoZW5jb2RlZFNpZ25hdHVyZXNMZW5ndGgubGVuZ3RoLCAnZW5jb2RlZFNpZ25hdHVyZXNMZW5ndGgnKSwgQnVmZmVyTGF5b3V0LnNlcShzaWduYXR1cmUoKSwgdGhpcy5zaWduYXR1cmVzLmxlbmd0aCwgJ3NpZ25hdHVyZXMnKSwgQnVmZmVyTGF5b3V0LmJsb2Ioc2VyaWFsaXplZE1lc3NhZ2UubGVuZ3RoLCAnc2VyaWFsaXplZE1lc3NhZ2UnKV0pO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRUcmFuc2FjdGlvbiA9IG5ldyBVaW50OEFycmF5KDIwNDgpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRUcmFuc2FjdGlvbkxlbmd0aCA9IHRyYW5zYWN0aW9uTGF5b3V0LmVuY29kZSh7XG4gICAgICBlbmNvZGVkU2lnbmF0dXJlc0xlbmd0aDogbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZFNpZ25hdHVyZXNMZW5ndGgpLFxuICAgICAgc2lnbmF0dXJlczogdGhpcy5zaWduYXR1cmVzLFxuICAgICAgc2VyaWFsaXplZE1lc3NhZ2VcbiAgICB9LCBzZXJpYWxpemVkVHJhbnNhY3Rpb24pO1xuICAgIHJldHVybiBzZXJpYWxpemVkVHJhbnNhY3Rpb24uc2xpY2UoMCwgc2VyaWFsaXplZFRyYW5zYWN0aW9uTGVuZ3RoKTtcbiAgfVxuICBzdGF0aWMgZGVzZXJpYWxpemUoc2VyaWFsaXplZFRyYW5zYWN0aW9uKSB7XG4gICAgbGV0IGJ5dGVBcnJheSA9IFsuLi5zZXJpYWxpemVkVHJhbnNhY3Rpb25dO1xuICAgIGNvbnN0IHNpZ25hdHVyZXMgPSBbXTtcbiAgICBjb25zdCBzaWduYXR1cmVzTGVuZ3RoID0gZGVjb2RlTGVuZ3RoKGJ5dGVBcnJheSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaWduYXR1cmVzTGVuZ3RoOyBpKyspIHtcbiAgICAgIHNpZ25hdHVyZXMucHVzaChuZXcgVWludDhBcnJheShndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgU0lHTkFUVVJFX0xFTkdUSF9JTl9CWVRFUykpKTtcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZSA9IFZlcnNpb25lZE1lc3NhZ2UuZGVzZXJpYWxpemUobmV3IFVpbnQ4QXJyYXkoYnl0ZUFycmF5KSk7XG4gICAgcmV0dXJuIG5ldyBWZXJzaW9uZWRUcmFuc2FjdGlvbihtZXNzYWdlLCBzaWduYXR1cmVzKTtcbiAgfVxuICBzaWduKHNpZ25lcnMpIHtcbiAgICBjb25zdCBtZXNzYWdlRGF0YSA9IHRoaXMubWVzc2FnZS5zZXJpYWxpemUoKTtcbiAgICBjb25zdCBzaWduZXJQdWJrZXlzID0gdGhpcy5tZXNzYWdlLnN0YXRpY0FjY291bnRLZXlzLnNsaWNlKDAsIHRoaXMubWVzc2FnZS5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzKTtcbiAgICBmb3IgKGNvbnN0IHNpZ25lciBvZiBzaWduZXJzKSB7XG4gICAgICBjb25zdCBzaWduZXJJbmRleCA9IHNpZ25lclB1YmtleXMuZmluZEluZGV4KHB1YmtleSA9PiBwdWJrZXkuZXF1YWxzKHNpZ25lci5wdWJsaWNLZXkpKTtcbiAgICAgIGFzc2VydChzaWduZXJJbmRleCA+PSAwLCBgQ2Fubm90IHNpZ24gd2l0aCBub24gc2lnbmVyIGtleSAke3NpZ25lci5wdWJsaWNLZXkudG9CYXNlNTgoKX1gKTtcbiAgICAgIHRoaXMuc2lnbmF0dXJlc1tzaWduZXJJbmRleF0gPSBzaWduKG1lc3NhZ2VEYXRhLCBzaWduZXIuc2VjcmV0S2V5KTtcbiAgICB9XG4gIH1cbiAgYWRkU2lnbmF0dXJlKHB1YmxpY0tleSwgc2lnbmF0dXJlKSB7XG4gICAgYXNzZXJ0KHNpZ25hdHVyZS5ieXRlTGVuZ3RoID09PSA2NCwgJ1NpZ25hdHVyZSBtdXN0IGJlIDY0IGJ5dGVzIGxvbmcnKTtcbiAgICBjb25zdCBzaWduZXJQdWJrZXlzID0gdGhpcy5tZXNzYWdlLnN0YXRpY0FjY291bnRLZXlzLnNsaWNlKDAsIHRoaXMubWVzc2FnZS5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzKTtcbiAgICBjb25zdCBzaWduZXJJbmRleCA9IHNpZ25lclB1YmtleXMuZmluZEluZGV4KHB1YmtleSA9PiBwdWJrZXkuZXF1YWxzKHB1YmxpY0tleSkpO1xuICAgIGFzc2VydChzaWduZXJJbmRleCA+PSAwLCBgQ2FuIG5vdCBhZGQgc2lnbmF0dXJlOyBcXGAke3B1YmxpY0tleS50b0Jhc2U1OCgpfVxcYCBpcyBub3QgcmVxdWlyZWQgdG8gc2lnbiB0aGlzIHRyYW5zYWN0aW9uYCk7XG4gICAgdGhpcy5zaWduYXR1cmVzW3NpZ25lckluZGV4XSA9IHNpZ25hdHVyZTtcbiAgfVxufVxuXG4vLyBUT0RPOiBUaGVzZSBjb25zdGFudHMgc2hvdWxkIGJlIHJlbW92ZWQgaW4gZmF2b3Igb2YgcmVhZGluZyB0aGVtIG91dCBvZiBhXG4vLyBTeXNjYWxsIGFjY291bnRcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgTlVNX1RJQ0tTX1BFUl9TRUNPTkQgPSAxNjA7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IERFRkFVTFRfVElDS1NfUEVSX1NMT1QgPSA2NDtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgTlVNX1NMT1RTX1BFUl9TRUNPTkQgPSBOVU1fVElDS1NfUEVSX1NFQ09ORCAvIERFRkFVTFRfVElDS1NfUEVSX1NMT1Q7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IE1TX1BFUl9TTE9UID0gMTAwMCAvIE5VTV9TTE9UU19QRVJfU0VDT05EO1xuXG5jb25zdCBTWVNWQVJfQ0xPQ0tfUFVCS0VZID0gbmV3IFB1YmxpY0tleSgnU3lzdmFyQzFvY2sxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuY29uc3QgU1lTVkFSX0VQT0NIX1NDSEVEVUxFX1BVQktFWSA9IG5ldyBQdWJsaWNLZXkoJ1N5c3ZhckVwb2NoU2NoZWR1MWUxMTExMTExMTExMTExMTExMTExMTExMTEnKTtcbmNvbnN0IFNZU1ZBUl9JTlNUUlVDVElPTlNfUFVCS0VZID0gbmV3IFB1YmxpY0tleSgnU3lzdmFyMW5zdHJ1Y3Rpb25zMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuY29uc3QgU1lTVkFSX1JFQ0VOVF9CTE9DS0hBU0hFU19QVUJLRVkgPSBuZXcgUHVibGljS2V5KCdTeXN2YXJSZWNlbnRCMW9ja0hhc2hlczExMTExMTExMTExMTExMTExMTExJyk7XG5jb25zdCBTWVNWQVJfUkVOVF9QVUJLRVkgPSBuZXcgUHVibGljS2V5KCdTeXN2YXJSZW50MTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5jb25zdCBTWVNWQVJfUkVXQVJEU19QVUJLRVkgPSBuZXcgUHVibGljS2V5KCdTeXN2YXJSZXdhcmRzMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5jb25zdCBTWVNWQVJfU0xPVF9IQVNIRVNfUFVCS0VZID0gbmV3IFB1YmxpY0tleSgnU3lzdmFyUzFvdEhhc2hlczExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuY29uc3QgU1lTVkFSX1NMT1RfSElTVE9SWV9QVUJLRVkgPSBuZXcgUHVibGljS2V5KCdTeXN2YXJTMW90SGlzdG9yeTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5jb25zdCBTWVNWQVJfU1RBS0VfSElTVE9SWV9QVUJLRVkgPSBuZXcgUHVibGljS2V5KCdTeXN2YXJTdGFrZUhpc3RvcnkxMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5cbmNsYXNzIFNlbmRUcmFuc2FjdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgYWN0aW9uLFxuICAgIHNpZ25hdHVyZSxcbiAgICB0cmFuc2FjdGlvbk1lc3NhZ2UsXG4gICAgbG9nc1xuICB9KSB7XG4gICAgY29uc3QgbWF5YmVMb2dzT3V0cHV0ID0gbG9ncyA/IGBMb2dzOiBcXG4ke0pTT04uc3RyaW5naWZ5KGxvZ3Muc2xpY2UoLTEwKSwgbnVsbCwgMil9LiBgIDogJyc7XG4gICAgY29uc3QgZ3VpZGVUZXh0ID0gJ1xcbkNhdGNoIHRoZSBgU2VuZFRyYW5zYWN0aW9uRXJyb3JgIGFuZCBjYWxsIGBnZXRMb2dzKClgIG9uIGl0IGZvciBmdWxsIGRldGFpbHMuJztcbiAgICBsZXQgbWVzc2FnZTtcbiAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgY2FzZSAnc2VuZCc6XG4gICAgICAgIG1lc3NhZ2UgPSBgVHJhbnNhY3Rpb24gJHtzaWduYXR1cmV9IHJlc3VsdGVkIGluIGFuIGVycm9yLiBcXG5gICsgYCR7dHJhbnNhY3Rpb25NZXNzYWdlfS4gYCArIG1heWJlTG9nc091dHB1dCArIGd1aWRlVGV4dDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzaW11bGF0ZSc6XG4gICAgICAgIG1lc3NhZ2UgPSBgU2ltdWxhdGlvbiBmYWlsZWQuIFxcbk1lc3NhZ2U6ICR7dHJhbnNhY3Rpb25NZXNzYWdlfS4gXFxuYCArIG1heWJlTG9nc091dHB1dCArIGd1aWRlVGV4dDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgbWVzc2FnZSA9IGBVbmtub3duIGFjdGlvbiAnJHsoYSA9PiBhKShhY3Rpb24pfSdgO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuc2lnbmF0dXJlID0gdm9pZCAwO1xuICAgIHRoaXMudHJhbnNhY3Rpb25NZXNzYWdlID0gdm9pZCAwO1xuICAgIHRoaXMudHJhbnNhY3Rpb25Mb2dzID0gdm9pZCAwO1xuICAgIHRoaXMuc2lnbmF0dXJlID0gc2lnbmF0dXJlO1xuICAgIHRoaXMudHJhbnNhY3Rpb25NZXNzYWdlID0gdHJhbnNhY3Rpb25NZXNzYWdlO1xuICAgIHRoaXMudHJhbnNhY3Rpb25Mb2dzID0gbG9ncyA/IGxvZ3MgOiB1bmRlZmluZWQ7XG4gIH1cbiAgZ2V0IHRyYW5zYWN0aW9uRXJyb3IoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1lc3NhZ2U6IHRoaXMudHJhbnNhY3Rpb25NZXNzYWdlLFxuICAgICAgbG9nczogQXJyYXkuaXNBcnJheSh0aGlzLnRyYW5zYWN0aW9uTG9ncykgPyB0aGlzLnRyYW5zYWN0aW9uTG9ncyA6IHVuZGVmaW5lZFxuICAgIH07XG4gIH1cblxuICAvKiBAZGVwcmVjYXRlZCBVc2UgYGF3YWl0IGdldExvZ3MoKWAgaW5zdGVhZCAqL1xuICBnZXQgbG9ncygpIHtcbiAgICBjb25zdCBjYWNoZWRMb2dzID0gdGhpcy50cmFuc2FjdGlvbkxvZ3M7XG4gICAgaWYgKGNhY2hlZExvZ3MgIT0gbnVsbCAmJiB0eXBlb2YgY2FjaGVkTG9ncyA9PT0gJ29iamVjdCcgJiYgJ3RoZW4nIGluIGNhY2hlZExvZ3MpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZWRMb2dzO1xuICB9XG4gIGFzeW5jIGdldExvZ3MoY29ubmVjdGlvbikge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0aGlzLnRyYW5zYWN0aW9uTG9ncykpIHtcbiAgICAgIHRoaXMudHJhbnNhY3Rpb25Mb2dzID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25uZWN0aW9uLmdldFRyYW5zYWN0aW9uKHRoaXMuc2lnbmF0dXJlKS50aGVuKHR4ID0+IHtcbiAgICAgICAgICBpZiAodHggJiYgdHgubWV0YSAmJiB0eC5tZXRhLmxvZ01lc3NhZ2VzKSB7XG4gICAgICAgICAgICBjb25zdCBsb2dzID0gdHgubWV0YS5sb2dNZXNzYWdlcztcbiAgICAgICAgICAgIHRoaXMudHJhbnNhY3Rpb25Mb2dzID0gbG9ncztcbiAgICAgICAgICAgIHJlc29sdmUobG9ncyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0xvZyBtZXNzYWdlcyBub3QgZm91bmQnKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zYWN0aW9uTG9ncztcbiAgfVxufVxuXG4vLyBLZWVwIGluIHN5bmMgd2l0aCBjbGllbnQvc3JjL3JwY19jdXN0b21fZXJyb3JzLnJzXG4vLyBUeXBlc2NyaXB0IGBlbnVtc2AgdGh3YXJ0IHRyZWUtc2hha2luZy4gU2VlIGh0dHBzOi8vYmFyZ3N0ZW4ub3JnL2pzdHMvZW51bXMvXG5jb25zdCBTb2xhbmFKU09OUlBDRXJyb3JDb2RlID0ge1xuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfQkxPQ0tfQ0xFQU5FRF9VUDogLTMyMDAxLFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfU0VORF9UUkFOU0FDVElPTl9QUkVGTElHSFRfRkFJTFVSRTogLTMyMDAyLFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fU0lHTkFUVVJFX1ZFUklGSUNBVElPTl9GQUlMVVJFOiAtMzIwMDMsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9CTE9DS19OT1RfQVZBSUxBQkxFOiAtMzIwMDQsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9OT0RFX1VOSEVBTFRIWTogLTMyMDA1LFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fUFJFQ09NUElMRV9WRVJJRklDQVRJT05fRkFJTFVSRTogLTMyMDA2LFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfU0xPVF9TS0lQUEVEOiAtMzIwMDcsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9OT19TTkFQU0hPVDogLTMyMDA4LFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfTE9OR19URVJNX1NUT1JBR0VfU0xPVF9TS0lQUEVEOiAtMzIwMDksXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9LRVlfRVhDTFVERURfRlJPTV9TRUNPTkRBUllfSU5ERVg6IC0zMjAxMCxcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX0hJU1RPUllfTk9UX0FWQUlMQUJMRTogLTMyMDExLFxuICBKU09OX1JQQ19TQ0FOX0VSUk9SOiAtMzIwMTIsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9TSUdOQVRVUkVfTEVOX01JU01BVENIOiAtMzIwMTMsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9CTE9DS19TVEFUVVNfTk9UX0FWQUlMQUJMRV9ZRVQ6IC0zMjAxNCxcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX1VOU1VQUE9SVEVEX1RSQU5TQUNUSU9OX1ZFUlNJT046IC0zMjAxNSxcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX01JTl9DT05URVhUX1NMT1RfTk9UX1JFQUNIRUQ6IC0zMjAxNlxufTtcbmNsYXNzIFNvbGFuYUpTT05SUENFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGNvZGUsXG4gICAgbWVzc2FnZSxcbiAgICBkYXRhXG4gIH0sIGN1c3RvbU1lc3NhZ2UpIHtcbiAgICBzdXBlcihjdXN0b21NZXNzYWdlICE9IG51bGwgPyBgJHtjdXN0b21NZXNzYWdlfTogJHttZXNzYWdlfWAgOiBtZXNzYWdlKTtcbiAgICB0aGlzLmNvZGUgPSB2b2lkIDA7XG4gICAgdGhpcy5kYXRhID0gdm9pZCAwO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLm5hbWUgPSAnU29sYW5hSlNPTlJQQ0Vycm9yJztcbiAgfVxufVxuXG4vKipcbiAqIFNpZ24sIHNlbmQgYW5kIGNvbmZpcm0gYSB0cmFuc2FjdGlvbi5cbiAqXG4gKiBJZiBgY29tbWl0bWVudGAgb3B0aW9uIGlzIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvICdtYXgnIGNvbW1pdG1lbnQuXG4gKlxuICogQHBhcmFtIHtDb25uZWN0aW9ufSBjb25uZWN0aW9uXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtBcnJheTxTaWduZXI+fSBzaWduZXJzXG4gKiBAcGFyYW0ge0NvbmZpcm1PcHRpb25zfSBbb3B0aW9uc11cbiAqIEByZXR1cm5zIHtQcm9taXNlPFRyYW5zYWN0aW9uU2lnbmF0dXJlPn1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gc2VuZEFuZENvbmZpcm1UcmFuc2FjdGlvbihjb25uZWN0aW9uLCB0cmFuc2FjdGlvbiwgc2lnbmVycywgb3B0aW9ucykge1xuICBjb25zdCBzZW5kT3B0aW9ucyA9IG9wdGlvbnMgJiYge1xuICAgIHNraXBQcmVmbGlnaHQ6IG9wdGlvbnMuc2tpcFByZWZsaWdodCxcbiAgICBwcmVmbGlnaHRDb21taXRtZW50OiBvcHRpb25zLnByZWZsaWdodENvbW1pdG1lbnQgfHwgb3B0aW9ucy5jb21taXRtZW50LFxuICAgIG1heFJldHJpZXM6IG9wdGlvbnMubWF4UmV0cmllcyxcbiAgICBtaW5Db250ZXh0U2xvdDogb3B0aW9ucy5taW5Db250ZXh0U2xvdFxuICB9O1xuICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBjb25uZWN0aW9uLnNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgc2lnbmVycywgc2VuZE9wdGlvbnMpO1xuICBsZXQgc3RhdHVzO1xuICBpZiAodHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoICE9IG51bGwgJiYgdHJhbnNhY3Rpb24ubGFzdFZhbGlkQmxvY2tIZWlnaHQgIT0gbnVsbCkge1xuICAgIHN0YXR1cyA9IChhd2FpdCBjb25uZWN0aW9uLmNvbmZpcm1UcmFuc2FjdGlvbih7XG4gICAgICBhYm9ydFNpZ25hbDogb3B0aW9ucz8uYWJvcnRTaWduYWwsXG4gICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZSxcbiAgICAgIGJsb2NraGFzaDogdHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoLFxuICAgICAgbGFzdFZhbGlkQmxvY2tIZWlnaHQ6IHRyYW5zYWN0aW9uLmxhc3RWYWxpZEJsb2NrSGVpZ2h0XG4gICAgfSwgb3B0aW9ucyAmJiBvcHRpb25zLmNvbW1pdG1lbnQpKS52YWx1ZTtcbiAgfSBlbHNlIGlmICh0cmFuc2FjdGlvbi5taW5Ob25jZUNvbnRleHRTbG90ICE9IG51bGwgJiYgdHJhbnNhY3Rpb24ubm9uY2VJbmZvICE9IG51bGwpIHtcbiAgICBjb25zdCB7XG4gICAgICBub25jZUluc3RydWN0aW9uXG4gICAgfSA9IHRyYW5zYWN0aW9uLm5vbmNlSW5mbztcbiAgICBjb25zdCBub25jZUFjY291bnRQdWJrZXkgPSBub25jZUluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5O1xuICAgIHN0YXR1cyA9IChhd2FpdCBjb25uZWN0aW9uLmNvbmZpcm1UcmFuc2FjdGlvbih7XG4gICAgICBhYm9ydFNpZ25hbDogb3B0aW9ucz8uYWJvcnRTaWduYWwsXG4gICAgICBtaW5Db250ZXh0U2xvdDogdHJhbnNhY3Rpb24ubWluTm9uY2VDb250ZXh0U2xvdCxcbiAgICAgIG5vbmNlQWNjb3VudFB1YmtleSxcbiAgICAgIG5vbmNlVmFsdWU6IHRyYW5zYWN0aW9uLm5vbmNlSW5mby5ub25jZSxcbiAgICAgIHNpZ25hdHVyZVxuICAgIH0sIG9wdGlvbnMgJiYgb3B0aW9ucy5jb21taXRtZW50KSkudmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgaWYgKG9wdGlvbnM/LmFib3J0U2lnbmFsICE9IG51bGwpIHtcbiAgICAgIGNvbnNvbGUud2Fybignc2VuZEFuZENvbmZpcm1UcmFuc2FjdGlvbigpOiBBIHRyYW5zYWN0aW9uIHdpdGggYSBkZXByZWNhdGVkIGNvbmZpcm1hdGlvbiBzdHJhdGVneSB3YXMgJyArICdzdXBwbGllZCBhbG9uZyB3aXRoIGFuIGBhYm9ydFNpZ25hbGAuIE9ubHkgdHJhbnNhY3Rpb25zIGhhdmluZyBgbGFzdFZhbGlkQmxvY2tIZWlnaHRgICcgKyAnb3IgYSBjb21iaW5hdGlvbiBvZiBgbm9uY2VJbmZvYCBhbmQgYG1pbk5vbmNlQ29udGV4dFNsb3RgIGFyZSBhYm9ydGFibGUuJyk7XG4gICAgfVxuICAgIHN0YXR1cyA9IChhd2FpdCBjb25uZWN0aW9uLmNvbmZpcm1UcmFuc2FjdGlvbihzaWduYXR1cmUsIG9wdGlvbnMgJiYgb3B0aW9ucy5jb21taXRtZW50KSkudmFsdWU7XG4gIH1cbiAgaWYgKHN0YXR1cy5lcnIpIHtcbiAgICBpZiAoc2lnbmF0dXJlICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBTZW5kVHJhbnNhY3Rpb25FcnJvcih7XG4gICAgICAgIGFjdGlvbjogJ3NlbmQnLFxuICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZSxcbiAgICAgICAgdHJhbnNhY3Rpb25NZXNzYWdlOiBgU3RhdHVzOiAoJHtKU09OLnN0cmluZ2lmeShzdGF0dXMpfSlgXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUcmFuc2FjdGlvbiAke3NpZ25hdHVyZX0gZmFpbGVkICgke0pTT04uc3RyaW5naWZ5KHN0YXR1cyl9KWApO1xuICB9XG4gIHJldHVybiBzaWduYXR1cmU7XG59XG5cbi8vIHp6elxuZnVuY3Rpb24gc2xlZXAobXMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBtcykpO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5cbi8qKlxuICogUG9wdWxhdGUgYSBidWZmZXIgb2YgaW5zdHJ1Y3Rpb24gZGF0YSB1c2luZyBhbiBJbnN0cnVjdGlvblR5cGVcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBlbmNvZGVEYXRhKHR5cGUsIGZpZWxkcykge1xuICBjb25zdCBhbGxvY0xlbmd0aCA9IHR5cGUubGF5b3V0LnNwYW4gPj0gMCA/IHR5cGUubGF5b3V0LnNwYW4gOiBnZXRBbGxvYyh0eXBlLCBmaWVsZHMpO1xuICBjb25zdCBkYXRhID0gQnVmZmVyLmFsbG9jKGFsbG9jTGVuZ3RoKTtcbiAgY29uc3QgbGF5b3V0RmllbGRzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgaW5zdHJ1Y3Rpb246IHR5cGUuaW5kZXhcbiAgfSwgZmllbGRzKTtcbiAgdHlwZS5sYXlvdXQuZW5jb2RlKGxheW91dEZpZWxkcywgZGF0YSk7XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIERlY29kZSBpbnN0cnVjdGlvbiBkYXRhIGJ1ZmZlciB1c2luZyBhbiBJbnN0cnVjdGlvblR5cGVcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBkZWNvZGVEYXRhJDEodHlwZSwgYnVmZmVyKSB7XG4gIGxldCBkYXRhO1xuICB0cnkge1xuICAgIGRhdGEgPSB0eXBlLmxheW91dC5kZWNvZGUoYnVmZmVyKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluc3RydWN0aW9uOyAnICsgZXJyKTtcbiAgfVxuICBpZiAoZGF0YS5pbnN0cnVjdGlvbiAhPT0gdHlwZS5pbmRleCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpbnN0cnVjdGlvbjsgaW5zdHJ1Y3Rpb24gaW5kZXggbWlzbWF0Y2ggJHtkYXRhLmluc3RydWN0aW9ufSAhPSAke3R5cGUuaW5kZXh9YCk7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3NvbGFuYS1sYWJzL3NvbGFuYS9ibG9iLzkwYmVkZDdlMDY3YjViOGYzZGRiYjQ1ZGEwMGE0ZTljYWJiMjJjNjIvc2RrL3NyYy9mZWVfY2FsY3VsYXRvci5ycyNMNy1MMTFcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgRmVlQ2FsY3VsYXRvckxheW91dCA9IEJ1ZmZlckxheW91dC5udTY0KCdsYW1wb3J0c1BlclNpZ25hdHVyZScpO1xuXG4vKipcbiAqIENhbGN1bGF0b3IgZm9yIHRyYW5zYWN0aW9uIGZlZXMuXG4gKlxuICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBTb2xhbmEgdjEuOC4wLlxuICovXG5cbi8qKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xhbmEtbGFicy9zb2xhbmEvYmxvYi8wZWEyODQzZWM5Y2RjNTE3NTcyYjhlNjJjOTU5ZjQxYjU1Y2Y0NDUzL3Nkay9zcmMvbm9uY2Vfc3RhdGUucnMjTDI5LUwzMlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBOb25jZUFjY291bnRMYXlvdXQgPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCd2ZXJzaW9uJyksIEJ1ZmZlckxheW91dC51MzIoJ3N0YXRlJyksIHB1YmxpY0tleSgnYXV0aG9yaXplZFB1YmtleScpLCBwdWJsaWNLZXkoJ25vbmNlJyksIEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0ZlZUNhbGN1bGF0b3JMYXlvdXRdLCAnZmVlQ2FsY3VsYXRvcicpXSk7XG5jb25zdCBOT05DRV9BQ0NPVU5UX0xFTkdUSCA9IE5vbmNlQWNjb3VudExheW91dC5zcGFuO1xuXG4vKipcbiAqIEEgZHVyYWJsZSBub25jZSBpcyBhIDMyIGJ5dGUgdmFsdWUgZW5jb2RlZCBhcyBhIGJhc2U1OCBzdHJpbmcuXG4gKi9cblxuLyoqXG4gKiBOb25jZUFjY291bnQgY2xhc3NcbiAqL1xuY2xhc3MgTm9uY2VBY2NvdW50IHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoYXJncykge1xuICAgIHRoaXMuYXV0aG9yaXplZFB1YmtleSA9IHZvaWQgMDtcbiAgICB0aGlzLm5vbmNlID0gdm9pZCAwO1xuICAgIHRoaXMuZmVlQ2FsY3VsYXRvciA9IHZvaWQgMDtcbiAgICB0aGlzLmF1dGhvcml6ZWRQdWJrZXkgPSBhcmdzLmF1dGhvcml6ZWRQdWJrZXk7XG4gICAgdGhpcy5ub25jZSA9IGFyZ3Mubm9uY2U7XG4gICAgdGhpcy5mZWVDYWxjdWxhdG9yID0gYXJncy5mZWVDYWxjdWxhdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIERlc2VyaWFsaXplIE5vbmNlQWNjb3VudCBmcm9tIHRoZSBhY2NvdW50IGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSBidWZmZXIgYWNjb3VudCBkYXRhXG4gICAqIEByZXR1cm4gTm9uY2VBY2NvdW50XG4gICAqL1xuICBzdGF0aWMgZnJvbUFjY291bnREYXRhKGJ1ZmZlcikge1xuICAgIGNvbnN0IG5vbmNlQWNjb3VudCA9IE5vbmNlQWNjb3VudExheW91dC5kZWNvZGUodG9CdWZmZXIoYnVmZmVyKSwgMCk7XG4gICAgcmV0dXJuIG5ldyBOb25jZUFjY291bnQoe1xuICAgICAgYXV0aG9yaXplZFB1YmtleTogbmV3IFB1YmxpY0tleShub25jZUFjY291bnQuYXV0aG9yaXplZFB1YmtleSksXG4gICAgICBub25jZTogbmV3IFB1YmxpY0tleShub25jZUFjY291bnQubm9uY2UpLnRvU3RyaW5nKCksXG4gICAgICBmZWVDYWxjdWxhdG9yOiBub25jZUFjY291bnQuZmVlQ2FsY3VsYXRvclxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHU2NChwcm9wZXJ0eSkge1xuICBjb25zdCBsYXlvdXQgPSBibG9iKDggLyogYnl0ZXMgKi8sIHByb3BlcnR5KTtcbiAgY29uc3QgZGVjb2RlID0gbGF5b3V0LmRlY29kZS5iaW5kKGxheW91dCk7XG4gIGNvbnN0IGVuY29kZSA9IGxheW91dC5lbmNvZGUuYmluZChsYXlvdXQpO1xuICBjb25zdCBiaWdJbnRMYXlvdXQgPSBsYXlvdXQ7XG4gIGNvbnN0IGNvZGVjID0gZ2V0VTY0Q29kZWMoKTtcbiAgYmlnSW50TGF5b3V0LmRlY29kZSA9IChidWZmZXIsIG9mZnNldCkgPT4ge1xuICAgIGNvbnN0IHNyYyA9IGRlY29kZShidWZmZXIsIG9mZnNldCk7XG4gICAgcmV0dXJuIGNvZGVjLmRlY29kZShzcmMpO1xuICB9O1xuICBiaWdJbnRMYXlvdXQuZW5jb2RlID0gKGJpZ0ludCwgYnVmZmVyLCBvZmZzZXQpID0+IHtcbiAgICBjb25zdCBzcmMgPSBjb2RlYy5lbmNvZGUoYmlnSW50KTtcbiAgICByZXR1cm4gZW5jb2RlKHNyYywgYnVmZmVyLCBvZmZzZXQpO1xuICB9O1xuICByZXR1cm4gYmlnSW50TGF5b3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhY2NvdW50IHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIFRyYW5zZmVyIHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIEFzc2lnbiBzeXN0ZW0gdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBDcmVhdGUgYWNjb3VudCB3aXRoIHNlZWQgc3lzdGVtIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogQ3JlYXRlIG5vbmNlIGFjY291bnQgc3lzdGVtIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogQ3JlYXRlIG5vbmNlIGFjY291bnQgd2l0aCBzZWVkIHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIEluaXRpYWxpemUgbm9uY2UgYWNjb3VudCBzeXN0ZW0gaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBBZHZhbmNlIG5vbmNlIGFjY291bnQgc3lzdGVtIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogV2l0aGRyYXcgbm9uY2UgYWNjb3VudCBzeXN0ZW0gdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBBdXRob3JpemUgbm9uY2UgYWNjb3VudCBzeXN0ZW0gdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBBbGxvY2F0ZSBhY2NvdW50IHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIEFsbG9jYXRlIGFjY291bnQgd2l0aCBzZWVkIHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIEFzc2lnbiBhY2NvdW50IHdpdGggc2VlZCBzeXN0ZW0gdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBUcmFuc2ZlciB3aXRoIHNlZWQgc3lzdGVtIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKiBEZWNvZGVkIHRyYW5zZmVyIHN5c3RlbSB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvbiAqL1xuXG4vKiogRGVjb2RlZCB0cmFuc2ZlcldpdGhTZWVkIHN5c3RlbSB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvbiAqL1xuXG4vKipcbiAqIFN5c3RlbSBJbnN0cnVjdGlvbiBjbGFzc1xuICovXG5jbGFzcyBTeXN0ZW1JbnN0cnVjdGlvbiB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogRGVjb2RlIGEgc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gdHlwZS5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVJbnN0cnVjdGlvblR5cGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25UeXBlTGF5b3V0ID0gQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKTtcbiAgICBjb25zdCB0eXBlSW5kZXggPSBpbnN0cnVjdGlvblR5cGVMYXlvdXQuZGVjb2RlKGluc3RydWN0aW9uLmRhdGEpO1xuICAgIGxldCB0eXBlO1xuICAgIGZvciAoY29uc3QgW2l4VHlwZSwgbGF5b3V0XSBvZiBPYmplY3QuZW50cmllcyhTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUykpIHtcbiAgICAgIGlmIChsYXlvdXQuaW5kZXggPT0gdHlwZUluZGV4KSB7XG4gICAgICAgIHR5cGUgPSBpeFR5cGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5zdHJ1Y3Rpb24gdHlwZSBpbmNvcnJlY3Q7IG5vdCBhIFN5c3RlbUluc3RydWN0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIGNyZWF0ZSBhY2NvdW50IHN5c3RlbSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVDcmVhdGVBY2NvdW50KGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMik7XG4gICAgY29uc3Qge1xuICAgICAgbGFtcG9ydHMsXG4gICAgICBzcGFjZSxcbiAgICAgIHByb2dyYW1JZFxuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQ3JlYXRlLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgZnJvbVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBuZXdBY2NvdW50UHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgIGxhbXBvcnRzLFxuICAgICAgc3BhY2UsXG4gICAgICBwcm9ncmFtSWQ6IG5ldyBQdWJsaWNLZXkocHJvZ3JhbUlkKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgdHJhbnNmZXIgc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZVRyYW5zZmVyKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMik7XG4gICAgY29uc3Qge1xuICAgICAgbGFtcG9ydHNcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLlRyYW5zZmVyLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgZnJvbVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICB0b1B1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICBsYW1wb3J0c1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgdHJhbnNmZXIgd2l0aCBzZWVkIHN5c3RlbSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVUcmFuc2ZlcldpdGhTZWVkKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMyk7XG4gICAgY29uc3Qge1xuICAgICAgbGFtcG9ydHMsXG4gICAgICBzZWVkLFxuICAgICAgcHJvZ3JhbUlkXG4gICAgfSA9IGRlY29kZURhdGEkMShTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5UcmFuc2ZlcldpdGhTZWVkLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgZnJvbVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBiYXNlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgIHRvUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzJdLnB1YmtleSxcbiAgICAgIGxhbXBvcnRzLFxuICAgICAgc2VlZCxcbiAgICAgIHByb2dyYW1JZDogbmV3IFB1YmxpY0tleShwcm9ncmFtSWQpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYW4gYWxsb2NhdGUgc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUFsbG9jYXRlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMSk7XG4gICAgY29uc3Qge1xuICAgICAgc3BhY2VcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkFsbG9jYXRlLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgYWNjb3VudFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBzcGFjZVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGFuIGFsbG9jYXRlIHdpdGggc2VlZCBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlQWxsb2NhdGVXaXRoU2VlZChpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDEpO1xuICAgIGNvbnN0IHtcbiAgICAgIGJhc2UsXG4gICAgICBzZWVkLFxuICAgICAgc3BhY2UsXG4gICAgICBwcm9ncmFtSWRcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkFsbG9jYXRlV2l0aFNlZWQsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBhY2NvdW50UHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGJhc2VQdWJrZXk6IG5ldyBQdWJsaWNLZXkoYmFzZSksXG4gICAgICBzZWVkLFxuICAgICAgc3BhY2UsXG4gICAgICBwcm9ncmFtSWQ6IG5ldyBQdWJsaWNLZXkocHJvZ3JhbUlkKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGFuIGFzc2lnbiBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlQXNzaWduKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMSk7XG4gICAgY29uc3Qge1xuICAgICAgcHJvZ3JhbUlkXG4gICAgfSA9IGRlY29kZURhdGEkMShTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5Bc3NpZ24sIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBhY2NvdW50UHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIHByb2dyYW1JZDogbmV3IFB1YmxpY0tleShwcm9ncmFtSWQpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYW4gYXNzaWduIHdpdGggc2VlZCBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlQXNzaWduV2l0aFNlZWQoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAxKTtcbiAgICBjb25zdCB7XG4gICAgICBiYXNlLFxuICAgICAgc2VlZCxcbiAgICAgIHByb2dyYW1JZFxuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXNzaWduV2l0aFNlZWQsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBhY2NvdW50UHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGJhc2VQdWJrZXk6IG5ldyBQdWJsaWNLZXkoYmFzZSksXG4gICAgICBzZWVkLFxuICAgICAgcHJvZ3JhbUlkOiBuZXcgUHVibGljS2V5KHByb2dyYW1JZClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIGNyZWF0ZSBhY2NvdW50IHdpdGggc2VlZCBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlQ3JlYXRlV2l0aFNlZWQoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAyKTtcbiAgICBjb25zdCB7XG4gICAgICBiYXNlLFxuICAgICAgc2VlZCxcbiAgICAgIGxhbXBvcnRzLFxuICAgICAgc3BhY2UsXG4gICAgICBwcm9ncmFtSWRcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkNyZWF0ZVdpdGhTZWVkLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgZnJvbVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBuZXdBY2NvdW50UHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgIGJhc2VQdWJrZXk6IG5ldyBQdWJsaWNLZXkoYmFzZSksXG4gICAgICBzZWVkLFxuICAgICAgbGFtcG9ydHMsXG4gICAgICBzcGFjZSxcbiAgICAgIHByb2dyYW1JZDogbmV3IFB1YmxpY0tleShwcm9ncmFtSWQpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBub25jZSBpbml0aWFsaXplIHN5c3RlbSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVOb25jZUluaXRpYWxpemUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAzKTtcbiAgICBjb25zdCB7XG4gICAgICBhdXRob3JpemVkXG4gICAgfSA9IGRlY29kZURhdGEkMShTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5Jbml0aWFsaXplTm9uY2VBY2NvdW50LCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgbm9uY2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogbmV3IFB1YmxpY0tleShhdXRob3JpemVkKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgbm9uY2UgYWR2YW5jZSBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlTm9uY2VBZHZhbmNlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMyk7XG4gICAgZGVjb2RlRGF0YSQxKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkFkdmFuY2VOb25jZUFjY291bnQsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBub25jZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzJdLnB1YmtleVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgbm9uY2Ugd2l0aGRyYXcgc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZU5vbmNlV2l0aGRyYXcoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCA1KTtcbiAgICBjb25zdCB7XG4gICAgICBsYW1wb3J0c1xuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuV2l0aGRyYXdOb25jZUFjY291bnQsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBub25jZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICB0b1B1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzRdLnB1YmtleSxcbiAgICAgIGxhbXBvcnRzXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBub25jZSBhdXRob3JpemUgc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZU5vbmNlQXV0aG9yaXplKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMik7XG4gICAgY29uc3Qge1xuICAgICAgYXV0aG9yaXplZFxuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXV0aG9yaXplTm9uY2VBY2NvdW50LCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgbm9uY2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICBuZXdBdXRob3JpemVkUHVia2V5OiBuZXcgUHVibGljS2V5KGF1dGhvcml6ZWQpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHN0YXRpYyBjaGVja1Byb2dyYW1JZChwcm9ncmFtSWQpIHtcbiAgICBpZiAoIXByb2dyYW1JZC5lcXVhbHMoU3lzdGVtUHJvZ3JhbS5wcm9ncmFtSWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5zdHJ1Y3Rpb247IHByb2dyYW1JZCBpcyBub3QgU3lzdGVtUHJvZ3JhbScpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHN0YXRpYyBjaGVja0tleUxlbmd0aChrZXlzLCBleHBlY3RlZExlbmd0aCkge1xuICAgIGlmIChrZXlzLmxlbmd0aCA8IGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW5zdHJ1Y3Rpb247IGZvdW5kICR7a2V5cy5sZW5ndGh9IGtleXMsIGV4cGVjdGVkIGF0IGxlYXN0ICR7ZXhwZWN0ZWRMZW5ndGh9YCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgdmFsaWQgU3lzdGVtSW5zdHJ1Y3Rpb25UeXBlJ3NcbiAqL1xuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIG9mIHZhbGlkIHN5c3RlbSBJbnN0cnVjdGlvblR5cGUnc1xuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTID0gT2JqZWN0LmZyZWV6ZSh7XG4gIENyZWF0ZToge1xuICAgIGluZGV4OiAwLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgQnVmZmVyTGF5b3V0Lm5zNjQoJ2xhbXBvcnRzJyksIEJ1ZmZlckxheW91dC5uczY0KCdzcGFjZScpLCBwdWJsaWNLZXkoJ3Byb2dyYW1JZCcpXSlcbiAgfSxcbiAgQXNzaWduOiB7XG4gICAgaW5kZXg6IDEsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBwdWJsaWNLZXkoJ3Byb2dyYW1JZCcpXSlcbiAgfSxcbiAgVHJhbnNmZXI6IHtcbiAgICBpbmRleDogMixcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIHU2NCgnbGFtcG9ydHMnKV0pXG4gIH0sXG4gIENyZWF0ZVdpdGhTZWVkOiB7XG4gICAgaW5kZXg6IDMsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBwdWJsaWNLZXkoJ2Jhc2UnKSwgcnVzdFN0cmluZygnc2VlZCcpLCBCdWZmZXJMYXlvdXQubnM2NCgnbGFtcG9ydHMnKSwgQnVmZmVyTGF5b3V0Lm5zNjQoJ3NwYWNlJyksIHB1YmxpY0tleSgncHJvZ3JhbUlkJyldKVxuICB9LFxuICBBZHZhbmNlTm9uY2VBY2NvdW50OiB7XG4gICAgaW5kZXg6IDQsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpXSlcbiAgfSxcbiAgV2l0aGRyYXdOb25jZUFjY291bnQ6IHtcbiAgICBpbmRleDogNSxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIEJ1ZmZlckxheW91dC5uczY0KCdsYW1wb3J0cycpXSlcbiAgfSxcbiAgSW5pdGlhbGl6ZU5vbmNlQWNjb3VudDoge1xuICAgIGluZGV4OiA2LFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgcHVibGljS2V5KCdhdXRob3JpemVkJyldKVxuICB9LFxuICBBdXRob3JpemVOb25jZUFjY291bnQ6IHtcbiAgICBpbmRleDogNyxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIHB1YmxpY0tleSgnYXV0aG9yaXplZCcpXSlcbiAgfSxcbiAgQWxsb2NhdGU6IHtcbiAgICBpbmRleDogOCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIEJ1ZmZlckxheW91dC5uczY0KCdzcGFjZScpXSlcbiAgfSxcbiAgQWxsb2NhdGVXaXRoU2VlZDoge1xuICAgIGluZGV4OiA5LFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgcHVibGljS2V5KCdiYXNlJyksIHJ1c3RTdHJpbmcoJ3NlZWQnKSwgQnVmZmVyTGF5b3V0Lm5zNjQoJ3NwYWNlJyksIHB1YmxpY0tleSgncHJvZ3JhbUlkJyldKVxuICB9LFxuICBBc3NpZ25XaXRoU2VlZDoge1xuICAgIGluZGV4OiAxMCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIHB1YmxpY0tleSgnYmFzZScpLCBydXN0U3RyaW5nKCdzZWVkJyksIHB1YmxpY0tleSgncHJvZ3JhbUlkJyldKVxuICB9LFxuICBUcmFuc2ZlcldpdGhTZWVkOiB7XG4gICAgaW5kZXg6IDExLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgdTY0KCdsYW1wb3J0cycpLCBydXN0U3RyaW5nKCdzZWVkJyksIHB1YmxpY0tleSgncHJvZ3JhbUlkJyldKVxuICB9LFxuICBVcGdyYWRlTm9uY2VBY2NvdW50OiB7XG4gICAgaW5kZXg6IDEyLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKV0pXG4gIH1cbn0pO1xuXG4vKipcbiAqIEZhY3RvcnkgY2xhc3MgZm9yIHRyYW5zYWN0aW9ucyB0byBpbnRlcmFjdCB3aXRoIHRoZSBTeXN0ZW0gcHJvZ3JhbVxuICovXG5jbGFzcyBTeXN0ZW1Qcm9ncmFtIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBQdWJsaWMga2V5IHRoYXQgaWRlbnRpZmllcyB0aGUgU3lzdGVtIHByb2dyYW1cbiAgICovXG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb24gdGhhdCBjcmVhdGVzIGEgbmV3IGFjY291bnRcbiAgICovXG4gIHN0YXRpYyBjcmVhdGVBY2NvdW50KHBhcmFtcykge1xuICAgIGNvbnN0IHR5cGUgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5DcmVhdGU7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgbGFtcG9ydHM6IHBhcmFtcy5sYW1wb3J0cyxcbiAgICAgIHNwYWNlOiBwYXJhbXMuc3BhY2UsXG4gICAgICBwcm9ncmFtSWQ6IHRvQnVmZmVyKHBhcmFtcy5wcm9ncmFtSWQudG9CdWZmZXIoKSlcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5czogW3tcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuZnJvbVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMubmV3QWNjb3VudFB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH1dLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIGluc3RydWN0aW9uIHRoYXQgdHJhbnNmZXJzIGxhbXBvcnRzIGZyb20gb25lIGFjY291bnQgdG8gYW5vdGhlclxuICAgKi9cbiAgc3RhdGljIHRyYW5zZmVyKHBhcmFtcykge1xuICAgIGxldCBkYXRhO1xuICAgIGxldCBrZXlzO1xuICAgIGlmICgnYmFzZVB1YmtleScgaW4gcGFyYW1zKSB7XG4gICAgICBjb25zdCB0eXBlID0gU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuVHJhbnNmZXJXaXRoU2VlZDtcbiAgICAgIGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgICAgbGFtcG9ydHM6IEJpZ0ludChwYXJhbXMubGFtcG9ydHMpLFxuICAgICAgICBzZWVkOiBwYXJhbXMuc2VlZCxcbiAgICAgICAgcHJvZ3JhbUlkOiB0b0J1ZmZlcihwYXJhbXMucHJvZ3JhbUlkLnRvQnVmZmVyKCkpXG4gICAgICB9KTtcbiAgICAgIGtleXMgPSBbe1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5mcm9tUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuYmFzZVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLnRvUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH1dO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0eXBlID0gU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuVHJhbnNmZXI7XG4gICAgICBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICAgIGxhbXBvcnRzOiBCaWdJbnQocGFyYW1zLmxhbXBvcnRzKVxuICAgICAgfSk7XG4gICAgICBrZXlzID0gW3tcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuZnJvbVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMudG9QdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfV07XG4gICAgfVxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIGluc3RydWN0aW9uIHRoYXQgYXNzaWducyBhbiBhY2NvdW50IHRvIGEgcHJvZ3JhbVxuICAgKi9cbiAgc3RhdGljIGFzc2lnbihwYXJhbXMpIHtcbiAgICBsZXQgZGF0YTtcbiAgICBsZXQga2V5cztcbiAgICBpZiAoJ2Jhc2VQdWJrZXknIGluIHBhcmFtcykge1xuICAgICAgY29uc3QgdHlwZSA9IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkFzc2lnbldpdGhTZWVkO1xuICAgICAgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgICBiYXNlOiB0b0J1ZmZlcihwYXJhbXMuYmFzZVB1YmtleS50b0J1ZmZlcigpKSxcbiAgICAgICAgc2VlZDogcGFyYW1zLnNlZWQsXG4gICAgICAgIHByb2dyYW1JZDogdG9CdWZmZXIocGFyYW1zLnByb2dyYW1JZC50b0J1ZmZlcigpKVxuICAgICAgfSk7XG4gICAgICBrZXlzID0gW3tcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuYWNjb3VudFB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmJhc2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5Bc3NpZ247XG4gICAgICBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICAgIHByb2dyYW1JZDogdG9CdWZmZXIocGFyYW1zLnByb2dyYW1JZC50b0J1ZmZlcigpKVxuICAgICAgfSk7XG4gICAgICBrZXlzID0gW3tcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuYWNjb3VudFB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH1dO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5cyxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvbiB0aGF0IGNyZWF0ZXMgYSBuZXcgYWNjb3VudCBhdFxuICAgKiAgIGFuIGFkZHJlc3MgZ2VuZXJhdGVkIHdpdGggYGZyb21gLCBhIHNlZWQsIGFuZCBwcm9ncmFtSWRcbiAgICovXG4gIHN0YXRpYyBjcmVhdGVBY2NvdW50V2l0aFNlZWQocGFyYW1zKSB7XG4gICAgY29uc3QgdHlwZSA9IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkNyZWF0ZVdpdGhTZWVkO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIGJhc2U6IHRvQnVmZmVyKHBhcmFtcy5iYXNlUHVia2V5LnRvQnVmZmVyKCkpLFxuICAgICAgc2VlZDogcGFyYW1zLnNlZWQsXG4gICAgICBsYW1wb3J0czogcGFyYW1zLmxhbXBvcnRzLFxuICAgICAgc3BhY2U6IHBhcmFtcy5zcGFjZSxcbiAgICAgIHByb2dyYW1JZDogdG9CdWZmZXIocGFyYW1zLnByb2dyYW1JZC50b0J1ZmZlcigpKVxuICAgIH0pO1xuICAgIGxldCBrZXlzID0gW3tcbiAgICAgIHB1YmtleTogcGFyYW1zLmZyb21QdWJrZXksXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IHBhcmFtcy5uZXdBY2NvdW50UHVia2V5LFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH1dO1xuICAgIGlmICghcGFyYW1zLmJhc2VQdWJrZXkuZXF1YWxzKHBhcmFtcy5mcm9tUHVia2V5KSkge1xuICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuYmFzZVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhbnNhY3Rpb24gdGhhdCBjcmVhdGVzIGEgbmV3IE5vbmNlIGFjY291bnRcbiAgICovXG4gIHN0YXRpYyBjcmVhdGVOb25jZUFjY291bnQocGFyYW1zKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICBpZiAoJ2Jhc2VQdWJrZXknIGluIHBhcmFtcyAmJiAnc2VlZCcgaW4gcGFyYW1zKSB7XG4gICAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS5jcmVhdGVBY2NvdW50V2l0aFNlZWQoe1xuICAgICAgICBmcm9tUHVia2V5OiBwYXJhbXMuZnJvbVB1YmtleSxcbiAgICAgICAgbmV3QWNjb3VudFB1YmtleTogcGFyYW1zLm5vbmNlUHVia2V5LFxuICAgICAgICBiYXNlUHVia2V5OiBwYXJhbXMuYmFzZVB1YmtleSxcbiAgICAgICAgc2VlZDogcGFyYW1zLnNlZWQsXG4gICAgICAgIGxhbXBvcnRzOiBwYXJhbXMubGFtcG9ydHMsXG4gICAgICAgIHNwYWNlOiBOT05DRV9BQ0NPVU5UX0xFTkdUSCxcbiAgICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZFxuICAgICAgfSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS5jcmVhdGVBY2NvdW50KHtcbiAgICAgICAgZnJvbVB1YmtleTogcGFyYW1zLmZyb21QdWJrZXksXG4gICAgICAgIG5ld0FjY291bnRQdWJrZXk6IHBhcmFtcy5ub25jZVB1YmtleSxcbiAgICAgICAgbGFtcG9ydHM6IHBhcmFtcy5sYW1wb3J0cyxcbiAgICAgICAgc3BhY2U6IE5PTkNFX0FDQ09VTlRfTEVOR1RILFxuICAgICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkXG4gICAgICB9KSk7XG4gICAgfVxuICAgIGNvbnN0IGluaXRQYXJhbXMgPSB7XG4gICAgICBub25jZVB1YmtleTogcGFyYW1zLm5vbmNlUHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogcGFyYW1zLmF1dGhvcml6ZWRQdWJrZXlcbiAgICB9O1xuICAgIHRyYW5zYWN0aW9uLmFkZCh0aGlzLm5vbmNlSW5pdGlhbGl6ZShpbml0UGFyYW1zKSk7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGFuIGluc3RydWN0aW9uIHRvIGluaXRpYWxpemUgYSBOb25jZSBhY2NvdW50XG4gICAqL1xuICBzdGF0aWMgbm9uY2VJbml0aWFsaXplKHBhcmFtcykge1xuICAgIGNvbnN0IHR5cGUgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5Jbml0aWFsaXplTm9uY2VBY2NvdW50O1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIGF1dGhvcml6ZWQ6IHRvQnVmZmVyKHBhcmFtcy5hdXRob3JpemVkUHVia2V5LnRvQnVmZmVyKCkpXG4gICAgfSk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25EYXRhID0ge1xuICAgICAga2V5czogW3tcbiAgICAgICAgcHVia2V5OiBwYXJhbXMubm9uY2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IFNZU1ZBUl9SRUNFTlRfQkxPQ0tIQVNIRVNfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX1JFTlRfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9XSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb25EYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhbiBpbnN0cnVjdGlvbiB0byBhZHZhbmNlIHRoZSBub25jZSBpbiBhIE5vbmNlIGFjY291bnRcbiAgICovXG4gIHN0YXRpYyBub25jZUFkdmFuY2UocGFyYW1zKSB7XG4gICAgY29uc3QgdHlwZSA9IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkFkdmFuY2VOb25jZUFjY291bnQ7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25EYXRhID0ge1xuICAgICAga2V5czogW3tcbiAgICAgICAgcHVia2V5OiBwYXJhbXMubm9uY2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IFNZU1ZBUl9SRUNFTlRfQkxPQ0tIQVNIRVNfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmF1dGhvcml6ZWRQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfV0sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH07XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKGluc3RydWN0aW9uRGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvbiB0aGF0IHdpdGhkcmF3cyBsYW1wb3J0cyBmcm9tIGEgTm9uY2UgYWNjb3VudFxuICAgKi9cbiAgc3RhdGljIG5vbmNlV2l0aGRyYXcocGFyYW1zKSB7XG4gICAgY29uc3QgdHlwZSA9IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLldpdGhkcmF3Tm9uY2VBY2NvdW50O1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIGxhbXBvcnRzOiBwYXJhbXMubGFtcG9ydHNcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5czogW3tcbiAgICAgICAgcHVia2V5OiBwYXJhbXMubm9uY2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy50b1B1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX1JFQ0VOVF9CTE9DS0hBU0hFU19QVUJLRVksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBTWVNWQVJfUkVOVF9QVUJLRVksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuYXV0aG9yaXplZFB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9XSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvbiB0aGF0IGF1dGhvcml6ZXMgYSBuZXcgUHVibGljS2V5IGFzIHRoZSBhdXRob3JpdHlcbiAgICogb24gYSBOb25jZSBhY2NvdW50LlxuICAgKi9cbiAgc3RhdGljIG5vbmNlQXV0aG9yaXplKHBhcmFtcykge1xuICAgIGNvbnN0IHR5cGUgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5BdXRob3JpemVOb25jZUFjY291bnQ7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgYXV0aG9yaXplZDogdG9CdWZmZXIocGFyYW1zLm5ld0F1dGhvcml6ZWRQdWJrZXkudG9CdWZmZXIoKSlcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5czogW3tcbiAgICAgICAgcHVia2V5OiBwYXJhbXMubm9uY2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5hdXRob3JpemVkUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH1dLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIGluc3RydWN0aW9uIHRoYXQgYWxsb2NhdGVzIHNwYWNlIGluIGFuIGFjY291bnQgd2l0aG91dCBmdW5kaW5nXG4gICAqL1xuICBzdGF0aWMgYWxsb2NhdGUocGFyYW1zKSB7XG4gICAgbGV0IGRhdGE7XG4gICAgbGV0IGtleXM7XG4gICAgaWYgKCdiYXNlUHVia2V5JyBpbiBwYXJhbXMpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5BbGxvY2F0ZVdpdGhTZWVkO1xuICAgICAgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgICBiYXNlOiB0b0J1ZmZlcihwYXJhbXMuYmFzZVB1YmtleS50b0J1ZmZlcigpKSxcbiAgICAgICAgc2VlZDogcGFyYW1zLnNlZWQsXG4gICAgICAgIHNwYWNlOiBwYXJhbXMuc3BhY2UsXG4gICAgICAgIHByb2dyYW1JZDogdG9CdWZmZXIocGFyYW1zLnByb2dyYW1JZC50b0J1ZmZlcigpKVxuICAgICAgfSk7XG4gICAgICBrZXlzID0gW3tcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuYWNjb3VudFB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmJhc2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5BbGxvY2F0ZTtcbiAgICAgIGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgICAgc3BhY2U6IHBhcmFtcy5zcGFjZVxuICAgICAgfSk7XG4gICAgICBrZXlzID0gW3tcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuYWNjb3VudFB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH1dO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5cyxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cbn1cblN5c3RlbVByb2dyYW0ucHJvZ3JhbUlkID0gbmV3IFB1YmxpY0tleSgnMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcblxuLy8gS2VlcCBwcm9ncmFtIGNodW5rcyB1bmRlciBQQUNLRVRfREFUQV9TSVpFLCBsZWF2aW5nIGVub3VnaCByb29tIGZvciB0aGVcbi8vIHJlc3Qgb2YgdGhlIFRyYW5zYWN0aW9uIGZpZWxkc1xuLy9cbi8vIFRPRE86IHJlcGxhY2UgMzAwIHdpdGggYSBwcm9wZXIgY29uc3RhbnQgZm9yIHRoZSBzaXplIG9mIHRoZSBvdGhlclxuLy8gVHJhbnNhY3Rpb24gZmllbGRzXG5jb25zdCBDSFVOS19TSVpFID0gUEFDS0VUX0RBVEFfU0laRSAtIDMwMDtcblxuLyoqXG4gKiBQcm9ncmFtIGxvYWRlciBpbnRlcmZhY2VcbiAqL1xuY2xhc3MgTG9hZGVyIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBBbW91bnQgb2YgcHJvZ3JhbSBkYXRhIHBsYWNlZCBpbiBlYWNoIGxvYWQgVHJhbnNhY3Rpb25cbiAgICovXG5cbiAgLyoqXG4gICAqIE1pbmltdW0gbnVtYmVyIG9mIHNpZ25hdHVyZXMgcmVxdWlyZWQgdG8gbG9hZCBhIHByb2dyYW0gbm90IGluY2x1ZGluZ1xuICAgKiByZXRyaWVzXG4gICAqXG4gICAqIENhbiBiZSB1c2VkIHRvIGNhbGN1bGF0ZSB0cmFuc2FjdGlvbiBmZWVzXG4gICAqL1xuICBzdGF0aWMgZ2V0TWluTnVtU2lnbmF0dXJlcyhkYXRhTGVuZ3RoKSB7XG4gICAgcmV0dXJuIDIgKiAoXG4gICAgLy8gRXZlcnkgdHJhbnNhY3Rpb24gcmVxdWlyZXMgdHdvIHNpZ25hdHVyZXMgKHBheWVyICsgcHJvZ3JhbSlcbiAgICBNYXRoLmNlaWwoZGF0YUxlbmd0aCAvIExvYWRlci5jaHVua1NpemUpICsgMSArXG4gICAgLy8gQWRkIG9uZSBmb3IgQ3JlYXRlIHRyYW5zYWN0aW9uXG4gICAgMSkgLy8gQWRkIG9uZSBmb3IgRmluYWxpemUgdHJhbnNhY3Rpb25cbiAgICA7XG4gIH1cblxuICAvKipcbiAgICogTG9hZHMgYSBnZW5lcmljIHByb2dyYW1cbiAgICpcbiAgICogQHBhcmFtIGNvbm5lY3Rpb24gVGhlIGNvbm5lY3Rpb24gdG8gdXNlXG4gICAqIEBwYXJhbSBwYXllciBTeXN0ZW0gYWNjb3VudCB0aGF0IHBheXMgdG8gbG9hZCB0aGUgcHJvZ3JhbVxuICAgKiBAcGFyYW0gcHJvZ3JhbSBBY2NvdW50IHRvIGxvYWQgdGhlIHByb2dyYW0gaW50b1xuICAgKiBAcGFyYW0gcHJvZ3JhbUlkIFB1YmxpYyBrZXkgdGhhdCBpZGVudGlmaWVzIHRoZSBsb2FkZXJcbiAgICogQHBhcmFtIGRhdGEgUHJvZ3JhbSBvY3RldHNcbiAgICogQHJldHVybiB0cnVlIGlmIHByb2dyYW0gd2FzIGxvYWRlZCBzdWNjZXNzZnVsbHksIGZhbHNlIGlmIHByb2dyYW0gd2FzIGFscmVhZHkgbG9hZGVkXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgbG9hZChjb25uZWN0aW9uLCBwYXllciwgcHJvZ3JhbSwgcHJvZ3JhbUlkLCBkYXRhKSB7XG4gICAge1xuICAgICAgY29uc3QgYmFsYW5jZU5lZWRlZCA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0TWluaW11bUJhbGFuY2VGb3JSZW50RXhlbXB0aW9uKGRhdGEubGVuZ3RoKTtcblxuICAgICAgLy8gRmV0Y2ggcHJvZ3JhbSBhY2NvdW50IGluZm8gdG8gY2hlY2sgaWYgaXQgaGFzIGFscmVhZHkgYmVlbiBjcmVhdGVkXG4gICAgICBjb25zdCBwcm9ncmFtSW5mbyA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0QWNjb3VudEluZm8ocHJvZ3JhbS5wdWJsaWNLZXksICdjb25maXJtZWQnKTtcbiAgICAgIGxldCB0cmFuc2FjdGlvbiA9IG51bGw7XG4gICAgICBpZiAocHJvZ3JhbUluZm8gIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHByb2dyYW1JbmZvLmV4ZWN1dGFibGUpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdQcm9ncmFtIGxvYWQgZmFpbGVkLCBhY2NvdW50IGlzIGFscmVhZHkgZXhlY3V0YWJsZScpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvZ3JhbUluZm8uZGF0YS5sZW5ndGggIT09IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbiB8fCBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICAgICAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS5hbGxvY2F0ZSh7XG4gICAgICAgICAgICBhY2NvdW50UHVia2V5OiBwcm9ncmFtLnB1YmxpY0tleSxcbiAgICAgICAgICAgIHNwYWNlOiBkYXRhLmxlbmd0aFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXByb2dyYW1JbmZvLm93bmVyLmVxdWFscyhwcm9ncmFtSWQpKSB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbiB8fCBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICAgICAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS5hc3NpZ24oe1xuICAgICAgICAgICAgYWNjb3VudFB1YmtleTogcHJvZ3JhbS5wdWJsaWNLZXksXG4gICAgICAgICAgICBwcm9ncmFtSWRcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2dyYW1JbmZvLmxhbXBvcnRzIDwgYmFsYW5jZU5lZWRlZCkge1xuICAgICAgICAgIHRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb24gfHwgbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uYWRkKFN5c3RlbVByb2dyYW0udHJhbnNmZXIoe1xuICAgICAgICAgICAgZnJvbVB1YmtleTogcGF5ZXIucHVibGljS2V5LFxuICAgICAgICAgICAgdG9QdWJrZXk6IHByb2dyYW0ucHVibGljS2V5LFxuICAgICAgICAgICAgbGFtcG9ydHM6IGJhbGFuY2VOZWVkZWQgLSBwcm9ncmFtSW5mby5sYW1wb3J0c1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoU3lzdGVtUHJvZ3JhbS5jcmVhdGVBY2NvdW50KHtcbiAgICAgICAgICBmcm9tUHVia2V5OiBwYXllci5wdWJsaWNLZXksXG4gICAgICAgICAgbmV3QWNjb3VudFB1YmtleTogcHJvZ3JhbS5wdWJsaWNLZXksXG4gICAgICAgICAgbGFtcG9ydHM6IGJhbGFuY2VOZWVkZWQgPiAwID8gYmFsYW5jZU5lZWRlZCA6IDEsXG4gICAgICAgICAgc3BhY2U6IGRhdGEubGVuZ3RoLFxuICAgICAgICAgIHByb2dyYW1JZFxuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBhY2NvdW50IGlzIGFscmVhZHkgY3JlYXRlZCBjb3JyZWN0bHksIHNraXAgdGhpcyBzdGVwXG4gICAgICAvLyBhbmQgcHJvY2VlZCBkaXJlY3RseSB0byBsb2FkaW5nIGluc3RydWN0aW9uc1xuICAgICAgaWYgKHRyYW5zYWN0aW9uICE9PSBudWxsKSB7XG4gICAgICAgIGF3YWl0IHNlbmRBbmRDb25maXJtVHJhbnNhY3Rpb24oY29ubmVjdGlvbiwgdHJhbnNhY3Rpb24sIFtwYXllciwgcHJvZ3JhbV0sIHtcbiAgICAgICAgICBjb21taXRtZW50OiAnY29uZmlybWVkJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZGF0YUxheW91dCA9IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIEJ1ZmZlckxheW91dC51MzIoJ29mZnNldCcpLCBCdWZmZXJMYXlvdXQudTMyKCdieXRlc0xlbmd0aCcpLCBCdWZmZXJMYXlvdXQudTMyKCdieXRlc0xlbmd0aFBhZGRpbmcnKSwgQnVmZmVyTGF5b3V0LnNlcShCdWZmZXJMYXlvdXQudTgoJ2J5dGUnKSwgQnVmZmVyTGF5b3V0Lm9mZnNldChCdWZmZXJMYXlvdXQudTMyKCksIC04KSwgJ2J5dGVzJyldKTtcbiAgICBjb25zdCBjaHVua1NpemUgPSBMb2FkZXIuY2h1bmtTaXplO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGxldCBhcnJheSA9IGRhdGE7XG4gICAgbGV0IHRyYW5zYWN0aW9ucyA9IFtdO1xuICAgIHdoaWxlIChhcnJheS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBieXRlcyA9IGFycmF5LnNsaWNlKDAsIGNodW5rU2l6ZSk7XG4gICAgICBjb25zdCBkYXRhID0gQnVmZmVyLmFsbG9jKGNodW5rU2l6ZSArIDE2KTtcbiAgICAgIGRhdGFMYXlvdXQuZW5jb2RlKHtcbiAgICAgICAgaW5zdHJ1Y3Rpb246IDAsXG4gICAgICAgIC8vIExvYWQgaW5zdHJ1Y3Rpb25cbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICBieXRlczogYnl0ZXMsXG4gICAgICAgIGJ5dGVzTGVuZ3RoOiAwLFxuICAgICAgICBieXRlc0xlbmd0aFBhZGRpbmc6IDBcbiAgICAgIH0sIGRhdGEpO1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoe1xuICAgICAgICBrZXlzOiBbe1xuICAgICAgICAgIHB1YmtleTogcHJvZ3JhbS5wdWJsaWNLZXksXG4gICAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgICB9XSxcbiAgICAgICAgcHJvZ3JhbUlkLFxuICAgICAgICBkYXRhXG4gICAgICB9KTtcbiAgICAgIHRyYW5zYWN0aW9ucy5wdXNoKHNlbmRBbmRDb25maXJtVHJhbnNhY3Rpb24oY29ubmVjdGlvbiwgdHJhbnNhY3Rpb24sIFtwYXllciwgcHJvZ3JhbV0sIHtcbiAgICAgICAgY29tbWl0bWVudDogJ2NvbmZpcm1lZCdcbiAgICAgIH0pKTtcblxuICAgICAgLy8gRGVsYXkgYmV0d2VlbiBzZW5kcyBpbiBhbiBhdHRlbXB0IHRvIHJlZHVjZSByYXRlIGxpbWl0IGVycm9yc1xuICAgICAgaWYgKGNvbm5lY3Rpb24uX3JwY0VuZHBvaW50LmluY2x1ZGVzKCdzb2xhbmEuY29tJykpIHtcbiAgICAgICAgY29uc3QgUkVRVUVTVFNfUEVSX1NFQ09ORCA9IDQ7XG4gICAgICAgIGF3YWl0IHNsZWVwKDEwMDAgLyBSRVFVRVNUU19QRVJfU0VDT05EKTtcbiAgICAgIH1cbiAgICAgIG9mZnNldCArPSBjaHVua1NpemU7XG4gICAgICBhcnJheSA9IGFycmF5LnNsaWNlKGNodW5rU2l6ZSk7XG4gICAgfVxuICAgIGF3YWl0IFByb21pc2UuYWxsKHRyYW5zYWN0aW9ucyk7XG5cbiAgICAvLyBGaW5hbGl6ZSB0aGUgYWNjb3VudCBsb2FkZWQgd2l0aCBwcm9ncmFtIGRhdGEgZm9yIGV4ZWN1dGlvblxuICAgIHtcbiAgICAgIGNvbnN0IGRhdGFMYXlvdXQgPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpXSk7XG4gICAgICBjb25zdCBkYXRhID0gQnVmZmVyLmFsbG9jKGRhdGFMYXlvdXQuc3Bhbik7XG4gICAgICBkYXRhTGF5b3V0LmVuY29kZSh7XG4gICAgICAgIGluc3RydWN0aW9uOiAxIC8vIEZpbmFsaXplIGluc3RydWN0aW9uXG4gICAgICB9LCBkYXRhKTtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgICAga2V5czogW3tcbiAgICAgICAgICBwdWJrZXk6IHByb2dyYW0ucHVibGljS2V5LFxuICAgICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgICAgfSwge1xuICAgICAgICAgIHB1YmtleTogU1lTVkFSX1JFTlRfUFVCS0VZLFxuICAgICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgICB9XSxcbiAgICAgICAgcHJvZ3JhbUlkLFxuICAgICAgICBkYXRhXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGRlcGxveUNvbW1pdG1lbnQgPSAncHJvY2Vzc2VkJztcbiAgICAgIGNvbnN0IGZpbmFsaXplU2lnbmF0dXJlID0gYXdhaXQgY29ubmVjdGlvbi5zZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIFtwYXllciwgcHJvZ3JhbV0sIHtcbiAgICAgICAgcHJlZmxpZ2h0Q29tbWl0bWVudDogZGVwbG95Q29tbWl0bWVudFxuICAgICAgfSk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIHZhbHVlXG4gICAgICB9ID0gYXdhaXQgY29ubmVjdGlvbi5jb25maXJtVHJhbnNhY3Rpb24oe1xuICAgICAgICBzaWduYXR1cmU6IGZpbmFsaXplU2lnbmF0dXJlLFxuICAgICAgICBsYXN0VmFsaWRCbG9ja0hlaWdodDogdHJhbnNhY3Rpb24ubGFzdFZhbGlkQmxvY2tIZWlnaHQsXG4gICAgICAgIGJsb2NraGFzaDogdHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoXG4gICAgICB9LCBkZXBsb3lDb21taXRtZW50KTtcbiAgICAgIGlmICh2YWx1ZS5lcnIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUcmFuc2FjdGlvbiAke2ZpbmFsaXplU2lnbmF0dXJlfSBmYWlsZWQgKCR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfSlgKTtcbiAgICAgIH1cbiAgICAgIC8vIFdlIHByZXZlbnQgcHJvZ3JhbXMgZnJvbSBiZWluZyB1c2FibGUgdW50aWwgdGhlIHNsb3QgYWZ0ZXIgdGhlaXIgZGVwbG95bWVudC5cbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hL3B1bGwvMjk2NTRcbiAgICAgIHdoaWxlICh0cnVlIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgICApIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50U2xvdCA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0U2xvdCh7XG4gICAgICAgICAgICBjb21taXRtZW50OiBkZXBsb3lDb21taXRtZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGN1cnJlbnRTbG90ID4gY29udGV4dC5zbG90KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIC8qIGVtcHR5ICovXG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIE1hdGgucm91bmQoTVNfUEVSX1NMT1QgLyAyKSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHN1Y2Nlc3NcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuTG9hZGVyLmNodW5rU2l6ZSA9IENIVU5LX1NJWkU7XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBTb2xhbmEgdjEuMTcuMjAuXG4gKi9cbmNvbnN0IEJQRl9MT0FERVJfUFJPR1JBTV9JRCA9IG5ldyBQdWJsaWNLZXkoJ0JQRkxvYWRlcjIxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcblxuLyoqXG4gKiBGYWN0b3J5IGNsYXNzIGZvciB0cmFuc2FjdGlvbnMgdG8gaW50ZXJhY3Qgd2l0aCBhIHByb2dyYW0gbG9hZGVyXG4gKlxuICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBTb2xhbmEgdjEuMTcuMjAuXG4gKi9cbmNsYXNzIEJwZkxvYWRlciB7XG4gIC8qKlxuICAgKiBNaW5pbXVtIG51bWJlciBvZiBzaWduYXR1cmVzIHJlcXVpcmVkIHRvIGxvYWQgYSBwcm9ncmFtIG5vdCBpbmNsdWRpbmdcbiAgICogcmV0cmllc1xuICAgKlxuICAgKiBDYW4gYmUgdXNlZCB0byBjYWxjdWxhdGUgdHJhbnNhY3Rpb24gZmVlc1xuICAgKi9cbiAgc3RhdGljIGdldE1pbk51bVNpZ25hdHVyZXMoZGF0YUxlbmd0aCkge1xuICAgIHJldHVybiBMb2FkZXIuZ2V0TWluTnVtU2lnbmF0dXJlcyhkYXRhTGVuZ3RoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIGEgU0JGIHByb2dyYW1cbiAgICpcbiAgICogQHBhcmFtIGNvbm5lY3Rpb24gVGhlIGNvbm5lY3Rpb24gdG8gdXNlXG4gICAqIEBwYXJhbSBwYXllciBBY2NvdW50IHRoYXQgd2lsbCBwYXkgcHJvZ3JhbSBsb2FkaW5nIGZlZXNcbiAgICogQHBhcmFtIHByb2dyYW0gQWNjb3VudCB0byBsb2FkIHRoZSBwcm9ncmFtIGludG9cbiAgICogQHBhcmFtIGVsZiBUaGUgZW50aXJlIEVMRiBjb250YWluaW5nIHRoZSBTQkYgcHJvZ3JhbVxuICAgKiBAcGFyYW0gbG9hZGVyUHJvZ3JhbUlkIFRoZSBwcm9ncmFtIGlkIG9mIHRoZSBCUEYgbG9hZGVyIHRvIHVzZVxuICAgKiBAcmV0dXJuIHRydWUgaWYgcHJvZ3JhbSB3YXMgbG9hZGVkIHN1Y2Nlc3NmdWxseSwgZmFsc2UgaWYgcHJvZ3JhbSB3YXMgYWxyZWFkeSBsb2FkZWRcbiAgICovXG4gIHN0YXRpYyBsb2FkKGNvbm5lY3Rpb24sIHBheWVyLCBwcm9ncmFtLCBlbGYsIGxvYWRlclByb2dyYW1JZCkge1xuICAgIHJldHVybiBMb2FkZXIubG9hZChjb25uZWN0aW9uLCBwYXllciwgcHJvZ3JhbSwgbG9hZGVyUHJvZ3JhbUlkLCBlbGYpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRFeHBvcnRGcm9tQ2pzICh4KSB7XG5cdHJldHVybiB4ICYmIHguX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ2RlZmF1bHQnKSA/IHhbJ2RlZmF1bHQnXSA6IHg7XG59XG5cbnZhciBhZ2VudGtlZXBhbGl2ZSA9IHtleHBvcnRzOiB7fX07XG5cbi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgbXM7XG52YXIgaGFzUmVxdWlyZWRNcztcblxuZnVuY3Rpb24gcmVxdWlyZU1zICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkTXMpIHJldHVybiBtcztcblx0aGFzUmVxdWlyZWRNcyA9IDE7XG5cdHZhciBzID0gMTAwMDtcblx0dmFyIG0gPSBzICogNjA7XG5cdHZhciBoID0gbSAqIDYwO1xuXHR2YXIgZCA9IGggKiAyNDtcblx0dmFyIHcgPSBkICogNztcblx0dmFyIHkgPSBkICogMzY1LjI1O1xuXG5cdC8qKlxuXHQgKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuXHQgKlxuXHQgKiBPcHRpb25zOlxuXHQgKlxuXHQgKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcblx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuXHQgKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcblx0ICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0bXMgPSBmdW5jdGlvbiAodmFsLCBvcHRpb25zKSB7XG5cdCAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdCAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuXHQgIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuXHQgICAgcmV0dXJuIHBhcnNlKHZhbCk7XG5cdCAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh2YWwpKSB7XG5cdCAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcblx0ICB9XG5cdCAgdGhyb3cgbmV3IEVycm9yKFxuXHQgICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG5cdCAgICAgIEpTT04uc3RyaW5naWZ5KHZhbClcblx0ICApO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG5cdCAgc3RyID0gU3RyaW5nKHN0cik7XG5cdCAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcblx0ICAgIHJldHVybjtcblx0ICB9XG5cdCAgdmFyIG1hdGNoID0gL14oLT8oPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHdlZWtzP3x3fHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxuXHQgICAgc3RyXG5cdCAgKTtcblx0ICBpZiAoIW1hdGNoKSB7XG5cdCAgICByZXR1cm47XG5cdCAgfVxuXHQgIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG5cdCAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcblx0ICBzd2l0Y2ggKHR5cGUpIHtcblx0ICAgIGNhc2UgJ3llYXJzJzpcblx0ICAgIGNhc2UgJ3llYXInOlxuXHQgICAgY2FzZSAneXJzJzpcblx0ICAgIGNhc2UgJ3lyJzpcblx0ICAgIGNhc2UgJ3knOlxuXHQgICAgICByZXR1cm4gbiAqIHk7XG5cdCAgICBjYXNlICd3ZWVrcyc6XG5cdCAgICBjYXNlICd3ZWVrJzpcblx0ICAgIGNhc2UgJ3cnOlxuXHQgICAgICByZXR1cm4gbiAqIHc7XG5cdCAgICBjYXNlICdkYXlzJzpcblx0ICAgIGNhc2UgJ2RheSc6XG5cdCAgICBjYXNlICdkJzpcblx0ICAgICAgcmV0dXJuIG4gKiBkO1xuXHQgICAgY2FzZSAnaG91cnMnOlxuXHQgICAgY2FzZSAnaG91cic6XG5cdCAgICBjYXNlICdocnMnOlxuXHQgICAgY2FzZSAnaHInOlxuXHQgICAgY2FzZSAnaCc6XG5cdCAgICAgIHJldHVybiBuICogaDtcblx0ICAgIGNhc2UgJ21pbnV0ZXMnOlxuXHQgICAgY2FzZSAnbWludXRlJzpcblx0ICAgIGNhc2UgJ21pbnMnOlxuXHQgICAgY2FzZSAnbWluJzpcblx0ICAgIGNhc2UgJ20nOlxuXHQgICAgICByZXR1cm4gbiAqIG07XG5cdCAgICBjYXNlICdzZWNvbmRzJzpcblx0ICAgIGNhc2UgJ3NlY29uZCc6XG5cdCAgICBjYXNlICdzZWNzJzpcblx0ICAgIGNhc2UgJ3NlYyc6XG5cdCAgICBjYXNlICdzJzpcblx0ICAgICAgcmV0dXJuIG4gKiBzO1xuXHQgICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcblx0ICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcblx0ICAgIGNhc2UgJ21zZWNzJzpcblx0ICAgIGNhc2UgJ21zZWMnOlxuXHQgICAgY2FzZSAnbXMnOlxuXHQgICAgICByZXR1cm4gbjtcblx0ICAgIGRlZmF1bHQ6XG5cdCAgICAgIHJldHVybiB1bmRlZmluZWQ7XG5cdCAgfVxuXHR9XG5cblx0LyoqXG5cdCAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cblx0ICpcblx0ICogQHBhcmFtIHtOdW1iZXJ9IG1zXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG5cdCAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuXHQgIGlmIChtc0FicyA+PSBkKSB7XG5cdCAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuXHQgIH1cblx0ICBpZiAobXNBYnMgPj0gaCkge1xuXHQgICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcblx0ICB9XG5cdCAgaWYgKG1zQWJzID49IG0pIHtcblx0ICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG5cdCAgfVxuXHQgIGlmIChtc0FicyA+PSBzKSB7XG5cdCAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuXHQgIH1cblx0ICByZXR1cm4gbXMgKyAnbXMnO1xuXHR9XG5cblx0LyoqXG5cdCAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuXHQgKlxuXHQgKiBAcGFyYW0ge051bWJlcn0gbXNcblx0ICogQHJldHVybiB7U3RyaW5nfVxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZnVuY3Rpb24gZm10TG9uZyhtcykge1xuXHQgIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcblx0ICBpZiAobXNBYnMgPj0gZCkge1xuXHQgICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGQsICdkYXknKTtcblx0ICB9XG5cdCAgaWYgKG1zQWJzID49IGgpIHtcblx0ICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBoLCAnaG91cicpO1xuXHQgIH1cblx0ICBpZiAobXNBYnMgPj0gbSkge1xuXHQgICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIG0sICdtaW51dGUnKTtcblx0ICB9XG5cdCAgaWYgKG1zQWJzID49IHMpIHtcblx0ICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBzLCAnc2Vjb25kJyk7XG5cdCAgfVxuXHQgIHJldHVybiBtcyArICcgbXMnO1xuXHR9XG5cblx0LyoqXG5cdCAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuXHQgKi9cblxuXHRmdW5jdGlvbiBwbHVyYWwobXMsIG1zQWJzLCBuLCBuYW1lKSB7XG5cdCAgdmFyIGlzUGx1cmFsID0gbXNBYnMgPj0gbiAqIDEuNTtcblx0ICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG4pICsgJyAnICsgbmFtZSArIChpc1BsdXJhbCA/ICdzJyA6ICcnKTtcblx0fVxuXHRyZXR1cm4gbXM7XG59XG5cbi8qIVxuICogaHVtYW5pemUtbXMgLSBpbmRleC5qc1xuICogQ29weXJpZ2h0KGMpIDIwMTQgZGVhZF9ob3JzZSA8ZGVhZF9ob3JzZUBxcS5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG52YXIgaHVtYW5pemVNcztcbnZhciBoYXNSZXF1aXJlZEh1bWFuaXplTXM7XG5cbmZ1bmN0aW9uIHJlcXVpcmVIdW1hbml6ZU1zICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkSHVtYW5pemVNcykgcmV0dXJuIGh1bWFuaXplTXM7XG5cdGhhc1JlcXVpcmVkSHVtYW5pemVNcyA9IDE7XG5cblx0LyoqXG5cdCAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG5cdCAqL1xuXG5cdHZhciB1dGlsID0gcmVxdWlyZSQkMDtcblx0dmFyIG1zID0gLypAX19QVVJFX18qLyByZXF1aXJlTXMoKTtcblxuXHRodW1hbml6ZU1zID0gZnVuY3Rpb24gKHQpIHtcblx0ICBpZiAodHlwZW9mIHQgPT09ICdudW1iZXInKSByZXR1cm4gdDtcblx0ICB2YXIgciA9IG1zKHQpO1xuXHQgIGlmIChyID09PSB1bmRlZmluZWQpIHtcblx0ICAgIHZhciBlcnIgPSBuZXcgRXJyb3IodXRpbC5mb3JtYXQoJ2h1bWFuaXplLW1zKCVqKSByZXN1bHQgdW5kZWZpbmVkJywgdCkpO1xuXHQgICAgY29uc29sZS53YXJuKGVyci5zdGFjayk7XG5cdCAgfVxuXHQgIHJldHVybiByO1xuXHR9O1xuXHRyZXR1cm4gaHVtYW5pemVNcztcbn1cblxudmFyIGNvbnN0YW50cztcbnZhciBoYXNSZXF1aXJlZENvbnN0YW50cztcblxuZnVuY3Rpb24gcmVxdWlyZUNvbnN0YW50cyAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZENvbnN0YW50cykgcmV0dXJuIGNvbnN0YW50cztcblx0aGFzUmVxdWlyZWRDb25zdGFudHMgPSAxO1xuXG5cdGNvbnN0YW50cyA9IHtcblx0ICAvLyBhZ2VudFxuXHQgIENVUlJFTlRfSUQ6IFN5bWJvbCgnYWdlbnRrZWVwYWxpdmUjY3VycmVudElkJyksXG5cdCAgQ1JFQVRFX0lEOiBTeW1ib2woJ2FnZW50a2VlcGFsaXZlI2NyZWF0ZUlkJyksXG5cdCAgSU5JVF9TT0NLRVQ6IFN5bWJvbCgnYWdlbnRrZWVwYWxpdmUjaW5pdFNvY2tldCcpLFxuXHQgIENSRUFURV9IVFRQU19DT05ORUNUSU9OOiBTeW1ib2woJ2FnZW50a2VlcGFsaXZlI2NyZWF0ZUh0dHBzQ29ubmVjdGlvbicpLFxuXHQgIC8vIHNvY2tldFxuXHQgIFNPQ0tFVF9DUkVBVEVEX1RJTUU6IFN5bWJvbCgnYWdlbnRrZWVwYWxpdmUjc29ja2V0Q3JlYXRlZFRpbWUnKSxcblx0ICBTT0NLRVRfTkFNRTogU3ltYm9sKCdhZ2VudGtlZXBhbGl2ZSNzb2NrZXROYW1lJyksXG5cdCAgU09DS0VUX1JFUVVFU1RfQ09VTlQ6IFN5bWJvbCgnYWdlbnRrZWVwYWxpdmUjc29ja2V0UmVxdWVzdENvdW50JyksXG5cdCAgU09DS0VUX1JFUVVFU1RfRklOSVNIRURfQ09VTlQ6IFN5bWJvbCgnYWdlbnRrZWVwYWxpdmUjc29ja2V0UmVxdWVzdEZpbmlzaGVkQ291bnQnKSxcblx0fTtcblx0cmV0dXJuIGNvbnN0YW50cztcbn1cblxudmFyIGFnZW50O1xudmFyIGhhc1JlcXVpcmVkQWdlbnQ7XG5cbmZ1bmN0aW9uIHJlcXVpcmVBZ2VudCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZEFnZW50KSByZXR1cm4gYWdlbnQ7XG5cdGhhc1JlcXVpcmVkQWdlbnQgPSAxO1xuXG5cdGNvbnN0IE9yaWdpbmFsQWdlbnQgPSByZXF1aXJlJCQwJDEuQWdlbnQ7XG5cdGNvbnN0IG1zID0gLypAX19QVVJFX18qLyByZXF1aXJlSHVtYW5pemVNcygpO1xuXHRjb25zdCBkZWJ1ZyA9IHJlcXVpcmUkJDAuZGVidWdsb2coJ2FnZW50a2VlcGFsaXZlJyk7XG5cdGNvbnN0IHtcblx0ICBJTklUX1NPQ0tFVCxcblx0ICBDVVJSRU5UX0lELFxuXHQgIENSRUFURV9JRCxcblx0ICBTT0NLRVRfQ1JFQVRFRF9USU1FLFxuXHQgIFNPQ0tFVF9OQU1FLFxuXHQgIFNPQ0tFVF9SRVFVRVNUX0NPVU5ULFxuXHQgIFNPQ0tFVF9SRVFVRVNUX0ZJTklTSEVEX0NPVU5ULFxuXHR9ID0gLypAX19QVVJFX18qLyByZXF1aXJlQ29uc3RhbnRzKCk7XG5cblx0Ly8gT3JpZ2luYWxBZ2VudCBjb21lIGZyb21cblx0Ly8gLSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi92OC4xMi4wL2xpYi9faHR0cF9hZ2VudC5qc1xuXHQvLyAtIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL3YxMC4xMi4wL2xpYi9faHR0cF9hZ2VudC5qc1xuXG5cdC8vIG5vZGUgPD0gMTBcblx0bGV0IGRlZmF1bHRUaW1lb3V0TGlzdGVuZXJDb3VudCA9IDE7XG5cdGNvbnN0IG1ham9yVmVyc2lvbiA9IHBhcnNlSW50KHByb2Nlc3MudmVyc2lvbi5zcGxpdCgnLicsIDEpWzBdLnN1YnN0cmluZygxKSk7XG5cdGlmIChtYWpvclZlcnNpb24gPj0gMTEgJiYgbWFqb3JWZXJzaW9uIDw9IDEyKSB7XG5cdCAgZGVmYXVsdFRpbWVvdXRMaXN0ZW5lckNvdW50ID0gMjtcblx0fSBlbHNlIGlmIChtYWpvclZlcnNpb24gPj0gMTMpIHtcblx0ICBkZWZhdWx0VGltZW91dExpc3RlbmVyQ291bnQgPSAzO1xuXHR9XG5cblx0ZnVuY3Rpb24gZGVwcmVjYXRlKG1lc3NhZ2UpIHtcblx0ICBjb25zb2xlLmxvZygnW2FnZW50a2VlcGFsaXZlOmRlcHJlY2F0ZWRdICVzJywgbWVzc2FnZSk7XG5cdH1cblxuXHRjbGFzcyBBZ2VudCBleHRlbmRzIE9yaWdpbmFsQWdlbnQge1xuXHQgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcblx0ICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHQgICAgb3B0aW9ucy5rZWVwQWxpdmUgPSBvcHRpb25zLmtlZXBBbGl2ZSAhPT0gZmFsc2U7XG5cdCAgICAvLyBkZWZhdWx0IGlzIGtlZXAtYWxpdmUgYW5kIDRzIGZyZWUgc29ja2V0IHRpbWVvdXRcblx0ICAgIC8vIHNlZSBodHRwczovL21lZGl1bS5jb20vc3NlbnNlLXRlY2gvcmVkdWNlLW5ldHdvcmtpbmctZXJyb3JzLWluLW5vZGVqcy0yM2I0ZWI5ZjJkODNcblx0ICAgIGlmIChvcHRpb25zLmZyZWVTb2NrZXRUaW1lb3V0ID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgb3B0aW9ucy5mcmVlU29ja2V0VGltZW91dCA9IDQwMDA7XG5cdCAgICB9XG5cdCAgICAvLyBMZWdhY3kgQVBJOiBrZWVwQWxpdmVUaW1lb3V0IHNob3VsZCBiZSByZW5hbWUgdG8gYGZyZWVTb2NrZXRUaW1lb3V0YFxuXHQgICAgaWYgKG9wdGlvbnMua2VlcEFsaXZlVGltZW91dCkge1xuXHQgICAgICBkZXByZWNhdGUoJ29wdGlvbnMua2VlcEFsaXZlVGltZW91dCBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIG9wdGlvbnMuZnJlZVNvY2tldFRpbWVvdXQgaW5zdGVhZCcpO1xuXHQgICAgICBvcHRpb25zLmZyZWVTb2NrZXRUaW1lb3V0ID0gb3B0aW9ucy5rZWVwQWxpdmVUaW1lb3V0O1xuXHQgICAgICBkZWxldGUgb3B0aW9ucy5rZWVwQWxpdmVUaW1lb3V0O1xuXHQgICAgfVxuXHQgICAgLy8gTGVnYWN5IEFQSTogZnJlZVNvY2tldEtlZXBBbGl2ZVRpbWVvdXQgc2hvdWxkIGJlIHJlbmFtZSB0byBgZnJlZVNvY2tldFRpbWVvdXRgXG5cdCAgICBpZiAob3B0aW9ucy5mcmVlU29ja2V0S2VlcEFsaXZlVGltZW91dCkge1xuXHQgICAgICBkZXByZWNhdGUoJ29wdGlvbnMuZnJlZVNvY2tldEtlZXBBbGl2ZVRpbWVvdXQgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBvcHRpb25zLmZyZWVTb2NrZXRUaW1lb3V0IGluc3RlYWQnKTtcblx0ICAgICAgb3B0aW9ucy5mcmVlU29ja2V0VGltZW91dCA9IG9wdGlvbnMuZnJlZVNvY2tldEtlZXBBbGl2ZVRpbWVvdXQ7XG5cdCAgICAgIGRlbGV0ZSBvcHRpb25zLmZyZWVTb2NrZXRLZWVwQWxpdmVUaW1lb3V0O1xuXHQgICAgfVxuXG5cdCAgICAvLyBTZXRzIHRoZSBzb2NrZXQgdG8gdGltZW91dCBhZnRlciB0aW1lb3V0IG1pbGxpc2Vjb25kcyBvZiBpbmFjdGl2aXR5IG9uIHRoZSBzb2NrZXQuXG5cdCAgICAvLyBCeSBkZWZhdWx0IGlzIGRvdWJsZSBmcmVlIHNvY2tldCB0aW1lb3V0LlxuXHQgICAgaWYgKG9wdGlvbnMudGltZW91dCA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgIC8vIG1ha2Ugc3VyZSBzb2NrZXQgZGVmYXVsdCBpbmFjdGl2aXR5IHRpbWVvdXQgPj0gOHNcblx0ICAgICAgb3B0aW9ucy50aW1lb3V0ID0gTWF0aC5tYXgob3B0aW9ucy5mcmVlU29ja2V0VGltZW91dCAqIDIsIDgwMDApO1xuXHQgICAgfVxuXG5cdCAgICAvLyBzdXBwb3J0IGh1bWFuaXplIGZvcm1hdFxuXHQgICAgb3B0aW9ucy50aW1lb3V0ID0gbXMob3B0aW9ucy50aW1lb3V0KTtcblx0ICAgIG9wdGlvbnMuZnJlZVNvY2tldFRpbWVvdXQgPSBtcyhvcHRpb25zLmZyZWVTb2NrZXRUaW1lb3V0KTtcblx0ICAgIG9wdGlvbnMuc29ja2V0QWN0aXZlVFRMID0gb3B0aW9ucy5zb2NrZXRBY3RpdmVUVEwgPyBtcyhvcHRpb25zLnNvY2tldEFjdGl2ZVRUTCkgOiAwO1xuXG5cdCAgICBzdXBlcihvcHRpb25zKTtcblxuXHQgICAgdGhpc1tDVVJSRU5UX0lEXSA9IDA7XG5cblx0ICAgIC8vIGNyZWF0ZSBzb2NrZXQgc3VjY2VzcyBjb3VudGVyXG5cdCAgICB0aGlzLmNyZWF0ZVNvY2tldENvdW50ID0gMDtcblx0ICAgIHRoaXMuY3JlYXRlU29ja2V0Q291bnRMYXN0Q2hlY2sgPSAwO1xuXG5cdCAgICB0aGlzLmNyZWF0ZVNvY2tldEVycm9yQ291bnQgPSAwO1xuXHQgICAgdGhpcy5jcmVhdGVTb2NrZXRFcnJvckNvdW50TGFzdENoZWNrID0gMDtcblxuXHQgICAgdGhpcy5jbG9zZVNvY2tldENvdW50ID0gMDtcblx0ICAgIHRoaXMuY2xvc2VTb2NrZXRDb3VudExhc3RDaGVjayA9IDA7XG5cblx0ICAgIC8vIHNvY2tldCBlcnJvciBldmVudCBjb3VudFxuXHQgICAgdGhpcy5lcnJvclNvY2tldENvdW50ID0gMDtcblx0ICAgIHRoaXMuZXJyb3JTb2NrZXRDb3VudExhc3RDaGVjayA9IDA7XG5cblx0ICAgIC8vIHJlcXVlc3QgZmluaXNoZWQgY291bnRlclxuXHQgICAgdGhpcy5yZXF1ZXN0Q291bnQgPSAwO1xuXHQgICAgdGhpcy5yZXF1ZXN0Q291bnRMYXN0Q2hlY2sgPSAwO1xuXG5cdCAgICAvLyBpbmNsdWRpbmcgZnJlZSBzb2NrZXQgdGltZW91dCBjb3VudGVyXG5cdCAgICB0aGlzLnRpbWVvdXRTb2NrZXRDb3VudCA9IDA7XG5cdCAgICB0aGlzLnRpbWVvdXRTb2NrZXRDb3VudExhc3RDaGVjayA9IDA7XG5cblx0ICAgIHRoaXMub24oJ2ZyZWUnLCBzb2NrZXQgPT4ge1xuXHQgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvcHVsbC8zMjAwMFxuXHQgICAgICAvLyBOb2RlLmpzIG5hdGl2ZSBhZ2VudCB3aWxsIGNoZWNrIHNvY2tldCB0aW1lb3V0IGVxcyBhZ2VudC5vcHRpb25zLnRpbWVvdXQuXG5cdCAgICAgIC8vIFVzZSB0aGUgdHRsIG9yIGZyZWVTb2NrZXRUaW1lb3V0IHRvIG92ZXJ3cml0ZS5cblx0ICAgICAgY29uc3QgdGltZW91dCA9IHRoaXMuY2FsY1NvY2tldFRpbWVvdXQoc29ja2V0KTtcblx0ICAgICAgaWYgKHRpbWVvdXQgPiAwICYmIHNvY2tldC50aW1lb3V0ICE9PSB0aW1lb3V0KSB7XG5cdCAgICAgICAgc29ja2V0LnNldFRpbWVvdXQodGltZW91dCk7XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHQgIH1cblxuXHQgIGdldCBmcmVlU29ja2V0S2VlcEFsaXZlVGltZW91dCgpIHtcblx0ICAgIGRlcHJlY2F0ZSgnYWdlbnQuZnJlZVNvY2tldEtlZXBBbGl2ZVRpbWVvdXQgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBhZ2VudC5vcHRpb25zLmZyZWVTb2NrZXRUaW1lb3V0IGluc3RlYWQnKTtcblx0ICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZnJlZVNvY2tldFRpbWVvdXQ7XG5cdCAgfVxuXG5cdCAgZ2V0IHRpbWVvdXQoKSB7XG5cdCAgICBkZXByZWNhdGUoJ2FnZW50LnRpbWVvdXQgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBhZ2VudC5vcHRpb25zLnRpbWVvdXQgaW5zdGVhZCcpO1xuXHQgICAgcmV0dXJuIHRoaXMub3B0aW9ucy50aW1lb3V0O1xuXHQgIH1cblxuXHQgIGdldCBzb2NrZXRBY3RpdmVUVEwoKSB7XG5cdCAgICBkZXByZWNhdGUoJ2FnZW50LnNvY2tldEFjdGl2ZVRUTCBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIGFnZW50Lm9wdGlvbnMuc29ja2V0QWN0aXZlVFRMIGluc3RlYWQnKTtcblx0ICAgIHJldHVybiB0aGlzLm9wdGlvbnMuc29ja2V0QWN0aXZlVFRMO1xuXHQgIH1cblxuXHQgIGNhbGNTb2NrZXRUaW1lb3V0KHNvY2tldCkge1xuXHQgICAgLyoqXG5cdCAgICAgKiByZXR1cm4gPD0gMDogc2hvdWxkIGZyZWUgc29ja2V0XG5cdCAgICAgKiByZXR1cm4gPiAwOiBzaG91bGQgdXBkYXRlIHNvY2tldCB0aW1lb3V0XG5cdCAgICAgKiByZXR1cm4gdW5kZWZpbmVkOiBub3QgZmluZCBjdXN0b20gdGltZW91dFxuXHQgICAgICovXG5cdCAgICBsZXQgZnJlZVNvY2tldFRpbWVvdXQgPSB0aGlzLm9wdGlvbnMuZnJlZVNvY2tldFRpbWVvdXQ7XG5cdCAgICBjb25zdCBzb2NrZXRBY3RpdmVUVEwgPSB0aGlzLm9wdGlvbnMuc29ja2V0QWN0aXZlVFRMO1xuXHQgICAgaWYgKHNvY2tldEFjdGl2ZVRUTCkge1xuXHQgICAgICAvLyBjaGVjayBzb2NrZXRBY3RpdmVUVExcblx0ICAgICAgY29uc3QgYWxpdmVUaW1lID0gRGF0ZS5ub3coKSAtIHNvY2tldFtTT0NLRVRfQ1JFQVRFRF9USU1FXTtcblx0ICAgICAgY29uc3QgZGlmZiA9IHNvY2tldEFjdGl2ZVRUTCAtIGFsaXZlVGltZTtcblx0ICAgICAgaWYgKGRpZmYgPD0gMCkge1xuXHQgICAgICAgIHJldHVybiBkaWZmO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChmcmVlU29ja2V0VGltZW91dCAmJiBkaWZmIDwgZnJlZVNvY2tldFRpbWVvdXQpIHtcblx0ICAgICAgICBmcmVlU29ja2V0VGltZW91dCA9IGRpZmY7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIC8vIHNldCBmcmVlU29ja2V0VGltZW91dFxuXHQgICAgaWYgKGZyZWVTb2NrZXRUaW1lb3V0KSB7XG5cdCAgICAgIC8vIHNldCBmcmVlIGtlZXBhbGl2ZSB0aW1lclxuXHQgICAgICAvLyB0cnkgdG8gdXNlIHNvY2tldCBjdXN0b20gZnJlZVNvY2tldFRpbWVvdXQgZmlyc3QsIHN1cHBvcnQgaGVhZGVyc1sna2VlcC1hbGl2ZSddXG5cdCAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlLW1vZHVsZXMvdXJsbGliL2Jsb2IvYjc2MDUzMDIwOTIzZjRkOTlhMWM5M2NmMmUxNmUwYzViYTEwYmFjZi9saWIvdXJsbGliLmpzI0w0OThcblx0ICAgICAgY29uc3QgY3VzdG9tRnJlZVNvY2tldFRpbWVvdXQgPSBzb2NrZXQuZnJlZVNvY2tldFRpbWVvdXQgfHwgc29ja2V0LmZyZWVTb2NrZXRLZWVwQWxpdmVUaW1lb3V0O1xuXHQgICAgICByZXR1cm4gY3VzdG9tRnJlZVNvY2tldFRpbWVvdXQgfHwgZnJlZVNvY2tldFRpbWVvdXQ7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAga2VlcFNvY2tldEFsaXZlKHNvY2tldCkge1xuXHQgICAgY29uc3QgcmVzdWx0ID0gc3VwZXIua2VlcFNvY2tldEFsaXZlKHNvY2tldCk7XG5cdCAgICAvLyBzaG91bGQgbm90IGtlZXBBbGl2ZSwgZG8gbm90aGluZ1xuXHQgICAgaWYgKCFyZXN1bHQpIHJldHVybiByZXN1bHQ7XG5cblx0ICAgIGNvbnN0IGN1c3RvbVRpbWVvdXQgPSB0aGlzLmNhbGNTb2NrZXRUaW1lb3V0KHNvY2tldCk7XG5cdCAgICBpZiAodHlwZW9mIGN1c3RvbVRpbWVvdXQgPT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXHQgICAgaWYgKGN1c3RvbVRpbWVvdXQgPD0gMCkge1xuXHQgICAgICBkZWJ1ZygnJXMocmVxdWVzdHM6ICVzLCBmaW5pc2hlZDogJXMpIGZyZWUgYnV0IG5lZWQgdG8gZGVzdHJveSBieSBUVEwsIHJlcXVlc3QgY291bnQgJXMsIGRpZmYgaXMgJXMnLFxuXHQgICAgICAgIHNvY2tldFtTT0NLRVRfTkFNRV0sIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9DT1VOVF0sIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9GSU5JU0hFRF9DT1VOVF0sIGN1c3RvbVRpbWVvdXQpO1xuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgICBpZiAoc29ja2V0LnRpbWVvdXQgIT09IGN1c3RvbVRpbWVvdXQpIHtcblx0ICAgICAgc29ja2V0LnNldFRpbWVvdXQoY3VzdG9tVGltZW91dCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0ICB9XG5cblx0ICAvLyBvbmx5IGNhbGwgb24gYWRkUmVxdWVzdFxuXHQgIHJldXNlU29ja2V0KC4uLmFyZ3MpIHtcblx0ICAgIC8vIHJldXNlU29ja2V0KHNvY2tldCwgcmVxKVxuXHQgICAgc3VwZXIucmV1c2VTb2NrZXQoLi4uYXJncyk7XG5cdCAgICBjb25zdCBzb2NrZXQgPSBhcmdzWzBdO1xuXHQgICAgY29uc3QgcmVxID0gYXJnc1sxXTtcblx0ICAgIHJlcS5yZXVzZWRTb2NrZXQgPSB0cnVlO1xuXHQgICAgY29uc3QgYWdlbnRUaW1lb3V0ID0gdGhpcy5vcHRpb25zLnRpbWVvdXQ7XG5cdCAgICBpZiAoZ2V0U29ja2V0VGltZW91dChzb2NrZXQpICE9PSBhZ2VudFRpbWVvdXQpIHtcblx0ICAgICAgLy8gcmVzZXQgdGltZW91dCBiZWZvcmUgdXNlXG5cdCAgICAgIHNvY2tldC5zZXRUaW1lb3V0KGFnZW50VGltZW91dCk7XG5cdCAgICAgIGRlYnVnKCclcyByZXNldCB0aW1lb3V0IHRvICVzbXMnLCBzb2NrZXRbU09DS0VUX05BTUVdLCBhZ2VudFRpbWVvdXQpO1xuXHQgICAgfVxuXHQgICAgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0NPVU5UXSsrO1xuXHQgICAgZGVidWcoJyVzKHJlcXVlc3RzOiAlcywgZmluaXNoZWQ6ICVzKSByZXVzZSBvbiBhZGRSZXF1ZXN0LCB0aW1lb3V0ICVzbXMnLFxuXHQgICAgICBzb2NrZXRbU09DS0VUX05BTUVdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfQ09VTlRdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfRklOSVNIRURfQ09VTlRdLFxuXHQgICAgICBnZXRTb2NrZXRUaW1lb3V0KHNvY2tldCkpO1xuXHQgIH1cblxuXHQgIFtDUkVBVEVfSURdKCkge1xuXHQgICAgY29uc3QgaWQgPSB0aGlzW0NVUlJFTlRfSURdKys7XG5cdCAgICBpZiAodGhpc1tDVVJSRU5UX0lEXSA9PT0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHRoaXNbQ1VSUkVOVF9JRF0gPSAwO1xuXHQgICAgcmV0dXJuIGlkO1xuXHQgIH1cblxuXHQgIFtJTklUX1NPQ0tFVF0oc29ja2V0LCBvcHRpb25zKSB7XG5cdCAgICAvLyBidWdmaXggaGVyZS5cblx0ICAgIC8vIGh0dHBzIG9uIG5vZGUgOCwgMTAgd29uJ3Qgc2V0IGFnZW50Lm9wdGlvbnMudGltZW91dCBieSBkZWZhdWx0XG5cdCAgICAvLyBUT0RPOiBuZWVkIHRvIGZpeCBvbiBub2RlIGl0c2VsZlxuXHQgICAgaWYgKG9wdGlvbnMudGltZW91dCkge1xuXHQgICAgICBjb25zdCB0aW1lb3V0ID0gZ2V0U29ja2V0VGltZW91dChzb2NrZXQpO1xuXHQgICAgICBpZiAoIXRpbWVvdXQpIHtcblx0ICAgICAgICBzb2NrZXQuc2V0VGltZW91dChvcHRpb25zLnRpbWVvdXQpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGlmICh0aGlzLm9wdGlvbnMua2VlcEFsaXZlKSB7XG5cdCAgICAgIC8vIERpc2FibGUgTmFnbGUncyBhbGdvcml0aG06IGh0dHA6Ly9ibG9nLmNhdXN0aWsuY29tLzIwMTIvMDQvMDgvc2NhbGluZy1ub2RlLWpzLXRvLTEwMGstY29uY3VycmVudC1jb25uZWN0aW9ucy9cblx0ICAgICAgLy8gaHR0cHM6Ly9mZW5nbWsyLmNvbS9iZW5jaG1hcmsvbmFnbGUtYWxnb3JpdGhtLWRlbGF5ZWQtYWNrLW1vY2suaHRtbFxuXHQgICAgICBzb2NrZXQuc2V0Tm9EZWxheSh0cnVlKTtcblx0ICAgIH1cblx0ICAgIHRoaXMuY3JlYXRlU29ja2V0Q291bnQrKztcblx0ICAgIGlmICh0aGlzLm9wdGlvbnMuc29ja2V0QWN0aXZlVFRMKSB7XG5cdCAgICAgIHNvY2tldFtTT0NLRVRfQ1JFQVRFRF9USU1FXSA9IERhdGUubm93KCk7XG5cdCAgICB9XG5cdCAgICAvLyBkb24ndCBzaG93IHRoZSBob2xlICctLS0tLUJFR0lOIENFUlRJRklDQVRFLS0tLScga2V5IHN0cmluZ1xuXHQgICAgc29ja2V0W1NPQ0tFVF9OQU1FXSA9IGBzb2NrWyR7dGhpc1tDUkVBVEVfSURdKCl9IyR7b3B0aW9ucy5fYWdlbnRLZXl9XWAuc3BsaXQoJy0tLS0tQkVHSU4nLCAxKVswXTtcblx0ICAgIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9DT1VOVF0gPSAxO1xuXHQgICAgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0ZJTklTSEVEX0NPVU5UXSA9IDA7XG5cdCAgICBpbnN0YWxsTGlzdGVuZXJzKHRoaXMsIHNvY2tldCwgb3B0aW9ucyk7XG5cdCAgfVxuXG5cdCAgY3JlYXRlQ29ubmVjdGlvbihvcHRpb25zLCBvbmNyZWF0ZSkge1xuXHQgICAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuXHQgICAgY29uc3Qgb25OZXdDcmVhdGUgPSAoZXJyLCBzb2NrZXQpID0+IHtcblx0ICAgICAgaWYgKGNhbGxlZCkgcmV0dXJuO1xuXHQgICAgICBjYWxsZWQgPSB0cnVlO1xuXG5cdCAgICAgIGlmIChlcnIpIHtcblx0ICAgICAgICB0aGlzLmNyZWF0ZVNvY2tldEVycm9yQ291bnQrKztcblx0ICAgICAgICByZXR1cm4gb25jcmVhdGUoZXJyKTtcblx0ICAgICAgfVxuXHQgICAgICB0aGlzW0lOSVRfU09DS0VUXShzb2NrZXQsIG9wdGlvbnMpO1xuXHQgICAgICBvbmNyZWF0ZShlcnIsIHNvY2tldCk7XG5cdCAgICB9O1xuXG5cdCAgICBjb25zdCBuZXdTb2NrZXQgPSBzdXBlci5jcmVhdGVDb25uZWN0aW9uKG9wdGlvbnMsIG9uTmV3Q3JlYXRlKTtcblx0ICAgIGlmIChuZXdTb2NrZXQpIG9uTmV3Q3JlYXRlKG51bGwsIG5ld1NvY2tldCk7XG5cdCAgICByZXR1cm4gbmV3U29ja2V0O1xuXHQgIH1cblxuXHQgIGdldCBzdGF0dXNDaGFuZ2VkKCkge1xuXHQgICAgY29uc3QgY2hhbmdlZCA9IHRoaXMuY3JlYXRlU29ja2V0Q291bnQgIT09IHRoaXMuY3JlYXRlU29ja2V0Q291bnRMYXN0Q2hlY2sgfHxcblx0ICAgICAgdGhpcy5jcmVhdGVTb2NrZXRFcnJvckNvdW50ICE9PSB0aGlzLmNyZWF0ZVNvY2tldEVycm9yQ291bnRMYXN0Q2hlY2sgfHxcblx0ICAgICAgdGhpcy5jbG9zZVNvY2tldENvdW50ICE9PSB0aGlzLmNsb3NlU29ja2V0Q291bnRMYXN0Q2hlY2sgfHxcblx0ICAgICAgdGhpcy5lcnJvclNvY2tldENvdW50ICE9PSB0aGlzLmVycm9yU29ja2V0Q291bnRMYXN0Q2hlY2sgfHxcblx0ICAgICAgdGhpcy50aW1lb3V0U29ja2V0Q291bnQgIT09IHRoaXMudGltZW91dFNvY2tldENvdW50TGFzdENoZWNrIHx8XG5cdCAgICAgIHRoaXMucmVxdWVzdENvdW50ICE9PSB0aGlzLnJlcXVlc3RDb3VudExhc3RDaGVjaztcblx0ICAgIGlmIChjaGFuZ2VkKSB7XG5cdCAgICAgIHRoaXMuY3JlYXRlU29ja2V0Q291bnRMYXN0Q2hlY2sgPSB0aGlzLmNyZWF0ZVNvY2tldENvdW50O1xuXHQgICAgICB0aGlzLmNyZWF0ZVNvY2tldEVycm9yQ291bnRMYXN0Q2hlY2sgPSB0aGlzLmNyZWF0ZVNvY2tldEVycm9yQ291bnQ7XG5cdCAgICAgIHRoaXMuY2xvc2VTb2NrZXRDb3VudExhc3RDaGVjayA9IHRoaXMuY2xvc2VTb2NrZXRDb3VudDtcblx0ICAgICAgdGhpcy5lcnJvclNvY2tldENvdW50TGFzdENoZWNrID0gdGhpcy5lcnJvclNvY2tldENvdW50O1xuXHQgICAgICB0aGlzLnRpbWVvdXRTb2NrZXRDb3VudExhc3RDaGVjayA9IHRoaXMudGltZW91dFNvY2tldENvdW50O1xuXHQgICAgICB0aGlzLnJlcXVlc3RDb3VudExhc3RDaGVjayA9IHRoaXMucmVxdWVzdENvdW50O1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGNoYW5nZWQ7XG5cdCAgfVxuXG5cdCAgZ2V0Q3VycmVudFN0YXR1cygpIHtcblx0ICAgIHJldHVybiB7XG5cdCAgICAgIGNyZWF0ZVNvY2tldENvdW50OiB0aGlzLmNyZWF0ZVNvY2tldENvdW50LFxuXHQgICAgICBjcmVhdGVTb2NrZXRFcnJvckNvdW50OiB0aGlzLmNyZWF0ZVNvY2tldEVycm9yQ291bnQsXG5cdCAgICAgIGNsb3NlU29ja2V0Q291bnQ6IHRoaXMuY2xvc2VTb2NrZXRDb3VudCxcblx0ICAgICAgZXJyb3JTb2NrZXRDb3VudDogdGhpcy5lcnJvclNvY2tldENvdW50LFxuXHQgICAgICB0aW1lb3V0U29ja2V0Q291bnQ6IHRoaXMudGltZW91dFNvY2tldENvdW50LFxuXHQgICAgICByZXF1ZXN0Q291bnQ6IHRoaXMucmVxdWVzdENvdW50LFxuXHQgICAgICBmcmVlU29ja2V0czogaW5zcGVjdCh0aGlzLmZyZWVTb2NrZXRzKSxcblx0ICAgICAgc29ja2V0czogaW5zcGVjdCh0aGlzLnNvY2tldHMpLFxuXHQgICAgICByZXF1ZXN0czogaW5zcGVjdCh0aGlzLnJlcXVlc3RzKSxcblx0ICAgIH07XG5cdCAgfVxuXHR9XG5cblx0Ly8gbm9kZSA4IGRvbid0IGhhcyB0aW1lb3V0IGF0dHJpYnV0ZSBvbiBzb2NrZXRcblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL3B1bGwvMjEyMDQvZmlsZXMjZGlmZi1lNmVmMDI0YzM3NzVkNzg3YzM4NDg3YTYzMDllNDkxZFI0MDhcblx0ZnVuY3Rpb24gZ2V0U29ja2V0VGltZW91dChzb2NrZXQpIHtcblx0ICByZXR1cm4gc29ja2V0LnRpbWVvdXQgfHwgc29ja2V0Ll9pZGxlVGltZW91dDtcblx0fVxuXG5cdGZ1bmN0aW9uIGluc3RhbGxMaXN0ZW5lcnMoYWdlbnQsIHNvY2tldCwgb3B0aW9ucykge1xuXHQgIGRlYnVnKCclcyBjcmVhdGUsIHRpbWVvdXQgJXNtcycsIHNvY2tldFtTT0NLRVRfTkFNRV0sIGdldFNvY2tldFRpbWVvdXQoc29ja2V0KSk7XG5cblx0ICAvLyBsaXN0ZW5lciBzb2NrZXQgZXZlbnRzOiBjbG9zZSwgdGltZW91dCwgZXJyb3IsIGZyZWVcblx0ICBmdW5jdGlvbiBvbkZyZWUoKSB7XG5cdCAgICAvLyBjcmVhdGUgYW5kIHNvY2tldC5lbWl0KCdmcmVlJykgbG9naWNcblx0ICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL21hc3Rlci9saWIvX2h0dHBfYWdlbnQuanMjTDMxMVxuXHQgICAgLy8gbm8gcmVxIG9uIHRoZSBzb2NrZXQsIGl0IHNob3VsZCBiZSB0aGUgbmV3IHNvY2tldFxuXHQgICAgaWYgKCFzb2NrZXQuX2h0dHBNZXNzYWdlICYmIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9DT1VOVF0gPT09IDEpIHJldHVybjtcblxuXHQgICAgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0ZJTklTSEVEX0NPVU5UXSsrO1xuXHQgICAgYWdlbnQucmVxdWVzdENvdW50Kys7XG5cdCAgICBkZWJ1ZygnJXMocmVxdWVzdHM6ICVzLCBmaW5pc2hlZDogJXMpIGZyZWUnLFxuXHQgICAgICBzb2NrZXRbU09DS0VUX05BTUVdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfQ09VTlRdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfRklOSVNIRURfQ09VTlRdKTtcblxuXHQgICAgLy8gc2hvdWxkIHJldXNlIG9uIHBlZGRpbmcgcmVxdWVzdHM/XG5cdCAgICBjb25zdCBuYW1lID0gYWdlbnQuZ2V0TmFtZShvcHRpb25zKTtcblx0ICAgIGlmIChzb2NrZXQud3JpdGFibGUgJiYgYWdlbnQucmVxdWVzdHNbbmFtZV0gJiYgYWdlbnQucmVxdWVzdHNbbmFtZV0ubGVuZ3RoKSB7XG5cdCAgICAgIC8vIHdpbGwgYmUgcmV1c2Ugb24gYWdlbnQgZnJlZSBsaXN0ZW5lclxuXHQgICAgICBzb2NrZXRbU09DS0VUX1JFUVVFU1RfQ09VTlRdKys7XG5cdCAgICAgIGRlYnVnKCclcyhyZXF1ZXN0czogJXMsIGZpbmlzaGVkOiAlcykgd2lsbCBiZSByZXVzZSBvbiBhZ2VudCBmcmVlIGV2ZW50Jyxcblx0ICAgICAgICBzb2NrZXRbU09DS0VUX05BTUVdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfQ09VTlRdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfRklOSVNIRURfQ09VTlRdKTtcblx0ICAgIH1cblx0ICB9XG5cdCAgc29ja2V0Lm9uKCdmcmVlJywgb25GcmVlKTtcblxuXHQgIGZ1bmN0aW9uIG9uQ2xvc2UoaXNFcnJvcikge1xuXHQgICAgZGVidWcoJyVzKHJlcXVlc3RzOiAlcywgZmluaXNoZWQ6ICVzKSBjbG9zZSwgaXNFcnJvcjogJXMnLFxuXHQgICAgICBzb2NrZXRbU09DS0VUX05BTUVdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfQ09VTlRdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfRklOSVNIRURfQ09VTlRdLCBpc0Vycm9yKTtcblx0ICAgIGFnZW50LmNsb3NlU29ja2V0Q291bnQrKztcblx0ICB9XG5cdCAgc29ja2V0Lm9uKCdjbG9zZScsIG9uQ2xvc2UpO1xuXG5cdCAgLy8gc3RhcnQgc29ja2V0IHRpbWVvdXQgaGFuZGxlclxuXHQgIGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcblx0ICAgIC8vIG9uVGltZW91dCBhbmQgZW1pdFJlcXVlc3RUaW1lb3V0KF9odHRwX2NsaWVudC5qcylcblx0ICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL3YxMi54L2xpYi9faHR0cF9jbGllbnQuanMjTDcxMVxuXHQgICAgY29uc3QgbGlzdGVuZXJDb3VudCA9IHNvY2tldC5saXN0ZW5lcnMoJ3RpbWVvdXQnKS5sZW5ndGg7XG5cdCAgICAvLyBub2RlIDw9IDEwLCBkZWZhdWx0IGxpc3RlbmVyQ291bnQgaXMgMSwgb25UaW1lb3V0XG5cdCAgICAvLyAxMSA8IG5vZGUgPD0gMTIsIGRlZmF1bHQgbGlzdGVuZXJDb3VudCBpcyAyLCBvblRpbWVvdXQgYW5kIGVtaXRSZXF1ZXN0VGltZW91dFxuXHQgICAgLy8gbm9kZSA+PSAxMywgZGVmYXVsdCBsaXN0ZW5lckNvdW50IGlzIDMsIG9uVGltZW91dCxcblx0ICAgIC8vICAgb25UaW1lb3V0KGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9wdWxsLzMyMDAwL2ZpbGVzI2RpZmYtNWY3ZmIwODUwNDEyYzZiZTE4OWZhZWRkZWE2YzUzNTlSMzMzKVxuXHQgICAgLy8gICBhbmQgZW1pdFJlcXVlc3RUaW1lb3V0XG5cdCAgICBjb25zdCB0aW1lb3V0ID0gZ2V0U29ja2V0VGltZW91dChzb2NrZXQpO1xuXHQgICAgY29uc3QgcmVxID0gc29ja2V0Ll9odHRwTWVzc2FnZTtcblx0ICAgIGNvbnN0IHJlcVRpbWVvdXRMaXN0ZW5lckNvdW50ID0gcmVxICYmIHJlcS5saXN0ZW5lcnMoJ3RpbWVvdXQnKS5sZW5ndGggfHwgMDtcblx0ICAgIGRlYnVnKCclcyhyZXF1ZXN0czogJXMsIGZpbmlzaGVkOiAlcykgdGltZW91dCBhZnRlciAlc21zLCBsaXN0ZW5lcnMgJXMsIGRlZmF1bHRUaW1lb3V0TGlzdGVuZXJDb3VudCAlcywgaGFzSHR0cFJlcXVlc3QgJXMsIEh0dHBSZXF1ZXN0IHRpbWVvdXRMaXN0ZW5lckNvdW50ICVzJyxcblx0ICAgICAgc29ja2V0W1NPQ0tFVF9OQU1FXSwgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0NPVU5UXSwgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0ZJTklTSEVEX0NPVU5UXSxcblx0ICAgICAgdGltZW91dCwgbGlzdGVuZXJDb3VudCwgZGVmYXVsdFRpbWVvdXRMaXN0ZW5lckNvdW50LCAhIXJlcSwgcmVxVGltZW91dExpc3RlbmVyQ291bnQpO1xuXHQgICAgaWYgKGRlYnVnLmVuYWJsZWQpIHtcblx0ICAgICAgZGVidWcoJ3RpbWVvdXQgbGlzdGVuZXJzOiAlcycsIHNvY2tldC5saXN0ZW5lcnMoJ3RpbWVvdXQnKS5tYXAoZiA9PiBmLm5hbWUpLmpvaW4oJywgJykpO1xuXHQgICAgfVxuXHQgICAgYWdlbnQudGltZW91dFNvY2tldENvdW50Kys7XG5cdCAgICBjb25zdCBuYW1lID0gYWdlbnQuZ2V0TmFtZShvcHRpb25zKTtcblx0ICAgIGlmIChhZ2VudC5mcmVlU29ja2V0c1tuYW1lXSAmJiBhZ2VudC5mcmVlU29ja2V0c1tuYW1lXS5pbmRleE9mKHNvY2tldCkgIT09IC0xKSB7XG5cdCAgICAgIC8vIGZyZWUgc29ja2V0IHRpbWVvdXQsIGRlc3Ryb3kgcXVpZXRseVxuXHQgICAgICBzb2NrZXQuZGVzdHJveSgpO1xuXHQgICAgICAvLyBSZW1vdmUgaXQgZnJvbSBmcmVlU29ja2V0cyBsaXN0IGltbWVkaWF0ZWx5IHRvIHByZXZlbnQgbmV3IHJlcXVlc3RzXG5cdCAgICAgIC8vIGZyb20gYmVpbmcgc2VudCB0aHJvdWdoIHRoaXMgc29ja2V0LlxuXHQgICAgICBhZ2VudC5yZW1vdmVTb2NrZXQoc29ja2V0LCBvcHRpb25zKTtcblx0ICAgICAgZGVidWcoJyVzIGlzIGZyZWUsIGRlc3Ryb3kgcXVpZXRseScsIHNvY2tldFtTT0NLRVRfTkFNRV0pO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gYW55IHJlcXVlc3Qgc29ja2V0IHRpbWVvdXQgaGFuZGxlcixcblx0ICAgICAgLy8gYWdlbnQgbmVlZCB0byBoYW5kbGUgc29ja2V0IHRpbWVvdXQgaXRzZWxmLlxuXHQgICAgICAvL1xuXHQgICAgICAvLyBjdXN0b20gcmVxdWVzdCBzb2NrZXQgdGltZW91dCBoYW5kbGUgbG9naWMgbXVzdCBmb2xsb3cgdGhlc2UgcnVsZXM6XG5cdCAgICAgIC8vICAxLiBEZXN0cm95IHNvY2tldCBmaXJzdFxuXHQgICAgICAvLyAgMi4gTXVzdCBlbWl0IHNvY2tldCAnYWdlbnRSZW1vdmUnIGV2ZW50IHRlbGwgYWdlbnQgcmVtb3ZlIHNvY2tldFxuXHQgICAgICAvLyAgICAgZnJvbSBmcmVlU29ja2V0cyBsaXN0IGltbWVkaWF0ZWx5LlxuXHQgICAgICAvLyAgICAgT3RoZXJpc2UgeW91IG1heSBiZSBnZXQgJ3NvY2tldCBoYW5nIHVwJyBlcnJvciB3aGVuIHJldXNlXG5cdCAgICAgIC8vICAgICBmcmVlIHNvY2tldCBhbmQgdGltZW91dCBoYXBwZW4gaW4gdGhlIHNhbWUgdGltZS5cblx0ICAgICAgaWYgKHJlcVRpbWVvdXRMaXN0ZW5lckNvdW50ID09PSAwKSB7XG5cdCAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ1NvY2tldCB0aW1lb3V0Jyk7XG5cdCAgICAgICAgZXJyb3IuY29kZSA9ICdFUlJfU09DS0VUX1RJTUVPVVQnO1xuXHQgICAgICAgIGVycm9yLnRpbWVvdXQgPSB0aW1lb3V0O1xuXHQgICAgICAgIC8vIG11c3QgbWFudWFsbHkgY2FsbCBzb2NrZXQuZW5kKCkgb3Igc29ja2V0LmRlc3Ryb3koKSB0byBlbmQgdGhlIGNvbm5lY3Rpb24uXG5cdCAgICAgICAgLy8gaHR0cHM6Ly9ub2RlanMub3JnL2Rpc3QvbGF0ZXN0LXYxMC54L2RvY3MvYXBpL25ldC5odG1sI25ldF9zb2NrZXRfc2V0dGltZW91dF90aW1lb3V0X2NhbGxiYWNrXG5cdCAgICAgICAgc29ja2V0LmRlc3Ryb3koZXJyb3IpO1xuXHQgICAgICAgIGFnZW50LnJlbW92ZVNvY2tldChzb2NrZXQsIG9wdGlvbnMpO1xuXHQgICAgICAgIGRlYnVnKCclcyBkZXN0cm95IHdpdGggdGltZW91dCBlcnJvcicsIHNvY2tldFtTT0NLRVRfTkFNRV0pO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHQgIHNvY2tldC5vbigndGltZW91dCcsIG9uVGltZW91dCk7XG5cblx0ICBmdW5jdGlvbiBvbkVycm9yKGVycikge1xuXHQgICAgY29uc3QgbGlzdGVuZXJDb3VudCA9IHNvY2tldC5saXN0ZW5lcnMoJ2Vycm9yJykubGVuZ3RoO1xuXHQgICAgZGVidWcoJyVzKHJlcXVlc3RzOiAlcywgZmluaXNoZWQ6ICVzKSBlcnJvcjogJXMsIGxpc3RlbmVyQ291bnQ6ICVzJyxcblx0ICAgICAgc29ja2V0W1NPQ0tFVF9OQU1FXSwgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0NPVU5UXSwgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0ZJTklTSEVEX0NPVU5UXSxcblx0ICAgICAgZXJyLCBsaXN0ZW5lckNvdW50KTtcblx0ICAgIGFnZW50LmVycm9yU29ja2V0Q291bnQrKztcblx0ICAgIGlmIChsaXN0ZW5lckNvdW50ID09PSAxKSB7XG5cdCAgICAgIC8vIGlmIHNvY2tldCBkb24ndCBjb250YWluIGVycm9yIGV2ZW50IGhhbmRsZXIsIGRvbid0IGNhdGNoIGl0LCBlbWl0IGl0IGFnYWluXG5cdCAgICAgIGRlYnVnKCclcyBlbWl0IHVuY2F1Z2h0IGVycm9yIGV2ZW50Jywgc29ja2V0W1NPQ0tFVF9OQU1FXSk7XG5cdCAgICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcblx0ICAgICAgc29ja2V0LmVtaXQoJ2Vycm9yJywgZXJyKTtcblx0ICAgIH1cblx0ICB9XG5cdCAgc29ja2V0Lm9uKCdlcnJvcicsIG9uRXJyb3IpO1xuXG5cdCAgZnVuY3Rpb24gb25SZW1vdmUoKSB7XG5cdCAgICBkZWJ1ZygnJXMocmVxdWVzdHM6ICVzLCBmaW5pc2hlZDogJXMpIGFnZW50UmVtb3ZlJyxcblx0ICAgICAgc29ja2V0W1NPQ0tFVF9OQU1FXSxcblx0ICAgICAgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0NPVU5UXSwgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0ZJTklTSEVEX0NPVU5UXSk7XG5cdCAgICAvLyBXZSBuZWVkIHRoaXMgZnVuY3Rpb24gZm9yIGNhc2VzIGxpa2UgSFRUUCAndXBncmFkZSdcblx0ICAgIC8vIChkZWZpbmVkIGJ5IFdlYlNvY2tldHMpIHdoZXJlIHdlIG5lZWQgdG8gcmVtb3ZlIGEgc29ja2V0IGZyb20gdGhlXG5cdCAgICAvLyBwb29sIGJlY2F1c2UgaXQnbGwgYmUgbG9ja2VkIHVwIGluZGVmaW5pdGVseVxuXHQgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uQ2xvc2UpO1xuXHQgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpO1xuXHQgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdmcmVlJywgb25GcmVlKTtcblx0ICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcigndGltZW91dCcsIG9uVGltZW91dCk7XG5cdCAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2FnZW50UmVtb3ZlJywgb25SZW1vdmUpO1xuXHQgIH1cblx0ICBzb2NrZXQub24oJ2FnZW50UmVtb3ZlJywgb25SZW1vdmUpO1xuXHR9XG5cblx0YWdlbnQgPSBBZ2VudDtcblxuXHRmdW5jdGlvbiBpbnNwZWN0KG9iaikge1xuXHQgIGNvbnN0IHJlcyA9IHt9O1xuXHQgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuXHQgICAgcmVzW2tleV0gPSBvYmpba2V5XS5sZW5ndGg7XG5cdCAgfVxuXHQgIHJldHVybiByZXM7XG5cdH1cblx0cmV0dXJuIGFnZW50O1xufVxuXG52YXIgaHR0cHNfYWdlbnQ7XG52YXIgaGFzUmVxdWlyZWRIdHRwc19hZ2VudDtcblxuZnVuY3Rpb24gcmVxdWlyZUh0dHBzX2FnZW50ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkSHR0cHNfYWdlbnQpIHJldHVybiBodHRwc19hZ2VudDtcblx0aGFzUmVxdWlyZWRIdHRwc19hZ2VudCA9IDE7XG5cblx0Y29uc3QgT3JpZ2luYWxIdHRwc0FnZW50ID0gcmVxdWlyZSQkMCQyLkFnZW50O1xuXHRjb25zdCBIdHRwQWdlbnQgPSAvKkBfX1BVUkVfXyovIHJlcXVpcmVBZ2VudCgpO1xuXHRjb25zdCB7XG5cdCAgSU5JVF9TT0NLRVQsXG5cdCAgQ1JFQVRFX0hUVFBTX0NPTk5FQ1RJT04sXG5cdH0gPSAvKkBfX1BVUkVfXyovIHJlcXVpcmVDb25zdGFudHMoKTtcblxuXHRjbGFzcyBIdHRwc0FnZW50IGV4dGVuZHMgSHR0cEFnZW50IHtcblx0ICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG5cdCAgICBzdXBlcihvcHRpb25zKTtcblxuXHQgICAgdGhpcy5kZWZhdWx0UG9ydCA9IDQ0Mztcblx0ICAgIHRoaXMucHJvdG9jb2wgPSAnaHR0cHM6Jztcblx0ICAgIHRoaXMubWF4Q2FjaGVkU2Vzc2lvbnMgPSB0aGlzLm9wdGlvbnMubWF4Q2FjaGVkU2Vzc2lvbnM7XG5cdCAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXHQgICAgaWYgKHRoaXMubWF4Q2FjaGVkU2Vzc2lvbnMgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICB0aGlzLm1heENhY2hlZFNlc3Npb25zID0gMTAwO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLl9zZXNzaW9uQ2FjaGUgPSB7XG5cdCAgICAgIG1hcDoge30sXG5cdCAgICAgIGxpc3Q6IFtdLFxuXHQgICAgfTtcblx0ICB9XG5cblx0ICBjcmVhdGVDb25uZWN0aW9uKG9wdGlvbnMsIG9uY3JlYXRlKSB7XG5cdCAgICBjb25zdCBzb2NrZXQgPSB0aGlzW0NSRUFURV9IVFRQU19DT05ORUNUSU9OXShvcHRpb25zLCBvbmNyZWF0ZSk7XG5cdCAgICB0aGlzW0lOSVRfU09DS0VUXShzb2NrZXQsIG9wdGlvbnMpO1xuXHQgICAgcmV0dXJuIHNvY2tldDtcblx0ICB9XG5cdH1cblxuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi9tYXN0ZXIvbGliL2h0dHBzLmpzI0w4OVxuXHRIdHRwc0FnZW50LnByb3RvdHlwZVtDUkVBVEVfSFRUUFNfQ09OTkVDVElPTl0gPSBPcmlnaW5hbEh0dHBzQWdlbnQucHJvdG90eXBlLmNyZWF0ZUNvbm5lY3Rpb247XG5cblx0W1xuXHQgICdnZXROYW1lJyxcblx0ICAnX2dldFNlc3Npb24nLFxuXHQgICdfY2FjaGVTZXNzaW9uJyxcblx0ICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvcHVsbC80OTgyXG5cdCAgJ19ldmljdFNlc3Npb24nLFxuXHRdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG5cdCAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0ICBpZiAodHlwZW9mIE9yaWdpbmFsSHR0cHNBZ2VudC5wcm90b3R5cGVbbWV0aG9kXSA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgSHR0cHNBZ2VudC5wcm90b3R5cGVbbWV0aG9kXSA9IE9yaWdpbmFsSHR0cHNBZ2VudC5wcm90b3R5cGVbbWV0aG9kXTtcblx0ICB9XG5cdH0pO1xuXG5cdGh0dHBzX2FnZW50ID0gSHR0cHNBZ2VudDtcblx0cmV0dXJuIGh0dHBzX2FnZW50O1xufVxuXG52YXIgaGFzUmVxdWlyZWRBZ2VudGtlZXBhbGl2ZTtcblxuZnVuY3Rpb24gcmVxdWlyZUFnZW50a2VlcGFsaXZlICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkQWdlbnRrZWVwYWxpdmUpIHJldHVybiBhZ2VudGtlZXBhbGl2ZS5leHBvcnRzO1xuXHRoYXNSZXF1aXJlZEFnZW50a2VlcGFsaXZlID0gMTtcblxuXHRhZ2VudGtlZXBhbGl2ZS5leHBvcnRzID0gLypAX19QVVJFX18qLyByZXF1aXJlQWdlbnQoKTtcblx0YWdlbnRrZWVwYWxpdmUuZXhwb3J0cy5IdHRwc0FnZW50ID0gLypAX19QVVJFX18qLyByZXF1aXJlSHR0cHNfYWdlbnQoKTtcblx0YWdlbnRrZWVwYWxpdmUuZXhwb3J0cy5jb25zdGFudHMgPSAvKkBfX1BVUkVfXyovIHJlcXVpcmVDb25zdGFudHMoKTtcblx0cmV0dXJuIGFnZW50a2VlcGFsaXZlLmV4cG9ydHM7XG59XG5cbnZhciBhZ2VudGtlZXBhbGl2ZUV4cG9ydHMgPSAvKkBfX1BVUkVfXyovIHJlcXVpcmVBZ2VudGtlZXBhbGl2ZSgpO1xudmFyIEh0dHBLZWVwQWxpdmVBZ2VudCA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhhZ2VudGtlZXBhbGl2ZUV4cG9ydHMpO1xuXG52YXIgZmFzdFN0YWJsZVN0cmluZ2lmeSQxO1xudmFyIGhhc1JlcXVpcmVkRmFzdFN0YWJsZVN0cmluZ2lmeTtcblxuZnVuY3Rpb24gcmVxdWlyZUZhc3RTdGFibGVTdHJpbmdpZnkgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRGYXN0U3RhYmxlU3RyaW5naWZ5KSByZXR1cm4gZmFzdFN0YWJsZVN0cmluZ2lmeSQxO1xuXHRoYXNSZXF1aXJlZEZhc3RTdGFibGVTdHJpbmdpZnkgPSAxO1xuXHR2YXIgb2JqVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXHR2YXIgb2JqS2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uKG9iaikge1xuXHRcdFx0dmFyIGtleXMgPSBbXTtcblx0XHRcdGZvciAodmFyIG5hbWUgaW4gb2JqKSB7XG5cdFx0XHRcdGtleXMucHVzaChuYW1lKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBrZXlzO1xuXHRcdH07XG5cblx0ZnVuY3Rpb24gc3RyaW5naWZ5KHZhbCwgaXNBcnJheVByb3ApIHtcblx0XHR2YXIgaSwgbWF4LCBzdHIsIGtleXMsIGtleSwgcHJvcFZhbCwgdG9TdHI7XG5cdFx0aWYgKHZhbCA9PT0gdHJ1ZSkge1xuXHRcdFx0cmV0dXJuIFwidHJ1ZVwiO1xuXHRcdH1cblx0XHRpZiAodmFsID09PSBmYWxzZSkge1xuXHRcdFx0cmV0dXJuIFwiZmFsc2VcIjtcblx0XHR9XG5cdFx0c3dpdGNoICh0eXBlb2YgdmFsKSB7XG5cdFx0XHRjYXNlIFwib2JqZWN0XCI6XG5cdFx0XHRcdGlmICh2YWwgPT09IG51bGwpIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fSBlbHNlIGlmICh2YWwudG9KU09OICYmIHR5cGVvZiB2YWwudG9KU09OID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHRyZXR1cm4gc3RyaW5naWZ5KHZhbC50b0pTT04oKSwgaXNBcnJheVByb3ApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRvU3RyID0gb2JqVG9TdHJpbmcuY2FsbCh2YWwpO1xuXHRcdFx0XHRcdGlmICh0b1N0ciA9PT0gXCJbb2JqZWN0IEFycmF5XVwiKSB7XG5cdFx0XHRcdFx0XHRzdHIgPSAnWyc7XG5cdFx0XHRcdFx0XHRtYXggPSB2YWwubGVuZ3RoIC0gMTtcblx0XHRcdFx0XHRcdGZvcihpID0gMDsgaSA8IG1heDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdHN0ciArPSBzdHJpbmdpZnkodmFsW2ldLCB0cnVlKSArICcsJztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChtYXggPiAtMSkge1xuXHRcdFx0XHRcdFx0XHRzdHIgKz0gc3RyaW5naWZ5KHZhbFtpXSwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXR1cm4gc3RyICsgJ10nO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodG9TdHIgPT09IFwiW29iamVjdCBPYmplY3RdXCIpIHtcblx0XHRcdFx0XHRcdC8vIG9ubHkgb2JqZWN0IGlzIGxlZnRcblx0XHRcdFx0XHRcdGtleXMgPSBvYmpLZXlzKHZhbCkuc29ydCgpO1xuXHRcdFx0XHRcdFx0bWF4ID0ga2V5cy5sZW5ndGg7XG5cdFx0XHRcdFx0XHRzdHIgPSBcIlwiO1xuXHRcdFx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdFx0XHR3aGlsZSAoaSA8IG1heCkge1xuXHRcdFx0XHRcdFx0XHRrZXkgPSBrZXlzW2ldO1xuXHRcdFx0XHRcdFx0XHRwcm9wVmFsID0gc3RyaW5naWZ5KHZhbFtrZXldLCBmYWxzZSk7XG5cdFx0XHRcdFx0XHRcdGlmIChwcm9wVmFsICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoc3RyKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzdHIgKz0gJywnO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRzdHIgKz0gSlNPTi5zdHJpbmdpZnkoa2V5KSArICc6JyArIHByb3BWYWw7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aSsrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmV0dXJuICd7JyArIHN0ciArICd9Jztcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRjYXNlIFwiZnVuY3Rpb25cIjpcblx0XHRcdGNhc2UgXCJ1bmRlZmluZWRcIjpcblx0XHRcdFx0cmV0dXJuIGlzQXJyYXlQcm9wID8gbnVsbCA6IHVuZGVmaW5lZDtcblx0XHRcdGNhc2UgXCJzdHJpbmdcIjpcblx0XHRcdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbCk7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gaXNGaW5pdGUodmFsKSA/IHZhbCA6IG51bGw7XG5cdFx0fVxuXHR9XG5cblx0ZmFzdFN0YWJsZVN0cmluZ2lmeSQxID0gZnVuY3Rpb24odmFsKSB7XG5cdFx0dmFyIHJldHVyblZhbCA9IHN0cmluZ2lmeSh2YWwsIGZhbHNlKTtcblx0XHRpZiAocmV0dXJuVmFsICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiAnJysgcmV0dXJuVmFsO1xuXHRcdH1cblx0fTtcblx0cmV0dXJuIGZhc3RTdGFibGVTdHJpbmdpZnkkMTtcbn1cblxudmFyIGZhc3RTdGFibGVTdHJpbmdpZnlFeHBvcnRzID0gLypAX19QVVJFX18qLyByZXF1aXJlRmFzdFN0YWJsZVN0cmluZ2lmeSgpO1xudmFyIGZhc3RTdGFibGVTdHJpbmdpZnkgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoZmFzdFN0YWJsZVN0cmluZ2lmeUV4cG9ydHMpO1xuXG5jb25zdCBNSU5JTVVNX1NMT1RfUEVSX0VQT0NIID0gMzI7XG5cbi8vIFJldHVybnMgdGhlIG51bWJlciBvZiB0cmFpbGluZyB6ZXJvcyBpbiB0aGUgYmluYXJ5IHJlcHJlc2VudGF0aW9uIG9mIHNlbGYuXG5mdW5jdGlvbiB0cmFpbGluZ1plcm9zKG4pIHtcbiAgbGV0IHRyYWlsaW5nWmVyb3MgPSAwO1xuICB3aGlsZSAobiA+IDEpIHtcbiAgICBuIC89IDI7XG4gICAgdHJhaWxpbmdaZXJvcysrO1xuICB9XG4gIHJldHVybiB0cmFpbGluZ1plcm9zO1xufVxuXG4vLyBSZXR1cm5zIHRoZSBzbWFsbGVzdCBwb3dlciBvZiB0d28gZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIG5cbmZ1bmN0aW9uIG5leHRQb3dlck9mVHdvKG4pIHtcbiAgaWYgKG4gPT09IDApIHJldHVybiAxO1xuICBuLS07XG4gIG4gfD0gbiA+PiAxO1xuICBuIHw9IG4gPj4gMjtcbiAgbiB8PSBuID4+IDQ7XG4gIG4gfD0gbiA+PiA4O1xuICBuIHw9IG4gPj4gMTY7XG4gIG4gfD0gbiA+PiAzMjtcbiAgcmV0dXJuIG4gKyAxO1xufVxuXG4vKipcbiAqIEVwb2NoIHNjaGVkdWxlXG4gKiAoc2VlIGh0dHBzOi8vZG9jcy5zb2xhbmEuY29tL3Rlcm1pbm9sb2d5I2Vwb2NoKVxuICogQ2FuIGJlIHJldHJpZXZlZCB3aXRoIHRoZSB7QGxpbmsgQ29ubmVjdGlvbi5nZXRFcG9jaFNjaGVkdWxlfSBtZXRob2RcbiAqL1xuY2xhc3MgRXBvY2hTY2hlZHVsZSB7XG4gIGNvbnN0cnVjdG9yKHNsb3RzUGVyRXBvY2gsIGxlYWRlclNjaGVkdWxlU2xvdE9mZnNldCwgd2FybXVwLCBmaXJzdE5vcm1hbEVwb2NoLCBmaXJzdE5vcm1hbFNsb3QpIHtcbiAgICAvKiogVGhlIG1heGltdW0gbnVtYmVyIG9mIHNsb3RzIGluIGVhY2ggZXBvY2ggKi9cbiAgICB0aGlzLnNsb3RzUGVyRXBvY2ggPSB2b2lkIDA7XG4gICAgLyoqIFRoZSBudW1iZXIgb2Ygc2xvdHMgYmVmb3JlIGJlZ2lubmluZyBvZiBhbiBlcG9jaCB0byBjYWxjdWxhdGUgYSBsZWFkZXIgc2NoZWR1bGUgZm9yIHRoYXQgZXBvY2ggKi9cbiAgICB0aGlzLmxlYWRlclNjaGVkdWxlU2xvdE9mZnNldCA9IHZvaWQgMDtcbiAgICAvKiogSW5kaWNhdGVzIHdoZXRoZXIgZXBvY2hzIHN0YXJ0IHNob3J0IGFuZCBncm93ICovXG4gICAgdGhpcy53YXJtdXAgPSB2b2lkIDA7XG4gICAgLyoqIFRoZSBmaXJzdCBlcG9jaCB3aXRoIGBzbG90c1BlckVwb2NoYCBzbG90cyAqL1xuICAgIHRoaXMuZmlyc3ROb3JtYWxFcG9jaCA9IHZvaWQgMDtcbiAgICAvKiogVGhlIGZpcnN0IHNsb3Qgb2YgYGZpcnN0Tm9ybWFsRXBvY2hgICovXG4gICAgdGhpcy5maXJzdE5vcm1hbFNsb3QgPSB2b2lkIDA7XG4gICAgdGhpcy5zbG90c1BlckVwb2NoID0gc2xvdHNQZXJFcG9jaDtcbiAgICB0aGlzLmxlYWRlclNjaGVkdWxlU2xvdE9mZnNldCA9IGxlYWRlclNjaGVkdWxlU2xvdE9mZnNldDtcbiAgICB0aGlzLndhcm11cCA9IHdhcm11cDtcbiAgICB0aGlzLmZpcnN0Tm9ybWFsRXBvY2ggPSBmaXJzdE5vcm1hbEVwb2NoO1xuICAgIHRoaXMuZmlyc3ROb3JtYWxTbG90ID0gZmlyc3ROb3JtYWxTbG90O1xuICB9XG4gIGdldEVwb2NoKHNsb3QpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRFcG9jaEFuZFNsb3RJbmRleChzbG90KVswXTtcbiAgfVxuICBnZXRFcG9jaEFuZFNsb3RJbmRleChzbG90KSB7XG4gICAgaWYgKHNsb3QgPCB0aGlzLmZpcnN0Tm9ybWFsU2xvdCkge1xuICAgICAgY29uc3QgZXBvY2ggPSB0cmFpbGluZ1plcm9zKG5leHRQb3dlck9mVHdvKHNsb3QgKyBNSU5JTVVNX1NMT1RfUEVSX0VQT0NIICsgMSkpIC0gdHJhaWxpbmdaZXJvcyhNSU5JTVVNX1NMT1RfUEVSX0VQT0NIKSAtIDE7XG4gICAgICBjb25zdCBlcG9jaExlbiA9IHRoaXMuZ2V0U2xvdHNJbkVwb2NoKGVwb2NoKTtcbiAgICAgIGNvbnN0IHNsb3RJbmRleCA9IHNsb3QgLSAoZXBvY2hMZW4gLSBNSU5JTVVNX1NMT1RfUEVSX0VQT0NIKTtcbiAgICAgIHJldHVybiBbZXBvY2gsIHNsb3RJbmRleF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG5vcm1hbFNsb3RJbmRleCA9IHNsb3QgLSB0aGlzLmZpcnN0Tm9ybWFsU2xvdDtcbiAgICAgIGNvbnN0IG5vcm1hbEVwb2NoSW5kZXggPSBNYXRoLmZsb29yKG5vcm1hbFNsb3RJbmRleCAvIHRoaXMuc2xvdHNQZXJFcG9jaCk7XG4gICAgICBjb25zdCBlcG9jaCA9IHRoaXMuZmlyc3ROb3JtYWxFcG9jaCArIG5vcm1hbEVwb2NoSW5kZXg7XG4gICAgICBjb25zdCBzbG90SW5kZXggPSBub3JtYWxTbG90SW5kZXggJSB0aGlzLnNsb3RzUGVyRXBvY2g7XG4gICAgICByZXR1cm4gW2Vwb2NoLCBzbG90SW5kZXhdO1xuICAgIH1cbiAgfVxuICBnZXRGaXJzdFNsb3RJbkVwb2NoKGVwb2NoKSB7XG4gICAgaWYgKGVwb2NoIDw9IHRoaXMuZmlyc3ROb3JtYWxFcG9jaCkge1xuICAgICAgcmV0dXJuIChNYXRoLnBvdygyLCBlcG9jaCkgLSAxKSAqIE1JTklNVU1fU0xPVF9QRVJfRVBPQ0g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoZXBvY2ggLSB0aGlzLmZpcnN0Tm9ybWFsRXBvY2gpICogdGhpcy5zbG90c1BlckVwb2NoICsgdGhpcy5maXJzdE5vcm1hbFNsb3Q7XG4gICAgfVxuICB9XG4gIGdldExhc3RTbG90SW5FcG9jaChlcG9jaCkge1xuICAgIHJldHVybiB0aGlzLmdldEZpcnN0U2xvdEluRXBvY2goZXBvY2gpICsgdGhpcy5nZXRTbG90c0luRXBvY2goZXBvY2gpIC0gMTtcbiAgfVxuICBnZXRTbG90c0luRXBvY2goZXBvY2gpIHtcbiAgICBpZiAoZXBvY2ggPCB0aGlzLmZpcnN0Tm9ybWFsRXBvY2gpIHtcbiAgICAgIHJldHVybiBNYXRoLnBvdygyLCBlcG9jaCArIHRyYWlsaW5nWmVyb3MoTUlOSU1VTV9TTE9UX1BFUl9FUE9DSCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5zbG90c1BlckVwb2NoO1xuICAgIH1cbiAgfVxufVxuXG52YXIgZmV0Y2hJbXBsID0gdHlwZW9mIGdsb2JhbFRoaXMuZmV0Y2ggPT09ICdmdW5jdGlvbicgP1xuLy8gVGhlIEZldGNoIEFQSSBpcyBzdXBwb3J0ZWQgZXhwZXJpbWVudGFsbHkgaW4gTm9kZSAxNy41KyBhbmQgbmF0aXZlbHkgaW4gTm9kZSAxOCsuXG5nbG9iYWxUaGlzLmZldGNoIDpcbi8vIE90aGVyd2lzZSB1c2UgdGhlIHBvbHlmaWxsLlxuYXN5bmMgZnVuY3Rpb24gKGlucHV0LCBpbml0KSB7XG4gIGNvbnN0IHByb2Nlc3NlZElucHV0ID0gdHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJyAmJiBpbnB1dC5zbGljZSgwLCAyKSA9PT0gJy8vJyA/ICdodHRwczonICsgaW5wdXQgOiBpbnB1dDtcbiAgcmV0dXJuIGF3YWl0IG5vZGVGZXRjaC5kZWZhdWx0KHByb2Nlc3NlZElucHV0LCBpbml0KTtcbn07XG5cbmNsYXNzIFJwY1dlYlNvY2tldENsaWVudCBleHRlbmRzIENvbW1vbkNsaWVudCB7XG4gIGNvbnN0cnVjdG9yKGFkZHJlc3MsIG9wdGlvbnMsIGdlbmVyYXRlX3JlcXVlc3RfaWQpIHtcbiAgICBjb25zdCB3ZWJTb2NrZXRGYWN0b3J5ID0gdXJsID0+IHtcbiAgICAgIGNvbnN0IHJwYyA9IFdlYlNvY2tldCh1cmwsIHtcbiAgICAgICAgYXV0b2Nvbm5lY3Q6IHRydWUsXG4gICAgICAgIG1heF9yZWNvbm5lY3RzOiA1LFxuICAgICAgICByZWNvbm5lY3Q6IHRydWUsXG4gICAgICAgIHJlY29ubmVjdF9pbnRlcnZhbDogMTAwMCxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSk7XG4gICAgICBpZiAoJ3NvY2tldCcgaW4gcnBjKSB7XG4gICAgICAgIHRoaXMudW5kZXJseWluZ1NvY2tldCA9IHJwYy5zb2NrZXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnVuZGVybHlpbmdTb2NrZXQgPSBycGM7XG4gICAgICB9XG4gICAgICByZXR1cm4gcnBjO1xuICAgIH07XG4gICAgc3VwZXIod2ViU29ja2V0RmFjdG9yeSwgYWRkcmVzcywgb3B0aW9ucywgZ2VuZXJhdGVfcmVxdWVzdF9pZCk7XG4gICAgdGhpcy51bmRlcmx5aW5nU29ja2V0ID0gdm9pZCAwO1xuICB9XG4gIGNhbGwoLi4uYXJncykge1xuICAgIGNvbnN0IHJlYWR5U3RhdGUgPSB0aGlzLnVuZGVybHlpbmdTb2NrZXQ/LnJlYWR5U3RhdGU7XG4gICAgaWYgKHJlYWR5U3RhdGUgPT09IDEgLyogV2ViU29ja2V0Lk9QRU4gKi8pIHtcbiAgICAgIHJldHVybiBzdXBlci5jYWxsKC4uLmFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdUcmllZCB0byBjYWxsIGEgSlNPTi1SUEMgbWV0aG9kIGAnICsgYXJnc1swXSArICdgIGJ1dCB0aGUgc29ja2V0IHdhcyBub3QgYENPTk5FQ1RJTkdgIG9yIGBPUEVOYCAoYHJlYWR5U3RhdGVgIHdhcyAnICsgcmVhZHlTdGF0ZSArICcpJykpO1xuICB9XG4gIG5vdGlmeSguLi5hcmdzKSB7XG4gICAgY29uc3QgcmVhZHlTdGF0ZSA9IHRoaXMudW5kZXJseWluZ1NvY2tldD8ucmVhZHlTdGF0ZTtcbiAgICBpZiAocmVhZHlTdGF0ZSA9PT0gMSAvKiBXZWJTb2NrZXQuT1BFTiAqLykge1xuICAgICAgcmV0dXJuIHN1cGVyLm5vdGlmeSguLi5hcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignVHJpZWQgdG8gc2VuZCBhIEpTT04tUlBDIG5vdGlmaWNhdGlvbiBgJyArIGFyZ3NbMF0gKyAnYCBidXQgdGhlIHNvY2tldCB3YXMgbm90IGBDT05ORUNUSU5HYCBvciBgT1BFTmAgKGByZWFkeVN0YXRlYCB3YXMgJyArIHJlYWR5U3RhdGUgKyAnKScpKTtcbiAgfVxufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5cbi8qKlxuICogRGVjb2RlIGFjY291bnQgZGF0YSBidWZmZXIgdXNpbmcgYW4gQWNjb3VudFR5cGVcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBkZWNvZGVEYXRhKHR5cGUsIGRhdGEpIHtcbiAgbGV0IGRlY29kZWQ7XG4gIHRyeSB7XG4gICAgZGVjb2RlZCA9IHR5cGUubGF5b3V0LmRlY29kZShkYXRhKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluc3RydWN0aW9uOyAnICsgZXJyKTtcbiAgfVxuICBpZiAoZGVjb2RlZC50eXBlSW5kZXggIT09IHR5cGUuaW5kZXgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgYWNjb3VudCBkYXRhOyBhY2NvdW50IHR5cGUgbWlzbWF0Y2ggJHtkZWNvZGVkLnR5cGVJbmRleH0gIT0gJHt0eXBlLmluZGV4fWApO1xuICB9XG4gIHJldHVybiBkZWNvZGVkO1xufVxuXG4vLy8gVGhlIHNlcmlhbGl6ZWQgc2l6ZSBvZiBsb29rdXAgdGFibGUgbWV0YWRhdGFcbmNvbnN0IExPT0tVUF9UQUJMRV9NRVRBX1NJWkUgPSA1NjtcbmNsYXNzIEFkZHJlc3NMb29rdXBUYWJsZUFjY291bnQge1xuICBjb25zdHJ1Y3RvcihhcmdzKSB7XG4gICAgdGhpcy5rZXkgPSB2b2lkIDA7XG4gICAgdGhpcy5zdGF0ZSA9IHZvaWQgMDtcbiAgICB0aGlzLmtleSA9IGFyZ3Mua2V5O1xuICAgIHRoaXMuc3RhdGUgPSBhcmdzLnN0YXRlO1xuICB9XG4gIGlzQWN0aXZlKCkge1xuICAgIGNvbnN0IFU2NF9NQVggPSBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZicpO1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmRlYWN0aXZhdGlvblNsb3QgPT09IFU2NF9NQVg7XG4gIH1cbiAgc3RhdGljIGRlc2VyaWFsaXplKGFjY291bnREYXRhKSB7XG4gICAgY29uc3QgbWV0YSA9IGRlY29kZURhdGEoTG9va3VwVGFibGVNZXRhTGF5b3V0LCBhY2NvdW50RGF0YSk7XG4gICAgY29uc3Qgc2VyaWFsaXplZEFkZHJlc3Nlc0xlbiA9IGFjY291bnREYXRhLmxlbmd0aCAtIExPT0tVUF9UQUJMRV9NRVRBX1NJWkU7XG4gICAgYXNzZXJ0KHNlcmlhbGl6ZWRBZGRyZXNzZXNMZW4gPj0gMCwgJ2xvb2t1cCB0YWJsZSBpcyBpbnZhbGlkJyk7XG4gICAgYXNzZXJ0KHNlcmlhbGl6ZWRBZGRyZXNzZXNMZW4gJSAzMiA9PT0gMCwgJ2xvb2t1cCB0YWJsZSBpcyBpbnZhbGlkJyk7XG4gICAgY29uc3QgbnVtU2VyaWFsaXplZEFkZHJlc3NlcyA9IHNlcmlhbGl6ZWRBZGRyZXNzZXNMZW4gLyAzMjtcbiAgICBjb25zdCB7XG4gICAgICBhZGRyZXNzZXNcbiAgICB9ID0gQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnNlcShwdWJsaWNLZXkoKSwgbnVtU2VyaWFsaXplZEFkZHJlc3NlcywgJ2FkZHJlc3NlcycpXSkuZGVjb2RlKGFjY291bnREYXRhLnNsaWNlKExPT0tVUF9UQUJMRV9NRVRBX1NJWkUpKTtcbiAgICByZXR1cm4ge1xuICAgICAgZGVhY3RpdmF0aW9uU2xvdDogbWV0YS5kZWFjdGl2YXRpb25TbG90LFxuICAgICAgbGFzdEV4dGVuZGVkU2xvdDogbWV0YS5sYXN0RXh0ZW5kZWRTbG90LFxuICAgICAgbGFzdEV4dGVuZGVkU2xvdFN0YXJ0SW5kZXg6IG1ldGEubGFzdEV4dGVuZGVkU3RhcnRJbmRleCxcbiAgICAgIGF1dGhvcml0eTogbWV0YS5hdXRob3JpdHkubGVuZ3RoICE9PSAwID8gbmV3IFB1YmxpY0tleShtZXRhLmF1dGhvcml0eVswXSkgOiB1bmRlZmluZWQsXG4gICAgICBhZGRyZXNzZXM6IGFkZHJlc3Nlcy5tYXAoYWRkcmVzcyA9PiBuZXcgUHVibGljS2V5KGFkZHJlc3MpKVxuICAgIH07XG4gIH1cbn1cbmNvbnN0IExvb2t1cFRhYmxlTWV0YUxheW91dCA9IHtcbiAgaW5kZXg6IDEsXG4gIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMigndHlwZUluZGV4JyksIHU2NCgnZGVhY3RpdmF0aW9uU2xvdCcpLCBCdWZmZXJMYXlvdXQubnU2NCgnbGFzdEV4dGVuZGVkU2xvdCcpLCBCdWZmZXJMYXlvdXQudTgoJ2xhc3RFeHRlbmRlZFN0YXJ0SW5kZXgnKSwgQnVmZmVyTGF5b3V0LnU4KCksXG4gIC8vIG9wdGlvblxuICBCdWZmZXJMYXlvdXQuc2VxKHB1YmxpY0tleSgpLCBCdWZmZXJMYXlvdXQub2Zmc2V0KEJ1ZmZlckxheW91dC51OCgpLCAtMSksICdhdXRob3JpdHknKV0pXG59O1xuXG5jb25zdCBVUkxfUkUgPSAvXlteOl0rOlxcL1xcLyhbXjpbXSt8XFxbW15cXF1dK1xcXSkoOlxcZCspPyguKikvaTtcbmZ1bmN0aW9uIG1ha2VXZWJzb2NrZXRVcmwoZW5kcG9pbnQpIHtcbiAgY29uc3QgbWF0Y2hlcyA9IGVuZHBvaW50Lm1hdGNoKFVSTF9SRSk7XG4gIGlmIChtYXRjaGVzID09IG51bGwpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoYEZhaWxlZCB0byB2YWxpZGF0ZSBlbmRwb2ludCBVUkwgXFxgJHtlbmRwb2ludH1cXGBgKTtcbiAgfVxuICBjb25zdCBbXyxcbiAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgaG9zdGlzaCwgcG9ydFdpdGhDb2xvbiwgcmVzdF0gPSBtYXRjaGVzO1xuICBjb25zdCBwcm90b2NvbCA9IGVuZHBvaW50LnN0YXJ0c1dpdGgoJ2h0dHBzOicpID8gJ3dzczonIDogJ3dzOic7XG4gIGNvbnN0IHN0YXJ0UG9ydCA9IHBvcnRXaXRoQ29sb24gPT0gbnVsbCA/IG51bGwgOiBwYXJzZUludChwb3J0V2l0aENvbG9uLnNsaWNlKDEpLCAxMCk7XG4gIGNvbnN0IHdlYnNvY2tldFBvcnQgPVxuICAvLyBPbmx5IHNoaWZ0IHRoZSBwb3J0IGJ5ICsxIGFzIGEgY29udmVudGlvbiBmb3Igd3Mocykgb25seSBpZiBnaXZlbiBlbmRwb2ludFxuICAvLyBpcyBleHBsaWNpdGx5IHNwZWNpZnlpbmcgdGhlIGVuZHBvaW50IHBvcnQgKEhUVFAtYmFzZWQgUlBDKSwgYXNzdW1pbmdcbiAgLy8gd2UncmUgZGlyZWN0bHkgdHJ5aW5nIHRvIGNvbm5lY3QgdG8gYWdhdmUtdmFsaWRhdG9yJ3Mgd3MgbGlzdGVuaW5nIHBvcnQuXG4gIC8vIFdoZW4gdGhlIGVuZHBvaW50IG9taXRzIHRoZSBwb3J0LCB3ZSdyZSBjb25uZWN0aW5nIHRvIHRoZSBwcm90b2NvbFxuICAvLyBkZWZhdWx0IHBvcnRzOiBodHRwKDgwKSBvciBodHRwcyg0NDMpIGFuZCBpdCdzIGFzc3VtZWQgd2UncmUgYmVoaW5kIGEgcmV2ZXJzZVxuICAvLyBwcm94eSB3aGljaCBtYW5hZ2VzIFdlYlNvY2tldCB1cGdyYWRlIGFuZCBiYWNrZW5kIHBvcnQgcmVkaXJlY3Rpb24uXG4gIHN0YXJ0UG9ydCA9PSBudWxsID8gJycgOiBgOiR7c3RhcnRQb3J0ICsgMX1gO1xuICByZXR1cm4gYCR7cHJvdG9jb2x9Ly8ke2hvc3Rpc2h9JHt3ZWJzb2NrZXRQb3J0fSR7cmVzdH1gO1xufVxuXG5jb25zdCBQdWJsaWNLZXlGcm9tU3RyaW5nID0gY29lcmNlKGluc3RhbmNlKFB1YmxpY0tleSksIHN0cmluZygpLCB2YWx1ZSA9PiBuZXcgUHVibGljS2V5KHZhbHVlKSk7XG5jb25zdCBSYXdBY2NvdW50RGF0YVJlc3VsdCA9IHR1cGxlKFtzdHJpbmcoKSwgbGl0ZXJhbCgnYmFzZTY0JyldKTtcbmNvbnN0IEJ1ZmZlckZyb21SYXdBY2NvdW50RGF0YSA9IGNvZXJjZShpbnN0YW5jZShCdWZmZXIpLCBSYXdBY2NvdW50RGF0YVJlc3VsdCwgdmFsdWUgPT4gQnVmZmVyLmZyb20odmFsdWVbMF0sICdiYXNlNjQnKSk7XG5cbi8qKlxuICogQXR0ZW1wdCB0byB1c2UgYSByZWNlbnQgYmxvY2toYXNoIGZvciB1cCB0byAzMCBzZWNvbmRzXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgQkxPQ0tIQVNIX0NBQ0hFX1RJTUVPVVRfTVMgPSAzMCAqIDEwMDA7XG5cbi8qKlxuICogSEFDSy5cbiAqIENvcGllZCBmcm9tIHJwYy13ZWJzb2NrZXRzL2Rpc3QvbGliL2NsaWVudC5cbiAqIE90aGVyd2lzZSwgYHlhcm4gYnVpbGRgIGZhaWxzIHdpdGg6XG4gKiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9zdGV2ZWx1c2NoZXIvYzA1N2VjYTgxZDQ3OWVmNzA1Y2RiNTMxNjJmOTk3MWRcbiAqL1xuXG4vKiogQGludGVybmFsICovXG4vKiogQGludGVybmFsICovXG4vKiogQGludGVybmFsICovXG4vKiogQGludGVybmFsICovXG5cbi8qKiBAaW50ZXJuYWwgKi9cbi8qKlxuICogQGludGVybmFsXG4gKiBFdmVyeSBzdWJzY3JpcHRpb24gY29udGFpbnMgdGhlIGFyZ3MgdXNlZCB0byBvcGVuIHRoZSBzdWJzY3JpcHRpb24gd2l0aFxuICogdGhlIHNlcnZlciwgYW5kIGEgbGlzdCBvZiBjYWxsZXJzIGludGVyZXN0ZWQgaW4gbm90aWZpY2F0aW9ucy5cbiAqL1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICogQSBzdWJzY3JpcHRpb24gbWF5IGJlIGluIHZhcmlvdXMgc3RhdGVzIG9mIGNvbm5lY3RlZG5lc3MuIE9ubHkgd2hlbiBpdCBpc1xuICogZnVsbHkgY29ubmVjdGVkIHdpbGwgaXQgaGF2ZSBhIHNlcnZlciBzdWJzY3JpcHRpb24gaWQgYXNzb2NpYXRlZCB3aXRoIGl0LlxuICogVGhpcyBpZCBjYW4gYmUgcmV0dXJuZWQgdG8gdGhlIHNlcnZlciB0byB1bnN1YnNjcmliZSB0aGUgY2xpZW50IGVudGlyZWx5LlxuICovXG5cbi8qKlxuICogQSB0eXBlIHRoYXQgZW5jYXBzdWxhdGVzIGEgc3Vic2NyaXB0aW9uJ3MgUlBDIG1ldGhvZFxuICogbmFtZXMgYW5kIG5vdGlmaWNhdGlvbiAoY2FsbGJhY2spIHNpZ25hdHVyZS5cbiAqL1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICogVXRpbGl0eSB0eXBlIHRoYXQga2VlcHMgdGFnZ2VkIHVuaW9ucyBpbnRhY3Qgd2hpbGUgb21pdHRpbmcgcHJvcGVydGllcy5cbiAqL1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICogVGhpcyB0eXBlIHJlcHJlc2VudHMgYSBzaW5nbGUgc3Vic2NyaWJhYmxlICd0b3BpYy4nIEl0J3MgbWFkZSB1cCBvZjpcbiAqXG4gKiAtIFRoZSBhcmdzIHVzZWQgdG8gb3BlbiB0aGUgc3Vic2NyaXB0aW9uIHdpdGggdGhlIHNlcnZlcixcbiAqIC0gVGhlIHN0YXRlIG9mIHRoZSBzdWJzY3JpcHRpb24sIGluIHRlcm1zIG9mIGl0cyBjb25uZWN0ZWRuZXNzLCBhbmRcbiAqIC0gVGhlIHNldCBvZiBjYWxsYmFja3MgdG8gY2FsbCB3aGVuIHRoZSBzZXJ2ZXIgcHVibGlzaGVzIG5vdGlmaWNhdGlvbnNcbiAqXG4gKiBUaGlzIHJlY29yZCBnZXRzIGluZGV4ZWQgYnkgYFN1YnNjcmlwdGlvbkNvbmZpZ0hhc2hgIGFuZCBpcyB1c2VkIHRvXG4gKiBzZXQgdXAgc3Vic2NyaXB0aW9ucywgZmFuIG91dCBub3RpZmljYXRpb25zLCBhbmQgdHJhY2sgc3Vic2NyaXB0aW9uIHN0YXRlLlxuICovXG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cblxuLyoqXG4gKiBFeHRyYSBjb250ZXh0dWFsIGluZm9ybWF0aW9uIGZvciBSUEMgcmVzcG9uc2VzXG4gKi9cblxuLyoqXG4gKiBPcHRpb25zIGZvciBzZW5kaW5nIHRyYW5zYWN0aW9uc1xuICovXG5cbi8qKlxuICogT3B0aW9ucyBmb3IgY29uZmlybWluZyB0cmFuc2FjdGlvbnNcbiAqL1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGdldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzMlxuICovXG5cbi8qKlxuICogT3B0aW9ucyBmb3IgZ2V0U2lnbmF0dXJlc0ZvckFkZHJlc3NcbiAqL1xuXG4vKipcbiAqIFJQQyBSZXNwb25zZSB3aXRoIGV4dHJhIGNvbnRleHR1YWwgaW5mb3JtYXRpb25cbiAqL1xuXG4vKipcbiAqIEEgc3RyYXRlZ3kgZm9yIGNvbmZpcm1pbmcgdHJhbnNhY3Rpb25zIHRoYXQgdXNlcyB0aGUgbGFzdCB2YWxpZFxuICogYmxvY2sgaGVpZ2h0IGZvciBhIGdpdmVuIGJsb2NraGFzaCB0byBjaGVjayBmb3IgdHJhbnNhY3Rpb24gZXhwaXJhdGlvbi5cbiAqL1xuXG4vKipcbiAqIEEgc3RyYXRlZ3kgZm9yIGNvbmZpcm1pbmcgZHVyYWJsZSBub25jZSB0cmFuc2FjdGlvbnMuXG4gKi9cblxuLyoqXG4gKiBQcm9wZXJ0aWVzIHNoYXJlZCBieSBhbGwgdHJhbnNhY3Rpb24gY29uZmlybWF0aW9uIHN0cmF0ZWdpZXNcbiAqL1xuXG4vKipcbiAqIFRoaXMgdHlwZSByZXByZXNlbnRzIGFsbCB0cmFuc2FjdGlvbiBjb25maXJtYXRpb24gc3RyYXRlZ2llc1xuICovXG5cbi8qIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gYXNzZXJ0RW5kcG9pbnRVcmwocHV0YXRpdmVVcmwpIHtcbiAgaWYgKC9eaHR0cHM/Oi8udGVzdChwdXRhdGl2ZVVybCkgPT09IGZhbHNlKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRW5kcG9pbnQgVVJMIG11c3Qgc3RhcnQgd2l0aCBgaHR0cDpgIG9yIGBodHRwczpgLicpO1xuICB9XG4gIHJldHVybiBwdXRhdGl2ZVVybDtcbn1cblxuLyoqIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZykge1xuICBsZXQgY29tbWl0bWVudDtcbiAgbGV0IGNvbmZpZztcbiAgaWYgKHR5cGVvZiBjb21taXRtZW50T3JDb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgY29tbWl0bWVudCA9IGNvbW1pdG1lbnRPckNvbmZpZztcbiAgfSBlbHNlIGlmIChjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50OiBzcGVjaWZpZWRDb21taXRtZW50LFxuICAgICAgLi4uc3BlY2lmaWVkQ29uZmlnXG4gICAgfSA9IGNvbW1pdG1lbnRPckNvbmZpZztcbiAgICBjb21taXRtZW50ID0gc3BlY2lmaWVkQ29tbWl0bWVudDtcbiAgICBjb25maWcgPSBzcGVjaWZpZWRDb25maWc7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjb21taXRtZW50LFxuICAgIGNvbmZpZ1xuICB9O1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBhcHBseURlZmF1bHRNZW1jbXBFbmNvZGluZ1RvRmlsdGVycyhmaWx0ZXJzKSB7XG4gIHJldHVybiBmaWx0ZXJzLm1hcChmaWx0ZXIgPT4gJ21lbWNtcCcgaW4gZmlsdGVyID8ge1xuICAgIC4uLmZpbHRlcixcbiAgICBtZW1jbXA6IHtcbiAgICAgIC4uLmZpbHRlci5tZW1jbXAsXG4gICAgICBlbmNvZGluZzogZmlsdGVyLm1lbWNtcC5lbmNvZGluZyA/PyAnYmFzZTU4J1xuICAgIH1cbiAgfSA6IGZpbHRlcik7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJwY1Jlc3VsdChyZXN1bHQpIHtcbiAgcmV0dXJuIHVuaW9uKFt0eXBlKHtcbiAgICBqc29ucnBjOiBsaXRlcmFsKCcyLjAnKSxcbiAgICBpZDogc3RyaW5nKCksXG4gICAgcmVzdWx0XG4gIH0pLCB0eXBlKHtcbiAgICBqc29ucnBjOiBsaXRlcmFsKCcyLjAnKSxcbiAgICBpZDogc3RyaW5nKCksXG4gICAgZXJyb3I6IHR5cGUoe1xuICAgICAgY29kZTogdW5rbm93bigpLFxuICAgICAgbWVzc2FnZTogc3RyaW5nKCksXG4gICAgICBkYXRhOiBvcHRpb25hbChhbnkoKSlcbiAgICB9KVxuICB9KV0pO1xufVxuY29uc3QgVW5rbm93blJwY1Jlc3VsdCA9IGNyZWF0ZVJwY1Jlc3VsdCh1bmtub3duKCkpO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBqc29uUnBjUmVzdWx0KHNjaGVtYSkge1xuICByZXR1cm4gY29lcmNlKGNyZWF0ZVJwY1Jlc3VsdChzY2hlbWEpLCBVbmtub3duUnBjUmVzdWx0LCB2YWx1ZSA9PiB7XG4gICAgaWYgKCdlcnJvcicgaW4gdmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4udmFsdWUsXG4gICAgICAgIHJlc3VsdDogY3JlYXRlKHZhbHVlLnJlc3VsdCwgc2NoZW1hKVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBqc29uUnBjUmVzdWx0QW5kQ29udGV4dCh2YWx1ZSkge1xuICByZXR1cm4ganNvblJwY1Jlc3VsdCh0eXBlKHtcbiAgICBjb250ZXh0OiB0eXBlKHtcbiAgICAgIHNsb3Q6IG51bWJlcigpXG4gICAgfSksXG4gICAgdmFsdWVcbiAgfSkpO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBub3RpZmljYXRpb25SZXN1bHRBbmRDb250ZXh0KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlKHtcbiAgICBjb250ZXh0OiB0eXBlKHtcbiAgICAgIHNsb3Q6IG51bWJlcigpXG4gICAgfSksXG4gICAgdmFsdWVcbiAgfSk7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHZlcnNpb25lZE1lc3NhZ2VGcm9tUmVzcG9uc2UodmVyc2lvbiwgcmVzcG9uc2UpIHtcbiAgaWYgKHZlcnNpb24gPT09IDApIHtcbiAgICByZXR1cm4gbmV3IE1lc3NhZ2VWMCh7XG4gICAgICBoZWFkZXI6IHJlc3BvbnNlLmhlYWRlcixcbiAgICAgIHN0YXRpY0FjY291bnRLZXlzOiByZXNwb25zZS5hY2NvdW50S2V5cy5tYXAoYWNjb3VudEtleSA9PiBuZXcgUHVibGljS2V5KGFjY291bnRLZXkpKSxcbiAgICAgIHJlY2VudEJsb2NraGFzaDogcmVzcG9uc2UucmVjZW50QmxvY2toYXNoLFxuICAgICAgY29tcGlsZWRJbnN0cnVjdGlvbnM6IHJlc3BvbnNlLmluc3RydWN0aW9ucy5tYXAoaXggPT4gKHtcbiAgICAgICAgcHJvZ3JhbUlkSW5kZXg6IGl4LnByb2dyYW1JZEluZGV4LFxuICAgICAgICBhY2NvdW50S2V5SW5kZXhlczogaXguYWNjb3VudHMsXG4gICAgICAgIGRhdGE6IGJzNTguZGVjb2RlKGl4LmRhdGEpXG4gICAgICB9KSksXG4gICAgICBhZGRyZXNzVGFibGVMb29rdXBzOiByZXNwb25zZS5hZGRyZXNzVGFibGVMb29rdXBzXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBNZXNzYWdlKHJlc3BvbnNlKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBsZXZlbCBvZiBjb21taXRtZW50IGRlc2lyZWQgd2hlbiBxdWVyeWluZyBzdGF0ZVxuICogPHByZT5cbiAqICAgJ3Byb2Nlc3NlZCc6IFF1ZXJ5IHRoZSBtb3N0IHJlY2VudCBibG9jayB3aGljaCBoYXMgcmVhY2hlZCAxIGNvbmZpcm1hdGlvbiBieSB0aGUgY29ubmVjdGVkIG5vZGVcbiAqICAgJ2NvbmZpcm1lZCc6IFF1ZXJ5IHRoZSBtb3N0IHJlY2VudCBibG9jayB3aGljaCBoYXMgcmVhY2hlZCAxIGNvbmZpcm1hdGlvbiBieSB0aGUgY2x1c3RlclxuICogICAnZmluYWxpemVkJzogUXVlcnkgdGhlIG1vc3QgcmVjZW50IGJsb2NrIHdoaWNoIGhhcyBiZWVuIGZpbmFsaXplZCBieSB0aGUgY2x1c3RlclxuICogPC9wcmU+XG4gKi9cblxuLy8gRGVwcmVjYXRlZCBhcyBvZiB2MS41LjVcblxuLyoqXG4gKiBBIHN1YnNldCBvZiBDb21taXRtZW50IGxldmVscywgd2hpY2ggYXJlIGF0IGxlYXN0IG9wdGltaXN0aWNhbGx5IGNvbmZpcm1lZFxuICogPHByZT5cbiAqICAgJ2NvbmZpcm1lZCc6IFF1ZXJ5IHRoZSBtb3N0IHJlY2VudCBibG9jayB3aGljaCBoYXMgcmVhY2hlZCAxIGNvbmZpcm1hdGlvbiBieSB0aGUgY2x1c3RlclxuICogICAnZmluYWxpemVkJzogUXVlcnkgdGhlIG1vc3QgcmVjZW50IGJsb2NrIHdoaWNoIGhhcyBiZWVuIGZpbmFsaXplZCBieSB0aGUgY2x1c3RlclxuICogPC9wcmU+XG4gKi9cblxuLyoqXG4gKiBGaWx0ZXIgZm9yIGxhcmdlc3QgYWNjb3VudHMgcXVlcnlcbiAqIDxwcmU+XG4gKiAgICdjaXJjdWxhdGluZyc6ICAgIFJldHVybiB0aGUgbGFyZ2VzdCBhY2NvdW50cyB0aGF0IGFyZSBwYXJ0IG9mIHRoZSBjaXJjdWxhdGluZyBzdXBwbHlcbiAqICAgJ25vbkNpcmN1bGF0aW5nJzogUmV0dXJuIHRoZSBsYXJnZXN0IGFjY291bnRzIHRoYXQgYXJlIG5vdCBwYXJ0IG9mIHRoZSBjaXJjdWxhdGluZyBzdXBwbHlcbiAqIDwvcHJlPlxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRBY2NvdW50SW5mb2AgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0QmFsYW5jZWAgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0QmxvY2tgIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldEJsb2NrYCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRTdGFrZU1pbmltdW1EZWxlZ2F0aW9uYCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRCbG9ja0hlaWdodGAgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0RXBvY2hJbmZvYCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRJbmZsYXRpb25SZXdhcmRgIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldExhdGVzdEJsb2NraGFzaGAgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgaXNCbG9ja2hhc2hWYWxpZGAgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0U2xvdGAgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0U2xvdExlYWRlcmAgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0VHJhbnNhY3Rpb25gIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldFRyYW5zYWN0aW9uYCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRMYXJnZXN0QWNjb3VudHNgIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldFN1cHBseWAgcmVxdWVzdCBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBJbmZvcm1hdGlvbiBkZXNjcmliaW5nIGEgY2x1c3RlciBub2RlXG4gKi9cblxuLyoqXG4gKiBJbmZvcm1hdGlvbiBkZXNjcmliaW5nIGEgdm90ZSBhY2NvdW50XG4gKi9cblxuLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2YgY2x1c3RlciB2b3RlIGFjY291bnRzXG4gKi9cblxuLyoqXG4gKiBOZXR3b3JrIEluZmxhdGlvblxuICogKHNlZSBodHRwczovL2RvY3Muc29sYW5hLmNvbS9pbXBsZW1lbnRlZC1wcm9wb3NhbHMvZWRfb3ZlcnZpZXcpXG4gKi9cblxuY29uc3QgR2V0SW5mbGF0aW9uR292ZXJub3JSZXN1bHQgPSB0eXBlKHtcbiAgZm91bmRhdGlvbjogbnVtYmVyKCksXG4gIGZvdW5kYXRpb25UZXJtOiBudW1iZXIoKSxcbiAgaW5pdGlhbDogbnVtYmVyKCksXG4gIHRhcGVyOiBudW1iZXIoKSxcbiAgdGVybWluYWw6IG51bWJlcigpXG59KTtcblxuLyoqXG4gKiBUaGUgaW5mbGF0aW9uIHJld2FyZCBmb3IgYW4gZXBvY2hcbiAqL1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRJbmZsYXRpb25SZXdhcmRcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldEluZmxhdGlvblJld2FyZFJlc3VsdCA9IGpzb25ScGNSZXN1bHQoYXJyYXkobnVsbGFibGUodHlwZSh7XG4gIGVwb2NoOiBudW1iZXIoKSxcbiAgZWZmZWN0aXZlU2xvdDogbnVtYmVyKCksXG4gIGFtb3VudDogbnVtYmVyKCksXG4gIHBvc3RCYWxhbmNlOiBudW1iZXIoKSxcbiAgY29tbWlzc2lvbjogb3B0aW9uYWwobnVsbGFibGUobnVtYmVyKCkpKVxufSkpKSk7XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRSZWNlbnRQcmlvcml0aXphdGlvbkZlZXNgIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRSZWNlbnRQcmlvcml0aXphdGlvbkZlZXNSZXN1bHQgPSBhcnJheSh0eXBlKHtcbiAgc2xvdDogbnVtYmVyKCksXG4gIHByaW9yaXRpemF0aW9uRmVlOiBudW1iZXIoKVxufSkpO1xuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0SW5mbGF0aW9uUmF0ZVwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0SW5mbGF0aW9uUmF0ZVJlc3VsdCA9IHR5cGUoe1xuICB0b3RhbDogbnVtYmVyKCksXG4gIHZhbGlkYXRvcjogbnVtYmVyKCksXG4gIGZvdW5kYXRpb246IG51bWJlcigpLFxuICBlcG9jaDogbnVtYmVyKClcbn0pO1xuXG4vKipcbiAqIEluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50IGVwb2NoXG4gKi9cblxuY29uc3QgR2V0RXBvY2hJbmZvUmVzdWx0ID0gdHlwZSh7XG4gIGVwb2NoOiBudW1iZXIoKSxcbiAgc2xvdEluZGV4OiBudW1iZXIoKSxcbiAgc2xvdHNJbkVwb2NoOiBudW1iZXIoKSxcbiAgYWJzb2x1dGVTbG90OiBudW1iZXIoKSxcbiAgYmxvY2tIZWlnaHQ6IG9wdGlvbmFsKG51bWJlcigpKSxcbiAgdHJhbnNhY3Rpb25Db3VudDogb3B0aW9uYWwobnVtYmVyKCkpXG59KTtcbmNvbnN0IEdldEVwb2NoU2NoZWR1bGVSZXN1bHQgPSB0eXBlKHtcbiAgc2xvdHNQZXJFcG9jaDogbnVtYmVyKCksXG4gIGxlYWRlclNjaGVkdWxlU2xvdE9mZnNldDogbnVtYmVyKCksXG4gIHdhcm11cDogYm9vbGVhbigpLFxuICBmaXJzdE5vcm1hbEVwb2NoOiBudW1iZXIoKSxcbiAgZmlyc3ROb3JtYWxTbG90OiBudW1iZXIoKVxufSk7XG5cbi8qKlxuICogTGVhZGVyIHNjaGVkdWxlXG4gKiAoc2VlIGh0dHBzOi8vZG9jcy5zb2xhbmEuY29tL3Rlcm1pbm9sb2d5I2xlYWRlci1zY2hlZHVsZSlcbiAqL1xuXG5jb25zdCBHZXRMZWFkZXJTY2hlZHVsZVJlc3VsdCA9IHJlY29yZChzdHJpbmcoKSwgYXJyYXkobnVtYmVyKCkpKTtcblxuLyoqXG4gKiBUcmFuc2FjdGlvbiBlcnJvciBvciBudWxsXG4gKi9cbmNvbnN0IFRyYW5zYWN0aW9uRXJyb3JSZXN1bHQgPSBudWxsYWJsZSh1bmlvbihbdHlwZSh7fSksIHN0cmluZygpXSkpO1xuXG4vKipcbiAqIFNpZ25hdHVyZSBzdGF0dXMgZm9yIGEgdHJhbnNhY3Rpb25cbiAqL1xuY29uc3QgU2lnbmF0dXJlU3RhdHVzUmVzdWx0ID0gdHlwZSh7XG4gIGVycjogVHJhbnNhY3Rpb25FcnJvclJlc3VsdFxufSk7XG5cbi8qKlxuICogVHJhbnNhY3Rpb24gc2lnbmF0dXJlIHJlY2VpdmVkIG5vdGlmaWNhdGlvblxuICovXG5jb25zdCBTaWduYXR1cmVSZWNlaXZlZFJlc3VsdCA9IGxpdGVyYWwoJ3JlY2VpdmVkU2lnbmF0dXJlJyk7XG5cbi8qKlxuICogVmVyc2lvbiBpbmZvIGZvciBhIG5vZGVcbiAqL1xuXG5jb25zdCBWZXJzaW9uUmVzdWx0ID0gdHlwZSh7XG4gICdzb2xhbmEtY29yZSc6IHN0cmluZygpLFxuICAnZmVhdHVyZS1zZXQnOiBvcHRpb25hbChudW1iZXIoKSlcbn0pO1xuY29uc3QgUGFyc2VkSW5zdHJ1Y3Rpb25TdHJ1Y3QgPSB0eXBlKHtcbiAgcHJvZ3JhbTogc3RyaW5nKCksXG4gIHByb2dyYW1JZDogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgcGFyc2VkOiB1bmtub3duKClcbn0pO1xuY29uc3QgUGFydGlhbGx5RGVjb2RlZEluc3RydWN0aW9uU3RydWN0ID0gdHlwZSh7XG4gIHByb2dyYW1JZDogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgYWNjb3VudHM6IGFycmF5KFB1YmxpY0tleUZyb21TdHJpbmcpLFxuICBkYXRhOiBzdHJpbmcoKVxufSk7XG5jb25zdCBTaW11bGF0ZWRUcmFuc2FjdGlvblJlc3BvbnNlU3RydWN0ID0ganNvblJwY1Jlc3VsdEFuZENvbnRleHQodHlwZSh7XG4gIGVycjogbnVsbGFibGUodW5pb24oW3R5cGUoe30pLCBzdHJpbmcoKV0pKSxcbiAgbG9nczogbnVsbGFibGUoYXJyYXkoc3RyaW5nKCkpKSxcbiAgYWNjb3VudHM6IG9wdGlvbmFsKG51bGxhYmxlKGFycmF5KG51bGxhYmxlKHR5cGUoe1xuICAgIGV4ZWN1dGFibGU6IGJvb2xlYW4oKSxcbiAgICBvd25lcjogc3RyaW5nKCksXG4gICAgbGFtcG9ydHM6IG51bWJlcigpLFxuICAgIGRhdGE6IGFycmF5KHN0cmluZygpKSxcbiAgICByZW50RXBvY2g6IG9wdGlvbmFsKG51bWJlcigpKVxuICB9KSkpKSksXG4gIHVuaXRzQ29uc3VtZWQ6IG9wdGlvbmFsKG51bWJlcigpKSxcbiAgcmV0dXJuRGF0YTogb3B0aW9uYWwobnVsbGFibGUodHlwZSh7XG4gICAgcHJvZ3JhbUlkOiBzdHJpbmcoKSxcbiAgICBkYXRhOiB0dXBsZShbc3RyaW5nKCksIGxpdGVyYWwoJ2Jhc2U2NCcpXSlcbiAgfSkpKSxcbiAgaW5uZXJJbnN0cnVjdGlvbnM6IG9wdGlvbmFsKG51bGxhYmxlKGFycmF5KHR5cGUoe1xuICAgIGluZGV4OiBudW1iZXIoKSxcbiAgICBpbnN0cnVjdGlvbnM6IGFycmF5KHVuaW9uKFtQYXJzZWRJbnN0cnVjdGlvblN0cnVjdCwgUGFydGlhbGx5RGVjb2RlZEluc3RydWN0aW9uU3RydWN0XSkpXG4gIH0pKSkpXG59KSk7XG5cbi8qKlxuICogTWV0YWRhdGEgZm9yIGEgcGFyc2VkIGNvbmZpcm1lZCB0cmFuc2FjdGlvbiBvbiB0aGUgbGVkZ2VyXG4gKlxuICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBSUEMgdjEuOC4wLiBQbGVhc2UgdXNlIHtAbGluayBQYXJzZWRUcmFuc2FjdGlvbk1ldGF9IGluc3RlYWQuXG4gKi9cblxuLyoqXG4gKiBDb2xsZWN0aW9uIG9mIGFkZHJlc3NlcyBsb2FkZWQgYnkgYSB0cmFuc2FjdGlvbiB1c2luZyBhZGRyZXNzIHRhYmxlIGxvb2t1cHNcbiAqL1xuXG4vKipcbiAqIE1ldGFkYXRhIGZvciBhIHBhcnNlZCB0cmFuc2FjdGlvbiBvbiB0aGUgbGVkZ2VyXG4gKi9cblxuLyoqXG4gKiBNZXRhZGF0YSBmb3IgYSBjb25maXJtZWQgdHJhbnNhY3Rpb24gb24gdGhlIGxlZGdlclxuICovXG5cbi8qKlxuICogQSBwcm9jZXNzZWQgdHJhbnNhY3Rpb24gZnJvbSB0aGUgUlBDIEFQSVxuICovXG5cbi8qKlxuICogQSBwcm9jZXNzZWQgdHJhbnNhY3Rpb24gZnJvbSB0aGUgUlBDIEFQSVxuICovXG5cbi8qKlxuICogQSBwcm9jZXNzZWQgdHJhbnNhY3Rpb24gbWVzc2FnZSBmcm9tIHRoZSBSUEMgQVBJXG4gKi9cblxuLyoqXG4gKiBBIGNvbmZpcm1lZCB0cmFuc2FjdGlvbiBvbiB0aGUgbGVkZ2VyXG4gKlxuICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBSUEMgdjEuOC4wLlxuICovXG5cbi8qKlxuICogQSBwYXJ0aWFsbHkgZGVjb2RlZCB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvblxuICovXG5cbi8qKlxuICogQSBwYXJzZWQgdHJhbnNhY3Rpb24gbWVzc2FnZSBhY2NvdW50XG4gKi9cblxuLyoqXG4gKiBBIHBhcnNlZCB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvblxuICovXG5cbi8qKlxuICogQSBwYXJzZWQgYWRkcmVzcyB0YWJsZSBsb29rdXBcbiAqL1xuXG4vKipcbiAqIEEgcGFyc2VkIHRyYW5zYWN0aW9uIG1lc3NhZ2VcbiAqL1xuXG4vKipcbiAqIEEgcGFyc2VkIHRyYW5zYWN0aW9uXG4gKi9cblxuLyoqXG4gKiBBIHBhcnNlZCBhbmQgY29uZmlybWVkIHRyYW5zYWN0aW9uIG9uIHRoZSBsZWRnZXJcbiAqXG4gKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFJQQyB2MS44LjAuIFBsZWFzZSB1c2Uge0BsaW5rIFBhcnNlZFRyYW5zYWN0aW9uV2l0aE1ldGF9IGluc3RlYWQuXG4gKi9cblxuLyoqXG4gKiBBIHBhcnNlZCB0cmFuc2FjdGlvbiBvbiB0aGUgbGVkZ2VyIHdpdGggbWV0YVxuICovXG5cbi8qKlxuICogQSBwcm9jZXNzZWQgYmxvY2sgZmV0Y2hlZCBmcm9tIHRoZSBSUEMgQVBJXG4gKi9cblxuLyoqXG4gKiBBIHByb2Nlc3NlZCBibG9jayBmZXRjaGVkIGZyb20gdGhlIFJQQyBBUEkgd2hlcmUgdGhlIGB0cmFuc2FjdGlvbkRldGFpbHNgIG1vZGUgaXMgYGFjY291bnRzYFxuICovXG5cbi8qKlxuICogQSBwcm9jZXNzZWQgYmxvY2sgZmV0Y2hlZCBmcm9tIHRoZSBSUEMgQVBJIHdoZXJlIHRoZSBgdHJhbnNhY3Rpb25EZXRhaWxzYCBtb2RlIGlzIGBub25lYFxuICovXG5cbi8qKlxuICogQSBibG9jayB3aXRoIHBhcnNlZCB0cmFuc2FjdGlvbnNcbiAqL1xuXG4vKipcbiAqIEEgYmxvY2sgd2l0aCBwYXJzZWQgdHJhbnNhY3Rpb25zIHdoZXJlIHRoZSBgdHJhbnNhY3Rpb25EZXRhaWxzYCBtb2RlIGlzIGBhY2NvdW50c2BcbiAqL1xuXG4vKipcbiAqIEEgYmxvY2sgd2l0aCBwYXJzZWQgdHJhbnNhY3Rpb25zIHdoZXJlIHRoZSBgdHJhbnNhY3Rpb25EZXRhaWxzYCBtb2RlIGlzIGBub25lYFxuICovXG5cbi8qKlxuICogQSBwcm9jZXNzZWQgYmxvY2sgZmV0Y2hlZCBmcm9tIHRoZSBSUEMgQVBJXG4gKi9cblxuLyoqXG4gKiBBIHByb2Nlc3NlZCBibG9jayBmZXRjaGVkIGZyb20gdGhlIFJQQyBBUEkgd2hlcmUgdGhlIGB0cmFuc2FjdGlvbkRldGFpbHNgIG1vZGUgaXMgYGFjY291bnRzYFxuICovXG5cbi8qKlxuICogQSBwcm9jZXNzZWQgYmxvY2sgZmV0Y2hlZCBmcm9tIHRoZSBSUEMgQVBJIHdoZXJlIHRoZSBgdHJhbnNhY3Rpb25EZXRhaWxzYCBtb2RlIGlzIGBub25lYFxuICovXG5cbi8qKlxuICogQSBjb25maXJtZWQgYmxvY2sgb24gdGhlIGxlZGdlclxuICpcbiAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgUlBDIHYxLjguMC5cbiAqL1xuXG4vKipcbiAqIEEgQmxvY2sgb24gdGhlIGxlZGdlciB3aXRoIHNpZ25hdHVyZXMgb25seVxuICovXG5cbi8qKlxuICogcmVjZW50IGJsb2NrIHByb2R1Y3Rpb24gaW5mb3JtYXRpb25cbiAqL1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRCbG9ja1Byb2R1Y3Rpb25cIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEJsb2NrUHJvZHVjdGlvblJlc3BvbnNlU3RydWN0ID0ganNvblJwY1Jlc3VsdEFuZENvbnRleHQodHlwZSh7XG4gIGJ5SWRlbnRpdHk6IHJlY29yZChzdHJpbmcoKSwgYXJyYXkobnVtYmVyKCkpKSxcbiAgcmFuZ2U6IHR5cGUoe1xuICAgIGZpcnN0U2xvdDogbnVtYmVyKCksXG4gICAgbGFzdFNsb3Q6IG51bWJlcigpXG4gIH0pXG59KSk7XG5cbi8qKlxuICogQSBwZXJmb3JtYW5jZSBzYW1wbGVcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVScGNDbGllbnQodXJsLCBodHRwSGVhZGVycywgY3VzdG9tRmV0Y2gsIGZldGNoTWlkZGxld2FyZSwgZGlzYWJsZVJldHJ5T25SYXRlTGltaXQsIGh0dHBBZ2VudCkge1xuICBjb25zdCBmZXRjaCA9IGN1c3RvbUZldGNoID8gY3VzdG9tRmV0Y2ggOiBmZXRjaEltcGw7XG4gIGxldCBhZ2VudDtcbiAge1xuICAgIGlmIChodHRwQWdlbnQgPT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICBjb25zdCBhZ2VudE9wdGlvbnMgPSB7XG4gICAgICAgICAgLy8gT25lIHNlY29uZCBmZXdlciB0aGFuIHRoZSBTb2xhbmEgUlBDJ3Mga2VlcGFsaXZlIHRpbWVvdXQuXG4gICAgICAgICAgLy8gUmVhZCBtb3JlOiBodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hL2lzc3Vlcy8yNzg1OSNpc3N1ZWNvbW1lbnQtMTM0MDA5Nzg4OVxuICAgICAgICAgIGZyZWVTb2NrZXRUaW1lb3V0OiAxOTAwMCxcbiAgICAgICAgICBrZWVwQWxpdmU6IHRydWUsXG4gICAgICAgICAgbWF4U29ja2V0czogMjVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHVybC5zdGFydHNXaXRoKCdodHRwczonKSkge1xuICAgICAgICAgIGFnZW50ID0gbmV3IGFnZW50a2VlcGFsaXZlRXhwb3J0cy5IdHRwc0FnZW50KGFnZW50T3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWdlbnQgPSBuZXcgSHR0cEtlZXBBbGl2ZUFnZW50KGFnZW50T3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGh0dHBBZ2VudCAhPT0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgaXNIdHRwcyA9IHVybC5zdGFydHNXaXRoKCdodHRwczonKTtcbiAgICAgICAgaWYgKGlzSHR0cHMgJiYgIShodHRwQWdlbnQgaW5zdGFuY2VvZiBBZ2VudCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBlbmRwb2ludCBgJyArIHVybCArICdgIGNhbiBvbmx5IGJlIHBhaXJlZCB3aXRoIGFuIGBodHRwcy5BZ2VudGAuIFlvdSBoYXZlLCBpbnN0ZWFkLCBzdXBwbGllZCBhbiAnICsgJ2BodHRwLkFnZW50YCB0aHJvdWdoIGBodHRwQWdlbnRgLicpO1xuICAgICAgICB9IGVsc2UgaWYgKCFpc0h0dHBzICYmIGh0dHBBZ2VudCBpbnN0YW5jZW9mIEFnZW50KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZW5kcG9pbnQgYCcgKyB1cmwgKyAnYCBjYW4gb25seSBiZSBwYWlyZWQgd2l0aCBhbiBgaHR0cC5BZ2VudGAuIFlvdSBoYXZlLCBpbnN0ZWFkLCBzdXBwbGllZCBhbiAnICsgJ2BodHRwcy5BZ2VudGAgdGhyb3VnaCBgaHR0cEFnZW50YC4nKTtcbiAgICAgICAgfVxuICAgICAgICBhZ2VudCA9IGh0dHBBZ2VudDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbGV0IGZldGNoV2l0aE1pZGRsZXdhcmU7XG4gIGlmIChmZXRjaE1pZGRsZXdhcmUpIHtcbiAgICBmZXRjaFdpdGhNaWRkbGV3YXJlID0gYXN5bmMgKGluZm8sIGluaXQpID0+IHtcbiAgICAgIGNvbnN0IG1vZGlmaWVkRmV0Y2hBcmdzID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZldGNoTWlkZGxld2FyZShpbmZvLCBpbml0LCAobW9kaWZpZWRJbmZvLCBtb2RpZmllZEluaXQpID0+IHJlc29sdmUoW21vZGlmaWVkSW5mbywgbW9kaWZpZWRJbml0XSkpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGF3YWl0IGZldGNoKC4uLm1vZGlmaWVkRmV0Y2hBcmdzKTtcbiAgICB9O1xuICB9XG4gIGNvbnN0IGNsaWVudEJyb3dzZXIgPSBuZXcgUnBjQ2xpZW50KGFzeW5jIChyZXF1ZXN0LCBjYWxsYmFjaykgPT4ge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGJvZHk6IHJlcXVlc3QsXG4gICAgICBhZ2VudCxcbiAgICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICB9LCBodHRwSGVhZGVycyB8fCB7fSwgQ09NTU9OX0hUVFBfSEVBREVSUylcbiAgICB9O1xuICAgIHRyeSB7XG4gICAgICBsZXQgdG9vX21hbnlfcmVxdWVzdHNfcmV0cmllcyA9IDU7XG4gICAgICBsZXQgcmVzO1xuICAgICAgbGV0IHdhaXRUaW1lID0gNTAwO1xuICAgICAgZm9yICg7Oykge1xuICAgICAgICBpZiAoZmV0Y2hXaXRoTWlkZGxld2FyZSkge1xuICAgICAgICAgIHJlcyA9IGF3YWl0IGZldGNoV2l0aE1pZGRsZXdhcmUodXJsLCBvcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXMgPSBhd2FpdCBmZXRjaCh1cmwsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXMuc3RhdHVzICE9PSA0MjkgLyogVG9vIG1hbnkgcmVxdWVzdHMgKi8pIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlzYWJsZVJldHJ5T25SYXRlTGltaXQgPT09IHRydWUpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0b29fbWFueV9yZXF1ZXN0c19yZXRyaWVzIC09IDE7XG4gICAgICAgIGlmICh0b29fbWFueV9yZXF1ZXN0c19yZXRyaWVzID09PSAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5lcnJvcihgU2VydmVyIHJlc3BvbmRlZCB3aXRoICR7cmVzLnN0YXR1c30gJHtyZXMuc3RhdHVzVGV4dH0uICBSZXRyeWluZyBhZnRlciAke3dhaXRUaW1lfW1zIGRlbGF5Li4uYCk7XG4gICAgICAgIGF3YWl0IHNsZWVwKHdhaXRUaW1lKTtcbiAgICAgICAgd2FpdFRpbWUgKj0gMjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgaWYgKHJlcy5vaykge1xuICAgICAgICBjYWxsYmFjayhudWxsLCB0ZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcihgJHtyZXMuc3RhdHVzfSAke3Jlcy5zdGF0dXNUZXh0fTogJHt0ZXh0fWApKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikgY2FsbGJhY2soZXJyKTtcbiAgICB9XG4gIH0sIHt9KTtcbiAgcmV0dXJuIGNsaWVudEJyb3dzZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVScGNSZXF1ZXN0KGNsaWVudCkge1xuICByZXR1cm4gKG1ldGhvZCwgYXJncykgPT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjbGllbnQucmVxdWVzdChtZXRob2QsIGFyZ3MsIChlcnIsIHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJwY0JhdGNoUmVxdWVzdChjbGllbnQpIHtcbiAgcmV0dXJuIHJlcXVlc3RzID0+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgLy8gRG8gbm90aGluZyBpZiByZXF1ZXN0cyBpcyBlbXB0eVxuICAgICAgaWYgKHJlcXVlc3RzLmxlbmd0aCA9PT0gMCkgcmVzb2x2ZShbXSk7XG4gICAgICBjb25zdCBiYXRjaCA9IHJlcXVlc3RzLm1hcChwYXJhbXMgPT4ge1xuICAgICAgICByZXR1cm4gY2xpZW50LnJlcXVlc3QocGFyYW1zLm1ldGhvZE5hbWUsIHBhcmFtcy5hcmdzKTtcbiAgICAgIH0pO1xuICAgICAgY2xpZW50LnJlcXVlc3QoYmF0Y2gsIChlcnIsIHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbn1cblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0SW5mbGF0aW9uR292ZXJub3JcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldEluZmxhdGlvbkdvdmVybm9yUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChHZXRJbmZsYXRpb25Hb3Zlcm5vclJlc3VsdCk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEluZmxhdGlvblJhdGVcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldEluZmxhdGlvblJhdGVScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KEdldEluZmxhdGlvblJhdGVSZXN1bHQpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRSZWNlbnRQcmlvcml0aXphdGlvbkZlZXNcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldFJlY2VudFByaW9yaXRpemF0aW9uRmVlc1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoR2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzUmVzdWx0KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0RXBvY2hJbmZvXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRFcG9jaEluZm9ScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KEdldEVwb2NoSW5mb1Jlc3VsdCk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEVwb2NoU2NoZWR1bGVcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldEVwb2NoU2NoZWR1bGVScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KEdldEVwb2NoU2NoZWR1bGVSZXN1bHQpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRMZWFkZXJTY2hlZHVsZVwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0TGVhZGVyU2NoZWR1bGVScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KEdldExlYWRlclNjaGVkdWxlUmVzdWx0KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwibWluaW11bUxlZGdlclNsb3RcIiBhbmQgXCJnZXRGaXJzdEF2YWlsYWJsZUJsb2NrXCIgbWVzc2FnZXNcbiAqL1xuY29uc3QgU2xvdFJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQobnVtYmVyKCkpO1xuXG4vKipcbiAqIFN1cHBseVxuICovXG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFN1cHBseVwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0U3VwcGx5UnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdEFuZENvbnRleHQodHlwZSh7XG4gIHRvdGFsOiBudW1iZXIoKSxcbiAgY2lyY3VsYXRpbmc6IG51bWJlcigpLFxuICBub25DaXJjdWxhdGluZzogbnVtYmVyKCksXG4gIG5vbkNpcmN1bGF0aW5nQWNjb3VudHM6IGFycmF5KFB1YmxpY0tleUZyb21TdHJpbmcpXG59KSk7XG5cbi8qKlxuICogVG9rZW4gYW1vdW50IG9iamVjdCB3aGljaCByZXR1cm5zIGEgdG9rZW4gYW1vdW50IGluIGRpZmZlcmVudCBmb3JtYXRzXG4gKiBmb3IgdmFyaW91cyBjbGllbnQgdXNlIGNhc2VzLlxuICovXG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgc3RydWN0dXJlIGZvciB0b2tlbiBhbW91bnRzXG4gKi9cbmNvbnN0IFRva2VuQW1vdW50UmVzdWx0ID0gdHlwZSh7XG4gIGFtb3VudDogc3RyaW5nKCksXG4gIHVpQW1vdW50OiBudWxsYWJsZShudW1iZXIoKSksXG4gIGRlY2ltYWxzOiBudW1iZXIoKSxcbiAgdWlBbW91bnRTdHJpbmc6IG9wdGlvbmFsKHN0cmluZygpKVxufSk7XG5cbi8qKlxuICogVG9rZW4gYWRkcmVzcyBhbmQgYmFsYW5jZS5cbiAqL1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRUb2tlbkxhcmdlc3RBY2NvdW50c1wiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0VG9rZW5MYXJnZXN0QWNjb3VudHNSZXN1bHQgPSBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChhcnJheSh0eXBlKHtcbiAgYWRkcmVzczogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgYW1vdW50OiBzdHJpbmcoKSxcbiAgdWlBbW91bnQ6IG51bGxhYmxlKG51bWJlcigpKSxcbiAgZGVjaW1hbHM6IG51bWJlcigpLFxuICB1aUFtb3VudFN0cmluZzogb3B0aW9uYWwoc3RyaW5nKCkpXG59KSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRUb2tlbkFjY291bnRzQnlPd25lclwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0VG9rZW5BY2NvdW50c0J5T3duZXIgPSBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChhcnJheSh0eXBlKHtcbiAgcHVia2V5OiBQdWJsaWNLZXlGcm9tU3RyaW5nLFxuICBhY2NvdW50OiB0eXBlKHtcbiAgICBleGVjdXRhYmxlOiBib29sZWFuKCksXG4gICAgb3duZXI6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gICAgbGFtcG9ydHM6IG51bWJlcigpLFxuICAgIGRhdGE6IEJ1ZmZlckZyb21SYXdBY2NvdW50RGF0YSxcbiAgICByZW50RXBvY2g6IG51bWJlcigpXG4gIH0pXG59KSkpO1xuY29uc3QgUGFyc2VkQWNjb3VudERhdGFSZXN1bHQgPSB0eXBlKHtcbiAgcHJvZ3JhbTogc3RyaW5nKCksXG4gIHBhcnNlZDogdW5rbm93bigpLFxuICBzcGFjZTogbnVtYmVyKClcbn0pO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRUb2tlbkFjY291bnRzQnlPd25lclwiIG1lc3NhZ2Ugd2l0aCBwYXJzZWQgZGF0YVxuICovXG5jb25zdCBHZXRQYXJzZWRUb2tlbkFjY291bnRzQnlPd25lciA9IGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KGFycmF5KHR5cGUoe1xuICBwdWJrZXk6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gIGFjY291bnQ6IHR5cGUoe1xuICAgIGV4ZWN1dGFibGU6IGJvb2xlYW4oKSxcbiAgICBvd25lcjogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgICBsYW1wb3J0czogbnVtYmVyKCksXG4gICAgZGF0YTogUGFyc2VkQWNjb3VudERhdGFSZXN1bHQsXG4gICAgcmVudEVwb2NoOiBudW1iZXIoKVxuICB9KVxufSkpKTtcblxuLyoqXG4gKiBQYWlyIG9mIGFuIGFjY291bnQgYWRkcmVzcyBhbmQgaXRzIGJhbGFuY2VcbiAqL1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRMYXJnZXN0QWNjb3VudHNcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldExhcmdlc3RBY2NvdW50c1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KGFycmF5KHR5cGUoe1xuICBsYW1wb3J0czogbnVtYmVyKCksXG4gIGFkZHJlc3M6IFB1YmxpY0tleUZyb21TdHJpbmdcbn0pKSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IEFjY291bnRJbmZvUmVzdWx0ID0gdHlwZSh7XG4gIGV4ZWN1dGFibGU6IGJvb2xlYW4oKSxcbiAgb3duZXI6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gIGxhbXBvcnRzOiBudW1iZXIoKSxcbiAgZGF0YTogQnVmZmVyRnJvbVJhd0FjY291bnREYXRhLFxuICByZW50RXBvY2g6IG51bWJlcigpXG59KTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgS2V5ZWRBY2NvdW50SW5mb1Jlc3VsdCA9IHR5cGUoe1xuICBwdWJrZXk6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gIGFjY291bnQ6IEFjY291bnRJbmZvUmVzdWx0XG59KTtcbmNvbnN0IFBhcnNlZE9yUmF3QWNjb3VudERhdGEgPSBjb2VyY2UodW5pb24oW2luc3RhbmNlKEJ1ZmZlciksIFBhcnNlZEFjY291bnREYXRhUmVzdWx0XSksIHVuaW9uKFtSYXdBY2NvdW50RGF0YVJlc3VsdCwgUGFyc2VkQWNjb3VudERhdGFSZXN1bHRdKSwgdmFsdWUgPT4ge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gY3JlYXRlKHZhbHVlLCBCdWZmZXJGcm9tUmF3QWNjb3VudERhdGEpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFBhcnNlZEFjY291bnRJbmZvUmVzdWx0ID0gdHlwZSh7XG4gIGV4ZWN1dGFibGU6IGJvb2xlYW4oKSxcbiAgb3duZXI6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gIGxhbXBvcnRzOiBudW1iZXIoKSxcbiAgZGF0YTogUGFyc2VkT3JSYXdBY2NvdW50RGF0YSxcbiAgcmVudEVwb2NoOiBudW1iZXIoKVxufSk7XG5jb25zdCBLZXllZFBhcnNlZEFjY291bnRJbmZvUmVzdWx0ID0gdHlwZSh7XG4gIHB1YmtleTogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgYWNjb3VudDogUGFyc2VkQWNjb3VudEluZm9SZXN1bHRcbn0pO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBTdGFrZUFjdGl2YXRpb25SZXN1bHQgPSB0eXBlKHtcbiAgc3RhdGU6IHVuaW9uKFtsaXRlcmFsKCdhY3RpdmUnKSwgbGl0ZXJhbCgnaW5hY3RpdmUnKSwgbGl0ZXJhbCgnYWN0aXZhdGluZycpLCBsaXRlcmFsKCdkZWFjdGl2YXRpbmcnKV0pLFxuICBhY3RpdmU6IG51bWJlcigpLFxuICBpbmFjdGl2ZTogbnVtYmVyKClcbn0pO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzczJcIiBtZXNzYWdlXG4gKi9cblxuY29uc3QgR2V0Q29uZmlybWVkU2lnbmF0dXJlc0ZvckFkZHJlc3MyUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChhcnJheSh0eXBlKHtcbiAgc2lnbmF0dXJlOiBzdHJpbmcoKSxcbiAgc2xvdDogbnVtYmVyKCksXG4gIGVycjogVHJhbnNhY3Rpb25FcnJvclJlc3VsdCxcbiAgbWVtbzogbnVsbGFibGUoc3RyaW5nKCkpLFxuICBibG9ja1RpbWU6IG9wdGlvbmFsKG51bGxhYmxlKG51bWJlcigpKSlcbn0pKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFNpZ25hdHVyZXNGb3JBZGRyZXNzXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRTaWduYXR1cmVzRm9yQWRkcmVzc1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoYXJyYXkodHlwZSh7XG4gIHNpZ25hdHVyZTogc3RyaW5nKCksXG4gIHNsb3Q6IG51bWJlcigpLFxuICBlcnI6IFRyYW5zYWN0aW9uRXJyb3JSZXN1bHQsXG4gIG1lbW86IG51bGxhYmxlKHN0cmluZygpKSxcbiAgYmxvY2tUaW1lOiBvcHRpb25hbChudWxsYWJsZShudW1iZXIoKSkpXG59KSkpO1xuXG4vKioqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiYWNjb3VudE5vdGlmaWNhdGlvblwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgQWNjb3VudE5vdGlmaWNhdGlvblJlc3VsdCA9IHR5cGUoe1xuICBzdWJzY3JpcHRpb246IG51bWJlcigpLFxuICByZXN1bHQ6IG5vdGlmaWNhdGlvblJlc3VsdEFuZENvbnRleHQoQWNjb3VudEluZm9SZXN1bHQpXG59KTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgUHJvZ3JhbUFjY291bnRJbmZvUmVzdWx0ID0gdHlwZSh7XG4gIHB1YmtleTogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgYWNjb3VudDogQWNjb3VudEluZm9SZXN1bHRcbn0pO1xuXG4vKioqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwicHJvZ3JhbU5vdGlmaWNhdGlvblwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgUHJvZ3JhbUFjY291bnROb3RpZmljYXRpb25SZXN1bHQgPSB0eXBlKHtcbiAgc3Vic2NyaXB0aW9uOiBudW1iZXIoKSxcbiAgcmVzdWx0OiBub3RpZmljYXRpb25SZXN1bHRBbmRDb250ZXh0KFByb2dyYW1BY2NvdW50SW5mb1Jlc3VsdClcbn0pO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBTbG90SW5mb1Jlc3VsdCA9IHR5cGUoe1xuICBwYXJlbnQ6IG51bWJlcigpLFxuICBzbG90OiBudW1iZXIoKSxcbiAgcm9vdDogbnVtYmVyKClcbn0pO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJzbG90Tm90aWZpY2F0aW9uXCIgbWVzc2FnZVxuICovXG5jb25zdCBTbG90Tm90aWZpY2F0aW9uUmVzdWx0ID0gdHlwZSh7XG4gIHN1YnNjcmlwdGlvbjogbnVtYmVyKCksXG4gIHJlc3VsdDogU2xvdEluZm9SZXN1bHRcbn0pO1xuXG4vKipcbiAqIFNsb3QgdXBkYXRlcyB3aGljaCBjYW4gYmUgdXNlZCBmb3IgdHJhY2tpbmcgdGhlIGxpdmUgcHJvZ3Jlc3Mgb2YgYSBjbHVzdGVyLlxuICogLSBgXCJmaXJzdFNocmVkUmVjZWl2ZWRcImA6IGNvbm5lY3RlZCBub2RlIHJlY2VpdmVkIHRoZSBmaXJzdCBzaHJlZCBvZiBhIGJsb2NrLlxuICogSW5kaWNhdGVzIHRoYXQgYSBuZXcgYmxvY2sgdGhhdCBpcyBiZWluZyBwcm9kdWNlZC5cbiAqIC0gYFwiY29tcGxldGVkXCJgOiBjb25uZWN0ZWQgbm9kZSBoYXMgcmVjZWl2ZWQgYWxsIHNocmVkcyBvZiBhIGJsb2NrLiBJbmRpY2F0ZXNcbiAqIGEgYmxvY2sgd2FzIHJlY2VudGx5IHByb2R1Y2VkLlxuICogLSBgXCJvcHRpbWlzdGljQ29uZmlybWF0aW9uXCJgOiBibG9jayB3YXMgb3B0aW1pc3RpY2FsbHkgY29uZmlybWVkIGJ5IHRoZVxuICogY2x1c3Rlci4gSXQgaXMgbm90IGd1YXJhbnRlZWQgdGhhdCBhbiBvcHRpbWlzdGljIGNvbmZpcm1hdGlvbiBub3RpZmljYXRpb25cbiAqIHdpbGwgYmUgc2VudCBmb3IgZXZlcnkgZmluYWxpemVkIGJsb2Nrcy5cbiAqIC0gYFwicm9vdFwiYDogdGhlIGNvbm5lY3RlZCBub2RlIHJvb3RlZCB0aGlzIGJsb2NrLlxuICogLSBgXCJjcmVhdGVkQmFua1wiYDogdGhlIGNvbm5lY3RlZCBub2RlIGhhcyBzdGFydGVkIHZhbGlkYXRpbmcgdGhpcyBibG9jay5cbiAqIC0gYFwiZnJvemVuXCJgOiB0aGUgY29ubmVjdGVkIG5vZGUgaGFzIHZhbGlkYXRlZCB0aGlzIGJsb2NrLlxuICogLSBgXCJkZWFkXCJgOiB0aGUgY29ubmVjdGVkIG5vZGUgZmFpbGVkIHRvIHZhbGlkYXRlIHRoaXMgYmxvY2suXG4gKi9cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgU2xvdFVwZGF0ZVJlc3VsdCA9IHVuaW9uKFt0eXBlKHtcbiAgdHlwZTogdW5pb24oW2xpdGVyYWwoJ2ZpcnN0U2hyZWRSZWNlaXZlZCcpLCBsaXRlcmFsKCdjb21wbGV0ZWQnKSwgbGl0ZXJhbCgnb3B0aW1pc3RpY0NvbmZpcm1hdGlvbicpLCBsaXRlcmFsKCdyb290JyldKSxcbiAgc2xvdDogbnVtYmVyKCksXG4gIHRpbWVzdGFtcDogbnVtYmVyKClcbn0pLCB0eXBlKHtcbiAgdHlwZTogbGl0ZXJhbCgnY3JlYXRlZEJhbmsnKSxcbiAgcGFyZW50OiBudW1iZXIoKSxcbiAgc2xvdDogbnVtYmVyKCksXG4gIHRpbWVzdGFtcDogbnVtYmVyKClcbn0pLCB0eXBlKHtcbiAgdHlwZTogbGl0ZXJhbCgnZnJvemVuJyksXG4gIHNsb3Q6IG51bWJlcigpLFxuICB0aW1lc3RhbXA6IG51bWJlcigpLFxuICBzdGF0czogdHlwZSh7XG4gICAgbnVtVHJhbnNhY3Rpb25FbnRyaWVzOiBudW1iZXIoKSxcbiAgICBudW1TdWNjZXNzZnVsVHJhbnNhY3Rpb25zOiBudW1iZXIoKSxcbiAgICBudW1GYWlsZWRUcmFuc2FjdGlvbnM6IG51bWJlcigpLFxuICAgIG1heFRyYW5zYWN0aW9uc1BlckVudHJ5OiBudW1iZXIoKVxuICB9KVxufSksIHR5cGUoe1xuICB0eXBlOiBsaXRlcmFsKCdkZWFkJyksXG4gIHNsb3Q6IG51bWJlcigpLFxuICB0aW1lc3RhbXA6IG51bWJlcigpLFxuICBlcnI6IHN0cmluZygpXG59KV0pO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJzbG90c1VwZGF0ZXNOb3RpZmljYXRpb25cIiBtZXNzYWdlXG4gKi9cbmNvbnN0IFNsb3RVcGRhdGVOb3RpZmljYXRpb25SZXN1bHQgPSB0eXBlKHtcbiAgc3Vic2NyaXB0aW9uOiBudW1iZXIoKSxcbiAgcmVzdWx0OiBTbG90VXBkYXRlUmVzdWx0XG59KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwic2lnbmF0dXJlTm90aWZpY2F0aW9uXCIgbWVzc2FnZVxuICovXG5jb25zdCBTaWduYXR1cmVOb3RpZmljYXRpb25SZXN1bHQgPSB0eXBlKHtcbiAgc3Vic2NyaXB0aW9uOiBudW1iZXIoKSxcbiAgcmVzdWx0OiBub3RpZmljYXRpb25SZXN1bHRBbmRDb250ZXh0KHVuaW9uKFtTaWduYXR1cmVTdGF0dXNSZXN1bHQsIFNpZ25hdHVyZVJlY2VpdmVkUmVzdWx0XSkpXG59KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwicm9vdE5vdGlmaWNhdGlvblwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgUm9vdE5vdGlmaWNhdGlvblJlc3VsdCA9IHR5cGUoe1xuICBzdWJzY3JpcHRpb246IG51bWJlcigpLFxuICByZXN1bHQ6IG51bWJlcigpXG59KTtcbmNvbnN0IENvbnRhY3RJbmZvUmVzdWx0ID0gdHlwZSh7XG4gIHB1YmtleTogc3RyaW5nKCksXG4gIGdvc3NpcDogbnVsbGFibGUoc3RyaW5nKCkpLFxuICB0cHU6IG51bGxhYmxlKHN0cmluZygpKSxcbiAgcnBjOiBudWxsYWJsZShzdHJpbmcoKSksXG4gIHZlcnNpb246IG51bGxhYmxlKHN0cmluZygpKVxufSk7XG5jb25zdCBWb3RlQWNjb3VudEluZm9SZXN1bHQgPSB0eXBlKHtcbiAgdm90ZVB1YmtleTogc3RyaW5nKCksXG4gIG5vZGVQdWJrZXk6IHN0cmluZygpLFxuICBhY3RpdmF0ZWRTdGFrZTogbnVtYmVyKCksXG4gIGVwb2NoVm90ZUFjY291bnQ6IGJvb2xlYW4oKSxcbiAgZXBvY2hDcmVkaXRzOiBhcnJheSh0dXBsZShbbnVtYmVyKCksIG51bWJlcigpLCBudW1iZXIoKV0pKSxcbiAgY29tbWlzc2lvbjogbnVtYmVyKCksXG4gIGxhc3RWb3RlOiBudW1iZXIoKSxcbiAgcm9vdFNsb3Q6IG51bGxhYmxlKG51bWJlcigpKVxufSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFZvdGVBY2NvdW50c1wiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0Vm90ZUFjY291bnRzID0ganNvblJwY1Jlc3VsdCh0eXBlKHtcbiAgY3VycmVudDogYXJyYXkoVm90ZUFjY291bnRJbmZvUmVzdWx0KSxcbiAgZGVsaW5xdWVudDogYXJyYXkoVm90ZUFjY291bnRJbmZvUmVzdWx0KVxufSkpO1xuY29uc3QgQ29uZmlybWF0aW9uU3RhdHVzID0gdW5pb24oW2xpdGVyYWwoJ3Byb2Nlc3NlZCcpLCBsaXRlcmFsKCdjb25maXJtZWQnKSwgbGl0ZXJhbCgnZmluYWxpemVkJyldKTtcbmNvbnN0IFNpZ25hdHVyZVN0YXR1c1Jlc3BvbnNlID0gdHlwZSh7XG4gIHNsb3Q6IG51bWJlcigpLFxuICBjb25maXJtYXRpb25zOiBudWxsYWJsZShudW1iZXIoKSksXG4gIGVycjogVHJhbnNhY3Rpb25FcnJvclJlc3VsdCxcbiAgY29uZmlybWF0aW9uU3RhdHVzOiBvcHRpb25hbChDb25maXJtYXRpb25TdGF0dXMpXG59KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0U2lnbmF0dXJlU3RhdHVzZXNcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldFNpZ25hdHVyZVN0YXR1c2VzUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdEFuZENvbnRleHQoYXJyYXkobnVsbGFibGUoU2lnbmF0dXJlU3RhdHVzUmVzcG9uc2UpKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldE1pbmltdW1CYWxhbmNlRm9yUmVudEV4ZW1wdGlvblwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0TWluaW11bUJhbGFuY2VGb3JSZW50RXhlbXB0aW9uUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChudW1iZXIoKSk7XG5jb25zdCBBZGRyZXNzVGFibGVMb29rdXBTdHJ1Y3QgPSB0eXBlKHtcbiAgYWNjb3VudEtleTogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgd3JpdGFibGVJbmRleGVzOiBhcnJheShudW1iZXIoKSksXG4gIHJlYWRvbmx5SW5kZXhlczogYXJyYXkobnVtYmVyKCkpXG59KTtcbmNvbnN0IENvbmZpcm1lZFRyYW5zYWN0aW9uUmVzdWx0ID0gdHlwZSh7XG4gIHNpZ25hdHVyZXM6IGFycmF5KHN0cmluZygpKSxcbiAgbWVzc2FnZTogdHlwZSh7XG4gICAgYWNjb3VudEtleXM6IGFycmF5KHN0cmluZygpKSxcbiAgICBoZWFkZXI6IHR5cGUoe1xuICAgICAgbnVtUmVxdWlyZWRTaWduYXR1cmVzOiBudW1iZXIoKSxcbiAgICAgIG51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHM6IG51bWJlcigpLFxuICAgICAgbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzOiBudW1iZXIoKVxuICAgIH0pLFxuICAgIGluc3RydWN0aW9uczogYXJyYXkodHlwZSh7XG4gICAgICBhY2NvdW50czogYXJyYXkobnVtYmVyKCkpLFxuICAgICAgZGF0YTogc3RyaW5nKCksXG4gICAgICBwcm9ncmFtSWRJbmRleDogbnVtYmVyKClcbiAgICB9KSksXG4gICAgcmVjZW50QmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgICBhZGRyZXNzVGFibGVMb29rdXBzOiBvcHRpb25hbChhcnJheShBZGRyZXNzVGFibGVMb29rdXBTdHJ1Y3QpKVxuICB9KVxufSk7XG5jb25zdCBBbm5vdGF0ZWRBY2NvdW50S2V5ID0gdHlwZSh7XG4gIHB1YmtleTogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgc2lnbmVyOiBib29sZWFuKCksXG4gIHdyaXRhYmxlOiBib29sZWFuKCksXG4gIHNvdXJjZTogb3B0aW9uYWwodW5pb24oW2xpdGVyYWwoJ3RyYW5zYWN0aW9uJyksIGxpdGVyYWwoJ2xvb2t1cFRhYmxlJyldKSlcbn0pO1xuY29uc3QgQ29uZmlybWVkVHJhbnNhY3Rpb25BY2NvdW50c01vZGVSZXN1bHQgPSB0eXBlKHtcbiAgYWNjb3VudEtleXM6IGFycmF5KEFubm90YXRlZEFjY291bnRLZXkpLFxuICBzaWduYXR1cmVzOiBhcnJheShzdHJpbmcoKSlcbn0pO1xuY29uc3QgUGFyc2VkSW5zdHJ1Y3Rpb25SZXN1bHQgPSB0eXBlKHtcbiAgcGFyc2VkOiB1bmtub3duKCksXG4gIHByb2dyYW06IHN0cmluZygpLFxuICBwcm9ncmFtSWQ6IFB1YmxpY0tleUZyb21TdHJpbmdcbn0pO1xuY29uc3QgUmF3SW5zdHJ1Y3Rpb25SZXN1bHQgPSB0eXBlKHtcbiAgYWNjb3VudHM6IGFycmF5KFB1YmxpY0tleUZyb21TdHJpbmcpLFxuICBkYXRhOiBzdHJpbmcoKSxcbiAgcHJvZ3JhbUlkOiBQdWJsaWNLZXlGcm9tU3RyaW5nXG59KTtcbmNvbnN0IEluc3RydWN0aW9uUmVzdWx0ID0gdW5pb24oW1Jhd0luc3RydWN0aW9uUmVzdWx0LCBQYXJzZWRJbnN0cnVjdGlvblJlc3VsdF0pO1xuY29uc3QgVW5rbm93bkluc3RydWN0aW9uUmVzdWx0ID0gdW5pb24oW3R5cGUoe1xuICBwYXJzZWQ6IHVua25vd24oKSxcbiAgcHJvZ3JhbTogc3RyaW5nKCksXG4gIHByb2dyYW1JZDogc3RyaW5nKClcbn0pLCB0eXBlKHtcbiAgYWNjb3VudHM6IGFycmF5KHN0cmluZygpKSxcbiAgZGF0YTogc3RyaW5nKCksXG4gIHByb2dyYW1JZDogc3RyaW5nKClcbn0pXSk7XG5jb25zdCBQYXJzZWRPclJhd0luc3RydWN0aW9uID0gY29lcmNlKEluc3RydWN0aW9uUmVzdWx0LCBVbmtub3duSW5zdHJ1Y3Rpb25SZXN1bHQsIHZhbHVlID0+IHtcbiAgaWYgKCdhY2NvdW50cycgaW4gdmFsdWUpIHtcbiAgICByZXR1cm4gY3JlYXRlKHZhbHVlLCBSYXdJbnN0cnVjdGlvblJlc3VsdCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNyZWF0ZSh2YWx1ZSwgUGFyc2VkSW5zdHJ1Y3Rpb25SZXN1bHQpO1xuICB9XG59KTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgUGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb25SZXN1bHQgPSB0eXBlKHtcbiAgc2lnbmF0dXJlczogYXJyYXkoc3RyaW5nKCkpLFxuICBtZXNzYWdlOiB0eXBlKHtcbiAgICBhY2NvdW50S2V5czogYXJyYXkoQW5ub3RhdGVkQWNjb3VudEtleSksXG4gICAgaW5zdHJ1Y3Rpb25zOiBhcnJheShQYXJzZWRPclJhd0luc3RydWN0aW9uKSxcbiAgICByZWNlbnRCbG9ja2hhc2g6IHN0cmluZygpLFxuICAgIGFkZHJlc3NUYWJsZUxvb2t1cHM6IG9wdGlvbmFsKG51bGxhYmxlKGFycmF5KEFkZHJlc3NUYWJsZUxvb2t1cFN0cnVjdCkpKVxuICB9KVxufSk7XG5jb25zdCBUb2tlbkJhbGFuY2VSZXN1bHQgPSB0eXBlKHtcbiAgYWNjb3VudEluZGV4OiBudW1iZXIoKSxcbiAgbWludDogc3RyaW5nKCksXG4gIG93bmVyOiBvcHRpb25hbChzdHJpbmcoKSksXG4gIHByb2dyYW1JZDogb3B0aW9uYWwoc3RyaW5nKCkpLFxuICB1aVRva2VuQW1vdW50OiBUb2tlbkFtb3VudFJlc3VsdFxufSk7XG5jb25zdCBMb2FkZWRBZGRyZXNzZXNSZXN1bHQgPSB0eXBlKHtcbiAgd3JpdGFibGU6IGFycmF5KFB1YmxpY0tleUZyb21TdHJpbmcpLFxuICByZWFkb25seTogYXJyYXkoUHVibGljS2V5RnJvbVN0cmluZylcbn0pO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQgPSB0eXBlKHtcbiAgZXJyOiBUcmFuc2FjdGlvbkVycm9yUmVzdWx0LFxuICBmZWU6IG51bWJlcigpLFxuICBpbm5lckluc3RydWN0aW9uczogb3B0aW9uYWwobnVsbGFibGUoYXJyYXkodHlwZSh7XG4gICAgaW5kZXg6IG51bWJlcigpLFxuICAgIGluc3RydWN0aW9uczogYXJyYXkodHlwZSh7XG4gICAgICBhY2NvdW50czogYXJyYXkobnVtYmVyKCkpLFxuICAgICAgZGF0YTogc3RyaW5nKCksXG4gICAgICBwcm9ncmFtSWRJbmRleDogbnVtYmVyKClcbiAgICB9KSlcbiAgfSkpKSksXG4gIHByZUJhbGFuY2VzOiBhcnJheShudW1iZXIoKSksXG4gIHBvc3RCYWxhbmNlczogYXJyYXkobnVtYmVyKCkpLFxuICBsb2dNZXNzYWdlczogb3B0aW9uYWwobnVsbGFibGUoYXJyYXkoc3RyaW5nKCkpKSksXG4gIHByZVRva2VuQmFsYW5jZXM6IG9wdGlvbmFsKG51bGxhYmxlKGFycmF5KFRva2VuQmFsYW5jZVJlc3VsdCkpKSxcbiAgcG9zdFRva2VuQmFsYW5jZXM6IG9wdGlvbmFsKG51bGxhYmxlKGFycmF5KFRva2VuQmFsYW5jZVJlc3VsdCkpKSxcbiAgbG9hZGVkQWRkcmVzc2VzOiBvcHRpb25hbChMb2FkZWRBZGRyZXNzZXNSZXN1bHQpLFxuICBjb21wdXRlVW5pdHNDb25zdW1lZDogb3B0aW9uYWwobnVtYmVyKCkpLFxuICBjb3N0VW5pdHM6IG9wdGlvbmFsKG51bWJlcigpKVxufSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9uTWV0YVJlc3VsdCA9IHR5cGUoe1xuICBlcnI6IFRyYW5zYWN0aW9uRXJyb3JSZXN1bHQsXG4gIGZlZTogbnVtYmVyKCksXG4gIGlubmVySW5zdHJ1Y3Rpb25zOiBvcHRpb25hbChudWxsYWJsZShhcnJheSh0eXBlKHtcbiAgICBpbmRleDogbnVtYmVyKCksXG4gICAgaW5zdHJ1Y3Rpb25zOiBhcnJheShQYXJzZWRPclJhd0luc3RydWN0aW9uKVxuICB9KSkpKSxcbiAgcHJlQmFsYW5jZXM6IGFycmF5KG51bWJlcigpKSxcbiAgcG9zdEJhbGFuY2VzOiBhcnJheShudW1iZXIoKSksXG4gIGxvZ01lc3NhZ2VzOiBvcHRpb25hbChudWxsYWJsZShhcnJheShzdHJpbmcoKSkpKSxcbiAgcHJlVG9rZW5CYWxhbmNlczogb3B0aW9uYWwobnVsbGFibGUoYXJyYXkoVG9rZW5CYWxhbmNlUmVzdWx0KSkpLFxuICBwb3N0VG9rZW5CYWxhbmNlczogb3B0aW9uYWwobnVsbGFibGUoYXJyYXkoVG9rZW5CYWxhbmNlUmVzdWx0KSkpLFxuICBsb2FkZWRBZGRyZXNzZXM6IG9wdGlvbmFsKExvYWRlZEFkZHJlc3Nlc1Jlc3VsdCksXG4gIGNvbXB1dGVVbml0c0NvbnN1bWVkOiBvcHRpb25hbChudW1iZXIoKSksXG4gIGNvc3RVbml0czogb3B0aW9uYWwobnVtYmVyKCkpXG59KTtcbmNvbnN0IFRyYW5zYWN0aW9uVmVyc2lvblN0cnVjdCA9IHVuaW9uKFtsaXRlcmFsKDApLCBsaXRlcmFsKCdsZWdhY3knKV0pO1xuXG4vKiogQGludGVybmFsICovXG5jb25zdCBSZXdhcmRzUmVzdWx0ID0gdHlwZSh7XG4gIHB1YmtleTogc3RyaW5nKCksXG4gIGxhbXBvcnRzOiBudW1iZXIoKSxcbiAgcG9zdEJhbGFuY2U6IG51bGxhYmxlKG51bWJlcigpKSxcbiAgcmV3YXJkVHlwZTogbnVsbGFibGUoc3RyaW5nKCkpLFxuICBjb21taXNzaW9uOiBvcHRpb25hbChudWxsYWJsZShudW1iZXIoKSkpXG59KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0QmxvY2tcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldEJsb2NrUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChudWxsYWJsZSh0eXBlKHtcbiAgYmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgcHJldmlvdXNCbG9ja2hhc2g6IHN0cmluZygpLFxuICBwYXJlbnRTbG90OiBudW1iZXIoKSxcbiAgdHJhbnNhY3Rpb25zOiBhcnJheSh0eXBlKHtcbiAgICB0cmFuc2FjdGlvbjogQ29uZmlybWVkVHJhbnNhY3Rpb25SZXN1bHQsXG4gICAgbWV0YTogbnVsbGFibGUoQ29uZmlybWVkVHJhbnNhY3Rpb25NZXRhUmVzdWx0KSxcbiAgICB2ZXJzaW9uOiBvcHRpb25hbChUcmFuc2FjdGlvblZlcnNpb25TdHJ1Y3QpXG4gIH0pKSxcbiAgcmV3YXJkczogb3B0aW9uYWwoYXJyYXkoUmV3YXJkc1Jlc3VsdCkpLFxuICBibG9ja1RpbWU6IG51bGxhYmxlKG51bWJlcigpKSxcbiAgYmxvY2tIZWlnaHQ6IG51bGxhYmxlKG51bWJlcigpKVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0QmxvY2tcIiBtZXNzYWdlIHdoZW4gYHRyYW5zYWN0aW9uRGV0YWlsc2AgaXMgYG5vbmVgXG4gKi9cbmNvbnN0IEdldE5vbmVNb2RlQmxvY2tScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KG51bGxhYmxlKHR5cGUoe1xuICBibG9ja2hhc2g6IHN0cmluZygpLFxuICBwcmV2aW91c0Jsb2NraGFzaDogc3RyaW5nKCksXG4gIHBhcmVudFNsb3Q6IG51bWJlcigpLFxuICByZXdhcmRzOiBvcHRpb25hbChhcnJheShSZXdhcmRzUmVzdWx0KSksXG4gIGJsb2NrVGltZTogbnVsbGFibGUobnVtYmVyKCkpLFxuICBibG9ja0hlaWdodDogbnVsbGFibGUobnVtYmVyKCkpXG59KSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRCbG9ja1wiIG1lc3NhZ2Ugd2hlbiBgdHJhbnNhY3Rpb25EZXRhaWxzYCBpcyBgYWNjb3VudHNgXG4gKi9cbmNvbnN0IEdldEFjY291bnRzTW9kZUJsb2NrUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChudWxsYWJsZSh0eXBlKHtcbiAgYmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgcHJldmlvdXNCbG9ja2hhc2g6IHN0cmluZygpLFxuICBwYXJlbnRTbG90OiBudW1iZXIoKSxcbiAgdHJhbnNhY3Rpb25zOiBhcnJheSh0eXBlKHtcbiAgICB0cmFuc2FjdGlvbjogQ29uZmlybWVkVHJhbnNhY3Rpb25BY2NvdW50c01vZGVSZXN1bHQsXG4gICAgbWV0YTogbnVsbGFibGUoQ29uZmlybWVkVHJhbnNhY3Rpb25NZXRhUmVzdWx0KSxcbiAgICB2ZXJzaW9uOiBvcHRpb25hbChUcmFuc2FjdGlvblZlcnNpb25TdHJ1Y3QpXG4gIH0pKSxcbiAgcmV3YXJkczogb3B0aW9uYWwoYXJyYXkoUmV3YXJkc1Jlc3VsdCkpLFxuICBibG9ja1RpbWU6IG51bGxhYmxlKG51bWJlcigpKSxcbiAgYmxvY2tIZWlnaHQ6IG51bGxhYmxlKG51bWJlcigpKVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBwYXJzZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEJsb2NrXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRQYXJzZWRCbG9ja1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQobnVsbGFibGUodHlwZSh7XG4gIGJsb2NraGFzaDogc3RyaW5nKCksXG4gIHByZXZpb3VzQmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgcGFyZW50U2xvdDogbnVtYmVyKCksXG4gIHRyYW5zYWN0aW9uczogYXJyYXkodHlwZSh7XG4gICAgdHJhbnNhY3Rpb246IFBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9uUmVzdWx0LFxuICAgIG1ldGE6IG51bGxhYmxlKFBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9uTWV0YVJlc3VsdCksXG4gICAgdmVyc2lvbjogb3B0aW9uYWwoVHJhbnNhY3Rpb25WZXJzaW9uU3RydWN0KVxuICB9KSksXG4gIHJld2FyZHM6IG9wdGlvbmFsKGFycmF5KFJld2FyZHNSZXN1bHQpKSxcbiAgYmxvY2tUaW1lOiBudWxsYWJsZShudW1iZXIoKSksXG4gIGJsb2NrSGVpZ2h0OiBudWxsYWJsZShudW1iZXIoKSlcbn0pKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgcGFyc2VkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRCbG9ja1wiIG1lc3NhZ2UgIHdoZW4gYHRyYW5zYWN0aW9uRGV0YWlsc2AgaXMgYGFjY291bnRzYFxuICovXG5jb25zdCBHZXRQYXJzZWRBY2NvdW50c01vZGVCbG9ja1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQobnVsbGFibGUodHlwZSh7XG4gIGJsb2NraGFzaDogc3RyaW5nKCksXG4gIHByZXZpb3VzQmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgcGFyZW50U2xvdDogbnVtYmVyKCksXG4gIHRyYW5zYWN0aW9uczogYXJyYXkodHlwZSh7XG4gICAgdHJhbnNhY3Rpb246IENvbmZpcm1lZFRyYW5zYWN0aW9uQWNjb3VudHNNb2RlUmVzdWx0LFxuICAgIG1ldGE6IG51bGxhYmxlKFBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9uTWV0YVJlc3VsdCksXG4gICAgdmVyc2lvbjogb3B0aW9uYWwoVHJhbnNhY3Rpb25WZXJzaW9uU3RydWN0KVxuICB9KSksXG4gIHJld2FyZHM6IG9wdGlvbmFsKGFycmF5KFJld2FyZHNSZXN1bHQpKSxcbiAgYmxvY2tUaW1lOiBudWxsYWJsZShudW1iZXIoKSksXG4gIGJsb2NrSGVpZ2h0OiBudWxsYWJsZShudW1iZXIoKSlcbn0pKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgcGFyc2VkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRCbG9ja1wiIG1lc3NhZ2UgIHdoZW4gYHRyYW5zYWN0aW9uRGV0YWlsc2AgaXMgYG5vbmVgXG4gKi9cbmNvbnN0IEdldFBhcnNlZE5vbmVNb2RlQmxvY2tScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KG51bGxhYmxlKHR5cGUoe1xuICBibG9ja2hhc2g6IHN0cmluZygpLFxuICBwcmV2aW91c0Jsb2NraGFzaDogc3RyaW5nKCksXG4gIHBhcmVudFNsb3Q6IG51bWJlcigpLFxuICByZXdhcmRzOiBvcHRpb25hbChhcnJheShSZXdhcmRzUmVzdWx0KSksXG4gIGJsb2NrVGltZTogbnVsbGFibGUobnVtYmVyKCkpLFxuICBibG9ja0hlaWdodDogbnVsbGFibGUobnVtYmVyKCkpXG59KSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRDb25maXJtZWRCbG9ja1wiIG1lc3NhZ2VcbiAqXG4gKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFJQQyB2MS44LjAuIFBsZWFzZSB1c2Uge0BsaW5rIEdldEJsb2NrUnBjUmVzdWx0fSBpbnN0ZWFkLlxuICovXG5jb25zdCBHZXRDb25maXJtZWRCbG9ja1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQobnVsbGFibGUodHlwZSh7XG4gIGJsb2NraGFzaDogc3RyaW5nKCksXG4gIHByZXZpb3VzQmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgcGFyZW50U2xvdDogbnVtYmVyKCksXG4gIHRyYW5zYWN0aW9uczogYXJyYXkodHlwZSh7XG4gICAgdHJhbnNhY3Rpb246IENvbmZpcm1lZFRyYW5zYWN0aW9uUmVzdWx0LFxuICAgIG1ldGE6IG51bGxhYmxlKENvbmZpcm1lZFRyYW5zYWN0aW9uTWV0YVJlc3VsdClcbiAgfSkpLFxuICByZXdhcmRzOiBvcHRpb25hbChhcnJheShSZXdhcmRzUmVzdWx0KSksXG4gIGJsb2NrVGltZTogbnVsbGFibGUobnVtYmVyKCkpXG59KSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRCbG9ja1wiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0QmxvY2tTaWduYXR1cmVzUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChudWxsYWJsZSh0eXBlKHtcbiAgYmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgcHJldmlvdXNCbG9ja2hhc2g6IHN0cmluZygpLFxuICBwYXJlbnRTbG90OiBudW1iZXIoKSxcbiAgc2lnbmF0dXJlczogYXJyYXkoc3RyaW5nKCkpLFxuICBibG9ja1RpbWU6IG51bGxhYmxlKG51bWJlcigpKVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0VHJhbnNhY3Rpb25cIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldFRyYW5zYWN0aW9uUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChudWxsYWJsZSh0eXBlKHtcbiAgc2xvdDogbnVtYmVyKCksXG4gIG1ldGE6IG51bGxhYmxlKENvbmZpcm1lZFRyYW5zYWN0aW9uTWV0YVJlc3VsdCksXG4gIGJsb2NrVGltZTogb3B0aW9uYWwobnVsbGFibGUobnVtYmVyKCkpKSxcbiAgdHJhbnNhY3Rpb246IENvbmZpcm1lZFRyYW5zYWN0aW9uUmVzdWx0LFxuICB2ZXJzaW9uOiBvcHRpb25hbChUcmFuc2FjdGlvblZlcnNpb25TdHJ1Y3QpXG59KSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIHBhcnNlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0VHJhbnNhY3Rpb25cIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldFBhcnNlZFRyYW5zYWN0aW9uUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChudWxsYWJsZSh0eXBlKHtcbiAgc2xvdDogbnVtYmVyKCksXG4gIHRyYW5zYWN0aW9uOiBQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvblJlc3VsdCxcbiAgbWV0YTogbnVsbGFibGUoUGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb25NZXRhUmVzdWx0KSxcbiAgYmxvY2tUaW1lOiBvcHRpb25hbChudWxsYWJsZShudW1iZXIoKSkpLFxuICB2ZXJzaW9uOiBvcHRpb25hbChUcmFuc2FjdGlvblZlcnNpb25TdHJ1Y3QpXG59KSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRMYXRlc3RCbG9ja2hhc2hcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldExhdGVzdEJsb2NraGFzaFJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KHR5cGUoe1xuICBibG9ja2hhc2g6IHN0cmluZygpLFxuICBsYXN0VmFsaWRCbG9ja0hlaWdodDogbnVtYmVyKClcbn0pKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiaXNCbG9ja2hhc2hWYWxpZFwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgSXNCbG9ja2hhc2hWYWxpZFJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KGJvb2xlYW4oKSk7XG5jb25zdCBQZXJmU2FtcGxlUmVzdWx0ID0gdHlwZSh7XG4gIHNsb3Q6IG51bWJlcigpLFxuICBudW1UcmFuc2FjdGlvbnM6IG51bWJlcigpLFxuICBudW1TbG90czogbnVtYmVyKCksXG4gIHNhbXBsZVBlcmlvZFNlY3M6IG51bWJlcigpXG59KTtcblxuLypcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciBcImdldFJlY2VudFBlcmZvcm1hbmNlU2FtcGxlc1wiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0UmVjZW50UGVyZm9ybWFuY2VTYW1wbGVzUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChhcnJheShQZXJmU2FtcGxlUmVzdWx0KSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEZlZUNhbGN1bGF0b3JGb3JCbG9ja2hhc2hcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldEZlZUNhbGN1bGF0b3JScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChudWxsYWJsZSh0eXBlKHtcbiAgZmVlQ2FsY3VsYXRvcjogdHlwZSh7XG4gICAgbGFtcG9ydHNQZXJTaWduYXR1cmU6IG51bWJlcigpXG4gIH0pXG59KSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJyZXF1ZXN0QWlyZHJvcFwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgUmVxdWVzdEFpcmRyb3BScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KHN0cmluZygpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwic2VuZFRyYW5zYWN0aW9uXCIgbWVzc2FnZVxuICovXG5jb25zdCBTZW5kVHJhbnNhY3Rpb25ScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KHN0cmluZygpKTtcblxuLyoqXG4gKiBJbmZvcm1hdGlvbiBhYm91dCB0aGUgbGF0ZXN0IHNsb3QgYmVpbmcgcHJvY2Vzc2VkIGJ5IGEgbm9kZVxuICovXG5cbi8qKlxuICogUGFyc2VkIGFjY291bnQgZGF0YVxuICovXG5cbi8qKlxuICogU3Rha2UgQWN0aXZhdGlvbiBkYXRhXG4gKi9cblxuLyoqXG4gKiBEYXRhIHNsaWNlIGFyZ3VtZW50IGZvciBnZXRQcm9ncmFtQWNjb3VudHNcbiAqL1xuXG4vKipcbiAqIE1lbW9yeSBjb21wYXJpc29uIGZpbHRlciBmb3IgZ2V0UHJvZ3JhbUFjY291bnRzXG4gKi9cblxuLyoqXG4gKiBEYXRhIHNpemUgY29tcGFyaXNvbiBmaWx0ZXIgZm9yIGdldFByb2dyYW1BY2NvdW50c1xuICovXG5cbi8qKlxuICogQSBmaWx0ZXIgb2JqZWN0IGZvciBnZXRQcm9ncmFtQWNjb3VudHNcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBnZXRQcm9ncmFtQWNjb3VudHMgcmVxdWVzdHNcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBnZXRQYXJzZWRQcm9ncmFtQWNjb3VudHNcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBnZXRNdWx0aXBsZUFjY291bnRzXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgYGdldFN0YWtlQWN0aXZhdGlvbmBcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBgZ2V0U3Rha2VBY3RpdmF0aW9uYFxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGBnZXRTdGFrZUFjdGl2YXRpb25gXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgYGdldE5vbmNlYFxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGBnZXROb25jZUFuZENvbnRleHRgXG4gKi9cblxuLyoqXG4gKiBJbmZvcm1hdGlvbiBkZXNjcmliaW5nIGFuIGFjY291bnRcbiAqL1xuXG4vKipcbiAqIEFjY291bnQgaW5mb3JtYXRpb24gaWRlbnRpZmllZCBieSBwdWJrZXlcbiAqL1xuXG4vKipcbiAqIENhbGxiYWNrIGZ1bmN0aW9uIGZvciBhY2NvdW50IGNoYW5nZSBub3RpZmljYXRpb25zXG4gKi9cblxuLyoqXG4gKiBDYWxsYmFjayBmdW5jdGlvbiBmb3IgcHJvZ3JhbSBhY2NvdW50IGNoYW5nZSBub3RpZmljYXRpb25zXG4gKi9cblxuLyoqXG4gKiBDYWxsYmFjayBmdW5jdGlvbiBmb3Igc2xvdCBjaGFuZ2Ugbm90aWZpY2F0aW9uc1xuICovXG5cbi8qKlxuICogQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIHNsb3QgdXBkYXRlIG5vdGlmaWNhdGlvbnNcbiAqL1xuXG4vKipcbiAqIENhbGxiYWNrIGZ1bmN0aW9uIGZvciBzaWduYXR1cmUgc3RhdHVzIG5vdGlmaWNhdGlvbnNcbiAqL1xuXG4vKipcbiAqIFNpZ25hdHVyZSBzdGF0dXMgbm90aWZpY2F0aW9uIHdpdGggdHJhbnNhY3Rpb24gcmVzdWx0XG4gKi9cblxuLyoqXG4gKiBTaWduYXR1cmUgcmVjZWl2ZWQgbm90aWZpY2F0aW9uXG4gKi9cblxuLyoqXG4gKiBDYWxsYmFjayBmdW5jdGlvbiBmb3Igc2lnbmF0dXJlIG5vdGlmaWNhdGlvbnNcbiAqL1xuXG4vKipcbiAqIFNpZ25hdHVyZSBzdWJzY3JpcHRpb24gb3B0aW9uc1xuICovXG5cbi8qKlxuICogQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIHJvb3QgY2hhbmdlIG5vdGlmaWNhdGlvbnNcbiAqL1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBMb2dzUmVzdWx0ID0gdHlwZSh7XG4gIGVycjogVHJhbnNhY3Rpb25FcnJvclJlc3VsdCxcbiAgbG9nczogYXJyYXkoc3RyaW5nKCkpLFxuICBzaWduYXR1cmU6IHN0cmluZygpXG59KTtcblxuLyoqXG4gKiBMb2dzIHJlc3VsdC5cbiAqL1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJsb2dzTm90aWZpY2F0aW9uXCIgbWVzc2FnZS5cbiAqL1xuY29uc3QgTG9nc05vdGlmaWNhdGlvblJlc3VsdCA9IHR5cGUoe1xuICByZXN1bHQ6IG5vdGlmaWNhdGlvblJlc3VsdEFuZENvbnRleHQoTG9nc1Jlc3VsdCksXG4gIHN1YnNjcmlwdGlvbjogbnVtYmVyKClcbn0pO1xuXG4vKipcbiAqIEZpbHRlciBmb3IgbG9nIHN1YnNjcmlwdGlvbnMuXG4gKi9cblxuLyoqXG4gKiBDYWxsYmFjayBmdW5jdGlvbiBmb3IgbG9nIG5vdGlmaWNhdGlvbnMuXG4gKi9cblxuLyoqXG4gKiBTaWduYXR1cmUgcmVzdWx0XG4gKi9cblxuLyoqXG4gKiBUcmFuc2FjdGlvbiBlcnJvclxuICovXG5cbi8qKlxuICogVHJhbnNhY3Rpb24gY29uZmlybWF0aW9uIHN0YXR1c1xuICogPHByZT5cbiAqICAgJ3Byb2Nlc3NlZCc6IFRyYW5zYWN0aW9uIGxhbmRlZCBpbiBhIGJsb2NrIHdoaWNoIGhhcyByZWFjaGVkIDEgY29uZmlybWF0aW9uIGJ5IHRoZSBjb25uZWN0ZWQgbm9kZVxuICogICAnY29uZmlybWVkJzogVHJhbnNhY3Rpb24gbGFuZGVkIGluIGEgYmxvY2sgd2hpY2ggaGFzIHJlYWNoZWQgMSBjb25maXJtYXRpb24gYnkgdGhlIGNsdXN0ZXJcbiAqICAgJ2ZpbmFsaXplZCc6IFRyYW5zYWN0aW9uIGxhbmRlZCBpbiBhIGJsb2NrIHdoaWNoIGhhcyBiZWVuIGZpbmFsaXplZCBieSB0aGUgY2x1c3RlclxuICogPC9wcmU+XG4gKi9cblxuLyoqXG4gKiBTaWduYXR1cmUgc3RhdHVzXG4gKi9cblxuLyoqXG4gKiBBIGNvbmZpcm1lZCBzaWduYXR1cmUgd2l0aCBpdHMgc3RhdHVzXG4gKi9cblxuLyoqXG4gKiBBbiBvYmplY3QgZGVmaW5pbmcgaGVhZGVycyB0byBiZSBwYXNzZWQgdG8gdGhlIFJQQyBzZXJ2ZXJcbiAqL1xuXG4vKipcbiAqIFRoZSB0eXBlIG9mIHRoZSBKYXZhU2NyaXB0IGBmZXRjaCgpYCBBUElcbiAqL1xuXG4vKipcbiAqIEEgY2FsbGJhY2sgdXNlZCB0byBhdWdtZW50IHRoZSBvdXRnb2luZyBIVFRQIHJlcXVlc3RcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gZm9yIGluc3RhbnRpYXRpbmcgYSBDb25uZWN0aW9uXG4gKi9cblxuLyoqIEBpbnRlcm5hbCAqL1xuY29uc3QgQ09NTU9OX0hUVFBfSEVBREVSUyA9IHtcbiAgJ3NvbGFuYS1jbGllbnQnOiBganMvJHtcIjEuMC4wLW1haW50ZW5hbmNlXCJ9YFxufTtcblxuLyoqXG4gKiBBIGNvbm5lY3Rpb24gdG8gYSBmdWxsbm9kZSBKU09OIFJQQyBlbmRwb2ludFxuICovXG5jbGFzcyBDb25uZWN0aW9uIHtcbiAgLyoqXG4gICAqIEVzdGFibGlzaCBhIEpTT04gUlBDIGNvbm5lY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIGVuZHBvaW50IFVSTCB0byB0aGUgZnVsbG5vZGUgSlNPTiBSUEMgZW5kcG9pbnRcbiAgICogQHBhcmFtIGNvbW1pdG1lbnRPckNvbmZpZyBvcHRpb25hbCBkZWZhdWx0IGNvbW1pdG1lbnQgbGV2ZWwgb3Igb3B0aW9uYWwgQ29ubmVjdGlvbkNvbmZpZyBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgKi9cbiAgY29uc3RydWN0b3IoZW5kcG9pbnQsIF9jb21taXRtZW50T3JDb25maWcpIHtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fY29tbWl0bWVudCA9IHZvaWQgMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fY29uZmlybVRyYW5zYWN0aW9uSW5pdGlhbFRpbWVvdXQgPSB2b2lkIDA7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3JwY0VuZHBvaW50ID0gdm9pZCAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9ycGNXc0VuZHBvaW50ID0gdm9pZCAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9ycGNDbGllbnQgPSB2b2lkIDA7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3JwY1JlcXVlc3QgPSB2b2lkIDA7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3JwY0JhdGNoUmVxdWVzdCA9IHZvaWQgMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcnBjV2ViU29ja2V0ID0gdm9pZCAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9ycGNXZWJTb2NrZXRDb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcnBjV2ViU29ja2V0SGVhcnRiZWF0ID0gbnVsbDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcnBjV2ViU29ja2V0SWRsZVRpbWVvdXQgPSBudWxsO1xuICAgIC8qKiBAaW50ZXJuYWxcbiAgICAgKiBBIG51bWJlciB0aGF0IHdlIGluY3JlbWVudCBldmVyeSB0aW1lIGFuIGFjdGl2ZSBjb25uZWN0aW9uIGNsb3Nlcy5cbiAgICAgKiBVc2VkIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZSBzYW1lIHNvY2tldCBjb25uZWN0aW9uIHRoYXQgd2FzIG9wZW5cbiAgICAgKiB3aGVuIGFuIGFzeW5jIG9wZXJhdGlvbiBzdGFydGVkIGlzIHRoZSBzYW1lIG9uZSB0aGF0J3MgYWN0aXZlIHdoZW5cbiAgICAgKiBpdHMgY29udGludWF0aW9uIGZpcmVzLlxuICAgICAqXG4gICAgICovXG4gICAgdGhpcy5fcnBjV2ViU29ja2V0R2VuZXJhdGlvbiA9IDA7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX2Rpc2FibGVCbG9ja2hhc2hDYWNoaW5nID0gZmFsc2U7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3BvbGxpbmdCbG9ja2hhc2ggPSBmYWxzZTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fYmxvY2toYXNoSW5mbyA9IHtcbiAgICAgIGxhdGVzdEJsb2NraGFzaDogbnVsbCxcbiAgICAgIGxhc3RGZXRjaDogMCxcbiAgICAgIHRyYW5zYWN0aW9uU2lnbmF0dXJlczogW10sXG4gICAgICBzaW11bGF0ZWRTaWduYXR1cmVzOiBbXVxuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX25leHRDbGllbnRTdWJzY3JpcHRpb25JZCA9IDA7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbkRpc3Bvc2VGdW5jdGlvbnNCeUNsaWVudFN1YnNjcmlwdGlvbklkID0ge307XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbkhhc2hCeUNsaWVudFN1YnNjcmlwdGlvbklkID0ge307XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvblN0YXRlQ2hhbmdlQ2FsbGJhY2tzQnlIYXNoID0ge307XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbkNhbGxiYWNrc0J5U2VydmVyU3Vic2NyaXB0aW9uSWQgPSB7fTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uc0J5SGFzaCA9IHt9O1xuICAgIC8qKlxuICAgICAqIFNwZWNpYWwgY2FzZS5cbiAgICAgKiBBZnRlciBhIHNpZ25hdHVyZSBpcyBwcm9jZXNzZWQsIFJQQ3MgYXV0b21hdGljYWxseSBkaXNwb3NlIG9mIHRoZVxuICAgICAqIHN1YnNjcmlwdGlvbiBvbiB0aGUgc2VydmVyIHNpZGUuIFdlIG5lZWQgdG8gdHJhY2sgd2hpY2ggb2YgdGhlc2VcbiAgICAgKiBzdWJzY3JpcHRpb25zIGhhdmUgYmVlbiBkaXNwb3NlZCBpbiBzdWNoIGEgd2F5LCBzbyB0aGF0IHdlIGtub3dcbiAgICAgKiB3aGV0aGVyIHRoZSBjbGllbnQgaXMgZGVhbGluZyB3aXRoIGEgbm90LXlldC1wcm9jZXNzZWQgc2lnbmF0dXJlXG4gICAgICogKGluIHdoaWNoIGNhc2Ugd2UgbXVzdCB0ZWFyIGRvd24gdGhlIHNlcnZlciBzdWJzY3JpcHRpb24pIG9yIGFuXG4gICAgICogYWxyZWFkeS1wcm9jZXNzZWQgc2lnbmF0dXJlIChpbiB3aGljaCBjYXNlIHRoZSBjbGllbnQgY2FuIHNpbXBseVxuICAgICAqIGNsZWFyIG91dCB0aGUgc3Vic2NyaXB0aW9uIGxvY2FsbHkgd2l0aG91dCB0ZWxsaW5nIHRoZSBzZXJ2ZXIpLlxuICAgICAqXG4gICAgICogTk9URTogVGhlcmUgaXMgYSBwcm9wb3NhbCB0byBlbGltaW5hdGUgdGhpcyBzcGVjaWFsIGNhc2UsIGhlcmU6XG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL3NvbGFuYS1sYWJzL3NvbGFuYS9pc3N1ZXMvMTg4OTJcbiAgICAgKi9cbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uc0F1dG9EaXNwb3NlZEJ5UnBjID0gbmV3IFNldCgpO1xuICAgIC8qXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBibG9jayBoZWlnaHQgb2YgdGhlIG5vZGVcbiAgICAgKi9cbiAgICB0aGlzLmdldEJsb2NrSGVpZ2h0ID0gKCgpID0+IHtcbiAgICAgIGNvbnN0IHJlcXVlc3RQcm9taXNlcyA9IHt9O1xuICAgICAgcmV0dXJuIGFzeW5jIGNvbW1pdG1lbnRPckNvbmZpZyA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBjb21taXRtZW50LFxuICAgICAgICAgIGNvbmZpZ1xuICAgICAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW10sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywgY29uZmlnKTtcbiAgICAgICAgY29uc3QgcmVxdWVzdEhhc2ggPSBmYXN0U3RhYmxlU3RyaW5naWZ5KGFyZ3MpO1xuICAgICAgICByZXF1ZXN0UHJvbWlzZXNbcmVxdWVzdEhhc2hdID0gcmVxdWVzdFByb21pc2VzW3JlcXVlc3RIYXNoXSA/PyAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRCbG9ja0hlaWdodCcsIGFyZ3MpO1xuICAgICAgICAgICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChudW1iZXIoKSkpO1xuICAgICAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBibG9jayBoZWlnaHQgaW5mb3JtYXRpb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXMucmVzdWx0O1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBkZWxldGUgcmVxdWVzdFByb21pc2VzW3JlcXVlc3RIYXNoXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCByZXF1ZXN0UHJvbWlzZXNbcmVxdWVzdEhhc2hdO1xuICAgICAgfTtcbiAgICB9KSgpO1xuICAgIGxldCB3c0VuZHBvaW50O1xuICAgIGxldCBodHRwSGVhZGVycztcbiAgICBsZXQgZmV0Y2g7XG4gICAgbGV0IGZldGNoTWlkZGxld2FyZTtcbiAgICBsZXQgZGlzYWJsZVJldHJ5T25SYXRlTGltaXQ7XG4gICAgbGV0IGh0dHBBZ2VudDtcbiAgICBpZiAoX2NvbW1pdG1lbnRPckNvbmZpZyAmJiB0eXBlb2YgX2NvbW1pdG1lbnRPckNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuX2NvbW1pdG1lbnQgPSBfY29tbWl0bWVudE9yQ29uZmlnO1xuICAgIH0gZWxzZSBpZiAoX2NvbW1pdG1lbnRPckNvbmZpZykge1xuICAgICAgdGhpcy5fY29tbWl0bWVudCA9IF9jb21taXRtZW50T3JDb25maWcuY29tbWl0bWVudDtcbiAgICAgIHRoaXMuX2NvbmZpcm1UcmFuc2FjdGlvbkluaXRpYWxUaW1lb3V0ID0gX2NvbW1pdG1lbnRPckNvbmZpZy5jb25maXJtVHJhbnNhY3Rpb25Jbml0aWFsVGltZW91dDtcbiAgICAgIHdzRW5kcG9pbnQgPSBfY29tbWl0bWVudE9yQ29uZmlnLndzRW5kcG9pbnQ7XG4gICAgICBodHRwSGVhZGVycyA9IF9jb21taXRtZW50T3JDb25maWcuaHR0cEhlYWRlcnM7XG4gICAgICBmZXRjaCA9IF9jb21taXRtZW50T3JDb25maWcuZmV0Y2g7XG4gICAgICBmZXRjaE1pZGRsZXdhcmUgPSBfY29tbWl0bWVudE9yQ29uZmlnLmZldGNoTWlkZGxld2FyZTtcbiAgICAgIGRpc2FibGVSZXRyeU9uUmF0ZUxpbWl0ID0gX2NvbW1pdG1lbnRPckNvbmZpZy5kaXNhYmxlUmV0cnlPblJhdGVMaW1pdDtcbiAgICAgIGh0dHBBZ2VudCA9IF9jb21taXRtZW50T3JDb25maWcuaHR0cEFnZW50O1xuICAgIH1cbiAgICB0aGlzLl9ycGNFbmRwb2ludCA9IGFzc2VydEVuZHBvaW50VXJsKGVuZHBvaW50KTtcbiAgICB0aGlzLl9ycGNXc0VuZHBvaW50ID0gd3NFbmRwb2ludCB8fCBtYWtlV2Vic29ja2V0VXJsKGVuZHBvaW50KTtcbiAgICB0aGlzLl9ycGNDbGllbnQgPSBjcmVhdGVScGNDbGllbnQoZW5kcG9pbnQsIGh0dHBIZWFkZXJzLCBmZXRjaCwgZmV0Y2hNaWRkbGV3YXJlLCBkaXNhYmxlUmV0cnlPblJhdGVMaW1pdCwgaHR0cEFnZW50KTtcbiAgICB0aGlzLl9ycGNSZXF1ZXN0ID0gY3JlYXRlUnBjUmVxdWVzdCh0aGlzLl9ycGNDbGllbnQpO1xuICAgIHRoaXMuX3JwY0JhdGNoUmVxdWVzdCA9IGNyZWF0ZVJwY0JhdGNoUmVxdWVzdCh0aGlzLl9ycGNDbGllbnQpO1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldCA9IG5ldyBScGNXZWJTb2NrZXRDbGllbnQodGhpcy5fcnBjV3NFbmRwb2ludCwge1xuICAgICAgYXV0b2Nvbm5lY3Q6IGZhbHNlLFxuICAgICAgbWF4X3JlY29ubmVjdHM6IEluZmluaXR5XG4gICAgfSk7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Lm9uKCdvcGVuJywgdGhpcy5fd3NPbk9wZW4uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Lm9uKCdlcnJvcicsIHRoaXMuX3dzT25FcnJvci5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXQub24oJ2Nsb3NlJywgdGhpcy5fd3NPbkNsb3NlLmJpbmQodGhpcykpO1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldC5vbignYWNjb3VudE5vdGlmaWNhdGlvbicsIHRoaXMuX3dzT25BY2NvdW50Tm90aWZpY2F0aW9uLmJpbmQodGhpcykpO1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldC5vbigncHJvZ3JhbU5vdGlmaWNhdGlvbicsIHRoaXMuX3dzT25Qcm9ncmFtQWNjb3VudE5vdGlmaWNhdGlvbi5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXQub24oJ3Nsb3ROb3RpZmljYXRpb24nLCB0aGlzLl93c09uU2xvdE5vdGlmaWNhdGlvbi5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXQub24oJ3Nsb3RzVXBkYXRlc05vdGlmaWNhdGlvbicsIHRoaXMuX3dzT25TbG90VXBkYXRlc05vdGlmaWNhdGlvbi5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXQub24oJ3NpZ25hdHVyZU5vdGlmaWNhdGlvbicsIHRoaXMuX3dzT25TaWduYXR1cmVOb3RpZmljYXRpb24uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Lm9uKCdyb290Tm90aWZpY2F0aW9uJywgdGhpcy5fd3NPblJvb3ROb3RpZmljYXRpb24uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Lm9uKCdsb2dzTm90aWZpY2F0aW9uJywgdGhpcy5fd3NPbkxvZ3NOb3RpZmljYXRpb24uYmluZCh0aGlzKSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgY29tbWl0bWVudCB1c2VkIGZvciByZXF1ZXN0c1xuICAgKi9cbiAgZ2V0IGNvbW1pdG1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbW1pdG1lbnQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIFJQQyBlbmRwb2ludFxuICAgKi9cbiAgZ2V0IHJwY0VuZHBvaW50KCkge1xuICAgIHJldHVybiB0aGlzLl9ycGNFbmRwb2ludDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgYmFsYW5jZSBmb3IgdGhlIHNwZWNpZmllZCBwdWJsaWMga2V5LCByZXR1cm4gd2l0aCBjb250ZXh0XG4gICAqL1xuICBhc3luYyBnZXRCYWxhbmNlQW5kQ29udGV4dChwdWJsaWNLZXksIGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3B1YmxpY0tleS50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEJhbGFuY2UnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChudW1iZXIoKSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsIGBmYWlsZWQgdG8gZ2V0IGJhbGFuY2UgZm9yICR7cHVibGljS2V5LnRvQmFzZTU4KCl9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBiYWxhbmNlIGZvciB0aGUgc3BlY2lmaWVkIHB1YmxpYyBrZXlcbiAgICovXG4gIGFzeW5jIGdldEJhbGFuY2UocHVibGljS2V5LCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRCYWxhbmNlQW5kQ29udGV4dChwdWJsaWNLZXksIGNvbW1pdG1lbnRPckNvbmZpZykudGhlbih4ID0+IHgudmFsdWUpLmNhdGNoKGUgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdmYWlsZWQgdG8gZ2V0IGJhbGFuY2Ugb2YgYWNjb3VudCAnICsgcHVibGljS2V5LnRvQmFzZTU4KCkgKyAnOiAnICsgZSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGVzdGltYXRlZCBwcm9kdWN0aW9uIHRpbWUgb2YgYSBibG9ja1xuICAgKi9cbiAgYXN5bmMgZ2V0QmxvY2tUaW1lKHNsb3QpIHtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRCbG9ja1RpbWUnLCBbc2xvdF0pO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQobnVsbGFibGUobnVtYmVyKCkpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgYGZhaWxlZCB0byBnZXQgYmxvY2sgdGltZSBmb3Igc2xvdCAke3Nsb3R9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBsb3dlc3Qgc2xvdCB0aGF0IHRoZSBub2RlIGhhcyBpbmZvcm1hdGlvbiBhYm91dCBpbiBpdHMgbGVkZ2VyLlxuICAgKiBUaGlzIHZhbHVlIG1heSBpbmNyZWFzZSBvdmVyIHRpbWUgaWYgdGhlIG5vZGUgaXMgY29uZmlndXJlZCB0byBwdXJnZSBvbGRlciBsZWRnZXIgZGF0YVxuICAgKi9cbiAgYXN5bmMgZ2V0TWluaW11bUxlZGdlclNsb3QoKSB7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnbWluaW11bUxlZGdlclNsb3QnLCBbXSk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChudW1iZXIoKSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IG1pbmltdW0gbGVkZ2VyIHNsb3QnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIHNsb3Qgb2YgdGhlIGxvd2VzdCBjb25maXJtZWQgYmxvY2sgdGhhdCBoYXMgbm90IGJlZW4gcHVyZ2VkIGZyb20gdGhlIGxlZGdlclxuICAgKi9cbiAgYXN5bmMgZ2V0Rmlyc3RBdmFpbGFibGVCbG9jaygpIHtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRGaXJzdEF2YWlsYWJsZUJsb2NrJywgW10pO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIFNsb3RScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGZpcnN0IGF2YWlsYWJsZSBibG9jaycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY3VycmVudCBzdXBwbHlcbiAgICovXG4gIGFzeW5jIGdldFN1cHBseShjb25maWcpIHtcbiAgICBsZXQgY29uZmlnQXJnID0ge307XG4gICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25maWdBcmcgPSB7XG4gICAgICAgIGNvbW1pdG1lbnQ6IGNvbmZpZ1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGNvbmZpZykge1xuICAgICAgY29uZmlnQXJnID0ge1xuICAgICAgICAuLi5jb25maWcsXG4gICAgICAgIGNvbW1pdG1lbnQ6IGNvbmZpZyAmJiBjb25maWcuY29tbWl0bWVudCB8fCB0aGlzLmNvbW1pdG1lbnRcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbmZpZ0FyZyA9IHtcbiAgICAgICAgY29tbWl0bWVudDogdGhpcy5jb21taXRtZW50XG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRTdXBwbHknLCBbY29uZmlnQXJnXSk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0U3VwcGx5UnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBzdXBwbHknKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGN1cnJlbnQgc3VwcGx5IG9mIGEgdG9rZW4gbWludFxuICAgKi9cbiAgYXN5bmMgZ2V0VG9rZW5TdXBwbHkodG9rZW5NaW50QWRkcmVzcywgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3Rva2VuTWludEFkZHJlc3MudG9CYXNlNTgoKV0sIGNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFRva2VuU3VwcGx5JywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdEFuZENvbnRleHQoVG9rZW5BbW91bnRSZXN1bHQpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCB0b2tlbiBzdXBwbHknKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGN1cnJlbnQgYmFsYW5jZSBvZiBhIHRva2VuIGFjY291bnRcbiAgICovXG4gIGFzeW5jIGdldFRva2VuQWNjb3VudEJhbGFuY2UodG9rZW5BZGRyZXNzLCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbdG9rZW5BZGRyZXNzLnRvQmFzZTU4KCldLCBjb21taXRtZW50KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRUb2tlbkFjY291bnRCYWxhbmNlJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdEFuZENvbnRleHQoVG9rZW5BbW91bnRSZXN1bHQpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCB0b2tlbiBhY2NvdW50IGJhbGFuY2UnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYWxsIHRoZSB0b2tlbiBhY2NvdW50cyBvd25lZCBieSB0aGUgc3BlY2lmaWVkIGFjY291bnRcbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZTxScGNSZXNwb25zZUFuZENvbnRleHQ8R2V0UHJvZ3JhbUFjY291bnRzUmVzcG9uc2U+fVxuICAgKi9cbiAgYXN5bmMgZ2V0VG9rZW5BY2NvdW50c0J5T3duZXIob3duZXJBZGRyZXNzLCBmaWx0ZXIsIGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgbGV0IF9hcmdzID0gW293bmVyQWRkcmVzcy50b0Jhc2U1OCgpXTtcbiAgICBpZiAoJ21pbnQnIGluIGZpbHRlcikge1xuICAgICAgX2FyZ3MucHVzaCh7XG4gICAgICAgIG1pbnQ6IGZpbHRlci5taW50LnRvQmFzZTU4KClcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBfYXJncy5wdXNoKHtcbiAgICAgICAgcHJvZ3JhbUlkOiBmaWx0ZXIucHJvZ3JhbUlkLnRvQmFzZTU4KClcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKF9hcmdzLCBjb21taXRtZW50LCAnYmFzZTY0JywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRUb2tlbkFjY291bnRzQnlPd25lcicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFRva2VuQWNjb3VudHNCeU93bmVyKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBgZmFpbGVkIHRvIGdldCB0b2tlbiBhY2NvdW50cyBvd25lZCBieSBhY2NvdW50ICR7b3duZXJBZGRyZXNzLnRvQmFzZTU4KCl9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHBhcnNlZCB0b2tlbiBhY2NvdW50cyBvd25lZCBieSB0aGUgc3BlY2lmaWVkIGFjY291bnRcbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZTxScGNSZXNwb25zZUFuZENvbnRleHQ8QXJyYXk8e3B1YmtleTogUHVibGljS2V5LCBhY2NvdW50OiBBY2NvdW50SW5mbzxQYXJzZWRBY2NvdW50RGF0YT59Pj4+fVxuICAgKi9cbiAgYXN5bmMgZ2V0UGFyc2VkVG9rZW5BY2NvdW50c0J5T3duZXIob3duZXJBZGRyZXNzLCBmaWx0ZXIsIGNvbW1pdG1lbnQpIHtcbiAgICBsZXQgX2FyZ3MgPSBbb3duZXJBZGRyZXNzLnRvQmFzZTU4KCldO1xuICAgIGlmICgnbWludCcgaW4gZmlsdGVyKSB7XG4gICAgICBfYXJncy5wdXNoKHtcbiAgICAgICAgbWludDogZmlsdGVyLm1pbnQudG9CYXNlNTgoKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9hcmdzLnB1c2goe1xuICAgICAgICBwcm9ncmFtSWQ6IGZpbHRlci5wcm9ncmFtSWQudG9CYXNlNTgoKVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoX2FyZ3MsIGNvbW1pdG1lbnQsICdqc29uUGFyc2VkJyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0VG9rZW5BY2NvdW50c0J5T3duZXInLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRQYXJzZWRUb2tlbkFjY291bnRzQnlPd25lcik7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgYGZhaWxlZCB0byBnZXQgdG9rZW4gYWNjb3VudHMgb3duZWQgYnkgYWNjb3VudCAke293bmVyQWRkcmVzcy50b0Jhc2U1OCgpfWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgMjAgbGFyZ2VzdCBhY2NvdW50cyB3aXRoIHRoZWlyIGN1cnJlbnQgYmFsYW5jZXNcbiAgICovXG4gIGFzeW5jIGdldExhcmdlc3RBY2NvdW50cyhjb25maWcpIHtcbiAgICBjb25zdCBhcmcgPSB7XG4gICAgICAuLi5jb25maWcsXG4gICAgICBjb21taXRtZW50OiBjb25maWcgJiYgY29uZmlnLmNvbW1pdG1lbnQgfHwgdGhpcy5jb21taXRtZW50XG4gICAgfTtcbiAgICBjb25zdCBhcmdzID0gYXJnLmZpbHRlciB8fCBhcmcuY29tbWl0bWVudCA/IFthcmddIDogW107XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0TGFyZ2VzdEFjY291bnRzJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0TGFyZ2VzdEFjY291bnRzUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBsYXJnZXN0IGFjY291bnRzJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSAyMCBsYXJnZXN0IHRva2VuIGFjY291bnRzIHdpdGggdGhlaXIgY3VycmVudCBiYWxhbmNlc1xuICAgKiBmb3IgYSBnaXZlbiBtaW50LlxuICAgKi9cbiAgYXN5bmMgZ2V0VG9rZW5MYXJnZXN0QWNjb3VudHMobWludEFkZHJlc3MsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFttaW50QWRkcmVzcy50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0VG9rZW5MYXJnZXN0QWNjb3VudHMnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRUb2tlbkxhcmdlc3RBY2NvdW50c1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgdG9rZW4gbGFyZ2VzdCBhY2NvdW50cycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhbGwgdGhlIGFjY291bnQgaW5mbyBmb3IgdGhlIHNwZWNpZmllZCBwdWJsaWMga2V5LCByZXR1cm4gd2l0aCBjb250ZXh0XG4gICAqL1xuICBhc3luYyBnZXRBY2NvdW50SW5mb0FuZENvbnRleHQocHVibGljS2V5LCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3B1YmxpY0tleS50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCwgJ2Jhc2U2NCcsIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0QWNjb3VudEluZm8nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChudWxsYWJsZShBY2NvdW50SW5mb1Jlc3VsdCkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBgZmFpbGVkIHRvIGdldCBpbmZvIGFib3V0IGFjY291bnQgJHtwdWJsaWNLZXkudG9CYXNlNTgoKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggcGFyc2VkIGFjY291bnQgaW5mbyBmb3IgdGhlIHNwZWNpZmllZCBwdWJsaWMga2V5XG4gICAqL1xuICBhc3luYyBnZXRQYXJzZWRBY2NvdW50SW5mbyhwdWJsaWNLZXksIGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbcHVibGljS2V5LnRvQmFzZTU4KCldLCBjb21taXRtZW50LCAnanNvblBhcnNlZCcsIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0QWNjb3VudEluZm8nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChudWxsYWJsZShQYXJzZWRBY2NvdW50SW5mb1Jlc3VsdCkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBgZmFpbGVkIHRvIGdldCBpbmZvIGFib3V0IGFjY291bnQgJHtwdWJsaWNLZXkudG9CYXNlNTgoKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYWxsIHRoZSBhY2NvdW50IGluZm8gZm9yIHRoZSBzcGVjaWZpZWQgcHVibGljIGtleVxuICAgKi9cbiAgYXN5bmMgZ2V0QWNjb3VudEluZm8ocHVibGljS2V5LCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5nZXRBY2NvdW50SW5mb0FuZENvbnRleHQocHVibGljS2V5LCBjb21taXRtZW50T3JDb25maWcpO1xuICAgICAgcmV0dXJuIHJlcy52YWx1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZhaWxlZCB0byBnZXQgaW5mbyBhYm91dCBhY2NvdW50ICcgKyBwdWJsaWNLZXkudG9CYXNlNTgoKSArICc6ICcgKyBlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYWxsIHRoZSBhY2NvdW50IGluZm8gZm9yIG11bHRpcGxlIGFjY291bnRzIHNwZWNpZmllZCBieSBhbiBhcnJheSBvZiBwdWJsaWMga2V5cywgcmV0dXJuIHdpdGggY29udGV4dFxuICAgKi9cbiAgYXN5bmMgZ2V0TXVsdGlwbGVQYXJzZWRBY2NvdW50cyhwdWJsaWNLZXlzLCByYXdDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhyYXdDb25maWcpO1xuICAgIGNvbnN0IGtleXMgPSBwdWJsaWNLZXlzLm1hcChrZXkgPT4ga2V5LnRvQmFzZTU4KCkpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW2tleXNdLCBjb21taXRtZW50LCAnanNvblBhcnNlZCcsIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0TXVsdGlwbGVBY2NvdW50cycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KGFycmF5KG51bGxhYmxlKFBhcnNlZEFjY291bnRJbmZvUmVzdWx0KSkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBgZmFpbGVkIHRvIGdldCBpbmZvIGZvciBhY2NvdW50cyAke2tleXN9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGFsbCB0aGUgYWNjb3VudCBpbmZvIGZvciBtdWx0aXBsZSBhY2NvdW50cyBzcGVjaWZpZWQgYnkgYW4gYXJyYXkgb2YgcHVibGljIGtleXMsIHJldHVybiB3aXRoIGNvbnRleHRcbiAgICovXG4gIGFzeW5jIGdldE11bHRpcGxlQWNjb3VudHNJbmZvQW5kQ29udGV4dChwdWJsaWNLZXlzLCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGtleXMgPSBwdWJsaWNLZXlzLm1hcChrZXkgPT4ga2V5LnRvQmFzZTU4KCkpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW2tleXNdLCBjb21taXRtZW50LCAnYmFzZTY0JywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRNdWx0aXBsZUFjY291bnRzJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdEFuZENvbnRleHQoYXJyYXkobnVsbGFibGUoQWNjb3VudEluZm9SZXN1bHQpKSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsIGBmYWlsZWQgdG8gZ2V0IGluZm8gZm9yIGFjY291bnRzICR7a2V5c31gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYWxsIHRoZSBhY2NvdW50IGluZm8gZm9yIG11bHRpcGxlIGFjY291bnRzIHNwZWNpZmllZCBieSBhbiBhcnJheSBvZiBwdWJsaWMga2V5c1xuICAgKi9cbiAgYXN5bmMgZ2V0TXVsdGlwbGVBY2NvdW50c0luZm8ocHVibGljS2V5cywgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5nZXRNdWx0aXBsZUFjY291bnRzSW5mb0FuZENvbnRleHQocHVibGljS2V5cywgY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICByZXR1cm4gcmVzLnZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZXBvY2ggYWN0aXZhdGlvbiBpbmZvcm1hdGlvbiBmb3IgYSBzdGFrZSBhY2NvdW50IHRoYXQgaGFzIGJlZW4gZGVsZWdhdGVkXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgUlBDIHYxLjE4OyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi5cbiAgICovXG4gIGFzeW5jIGdldFN0YWtlQWN0aXZhdGlvbihwdWJsaWNLZXksIGNvbW1pdG1lbnRPckNvbmZpZywgZXBvY2gpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3B1YmxpY0tleS50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCB7XG4gICAgICAuLi5jb25maWcsXG4gICAgICBlcG9jaDogZXBvY2ggIT0gbnVsbCA/IGVwb2NoIDogY29uZmlnPy5lcG9jaFxuICAgIH0pO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFN0YWtlQWN0aXZhdGlvbicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQoU3Rha2VBY3RpdmF0aW9uUmVzdWx0KSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgYGZhaWxlZCB0byBnZXQgU3Rha2UgQWN0aXZhdGlvbiAke3B1YmxpY0tleS50b0Jhc2U1OCgpfWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhbGwgdGhlIGFjY291bnRzIG93bmVkIGJ5IHRoZSBzcGVjaWZpZWQgcHJvZ3JhbSBpZFxuICAgKlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5PHtwdWJrZXk6IFB1YmxpY0tleSwgYWNjb3VudDogQWNjb3VudEluZm88QnVmZmVyPn0+Pn1cbiAgICovXG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcbiAgYXN5bmMgZ2V0UHJvZ3JhbUFjY291bnRzKHByb2dyYW1JZCwgY29uZmlnT3JDb21taXRtZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29uZmlnT3JDb21taXRtZW50KTtcbiAgICBjb25zdCB7XG4gICAgICBlbmNvZGluZyxcbiAgICAgIC4uLmNvbmZpZ1dpdGhvdXRFbmNvZGluZ1xuICAgIH0gPSBjb25maWcgfHwge307XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbcHJvZ3JhbUlkLnRvQmFzZTU4KCldLCBjb21taXRtZW50LCBlbmNvZGluZyB8fCAnYmFzZTY0Jywge1xuICAgICAgLi4uY29uZmlnV2l0aG91dEVuY29kaW5nLFxuICAgICAgLi4uKGNvbmZpZ1dpdGhvdXRFbmNvZGluZy5maWx0ZXJzID8ge1xuICAgICAgICBmaWx0ZXJzOiBhcHBseURlZmF1bHRNZW1jbXBFbmNvZGluZ1RvRmlsdGVycyhjb25maWdXaXRob3V0RW5jb2RpbmcuZmlsdGVycylcbiAgICAgIH0gOiBudWxsKVxuICAgIH0pO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFByb2dyYW1BY2NvdW50cycsIGFyZ3MpO1xuICAgIGNvbnN0IGJhc2VTY2hlbWEgPSBhcnJheShLZXllZEFjY291bnRJbmZvUmVzdWx0KTtcbiAgICBjb25zdCByZXMgPSBjb25maWdXaXRob3V0RW5jb2Rpbmcud2l0aENvbnRleHQgPT09IHRydWUgPyBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChiYXNlU2NoZW1hKSkgOiBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KGJhc2VTY2hlbWEpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBgZmFpbGVkIHRvIGdldCBhY2NvdW50cyBvd25lZCBieSBwcm9ncmFtICR7cHJvZ3JhbUlkLnRvQmFzZTU4KCl9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGFuZCBwYXJzZSBhbGwgdGhlIGFjY291bnRzIG93bmVkIGJ5IHRoZSBzcGVjaWZpZWQgcHJvZ3JhbSBpZFxuICAgKlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5PHtwdWJrZXk6IFB1YmxpY0tleSwgYWNjb3VudDogQWNjb3VudEluZm88QnVmZmVyIHwgUGFyc2VkQWNjb3VudERhdGE+fT4+fVxuICAgKi9cbiAgYXN5bmMgZ2V0UGFyc2VkUHJvZ3JhbUFjY291bnRzKHByb2dyYW1JZCwgY29uZmlnT3JDb21taXRtZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29uZmlnT3JDb21taXRtZW50KTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtwcm9ncmFtSWQudG9CYXNlNTgoKV0sIGNvbW1pdG1lbnQsICdqc29uUGFyc2VkJywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRQcm9ncmFtQWNjb3VudHMnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KGFycmF5KEtleWVkUGFyc2VkQWNjb3VudEluZm9SZXN1bHQpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgYGZhaWxlZCB0byBnZXQgYWNjb3VudHMgb3duZWQgYnkgcHJvZ3JhbSAke3Byb2dyYW1JZC50b0Jhc2U1OCgpfWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKiBAZGVwcmVjYXRlZCBJbnN0ZWFkLCBjYWxsIGBjb25maXJtVHJhbnNhY3Rpb25gIGFuZCBwYXNzIGluIHtAbGluayBUcmFuc2FjdGlvbkNvbmZpcm1hdGlvblN0cmF0ZWd5fSAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuICBhc3luYyBjb25maXJtVHJhbnNhY3Rpb24oc3RyYXRlZ3ksIGNvbW1pdG1lbnQpIHtcbiAgICBsZXQgcmF3U2lnbmF0dXJlO1xuICAgIGlmICh0eXBlb2Ygc3RyYXRlZ3kgPT0gJ3N0cmluZycpIHtcbiAgICAgIHJhd1NpZ25hdHVyZSA9IHN0cmF0ZWd5O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjb25maWcgPSBzdHJhdGVneTtcbiAgICAgIGlmIChjb25maWcuYWJvcnRTaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGNvbmZpZy5hYm9ydFNpZ25hbC5yZWFzb24pO1xuICAgICAgfVxuICAgICAgcmF3U2lnbmF0dXJlID0gY29uZmlnLnNpZ25hdHVyZTtcbiAgICB9XG4gICAgbGV0IGRlY29kZWRTaWduYXR1cmU7XG4gICAgdHJ5IHtcbiAgICAgIGRlY29kZWRTaWduYXR1cmUgPSBiczU4LmRlY29kZShyYXdTaWduYXR1cmUpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduYXR1cmUgbXVzdCBiZSBiYXNlNTggZW5jb2RlZDogJyArIHJhd1NpZ25hdHVyZSk7XG4gICAgfVxuICAgIGFzc2VydChkZWNvZGVkU2lnbmF0dXJlLmxlbmd0aCA9PT0gNjQsICdzaWduYXR1cmUgaGFzIGludmFsaWQgbGVuZ3RoJyk7XG4gICAgaWYgKHR5cGVvZiBzdHJhdGVneSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNvbmZpcm1UcmFuc2FjdGlvblVzaW5nTGVnYWN5VGltZW91dFN0cmF0ZWd5KHtcbiAgICAgICAgY29tbWl0bWVudDogY29tbWl0bWVudCB8fCB0aGlzLmNvbW1pdG1lbnQsXG4gICAgICAgIHNpZ25hdHVyZTogcmF3U2lnbmF0dXJlXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCdsYXN0VmFsaWRCbG9ja0hlaWdodCcgaW4gc3RyYXRlZ3kpIHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNvbmZpcm1UcmFuc2FjdGlvblVzaW5nQmxvY2tIZWlnaHRFeGNlZWRhbmNlU3RyYXRlZ3koe1xuICAgICAgICBjb21taXRtZW50OiBjb21taXRtZW50IHx8IHRoaXMuY29tbWl0bWVudCxcbiAgICAgICAgc3RyYXRlZ3lcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5jb25maXJtVHJhbnNhY3Rpb25Vc2luZ0R1cmFibGVOb25jZVN0cmF0ZWd5KHtcbiAgICAgICAgY29tbWl0bWVudDogY29tbWl0bWVudCB8fCB0aGlzLmNvbW1pdG1lbnQsXG4gICAgICAgIHN0cmF0ZWd5XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZ2V0Q2FuY2VsbGF0aW9uUHJvbWlzZShzaWduYWwpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKHNpZ25hbCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICByZWplY3Qoc2lnbmFsLnJlYXNvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB7XG4gICAgICAgICAgcmVqZWN0KHNpZ25hbC5yZWFzb24pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnZXRUcmFuc2FjdGlvbkNvbmZpcm1hdGlvblByb21pc2Uoe1xuICAgIGNvbW1pdG1lbnQsXG4gICAgc2lnbmF0dXJlXG4gIH0pIHtcbiAgICBsZXQgc2lnbmF0dXJlU3Vic2NyaXB0aW9uSWQ7XG4gICAgbGV0IGRpc3Bvc2VTaWduYXR1cmVTdWJzY3JpcHRpb25TdGF0ZUNoYW5nZU9ic2VydmVyO1xuICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgY29uc3QgY29uZmlybWF0aW9uUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNpZ25hdHVyZVN1YnNjcmlwdGlvbklkID0gdGhpcy5vblNpZ25hdHVyZShzaWduYXR1cmUsIChyZXN1bHQsIGNvbnRleHQpID0+IHtcbiAgICAgICAgICBzaWduYXR1cmVTdWJzY3JpcHRpb25JZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHtcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICB2YWx1ZTogcmVzdWx0XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgIF9fdHlwZTogVHJhbnNhY3Rpb25TdGF0dXMuUFJPQ0VTU0VELFxuICAgICAgICAgICAgcmVzcG9uc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgY29tbWl0bWVudCk7XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvblNldHVwUHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmVTdWJzY3JpcHRpb25TZXR1cCA9PiB7XG4gICAgICAgICAgaWYgKHNpZ25hdHVyZVN1YnNjcmlwdGlvbklkID09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc29sdmVTdWJzY3JpcHRpb25TZXR1cCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaXNwb3NlU2lnbmF0dXJlU3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2VPYnNlcnZlciA9IHRoaXMuX29uU3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2Uoc2lnbmF0dXJlU3Vic2NyaXB0aW9uSWQsIG5leHRTdGF0ZSA9PiB7XG4gICAgICAgICAgICAgIGlmIChuZXh0U3RhdGUgPT09ICdzdWJzY3JpYmVkJykge1xuICAgICAgICAgICAgICAgIHJlc29sdmVTdWJzY3JpcHRpb25TZXR1cCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGF3YWl0IHN1YnNjcmlwdGlvblNldHVwUHJvbWlzZTtcbiAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5nZXRTaWduYXR1cmVTdGF0dXMoc2lnbmF0dXJlKTtcbiAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICAgIGlmIChyZXNwb25zZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0gPSByZXNwb25zZTtcbiAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWU/LmVycikge1xuICAgICAgICAgICAgcmVqZWN0KHZhbHVlLmVycik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN3aXRjaCAoY29tbWl0bWVudCkge1xuICAgICAgICAgICAgICBjYXNlICdjb25maXJtZWQnOlxuICAgICAgICAgICAgICBjYXNlICdzaW5nbGUnOlxuICAgICAgICAgICAgICBjYXNlICdzaW5nbGVHb3NzaXAnOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5jb25maXJtYXRpb25TdGF0dXMgPT09ICdwcm9jZXNzZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAnZmluYWxpemVkJzpcbiAgICAgICAgICAgICAgY2FzZSAnbWF4JzpcbiAgICAgICAgICAgICAgY2FzZSAncm9vdCc6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLmNvbmZpcm1hdGlvblN0YXR1cyA9PT0gJ3Byb2Nlc3NlZCcgfHwgdmFsdWUuY29uZmlybWF0aW9uU3RhdHVzID09PSAnY29uZmlybWVkJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIGV4aGF1c3QgZW51bXMgdG8gZW5zdXJlIGZ1bGwgY292ZXJhZ2VcbiAgICAgICAgICAgICAgY2FzZSAncHJvY2Vzc2VkJzpcbiAgICAgICAgICAgICAgY2FzZSAncmVjZW50JzpcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgIF9fdHlwZTogVHJhbnNhY3Rpb25TdGF0dXMuUFJPQ0VTU0VELFxuICAgICAgICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGFib3J0Q29uZmlybWF0aW9uID0gKCkgPT4ge1xuICAgICAgaWYgKGRpc3Bvc2VTaWduYXR1cmVTdWJzY3JpcHRpb25TdGF0ZUNoYW5nZU9ic2VydmVyKSB7XG4gICAgICAgIGRpc3Bvc2VTaWduYXR1cmVTdWJzY3JpcHRpb25TdGF0ZUNoYW5nZU9ic2VydmVyKCk7XG4gICAgICAgIGRpc3Bvc2VTaWduYXR1cmVTdWJzY3JpcHRpb25TdGF0ZUNoYW5nZU9ic2VydmVyID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKHNpZ25hdHVyZVN1YnNjcmlwdGlvbklkICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVTaWduYXR1cmVMaXN0ZW5lcihzaWduYXR1cmVTdWJzY3JpcHRpb25JZCk7XG4gICAgICAgIHNpZ25hdHVyZVN1YnNjcmlwdGlvbklkID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIGFib3J0Q29uZmlybWF0aW9uLFxuICAgICAgY29uZmlybWF0aW9uUHJvbWlzZVxuICAgIH07XG4gIH1cbiAgYXN5bmMgY29uZmlybVRyYW5zYWN0aW9uVXNpbmdCbG9ja0hlaWdodEV4Y2VlZGFuY2VTdHJhdGVneSh7XG4gICAgY29tbWl0bWVudCxcbiAgICBzdHJhdGVneToge1xuICAgICAgYWJvcnRTaWduYWwsXG4gICAgICBsYXN0VmFsaWRCbG9ja0hlaWdodCxcbiAgICAgIHNpZ25hdHVyZVxuICAgIH1cbiAgfSkge1xuICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgY29uc3QgZXhwaXJ5UHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgY29uc3QgY2hlY2tCbG9ja0hlaWdodCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBibG9ja0hlaWdodCA9IGF3YWl0IHRoaXMuZ2V0QmxvY2tIZWlnaHQoY29tbWl0bWVudCk7XG4gICAgICAgICAgcmV0dXJuIGJsb2NrSGVpZ2h0O1xuICAgICAgICB9IGNhdGNoIChfZSkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgIGxldCBjdXJyZW50QmxvY2tIZWlnaHQgPSBhd2FpdCBjaGVja0Jsb2NrSGVpZ2h0KCk7XG4gICAgICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgICAgIHdoaWxlIChjdXJyZW50QmxvY2tIZWlnaHQgPD0gbGFzdFZhbGlkQmxvY2tIZWlnaHQpIHtcbiAgICAgICAgICBhd2FpdCBzbGVlcCgxMDAwKTtcbiAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICAgIGN1cnJlbnRCbG9ja0hlaWdodCA9IGF3YWl0IGNoZWNrQmxvY2tIZWlnaHQoKTtcbiAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgIF9fdHlwZTogVHJhbnNhY3Rpb25TdGF0dXMuQkxPQ0tIRUlHSFRfRVhDRUVERURcbiAgICAgICAgfSk7XG4gICAgICB9KSgpO1xuICAgIH0pO1xuICAgIGNvbnN0IHtcbiAgICAgIGFib3J0Q29uZmlybWF0aW9uLFxuICAgICAgY29uZmlybWF0aW9uUHJvbWlzZVxuICAgIH0gPSB0aGlzLmdldFRyYW5zYWN0aW9uQ29uZmlybWF0aW9uUHJvbWlzZSh7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgc2lnbmF0dXJlXG4gICAgfSk7XG4gICAgY29uc3QgY2FuY2VsbGF0aW9uUHJvbWlzZSA9IHRoaXMuZ2V0Q2FuY2VsbGF0aW9uUHJvbWlzZShhYm9ydFNpZ25hbCk7XG4gICAgbGV0IHJlc3VsdDtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgb3V0Y29tZSA9IGF3YWl0IFByb21pc2UucmFjZShbY2FuY2VsbGF0aW9uUHJvbWlzZSwgY29uZmlybWF0aW9uUHJvbWlzZSwgZXhwaXJ5UHJvbWlzZV0pO1xuICAgICAgaWYgKG91dGNvbWUuX190eXBlID09PSBUcmFuc2FjdGlvblN0YXR1cy5QUk9DRVNTRUQpIHtcbiAgICAgICAgcmVzdWx0ID0gb3V0Y29tZS5yZXNwb25zZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBUcmFuc2FjdGlvbkV4cGlyZWRCbG9ja2hlaWdodEV4Y2VlZGVkRXJyb3Ioc2lnbmF0dXJlKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgZG9uZSA9IHRydWU7XG4gICAgICBhYm9ydENvbmZpcm1hdGlvbigpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGFzeW5jIGNvbmZpcm1UcmFuc2FjdGlvblVzaW5nRHVyYWJsZU5vbmNlU3RyYXRlZ3koe1xuICAgIGNvbW1pdG1lbnQsXG4gICAgc3RyYXRlZ3k6IHtcbiAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgbWluQ29udGV4dFNsb3QsXG4gICAgICBub25jZUFjY291bnRQdWJrZXksXG4gICAgICBub25jZVZhbHVlLFxuICAgICAgc2lnbmF0dXJlXG4gICAgfVxuICB9KSB7XG4gICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICBjb25zdCBleHBpcnlQcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBsZXQgY3VycmVudE5vbmNlVmFsdWUgPSBub25jZVZhbHVlO1xuICAgICAgbGV0IGxhc3RDaGVja2VkU2xvdCA9IG51bGw7XG4gICAgICBjb25zdCBnZXRDdXJyZW50Tm9uY2VWYWx1ZSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgdmFsdWU6IG5vbmNlQWNjb3VudFxuICAgICAgICAgIH0gPSBhd2FpdCB0aGlzLmdldE5vbmNlQW5kQ29udGV4dChub25jZUFjY291bnRQdWJrZXksIHtcbiAgICAgICAgICAgIGNvbW1pdG1lbnQsXG4gICAgICAgICAgICBtaW5Db250ZXh0U2xvdFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGxhc3RDaGVja2VkU2xvdCA9IGNvbnRleHQuc2xvdDtcbiAgICAgICAgICByZXR1cm4gbm9uY2VBY2NvdW50Py5ub25jZTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIElmIGZvciB3aGF0ZXZlciByZWFzb24gd2UgY2FuJ3QgcmVhY2gvcmVhZCB0aGUgbm9uY2VcbiAgICAgICAgICAvLyBhY2NvdW50LCBqdXN0IGtlZXAgdXNpbmcgdGhlIGxhc3Qta25vd24gdmFsdWUuXG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnROb25jZVZhbHVlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgY3VycmVudE5vbmNlVmFsdWUgPSBhd2FpdCBnZXRDdXJyZW50Tm9uY2VWYWx1ZSgpO1xuICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICB3aGlsZSAodHJ1ZSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgICAgICApIHtcbiAgICAgICAgICBpZiAobm9uY2VWYWx1ZSAhPT0gY3VycmVudE5vbmNlVmFsdWUpIHtcbiAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICBfX3R5cGU6IFRyYW5zYWN0aW9uU3RhdHVzLk5PTkNFX0lOVkFMSUQsXG4gICAgICAgICAgICAgIHNsb3RJbldoaWNoTm9uY2VEaWRBZHZhbmNlOiBsYXN0Q2hlY2tlZFNsb3RcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhd2FpdCBzbGVlcCgyMDAwKTtcbiAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICAgIGN1cnJlbnROb25jZVZhbHVlID0gYXdhaXQgZ2V0Q3VycmVudE5vbmNlVmFsdWUoKTtcbiAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9KSgpO1xuICAgIH0pO1xuICAgIGNvbnN0IHtcbiAgICAgIGFib3J0Q29uZmlybWF0aW9uLFxuICAgICAgY29uZmlybWF0aW9uUHJvbWlzZVxuICAgIH0gPSB0aGlzLmdldFRyYW5zYWN0aW9uQ29uZmlybWF0aW9uUHJvbWlzZSh7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgc2lnbmF0dXJlXG4gICAgfSk7XG4gICAgY29uc3QgY2FuY2VsbGF0aW9uUHJvbWlzZSA9IHRoaXMuZ2V0Q2FuY2VsbGF0aW9uUHJvbWlzZShhYm9ydFNpZ25hbCk7XG4gICAgbGV0IHJlc3VsdDtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgb3V0Y29tZSA9IGF3YWl0IFByb21pc2UucmFjZShbY2FuY2VsbGF0aW9uUHJvbWlzZSwgY29uZmlybWF0aW9uUHJvbWlzZSwgZXhwaXJ5UHJvbWlzZV0pO1xuICAgICAgaWYgKG91dGNvbWUuX190eXBlID09PSBUcmFuc2FjdGlvblN0YXR1cy5QUk9DRVNTRUQpIHtcbiAgICAgICAgcmVzdWx0ID0gb3V0Y29tZS5yZXNwb25zZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIERvdWJsZSBjaGVjayB0aGF0IHRoZSB0cmFuc2FjdGlvbiBpcyBpbmRlZWQgdW5jb25maXJtZWQuXG4gICAgICAgIGxldCBzaWduYXR1cmVTdGF0dXM7XG4gICAgICAgIHdoaWxlICh0cnVlIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IGF3YWl0IHRoaXMuZ2V0U2lnbmF0dXJlU3RhdHVzKHNpZ25hdHVyZSk7XG4gICAgICAgICAgaWYgKHN0YXR1cyA9PSBudWxsKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXR1cy5jb250ZXh0LnNsb3QgPCAob3V0Y29tZS5zbG90SW5XaGljaE5vbmNlRGlkQWR2YW5jZSA/PyBtaW5Db250ZXh0U2xvdCkpIHtcbiAgICAgICAgICAgIGF3YWl0IHNsZWVwKDQwMCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2lnbmF0dXJlU3RhdHVzID0gc3RhdHVzO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaWduYXR1cmVTdGF0dXM/LnZhbHVlKSB7XG4gICAgICAgICAgY29uc3QgY29tbWl0bWVudEZvclN0YXR1cyA9IGNvbW1pdG1lbnQgfHwgJ2ZpbmFsaXplZCc7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgY29uZmlybWF0aW9uU3RhdHVzXG4gICAgICAgICAgfSA9IHNpZ25hdHVyZVN0YXR1cy52YWx1ZTtcbiAgICAgICAgICBzd2l0Y2ggKGNvbW1pdG1lbnRGb3JTdGF0dXMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3Byb2Nlc3NlZCc6XG4gICAgICAgICAgICBjYXNlICdyZWNlbnQnOlxuICAgICAgICAgICAgICBpZiAoY29uZmlybWF0aW9uU3RhdHVzICE9PSAncHJvY2Vzc2VkJyAmJiBjb25maXJtYXRpb25TdGF0dXMgIT09ICdjb25maXJtZWQnICYmIGNvbmZpcm1hdGlvblN0YXR1cyAhPT0gJ2ZpbmFsaXplZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHJhbnNhY3Rpb25FeHBpcmVkTm9uY2VJbnZhbGlkRXJyb3Ioc2lnbmF0dXJlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NvbmZpcm1lZCc6XG4gICAgICAgICAgICBjYXNlICdzaW5nbGUnOlxuICAgICAgICAgICAgY2FzZSAnc2luZ2xlR29zc2lwJzpcbiAgICAgICAgICAgICAgaWYgKGNvbmZpcm1hdGlvblN0YXR1cyAhPT0gJ2NvbmZpcm1lZCcgJiYgY29uZmlybWF0aW9uU3RhdHVzICE9PSAnZmluYWxpemVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUcmFuc2FjdGlvbkV4cGlyZWROb25jZUludmFsaWRFcnJvcihzaWduYXR1cmUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZmluYWxpemVkJzpcbiAgICAgICAgICAgIGNhc2UgJ21heCc6XG4gICAgICAgICAgICBjYXNlICdyb290JzpcbiAgICAgICAgICAgICAgaWYgKGNvbmZpcm1hdGlvblN0YXR1cyAhPT0gJ2ZpbmFsaXplZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHJhbnNhY3Rpb25FeHBpcmVkTm9uY2VJbnZhbGlkRXJyb3Ioc2lnbmF0dXJlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIEV4aGF1c3RpdmUgc3dpdGNoLlxuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICAgICAgICAgIChfID0+IHt9KShjb21taXRtZW50Rm9yU3RhdHVzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgICAgY29udGV4dDogc2lnbmF0dXJlU3RhdHVzLmNvbnRleHQsXG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICBlcnI6IHNpZ25hdHVyZVN0YXR1cy52YWx1ZS5lcnJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBUcmFuc2FjdGlvbkV4cGlyZWROb25jZUludmFsaWRFcnJvcihzaWduYXR1cmUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgYWJvcnRDb25maXJtYXRpb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBhc3luYyBjb25maXJtVHJhbnNhY3Rpb25Vc2luZ0xlZ2FjeVRpbWVvdXRTdHJhdGVneSh7XG4gICAgY29tbWl0bWVudCxcbiAgICBzaWduYXR1cmVcbiAgfSkge1xuICAgIGxldCB0aW1lb3V0SWQ7XG4gICAgY29uc3QgZXhwaXJ5UHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgbGV0IHRpbWVvdXRNcyA9IHRoaXMuX2NvbmZpcm1UcmFuc2FjdGlvbkluaXRpYWxUaW1lb3V0IHx8IDYwICogMTAwMDtcbiAgICAgIHN3aXRjaCAoY29tbWl0bWVudCkge1xuICAgICAgICBjYXNlICdwcm9jZXNzZWQnOlxuICAgICAgICBjYXNlICdyZWNlbnQnOlxuICAgICAgICBjYXNlICdzaW5nbGUnOlxuICAgICAgICBjYXNlICdjb25maXJtZWQnOlxuICAgICAgICBjYXNlICdzaW5nbGVHb3NzaXAnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRpbWVvdXRNcyA9IHRoaXMuX2NvbmZpcm1UcmFuc2FjdGlvbkluaXRpYWxUaW1lb3V0IHx8IDMwICogMTAwMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4gcmVzb2x2ZSh7XG4gICAgICAgIF9fdHlwZTogVHJhbnNhY3Rpb25TdGF0dXMuVElNRURfT1VULFxuICAgICAgICB0aW1lb3V0TXNcbiAgICAgIH0pLCB0aW1lb3V0TXMpO1xuICAgIH0pO1xuICAgIGNvbnN0IHtcbiAgICAgIGFib3J0Q29uZmlybWF0aW9uLFxuICAgICAgY29uZmlybWF0aW9uUHJvbWlzZVxuICAgIH0gPSB0aGlzLmdldFRyYW5zYWN0aW9uQ29uZmlybWF0aW9uUHJvbWlzZSh7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgc2lnbmF0dXJlXG4gICAgfSk7XG4gICAgbGV0IHJlc3VsdDtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgb3V0Y29tZSA9IGF3YWl0IFByb21pc2UucmFjZShbY29uZmlybWF0aW9uUHJvbWlzZSwgZXhwaXJ5UHJvbWlzZV0pO1xuICAgICAgaWYgKG91dGNvbWUuX190eXBlID09PSBUcmFuc2FjdGlvblN0YXR1cy5QUk9DRVNTRUQpIHtcbiAgICAgICAgcmVzdWx0ID0gb3V0Y29tZS5yZXNwb25zZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBUcmFuc2FjdGlvbkV4cGlyZWRUaW1lb3V0RXJyb3Ioc2lnbmF0dXJlLCBvdXRjb21lLnRpbWVvdXRNcyAvIDEwMDApO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgIGFib3J0Q29uZmlybWF0aW9uKCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBsaXN0IG9mIG5vZGVzIHRoYXQgYXJlIGN1cnJlbnRseSBwYXJ0aWNpcGF0aW5nIGluIHRoZSBjbHVzdGVyXG4gICAqL1xuICBhc3luYyBnZXRDbHVzdGVyTm9kZXMoKSB7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0Q2x1c3Rlck5vZGVzJywgW10pO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQoYXJyYXkoQ29udGFjdEluZm9SZXN1bHQpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgY2x1c3RlciBub2RlcycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGxpc3Qgb2Ygbm9kZXMgdGhhdCBhcmUgY3VycmVudGx5IHBhcnRpY2lwYXRpbmcgaW4gdGhlIGNsdXN0ZXJcbiAgICovXG4gIGFzeW5jIGdldFZvdGVBY2NvdW50cyhjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbXSwgY29tbWl0bWVudCk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0Vm90ZUFjY291bnRzJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0Vm90ZUFjY291bnRzKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCB2b3RlIGFjY291bnRzJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBjdXJyZW50IHNsb3QgdGhhdCB0aGUgbm9kZSBpcyBwcm9jZXNzaW5nXG4gICAqL1xuICBhc3luYyBnZXRTbG90KGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFNsb3QnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KG51bWJlcigpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgc2xvdCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgY3VycmVudCBzbG90IGxlYWRlciBvZiB0aGUgY2x1c3RlclxuICAgKi9cbiAgYXN5bmMgZ2V0U2xvdExlYWRlcihjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW10sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRTbG90TGVhZGVyJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChzdHJpbmcoKSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHNsb3QgbGVhZGVyJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGBsaW1pdGAgbnVtYmVyIG9mIHNsb3QgbGVhZGVycyBzdGFydGluZyBmcm9tIGBzdGFydFNsb3RgXG4gICAqXG4gICAqIEBwYXJhbSBzdGFydFNsb3QgZmV0Y2ggc2xvdCBsZWFkZXJzIHN0YXJ0aW5nIGZyb20gdGhpcyBzbG90XG4gICAqIEBwYXJhbSBsaW1pdCBudW1iZXIgb2Ygc2xvdCBsZWFkZXJzIHRvIHJldHVyblxuICAgKi9cbiAgYXN5bmMgZ2V0U2xvdExlYWRlcnMoc3RhcnRTbG90LCBsaW1pdCkge1xuICAgIGNvbnN0IGFyZ3MgPSBbc3RhcnRTbG90LCBsaW1pdF07XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0U2xvdExlYWRlcnMnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KGFycmF5KFB1YmxpY0tleUZyb21TdHJpbmcpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgc2xvdCBsZWFkZXJzJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBjdXJyZW50IHN0YXR1cyBvZiBhIHNpZ25hdHVyZVxuICAgKi9cbiAgYXN5bmMgZ2V0U2lnbmF0dXJlU3RhdHVzKHNpZ25hdHVyZSwgY29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29udGV4dCxcbiAgICAgIHZhbHVlOiB2YWx1ZXNcbiAgICB9ID0gYXdhaXQgdGhpcy5nZXRTaWduYXR1cmVTdGF0dXNlcyhbc2lnbmF0dXJlXSwgY29uZmlnKTtcbiAgICBhc3NlcnQodmFsdWVzLmxlbmd0aCA9PT0gMSk7XG4gICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRleHQsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGN1cnJlbnQgc3RhdHVzZXMgb2YgYSBiYXRjaCBvZiBzaWduYXR1cmVzXG4gICAqL1xuICBhc3luYyBnZXRTaWduYXR1cmVTdGF0dXNlcyhzaWduYXR1cmVzLCBjb25maWcpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBbc2lnbmF0dXJlc107XG4gICAgaWYgKGNvbmZpZykge1xuICAgICAgcGFyYW1zLnB1c2goY29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0U2lnbmF0dXJlU3RhdHVzZXMnLCBwYXJhbXMpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFNpZ25hdHVyZVN0YXR1c2VzUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBzaWduYXR1cmUgc3RhdHVzJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBjdXJyZW50IHRyYW5zYWN0aW9uIGNvdW50IG9mIHRoZSBjbHVzdGVyXG4gICAqL1xuICBhc3luYyBnZXRUcmFuc2FjdGlvbkNvdW50KGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFRyYW5zYWN0aW9uQ291bnQnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KG51bWJlcigpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgdHJhbnNhY3Rpb24gY291bnQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGN1cnJlbnQgdG90YWwgY3VycmVuY3kgc3VwcGx5IG9mIHRoZSBjbHVzdGVyIGluIGxhbXBvcnRzXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgUlBDIHYxLjIuOC4gUGxlYXNlIHVzZSB7QGxpbmsgZ2V0U3VwcGx5fSBpbnN0ZWFkLlxuICAgKi9cbiAgYXN5bmMgZ2V0VG90YWxTdXBwbHkoY29tbWl0bWVudCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZ2V0U3VwcGx5KHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBleGNsdWRlTm9uQ2lyY3VsYXRpbmdBY2NvdW50c0xpc3Q6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0LnZhbHVlLnRvdGFsO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBjbHVzdGVyIEluZmxhdGlvbkdvdmVybm9yIHBhcmFtZXRlcnNcbiAgICovXG4gIGFzeW5jIGdldEluZmxhdGlvbkdvdmVybm9yKGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtdLCBjb21taXRtZW50KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRJbmZsYXRpb25Hb3Zlcm5vcicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldEluZmxhdGlvbkdvdmVybm9yUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBpbmZsYXRpb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGluZmxhdGlvbiByZXdhcmQgZm9yIGEgbGlzdCBvZiBhZGRyZXNzZXMgZm9yIGFuIGVwb2NoXG4gICAqL1xuICBhc3luYyBnZXRJbmZsYXRpb25SZXdhcmQoYWRkcmVzc2VzLCBlcG9jaCwgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFthZGRyZXNzZXMubWFwKHB1YmtleSA9PiBwdWJrZXkudG9CYXNlNTgoKSldLCBjb21taXRtZW50LCB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sIHtcbiAgICAgIC4uLmNvbmZpZyxcbiAgICAgIGVwb2NoOiBlcG9jaCAhPSBudWxsID8gZXBvY2ggOiBjb25maWc/LmVwb2NoXG4gICAgfSk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0SW5mbGF0aW9uUmV3YXJkJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0SW5mbGF0aW9uUmV3YXJkUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBpbmZsYXRpb24gcmV3YXJkJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBzcGVjaWZpYyBpbmZsYXRpb24gdmFsdWVzIGZvciB0aGUgY3VycmVudCBlcG9jaFxuICAgKi9cbiAgYXN5bmMgZ2V0SW5mbGF0aW9uUmF0ZSgpIHtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRJbmZsYXRpb25SYXRlJywgW10pO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldEluZmxhdGlvblJhdGVScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGluZmxhdGlvbiByYXRlJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBFcG9jaCBJbmZvIHBhcmFtZXRlcnNcbiAgICovXG4gIGFzeW5jIGdldEVwb2NoSW5mbyhjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW10sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRFcG9jaEluZm8nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRFcG9jaEluZm9ScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGVwb2NoIGluZm8nKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIEVwb2NoIFNjaGVkdWxlIHBhcmFtZXRlcnNcbiAgICovXG4gIGFzeW5jIGdldEVwb2NoU2NoZWR1bGUoKSB7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0RXBvY2hTY2hlZHVsZScsIFtdKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRFcG9jaFNjaGVkdWxlUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBlcG9jaCBzY2hlZHVsZScpO1xuICAgIH1cbiAgICBjb25zdCBlcG9jaFNjaGVkdWxlID0gcmVzLnJlc3VsdDtcbiAgICByZXR1cm4gbmV3IEVwb2NoU2NoZWR1bGUoZXBvY2hTY2hlZHVsZS5zbG90c1BlckVwb2NoLCBlcG9jaFNjaGVkdWxlLmxlYWRlclNjaGVkdWxlU2xvdE9mZnNldCwgZXBvY2hTY2hlZHVsZS53YXJtdXAsIGVwb2NoU2NoZWR1bGUuZmlyc3ROb3JtYWxFcG9jaCwgZXBvY2hTY2hlZHVsZS5maXJzdE5vcm1hbFNsb3QpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBsZWFkZXIgc2NoZWR1bGUgZm9yIHRoZSBjdXJyZW50IGVwb2NoXG4gICAqIEByZXR1cm4ge1Byb21pc2U8UnBjUmVzcG9uc2VBbmRDb250ZXh0PExlYWRlclNjaGVkdWxlPj59XG4gICAqL1xuICBhc3luYyBnZXRMZWFkZXJTY2hlZHVsZSgpIHtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRMZWFkZXJTY2hlZHVsZScsIFtdKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRMZWFkZXJTY2hlZHVsZVJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgbGVhZGVyIHNjaGVkdWxlJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBtaW5pbXVtIGJhbGFuY2UgbmVlZGVkIHRvIGV4ZW1wdCBhbiBhY2NvdW50IG9mIGBkYXRhTGVuZ3RoYFxuICAgKiBzaXplIGZyb20gcmVudFxuICAgKi9cbiAgYXN5bmMgZ2V0TWluaW11bUJhbGFuY2VGb3JSZW50RXhlbXB0aW9uKGRhdGFMZW5ndGgsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtkYXRhTGVuZ3RoXSwgY29tbWl0bWVudCk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0TWluaW11bUJhbGFuY2VGb3JSZW50RXhlbXB0aW9uJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0TWluaW11bUJhbGFuY2VGb3JSZW50RXhlbXB0aW9uUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIGNvbnNvbGUud2FybignVW5hYmxlIHRvIGZldGNoIG1pbmltdW0gYmFsYW5jZSBmb3IgcmVudCBleGVtcHRpb24nKTtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhIHJlY2VudCBibG9ja2hhc2ggZnJvbSB0aGUgY2x1c3RlciwgcmV0dXJuIHdpdGggY29udGV4dFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPFJwY1Jlc3BvbnNlQW5kQ29udGV4dDx7YmxvY2toYXNoOiBCbG9ja2hhc2gsIGZlZUNhbGN1bGF0b3I6IEZlZUNhbGN1bGF0b3J9Pj59XG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgUlBDIHYxLjkuMC4gUGxlYXNlIHVzZSB7QGxpbmsgZ2V0TGF0ZXN0QmxvY2toYXNofSBpbnN0ZWFkLlxuICAgKi9cbiAgYXN5bmMgZ2V0UmVjZW50QmxvY2toYXNoQW5kQ29udGV4dChjb21taXRtZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgY29udGV4dCxcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIGJsb2NraGFzaFxuICAgICAgfVxuICAgIH0gPSBhd2FpdCB0aGlzLmdldExhdGVzdEJsb2NraGFzaEFuZENvbnRleHQoY29tbWl0bWVudCk7XG4gICAgY29uc3QgZmVlQ2FsY3VsYXRvciA9IHtcbiAgICAgIGdldCBsYW1wb3J0c1BlclNpZ25hdHVyZSgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY2FwYWJpbGl0eSB0byBmZXRjaCBgbGFtcG9ydHNQZXJTaWduYXR1cmVgIHVzaW5nIHRoZSBgZ2V0UmVjZW50QmxvY2toYXNoYCBBUEkgaXMgJyArICdubyBsb25nZXIgb2ZmZXJlZCBieSB0aGUgbmV0d29yay4gVXNlIHRoZSBgZ2V0RmVlRm9yTWVzc2FnZWAgQVBJIHRvIG9idGFpbiB0aGUgZmVlICcgKyAnZm9yIGEgZ2l2ZW4gbWVzc2FnZS4nKTtcbiAgICAgIH0sXG4gICAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICBjb250ZXh0LFxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgYmxvY2toYXNoLFxuICAgICAgICBmZWVDYWxjdWxhdG9yXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCByZWNlbnQgcGVyZm9ybWFuY2Ugc2FtcGxlc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5PFBlcmZTYW1wbGU+Pn1cbiAgICovXG4gIGFzeW5jIGdldFJlY2VudFBlcmZvcm1hbmNlU2FtcGxlcyhsaW1pdCkge1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFJlY2VudFBlcmZvcm1hbmNlU2FtcGxlcycsIGxpbWl0ID8gW2xpbWl0XSA6IFtdKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRSZWNlbnRQZXJmb3JtYW5jZVNhbXBsZXNScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHJlY2VudCBwZXJmb3JtYW5jZSBzYW1wbGVzJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBmZWUgY2FsY3VsYXRvciBmb3IgYSByZWNlbnQgYmxvY2toYXNoIGZyb20gdGhlIGNsdXN0ZXIsIHJldHVybiB3aXRoIGNvbnRleHRcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBSUEMgdjEuOS4wLiBQbGVhc2UgdXNlIHtAbGluayBnZXRGZWVGb3JNZXNzYWdlfSBpbnN0ZWFkLlxuICAgKi9cbiAgYXN5bmMgZ2V0RmVlQ2FsY3VsYXRvckZvckJsb2NraGFzaChibG9ja2hhc2gsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtibG9ja2hhc2hdLCBjb21taXRtZW50KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRGZWVDYWxjdWxhdG9yRm9yQmxvY2toYXNoJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0RmVlQ2FsY3VsYXRvclJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgZmVlIGNhbGN1bGF0b3InKTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgY29udGV4dCxcbiAgICAgIHZhbHVlXG4gICAgfSA9IHJlcy5yZXN1bHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRleHQsXG4gICAgICB2YWx1ZTogdmFsdWUgIT09IG51bGwgPyB2YWx1ZS5mZWVDYWxjdWxhdG9yIDogbnVsbFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGZlZSBmb3IgYSBtZXNzYWdlIGZyb20gdGhlIGNsdXN0ZXIsIHJldHVybiB3aXRoIGNvbnRleHRcbiAgICovXG4gIGFzeW5jIGdldEZlZUZvck1lc3NhZ2UobWVzc2FnZSwgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IHdpcmVNZXNzYWdlID0gdG9CdWZmZXIobWVzc2FnZS5zZXJpYWxpemUoKSkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3dpcmVNZXNzYWdlXSwgY29tbWl0bWVudCk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0RmVlRm9yTWVzc2FnZScsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KG51bGxhYmxlKG51bWJlcigpKSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGZlZSBmb3IgbWVzc2FnZScpO1xuICAgIH1cbiAgICBpZiAocmVzLnJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGJsb2NraGFzaCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhIGxpc3Qgb2YgcHJpb3JpdGl6YXRpb24gZmVlcyBmcm9tIHJlY2VudCBibG9ja3MuXG4gICAqL1xuICBhc3luYyBnZXRSZWNlbnRQcmlvcml0aXphdGlvbkZlZXMoY29uZmlnKSB7XG4gICAgY29uc3QgYWNjb3VudHMgPSBjb25maWc/LmxvY2tlZFdyaXRhYmxlQWNjb3VudHM/Lm1hcChrZXkgPT4ga2V5LnRvQmFzZTU4KCkpO1xuICAgIGNvbnN0IGFyZ3MgPSBhY2NvdW50cz8ubGVuZ3RoID8gW2FjY291bnRzXSA6IFtdO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFJlY2VudFByaW9yaXRpemF0aW9uRmVlcycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFJlY2VudFByaW9yaXRpemF0aW9uRmVlc1JwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgcmVjZW50IHByaW9yaXRpemF0aW9uIGZlZXMnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoIGEgcmVjZW50IGJsb2NraGFzaCBmcm9tIHRoZSBjbHVzdGVyXG4gICAqIEByZXR1cm4ge1Byb21pc2U8e2Jsb2NraGFzaDogQmxvY2toYXNoLCBmZWVDYWxjdWxhdG9yOiBGZWVDYWxjdWxhdG9yfT59XG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgUlBDIHYxLjguMC4gUGxlYXNlIHVzZSB7QGxpbmsgZ2V0TGF0ZXN0QmxvY2toYXNofSBpbnN0ZWFkLlxuICAgKi9cbiAgYXN5bmMgZ2V0UmVjZW50QmxvY2toYXNoKGNvbW1pdG1lbnQpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5nZXRSZWNlbnRCbG9ja2hhc2hBbmRDb250ZXh0KGNvbW1pdG1lbnQpO1xuICAgICAgcmV0dXJuIHJlcy52YWx1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZhaWxlZCB0byBnZXQgcmVjZW50IGJsb2NraGFzaDogJyArIGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgbGF0ZXN0IGJsb2NraGFzaCBmcm9tIHRoZSBjbHVzdGVyXG4gICAqIEByZXR1cm4ge1Byb21pc2U8QmxvY2toYXNoV2l0aEV4cGlyeUJsb2NrSGVpZ2h0Pn1cbiAgICovXG4gIGFzeW5jIGdldExhdGVzdEJsb2NraGFzaChjb21taXRtZW50T3JDb25maWcpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5nZXRMYXRlc3RCbG9ja2hhc2hBbmRDb250ZXh0KGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgICByZXR1cm4gcmVzLnZhbHVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZmFpbGVkIHRvIGdldCByZWNlbnQgYmxvY2toYXNoOiAnICsgZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBsYXRlc3QgYmxvY2toYXNoIGZyb20gdGhlIGNsdXN0ZXJcbiAgICogQHJldHVybiB7UHJvbWlzZTxCbG9ja2hhc2hXaXRoRXhwaXJ5QmxvY2tIZWlnaHQ+fVxuICAgKi9cbiAgYXN5bmMgZ2V0TGF0ZXN0QmxvY2toYXNoQW5kQ29udGV4dChjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW10sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRMYXRlc3RCbG9ja2hhc2gnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRMYXRlc3RCbG9ja2hhc2hScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGxhdGVzdCBibG9ja2hhc2gnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIGEgYmxvY2toYXNoIGlzIHN0aWxsIHZhbGlkIG9yIG5vdFxuICAgKi9cbiAgYXN5bmMgaXNCbG9ja2hhc2hWYWxpZChibG9ja2hhc2gsIHJhd0NvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKHJhd0NvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbYmxvY2toYXNoXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2lzQmxvY2toYXNoVmFsaWQnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBJc0Jsb2NraGFzaFZhbGlkUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGRldGVybWluZSBpZiB0aGUgYmxvY2toYXNoIGAnICsgYmxvY2toYXNoICsgJ2BpcyB2YWxpZCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgbm9kZSB2ZXJzaW9uXG4gICAqL1xuICBhc3luYyBnZXRWZXJzaW9uKCkge1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFZlcnNpb24nLCBbXSk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChWZXJzaW9uUmVzdWx0KSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgdmVyc2lvbicpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgZ2VuZXNpcyBoYXNoXG4gICAqL1xuICBhc3luYyBnZXRHZW5lc2lzSGFzaCgpIHtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRHZW5lc2lzSGFzaCcsIFtdKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KHN0cmluZygpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgZ2VuZXNpcyBoYXNoJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGEgcHJvY2Vzc2VkIGJsb2NrIGZyb20gdGhlIGNsdXN0ZXIuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIEluc3RlYWQsIGNhbGwgYGdldEJsb2NrYCB1c2luZyBhIGBHZXRWZXJzaW9uZWRCbG9ja0NvbmZpZ2AgYnlcbiAgICogc2V0dGluZyB0aGUgYG1heFN1cHBvcnRlZFRyYW5zYWN0aW9uVmVyc2lvbmAgcHJvcGVydHkuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBJbnN0ZWFkLCBjYWxsIGBnZXRCbG9ja2AgdXNpbmcgYSBgR2V0VmVyc2lvbmVkQmxvY2tDb25maWdgIGJ5XG4gICAqIHNldHRpbmcgdGhlIGBtYXhTdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb25gIHByb3BlcnR5LlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBJbnN0ZWFkLCBjYWxsIGBnZXRCbG9ja2AgdXNpbmcgYSBgR2V0VmVyc2lvbmVkQmxvY2tDb25maWdgIGJ5XG4gICAqIHNldHRpbmcgdGhlIGBtYXhTdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb25gIHByb3BlcnR5LlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuXG4gIC8qKlxuICAgKiBGZXRjaCBhIHByb2Nlc3NlZCBibG9jayBmcm9tIHRoZSBjbHVzdGVyLlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG5cbiAgLyoqXG4gICAqIEZldGNoIGEgcHJvY2Vzc2VkIGJsb2NrIGZyb20gdGhlIGNsdXN0ZXIuXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG4gIGFzeW5jIGdldEJsb2NrKHNsb3QsIHJhd0NvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKHJhd0NvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW3Nsb3RdLCBjb21taXRtZW50LCB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0QmxvY2snLCBhcmdzKTtcbiAgICB0cnkge1xuICAgICAgc3dpdGNoIChjb25maWc/LnRyYW5zYWN0aW9uRGV0YWlscykge1xuICAgICAgICBjYXNlICdhY2NvdW50cyc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0QWNjb3VudHNNb2RlQmxvY2tScGNSZXN1bHQpO1xuICAgICAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICAgICAgICAgIHRocm93IHJlcy5lcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXMucmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnbm9uZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0Tm9uZU1vZGVCbG9ja1JwY1Jlc3VsdCk7XG4gICAgICAgICAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgICAgICAgICAgdGhyb3cgcmVzLmVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldEJsb2NrUnBjUmVzdWx0KTtcbiAgICAgICAgICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgICAgICAgICB0aHJvdyByZXMuZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIHJlc3VsdFxuICAgICAgICAgICAgfSA9IHJlcztcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgPyB7XG4gICAgICAgICAgICAgIC4uLnJlc3VsdCxcbiAgICAgICAgICAgICAgdHJhbnNhY3Rpb25zOiByZXN1bHQudHJhbnNhY3Rpb25zLm1hcCgoe1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgICAgIG1ldGEsXG4gICAgICAgICAgICAgICAgdmVyc2lvblxuICAgICAgICAgICAgICB9KSA9PiAoe1xuICAgICAgICAgICAgICAgIG1ldGEsXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IHtcbiAgICAgICAgICAgICAgICAgIC4uLnRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogdmVyc2lvbmVkTWVzc2FnZUZyb21SZXNwb25zZSh2ZXJzaW9uLCB0cmFuc2FjdGlvbi5tZXNzYWdlKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdmVyc2lvblxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIH0gOiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKGUsICdmYWlsZWQgdG8gZ2V0IGNvbmZpcm1lZCBibG9jaycpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBwYXJzZWQgdHJhbnNhY3Rpb24gZGV0YWlscyBmb3IgYSBjb25maXJtZWQgb3IgZmluYWxpemVkIGJsb2NrXG4gICAqL1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuICBhc3luYyBnZXRQYXJzZWRCbG9jayhzbG90LCByYXdDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhyYXdDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFtzbG90XSwgY29tbWl0bWVudCwgJ2pzb25QYXJzZWQnLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEJsb2NrJywgYXJncyk7XG4gICAgdHJ5IHtcbiAgICAgIHN3aXRjaCAoY29uZmlnPy50cmFuc2FjdGlvbkRldGFpbHMpIHtcbiAgICAgICAgY2FzZSAnYWNjb3VudHMnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFBhcnNlZEFjY291bnRzTW9kZUJsb2NrUnBjUmVzdWx0KTtcbiAgICAgICAgICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgICAgICAgICB0aHJvdyByZXMuZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ25vbmUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFBhcnNlZE5vbmVNb2RlQmxvY2tScGNSZXN1bHQpO1xuICAgICAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICAgICAgICAgIHRocm93IHJlcy5lcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXMucmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRQYXJzZWRCbG9ja1JwY1Jlc3VsdCk7XG4gICAgICAgICAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgICAgICAgICAgdGhyb3cgcmVzLmVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IoZSwgJ2ZhaWxlZCB0byBnZXQgYmxvY2snKTtcbiAgICB9XG4gIH1cbiAgLypcbiAgICogUmV0dXJucyByZWNlbnQgYmxvY2sgcHJvZHVjdGlvbiBpbmZvcm1hdGlvbiBmcm9tIHRoZSBjdXJyZW50IG9yIHByZXZpb3VzIGVwb2NoXG4gICAqL1xuICBhc3luYyBnZXRCbG9ja1Byb2R1Y3Rpb24oY29uZmlnT3JDb21taXRtZW50KSB7XG4gICAgbGV0IGV4dHJhO1xuICAgIGxldCBjb21taXRtZW50O1xuICAgIGlmICh0eXBlb2YgY29uZmlnT3JDb21taXRtZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgY29tbWl0bWVudCA9IGNvbmZpZ09yQ29tbWl0bWVudDtcbiAgICB9IGVsc2UgaWYgKGNvbmZpZ09yQ29tbWl0bWVudCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjb21taXRtZW50OiBjLFxuICAgICAgICAuLi5yZXN0XG4gICAgICB9ID0gY29uZmlnT3JDb21taXRtZW50O1xuICAgICAgY29tbWl0bWVudCA9IGM7XG4gICAgICBleHRyYSA9IHJlc3Q7XG4gICAgfVxuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW10sIGNvbW1pdG1lbnQsICdiYXNlNjQnLCBleHRyYSk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0QmxvY2tQcm9kdWN0aW9uJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgQmxvY2tQcm9kdWN0aW9uUmVzcG9uc2VTdHJ1Y3QpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGJsb2NrIHByb2R1Y3Rpb24gaW5mb3JtYXRpb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYSBjb25maXJtZWQgb3IgZmluYWxpemVkIHRyYW5zYWN0aW9uIGZyb20gdGhlIGNsdXN0ZXIuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIEluc3RlYWQsIGNhbGwgYGdldFRyYW5zYWN0aW9uYCB1c2luZyBhXG4gICAqIGBHZXRWZXJzaW9uZWRUcmFuc2FjdGlvbkNvbmZpZ2AgYnkgc2V0dGluZyB0aGVcbiAgICogYG1heFN1cHBvcnRlZFRyYW5zYWN0aW9uVmVyc2lvbmAgcHJvcGVydHkuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBGZXRjaCBhIGNvbmZpcm1lZCBvciBmaW5hbGl6ZWQgdHJhbnNhY3Rpb24gZnJvbSB0aGUgY2x1c3Rlci5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvKipcbiAgICogRmV0Y2ggYSBjb25maXJtZWQgb3IgZmluYWxpemVkIHRyYW5zYWN0aW9uIGZyb20gdGhlIGNsdXN0ZXIuXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG4gIGFzeW5jIGdldFRyYW5zYWN0aW9uKHNpZ25hdHVyZSwgcmF3Q29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcocmF3Q29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbc2lnbmF0dXJlXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFRyYW5zYWN0aW9uJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0VHJhbnNhY3Rpb25ScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHRyYW5zYWN0aW9uJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHJlcy5yZXN1bHQ7XG4gICAgaWYgKCFyZXN1bHQpIHJldHVybiByZXN1bHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJlc3VsdCxcbiAgICAgIHRyYW5zYWN0aW9uOiB7XG4gICAgICAgIC4uLnJlc3VsdC50cmFuc2FjdGlvbixcbiAgICAgICAgbWVzc2FnZTogdmVyc2lvbmVkTWVzc2FnZUZyb21SZXNwb25zZShyZXN1bHQudmVyc2lvbiwgcmVzdWx0LnRyYW5zYWN0aW9uLm1lc3NhZ2UpXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBwYXJzZWQgdHJhbnNhY3Rpb24gZGV0YWlscyBmb3IgYSBjb25maXJtZWQgb3IgZmluYWxpemVkIHRyYW5zYWN0aW9uXG4gICAqL1xuICBhc3luYyBnZXRQYXJzZWRUcmFuc2FjdGlvbihzaWduYXR1cmUsIGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW3NpZ25hdHVyZV0sIGNvbW1pdG1lbnQsICdqc29uUGFyc2VkJywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRUcmFuc2FjdGlvbicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFBhcnNlZFRyYW5zYWN0aW9uUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCB0cmFuc2FjdGlvbicpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBwYXJzZWQgdHJhbnNhY3Rpb24gZGV0YWlscyBmb3IgYSBiYXRjaCBvZiBjb25maXJtZWQgdHJhbnNhY3Rpb25zXG4gICAqL1xuICBhc3luYyBnZXRQYXJzZWRUcmFuc2FjdGlvbnMoc2lnbmF0dXJlcywgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBiYXRjaCA9IHNpZ25hdHVyZXMubWFwKHNpZ25hdHVyZSA9PiB7XG4gICAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbc2lnbmF0dXJlXSwgY29tbWl0bWVudCwgJ2pzb25QYXJzZWQnLCBjb25maWcpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWV0aG9kTmFtZTogJ2dldFRyYW5zYWN0aW9uJyxcbiAgICAgICAgYXJnc1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNCYXRjaFJlcXVlc3QoYmF0Y2gpO1xuICAgIGNvbnN0IHJlcyA9IHVuc2FmZVJlcy5tYXAodW5zYWZlUmVzID0+IHtcbiAgICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFBhcnNlZFRyYW5zYWN0aW9uUnBjUmVzdWx0KTtcbiAgICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgdHJhbnNhY3Rpb25zJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRyYW5zYWN0aW9uIGRldGFpbHMgZm9yIGEgYmF0Y2ggb2YgY29uZmlybWVkIHRyYW5zYWN0aW9ucy5cbiAgICogU2ltaWxhciB0byB7QGxpbmsgZ2V0UGFyc2VkVHJhbnNhY3Rpb25zfSBidXQgcmV0dXJucyBhIHtAbGluayBUcmFuc2FjdGlvblJlc3BvbnNlfS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgSW5zdGVhZCwgY2FsbCBgZ2V0VHJhbnNhY3Rpb25zYCB1c2luZyBhXG4gICAqIGBHZXRWZXJzaW9uZWRUcmFuc2FjdGlvbkNvbmZpZ2AgYnkgc2V0dGluZyB0aGVcbiAgICogYG1heFN1cHBvcnRlZFRyYW5zYWN0aW9uVmVyc2lvbmAgcHJvcGVydHkuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBGZXRjaCB0cmFuc2FjdGlvbiBkZXRhaWxzIGZvciBhIGJhdGNoIG9mIGNvbmZpcm1lZCB0cmFuc2FjdGlvbnMuXG4gICAqIFNpbWlsYXIgdG8ge0BsaW5rIGdldFBhcnNlZFRyYW5zYWN0aW9uc30gYnV0IHJldHVybnMgYSB7QGxpbmtcbiAgICogVmVyc2lvbmVkVHJhbnNhY3Rpb25SZXNwb25zZX0uXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG5cbiAgLyoqXG4gICAqIEZldGNoIHRyYW5zYWN0aW9uIGRldGFpbHMgZm9yIGEgYmF0Y2ggb2YgY29uZmlybWVkIHRyYW5zYWN0aW9ucy5cbiAgICogU2ltaWxhciB0byB7QGxpbmsgZ2V0UGFyc2VkVHJhbnNhY3Rpb25zfSBidXQgcmV0dXJucyBhIHtAbGlua1xuICAgKiBWZXJzaW9uZWRUcmFuc2FjdGlvblJlc3BvbnNlfS5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25zKHNpZ25hdHVyZXMsIGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3QgYmF0Y2ggPSBzaWduYXR1cmVzLm1hcChzaWduYXR1cmUgPT4ge1xuICAgICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW3NpZ25hdHVyZV0sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywgY29uZmlnKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1ldGhvZE5hbWU6ICdnZXRUcmFuc2FjdGlvbicsXG4gICAgICAgIGFyZ3NcbiAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjQmF0Y2hSZXF1ZXN0KGJhdGNoKTtcbiAgICBjb25zdCByZXMgPSB1bnNhZmVSZXMubWFwKHVuc2FmZVJlcyA9PiB7XG4gICAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRUcmFuc2FjdGlvblJwY1Jlc3VsdCk7XG4gICAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHRyYW5zYWN0aW9ucycpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gcmVzLnJlc3VsdDtcbiAgICAgIGlmICghcmVzdWx0KSByZXR1cm4gcmVzdWx0O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucmVzdWx0LFxuICAgICAgICB0cmFuc2FjdGlvbjoge1xuICAgICAgICAgIC4uLnJlc3VsdC50cmFuc2FjdGlvbixcbiAgICAgICAgICBtZXNzYWdlOiB2ZXJzaW9uZWRNZXNzYWdlRnJvbVJlc3BvbnNlKHJlc3VsdC52ZXJzaW9uLCByZXN1bHQudHJhbnNhY3Rpb24ubWVzc2FnZSlcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGEgbGlzdCBvZiBUcmFuc2FjdGlvbnMgYW5kIHRyYW5zYWN0aW9uIHN0YXR1c2VzIGZyb20gdGhlIGNsdXN0ZXJcbiAgICogZm9yIGEgY29uZmlybWVkIGJsb2NrLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFJQQyB2MS43LjAuIFBsZWFzZSB1c2Uge0BsaW5rIGdldEJsb2NrfSBpbnN0ZWFkLlxuICAgKi9cbiAgYXN5bmMgZ2V0Q29uZmlybWVkQmxvY2soc2xvdCwgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFtzbG90XSwgY29tbWl0bWVudCk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0QmxvY2snLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRDb25maXJtZWRCbG9ja1JwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgY29uZmlybWVkIGJsb2NrJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHJlcy5yZXN1bHQ7XG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ29uZmlybWVkIGJsb2NrICcgKyBzbG90ICsgJyBub3QgZm91bmQnKTtcbiAgICB9XG4gICAgY29uc3QgYmxvY2sgPSB7XG4gICAgICAuLi5yZXN1bHQsXG4gICAgICB0cmFuc2FjdGlvbnM6IHJlc3VsdC50cmFuc2FjdGlvbnMubWFwKCh7XG4gICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICBtZXRhXG4gICAgICB9KSA9PiB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBuZXcgTWVzc2FnZSh0cmFuc2FjdGlvbi5tZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtZXRhLFxuICAgICAgICAgIHRyYW5zYWN0aW9uOiB7XG4gICAgICAgICAgICAuLi50cmFuc2FjdGlvbixcbiAgICAgICAgICAgIG1lc3NhZ2VcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmJsb2NrLFxuICAgICAgdHJhbnNhY3Rpb25zOiBibG9jay50cmFuc2FjdGlvbnMubWFwKCh7XG4gICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICBtZXRhXG4gICAgICB9KSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbWV0YSxcbiAgICAgICAgICB0cmFuc2FjdGlvbjogVHJhbnNhY3Rpb24ucG9wdWxhdGUodHJhbnNhY3Rpb24ubWVzc2FnZSwgdHJhbnNhY3Rpb24uc2lnbmF0dXJlcylcbiAgICAgICAgfTtcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBjb25maXJtZWQgYmxvY2tzIGJldHdlZW4gdHdvIHNsb3RzXG4gICAqL1xuICBhc3luYyBnZXRCbG9ja3Moc3RhcnRTbG90LCBlbmRTbG90LCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoZW5kU2xvdCAhPT0gdW5kZWZpbmVkID8gW3N0YXJ0U2xvdCwgZW5kU2xvdF0gOiBbc3RhcnRTbG90XSwgY29tbWl0bWVudCk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0QmxvY2tzJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChhcnJheShudW1iZXIoKSkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBibG9ja3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYSBsaXN0IG9mIFNpZ25hdHVyZXMgZnJvbSB0aGUgY2x1c3RlciBmb3IgYSBibG9jaywgZXhjbHVkaW5nIHJld2FyZHNcbiAgICovXG4gIGFzeW5jIGdldEJsb2NrU2lnbmF0dXJlcyhzbG90LCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW3Nsb3RdLCBjb21taXRtZW50LCB1bmRlZmluZWQsIHtcbiAgICAgIHRyYW5zYWN0aW9uRGV0YWlsczogJ3NpZ25hdHVyZXMnLFxuICAgICAgcmV3YXJkczogZmFsc2VcbiAgICB9KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRCbG9jaycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldEJsb2NrU2lnbmF0dXJlc1JwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgYmxvY2snKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gcmVzLnJlc3VsdDtcbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCbG9jayAnICsgc2xvdCArICcgbm90IGZvdW5kJyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYSBsaXN0IG9mIFNpZ25hdHVyZXMgZnJvbSB0aGUgY2x1c3RlciBmb3IgYSBjb25maXJtZWQgYmxvY2ssIGV4Y2x1ZGluZyByZXdhcmRzXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgUlBDIHYxLjcuMC4gUGxlYXNlIHVzZSB7QGxpbmsgZ2V0QmxvY2tTaWduYXR1cmVzfSBpbnN0ZWFkLlxuICAgKi9cbiAgYXN5bmMgZ2V0Q29uZmlybWVkQmxvY2tTaWduYXR1cmVzKHNsb3QsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbc2xvdF0sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCwge1xuICAgICAgdHJhbnNhY3Rpb25EZXRhaWxzOiAnc2lnbmF0dXJlcycsXG4gICAgICByZXdhcmRzOiBmYWxzZVxuICAgIH0pO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEJsb2NrJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0QmxvY2tTaWduYXR1cmVzUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBjb25maXJtZWQgYmxvY2snKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gcmVzLnJlc3VsdDtcbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb25maXJtZWQgYmxvY2sgJyArIHNsb3QgKyAnIG5vdCBmb3VuZCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGEgdHJhbnNhY3Rpb24gZGV0YWlscyBmb3IgYSBjb25maXJtZWQgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBSUEMgdjEuNy4wLiBQbGVhc2UgdXNlIHtAbGluayBnZXRUcmFuc2FjdGlvbn0gaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIGdldENvbmZpcm1lZFRyYW5zYWN0aW9uKHNpZ25hdHVyZSwgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFtzaWduYXR1cmVdLCBjb21taXRtZW50KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRUcmFuc2FjdGlvbicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFRyYW5zYWN0aW9uUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCB0cmFuc2FjdGlvbicpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSByZXMucmVzdWx0O1xuICAgIGlmICghcmVzdWx0KSByZXR1cm4gcmVzdWx0O1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBuZXcgTWVzc2FnZShyZXN1bHQudHJhbnNhY3Rpb24ubWVzc2FnZSk7XG4gICAgY29uc3Qgc2lnbmF0dXJlcyA9IHJlc3VsdC50cmFuc2FjdGlvbi5zaWduYXR1cmVzO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5yZXN1bHQsXG4gICAgICB0cmFuc2FjdGlvbjogVHJhbnNhY3Rpb24ucG9wdWxhdGUobWVzc2FnZSwgc2lnbmF0dXJlcylcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHBhcnNlZCB0cmFuc2FjdGlvbiBkZXRhaWxzIGZvciBhIGNvbmZpcm1lZCB0cmFuc2FjdGlvblxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFJQQyB2MS43LjAuIFBsZWFzZSB1c2Uge0BsaW5rIGdldFBhcnNlZFRyYW5zYWN0aW9ufSBpbnN0ZWFkLlxuICAgKi9cbiAgYXN5bmMgZ2V0UGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb24oc2lnbmF0dXJlLCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW3NpZ25hdHVyZV0sIGNvbW1pdG1lbnQsICdqc29uUGFyc2VkJyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0VHJhbnNhY3Rpb24nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRQYXJzZWRUcmFuc2FjdGlvblJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgY29uZmlybWVkIHRyYW5zYWN0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHBhcnNlZCB0cmFuc2FjdGlvbiBkZXRhaWxzIGZvciBhIGJhdGNoIG9mIGNvbmZpcm1lZCB0cmFuc2FjdGlvbnNcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBSUEMgdjEuNy4wLiBQbGVhc2UgdXNlIHtAbGluayBnZXRQYXJzZWRUcmFuc2FjdGlvbnN9IGluc3RlYWQuXG4gICAqL1xuICBhc3luYyBnZXRQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvbnMoc2lnbmF0dXJlcywgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGJhdGNoID0gc2lnbmF0dXJlcy5tYXAoc2lnbmF0dXJlID0+IHtcbiAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFtzaWduYXR1cmVdLCBjb21taXRtZW50LCAnanNvblBhcnNlZCcpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWV0aG9kTmFtZTogJ2dldFRyYW5zYWN0aW9uJyxcbiAgICAgICAgYXJnc1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNCYXRjaFJlcXVlc3QoYmF0Y2gpO1xuICAgIGNvbnN0IHJlcyA9IHVuc2FmZVJlcy5tYXAodW5zYWZlUmVzID0+IHtcbiAgICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFBhcnNlZFRyYW5zYWN0aW9uUnBjUmVzdWx0KTtcbiAgICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgY29uZmlybWVkIHRyYW5zYWN0aW9ucycpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhIGxpc3Qgb2YgYWxsIHRoZSBjb25maXJtZWQgc2lnbmF0dXJlcyBmb3IgdHJhbnNhY3Rpb25zIGludm9sdmluZyBhbiBhZGRyZXNzXG4gICAqIHdpdGhpbiBhIHNwZWNpZmllZCBzbG90IHJhbmdlLiBNYXggcmFuZ2UgYWxsb3dlZCBpcyAxMCwwMDAgc2xvdHMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgUlBDIHYxLjMuIFBsZWFzZSB1c2Uge0BsaW5rIGdldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzMn0gaW5zdGVhZC5cbiAgICpcbiAgICogQHBhcmFtIGFkZHJlc3MgcXVlcmllZCBhZGRyZXNzXG4gICAqIEBwYXJhbSBzdGFydFNsb3Qgc3RhcnQgc2xvdCwgaW5jbHVzaXZlXG4gICAqIEBwYXJhbSBlbmRTbG90IGVuZCBzbG90LCBpbmNsdXNpdmVcbiAgICovXG4gIGFzeW5jIGdldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzKGFkZHJlc3MsIHN0YXJ0U2xvdCwgZW5kU2xvdCkge1xuICAgIGxldCBvcHRpb25zID0ge307XG4gICAgbGV0IGZpcnN0QXZhaWxhYmxlQmxvY2sgPSBhd2FpdCB0aGlzLmdldEZpcnN0QXZhaWxhYmxlQmxvY2soKTtcbiAgICB3aGlsZSAoISgndW50aWwnIGluIG9wdGlvbnMpKSB7XG4gICAgICBzdGFydFNsb3QtLTtcbiAgICAgIGlmIChzdGFydFNsb3QgPD0gMCB8fCBzdGFydFNsb3QgPCBmaXJzdEF2YWlsYWJsZUJsb2NrKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYmxvY2sgPSBhd2FpdCB0aGlzLmdldENvbmZpcm1lZEJsb2NrU2lnbmF0dXJlcyhzdGFydFNsb3QsICdmaW5hbGl6ZWQnKTtcbiAgICAgICAgaWYgKGJsb2NrLnNpZ25hdHVyZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIG9wdGlvbnMudW50aWwgPSBibG9jay5zaWduYXR1cmVzW2Jsb2NrLnNpZ25hdHVyZXMubGVuZ3RoIC0gMV0udG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnIubWVzc2FnZS5pbmNsdWRlcygnc2tpcHBlZCcpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBoaWdoZXN0Q29uZmlybWVkUm9vdCA9IGF3YWl0IHRoaXMuZ2V0U2xvdCgnZmluYWxpemVkJyk7XG4gICAgd2hpbGUgKCEoJ2JlZm9yZScgaW4gb3B0aW9ucykpIHtcbiAgICAgIGVuZFNsb3QrKztcbiAgICAgIGlmIChlbmRTbG90ID4gaGlnaGVzdENvbmZpcm1lZFJvb3QpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBibG9jayA9IGF3YWl0IHRoaXMuZ2V0Q29uZmlybWVkQmxvY2tTaWduYXR1cmVzKGVuZFNsb3QpO1xuICAgICAgICBpZiAoYmxvY2suc2lnbmF0dXJlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgb3B0aW9ucy5iZWZvcmUgPSBibG9jay5zaWduYXR1cmVzW2Jsb2NrLnNpZ25hdHVyZXMubGVuZ3RoIC0gMV0udG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnIubWVzc2FnZS5pbmNsdWRlcygnc2tpcHBlZCcpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNvbmZpcm1lZFNpZ25hdHVyZUluZm8gPSBhd2FpdCB0aGlzLmdldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzMihhZGRyZXNzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gY29uZmlybWVkU2lnbmF0dXJlSW5mby5tYXAoaW5mbyA9PiBpbmZvLnNpZ25hdHVyZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBjb25maXJtZWQgc2lnbmF0dXJlcyBmb3IgdHJhbnNhY3Rpb25zIGludm9sdmluZyBhblxuICAgKiBhZGRyZXNzIGJhY2t3YXJkcyBpbiB0aW1lIGZyb20gdGhlIHByb3ZpZGVkIHNpZ25hdHVyZSBvciBtb3N0IHJlY2VudCBjb25maXJtZWQgYmxvY2tcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBSUEMgdjEuNy4wLiBQbGVhc2UgdXNlIHtAbGluayBnZXRTaWduYXR1cmVzRm9yQWRkcmVzc30gaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIGdldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzMihhZGRyZXNzLCBvcHRpb25zLCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW2FkZHJlc3MudG9CYXNlNTgoKV0sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCwgb3B0aW9ucyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0Q29uZmlybWVkU2lnbmF0dXJlc0ZvckFkZHJlc3MyJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0Q29uZmlybWVkU2lnbmF0dXJlc0ZvckFkZHJlc3MyUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBjb25maXJtZWQgc2lnbmF0dXJlcyBmb3IgYWRkcmVzcycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGNvbmZpcm1lZCBzaWduYXR1cmVzIGZvciB0cmFuc2FjdGlvbnMgaW52b2x2aW5nIGFuXG4gICAqIGFkZHJlc3MgYmFja3dhcmRzIGluIHRpbWUgZnJvbSB0aGUgcHJvdmlkZWQgc2lnbmF0dXJlIG9yIG1vc3QgcmVjZW50IGNvbmZpcm1lZCBibG9ja1xuICAgKlxuICAgKlxuICAgKiBAcGFyYW0gYWRkcmVzcyBxdWVyaWVkIGFkZHJlc3NcbiAgICogQHBhcmFtIG9wdGlvbnNcbiAgICovXG4gIGFzeW5jIGdldFNpZ25hdHVyZXNGb3JBZGRyZXNzKGFkZHJlc3MsIG9wdGlvbnMsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbYWRkcmVzcy50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkLCBvcHRpb25zKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRTaWduYXR1cmVzRm9yQWRkcmVzcycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFNpZ25hdHVyZXNGb3JBZGRyZXNzUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBzaWduYXR1cmVzIGZvciBhZGRyZXNzJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG4gIGFzeW5jIGdldEFkZHJlc3NMb29rdXBUYWJsZShhY2NvdW50S2V5LCBjb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb250ZXh0LFxuICAgICAgdmFsdWU6IGFjY291bnRJbmZvXG4gICAgfSA9IGF3YWl0IHRoaXMuZ2V0QWNjb3VudEluZm9BbmRDb250ZXh0KGFjY291bnRLZXksIGNvbmZpZyk7XG4gICAgbGV0IHZhbHVlID0gbnVsbDtcbiAgICBpZiAoYWNjb3VudEluZm8gIT09IG51bGwpIHtcbiAgICAgIHZhbHVlID0gbmV3IEFkZHJlc3NMb29rdXBUYWJsZUFjY291bnQoe1xuICAgICAgICBrZXk6IGFjY291bnRLZXksXG4gICAgICAgIHN0YXRlOiBBZGRyZXNzTG9va3VwVGFibGVBY2NvdW50LmRlc2VyaWFsaXplKGFjY291bnRJbmZvLmRhdGEpXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRleHQsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGNvbnRlbnRzIG9mIGEgTm9uY2UgYWNjb3VudCBmcm9tIHRoZSBjbHVzdGVyLCByZXR1cm4gd2l0aCBjb250ZXh0XG4gICAqL1xuICBhc3luYyBnZXROb25jZUFuZENvbnRleHQobm9uY2VBY2NvdW50LCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb250ZXh0LFxuICAgICAgdmFsdWU6IGFjY291bnRJbmZvXG4gICAgfSA9IGF3YWl0IHRoaXMuZ2V0QWNjb3VudEluZm9BbmRDb250ZXh0KG5vbmNlQWNjb3VudCwgY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBsZXQgdmFsdWUgPSBudWxsO1xuICAgIGlmIChhY2NvdW50SW5mbyAhPT0gbnVsbCkge1xuICAgICAgdmFsdWUgPSBOb25jZUFjY291bnQuZnJvbUFjY291bnREYXRhKGFjY291bnRJbmZvLmRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgY29udGV4dCxcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgY29udGVudHMgb2YgYSBOb25jZSBhY2NvdW50IGZyb20gdGhlIGNsdXN0ZXJcbiAgICovXG4gIGFzeW5jIGdldE5vbmNlKG5vbmNlQWNjb3VudCwgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0Tm9uY2VBbmRDb250ZXh0KG5vbmNlQWNjb3VudCwgY29tbWl0bWVudE9yQ29uZmlnKS50aGVuKHggPT4geC52YWx1ZSkuY2F0Y2goZSA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZhaWxlZCB0byBnZXQgbm9uY2UgZm9yIGFjY291bnQgJyArIG5vbmNlQWNjb3VudC50b0Jhc2U1OCgpICsgJzogJyArIGUpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgYW4gYWxsb2NhdGlvbiBvZiBsYW1wb3J0cyB0byB0aGUgc3BlY2lmaWVkIGFkZHJlc3NcbiAgICpcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBpbXBvcnQgeyBDb25uZWN0aW9uLCBQdWJsaWNLZXksIExBTVBPUlRTX1BFUl9TT0wgfSBmcm9tIFwiQHNvbGFuYS93ZWIzLmpzXCI7XG4gICAqXG4gICAqIChhc3luYyAoKSA9PiB7XG4gICAqICAgY29uc3QgY29ubmVjdGlvbiA9IG5ldyBDb25uZWN0aW9uKFwiaHR0cHM6Ly9hcGkudGVzdG5ldC5zb2xhbmEuY29tXCIsIFwiY29uZmlybWVkXCIpO1xuICAgKiAgIGNvbnN0IG15QWRkcmVzcyA9IG5ldyBQdWJsaWNLZXkoXCIybnIxYkhGVDg2Vzl0R255dm1ZVzR2Y0hLc1FCM3NWUWZuZGRhc3o0a0V4TVwiKTtcbiAgICogICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBjb25uZWN0aW9uLnJlcXVlc3RBaXJkcm9wKG15QWRkcmVzcywgTEFNUE9SVFNfUEVSX1NPTCk7XG4gICAqICAgYXdhaXQgY29ubmVjdGlvbi5jb25maXJtVHJhbnNhY3Rpb24oc2lnbmF0dXJlKTtcbiAgICogfSkoKTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyByZXF1ZXN0QWlyZHJvcCh0bywgbGFtcG9ydHMpIHtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdyZXF1ZXN0QWlyZHJvcCcsIFt0by50b0Jhc2U1OCgpLCBsYW1wb3J0c10pO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIFJlcXVlc3RBaXJkcm9wUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBgYWlyZHJvcCB0byAke3RvLnRvQmFzZTU4KCl9IGZhaWxlZGApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGFzeW5jIF9ibG9ja2hhc2hXaXRoRXhwaXJ5QmxvY2tIZWlnaHQoZGlzYWJsZUNhY2hlKSB7XG4gICAgaWYgKCFkaXNhYmxlQ2FjaGUpIHtcbiAgICAgIC8vIFdhaXQgZm9yIHBvbGxpbmcgdG8gZmluaXNoXG4gICAgICB3aGlsZSAodGhpcy5fcG9sbGluZ0Jsb2NraGFzaCkge1xuICAgICAgICBhd2FpdCBzbGVlcCgxMDApO1xuICAgICAgfVxuICAgICAgY29uc3QgdGltZVNpbmNlRmV0Y2ggPSBEYXRlLm5vdygpIC0gdGhpcy5fYmxvY2toYXNoSW5mby5sYXN0RmV0Y2g7XG4gICAgICBjb25zdCBleHBpcmVkID0gdGltZVNpbmNlRmV0Y2ggPj0gQkxPQ0tIQVNIX0NBQ0hFX1RJTUVPVVRfTVM7XG4gICAgICBpZiAodGhpcy5fYmxvY2toYXNoSW5mby5sYXRlc3RCbG9ja2hhc2ggIT09IG51bGwgJiYgIWV4cGlyZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Jsb2NraGFzaEluZm8ubGF0ZXN0QmxvY2toYXNoO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5fcG9sbE5ld0Jsb2NraGFzaCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgYXN5bmMgX3BvbGxOZXdCbG9ja2hhc2goKSB7XG4gICAgdGhpcy5fcG9sbGluZ0Jsb2NraGFzaCA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICBjb25zdCBjYWNoZWRMYXRlc3RCbG9ja2hhc2ggPSB0aGlzLl9ibG9ja2hhc2hJbmZvLmxhdGVzdEJsb2NraGFzaDtcbiAgICAgIGNvbnN0IGNhY2hlZEJsb2NraGFzaCA9IGNhY2hlZExhdGVzdEJsb2NraGFzaCA/IGNhY2hlZExhdGVzdEJsb2NraGFzaC5ibG9ja2hhc2ggOiBudWxsO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1MDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGxhdGVzdEJsb2NraGFzaCA9IGF3YWl0IHRoaXMuZ2V0TGF0ZXN0QmxvY2toYXNoKCdmaW5hbGl6ZWQnKTtcbiAgICAgICAgaWYgKGNhY2hlZEJsb2NraGFzaCAhPT0gbGF0ZXN0QmxvY2toYXNoLmJsb2NraGFzaCkge1xuICAgICAgICAgIHRoaXMuX2Jsb2NraGFzaEluZm8gPSB7XG4gICAgICAgICAgICBsYXRlc3RCbG9ja2hhc2gsXG4gICAgICAgICAgICBsYXN0RmV0Y2g6IERhdGUubm93KCksXG4gICAgICAgICAgICB0cmFuc2FjdGlvblNpZ25hdHVyZXM6IFtdLFxuICAgICAgICAgICAgc2ltdWxhdGVkU2lnbmF0dXJlczogW11cbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiBsYXRlc3RCbG9ja2hhc2g7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTbGVlcCBmb3IgYXBwcm94aW1hdGVseSBoYWxmIGEgc2xvdFxuICAgICAgICBhd2FpdCBzbGVlcChNU19QRVJfU0xPVCAvIDIpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gb2J0YWluIGEgbmV3IGJsb2NraGFzaCBhZnRlciAke0RhdGUubm93KCkgLSBzdGFydFRpbWV9bXNgKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5fcG9sbGluZ0Jsb2NraGFzaCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgdGhlIHN0YWtlIG1pbmltdW0gZGVsZWdhdGlvblxuICAgKi9cbiAgYXN5bmMgZ2V0U3Rha2VNaW5pbXVtRGVsZWdhdGlvbihjb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnOiBjb25maWdBcmdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbXSwgY29tbWl0bWVudCwgJ2Jhc2U2NCcsIGNvbmZpZ0FyZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0U3Rha2VNaW5pbXVtRGVsZWdhdGlvbicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KG51bWJlcigpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgYGZhaWxlZCB0byBnZXQgc3Rha2UgbWluaW11bSBkZWxlZ2F0aW9uYCk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFNpbXVsYXRlIGEgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgSW5zdGVhZCwgY2FsbCB7QGxpbmsgc2ltdWxhdGVUcmFuc2FjdGlvbn0gd2l0aCB7QGxpbmtcbiAgICogVmVyc2lvbmVkVHJhbnNhY3Rpb259IGFuZCB7QGxpbmsgU2ltdWxhdGVUcmFuc2FjdGlvbkNvbmZpZ30gcGFyYW1ldGVyc1xuICAgKi9cblxuICAvKipcbiAgICogU2ltdWxhdGUgYSB0cmFuc2FjdGlvblxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuXG4gIC8qKlxuICAgKiBTaW11bGF0ZSBhIHRyYW5zYWN0aW9uXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG4gIGFzeW5jIHNpbXVsYXRlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25Pck1lc3NhZ2UsIGNvbmZpZ09yU2lnbmVycywgaW5jbHVkZUFjY291bnRzKSB7XG4gICAgaWYgKCdtZXNzYWdlJyBpbiB0cmFuc2FjdGlvbk9yTWVzc2FnZSkge1xuICAgICAgY29uc3QgdmVyc2lvbmVkVHggPSB0cmFuc2FjdGlvbk9yTWVzc2FnZTtcbiAgICAgIGNvbnN0IHdpcmVUcmFuc2FjdGlvbiA9IHZlcnNpb25lZFR4LnNlcmlhbGl6ZSgpO1xuICAgICAgY29uc3QgZW5jb2RlZFRyYW5zYWN0aW9uID0gQnVmZmVyLmZyb20od2lyZVRyYW5zYWN0aW9uKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShjb25maWdPclNpZ25lcnMpIHx8IGluY2x1ZGVBY2NvdW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbmZpZyA9IGNvbmZpZ09yU2lnbmVycyB8fCB7fTtcbiAgICAgIGNvbmZpZy5lbmNvZGluZyA9ICdiYXNlNjQnO1xuICAgICAgaWYgKCEoJ2NvbW1pdG1lbnQnIGluIGNvbmZpZykpIHtcbiAgICAgICAgY29uZmlnLmNvbW1pdG1lbnQgPSB0aGlzLmNvbW1pdG1lbnQ7XG4gICAgICB9XG4gICAgICBpZiAoY29uZmlnT3JTaWduZXJzICYmIHR5cGVvZiBjb25maWdPclNpZ25lcnMgPT09ICdvYmplY3QnICYmICdpbm5lckluc3RydWN0aW9ucycgaW4gY29uZmlnT3JTaWduZXJzKSB7XG4gICAgICAgIGNvbmZpZy5pbm5lckluc3RydWN0aW9ucyA9IGNvbmZpZ09yU2lnbmVycy5pbm5lckluc3RydWN0aW9ucztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFyZ3MgPSBbZW5jb2RlZFRyYW5zYWN0aW9uLCBjb25maWddO1xuICAgICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnc2ltdWxhdGVUcmFuc2FjdGlvbicsIGFyZ3MpO1xuICAgICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgU2ltdWxhdGVkVHJhbnNhY3Rpb25SZXNwb25zZVN0cnVjdCk7XG4gICAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmYWlsZWQgdG8gc2ltdWxhdGUgdHJhbnNhY3Rpb246ICcgKyByZXMuZXJyb3IubWVzc2FnZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgICB9XG4gICAgbGV0IHRyYW5zYWN0aW9uO1xuICAgIGlmICh0cmFuc2FjdGlvbk9yTWVzc2FnZSBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uKSB7XG4gICAgICBsZXQgb3JpZ2luYWxUeCA9IHRyYW5zYWN0aW9uT3JNZXNzYWdlO1xuICAgICAgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICAgIHRyYW5zYWN0aW9uLmZlZVBheWVyID0gb3JpZ2luYWxUeC5mZWVQYXllcjtcbiAgICAgIHRyYW5zYWN0aW9uLmluc3RydWN0aW9ucyA9IHRyYW5zYWN0aW9uT3JNZXNzYWdlLmluc3RydWN0aW9ucztcbiAgICAgIHRyYW5zYWN0aW9uLm5vbmNlSW5mbyA9IG9yaWdpbmFsVHgubm9uY2VJbmZvO1xuICAgICAgdHJhbnNhY3Rpb24uc2lnbmF0dXJlcyA9IG9yaWdpbmFsVHguc2lnbmF0dXJlcztcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhbnNhY3Rpb24gPSBUcmFuc2FjdGlvbi5wb3B1bGF0ZSh0cmFuc2FjdGlvbk9yTWVzc2FnZSk7XG4gICAgICAvLyBIQUNLOiB0aGlzIGZ1bmN0aW9uIHJlbGllcyBvbiBtdXRhdGluZyB0aGUgcG9wdWxhdGVkIHRyYW5zYWN0aW9uXG4gICAgICB0cmFuc2FjdGlvbi5fbWVzc2FnZSA9IHRyYW5zYWN0aW9uLl9qc29uID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoY29uZmlnT3JTaWduZXJzICE9PSB1bmRlZmluZWQgJiYgIUFycmF5LmlzQXJyYXkoY29uZmlnT3JTaWduZXJzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cycpO1xuICAgIH1cbiAgICBjb25zdCBzaWduZXJzID0gY29uZmlnT3JTaWduZXJzO1xuICAgIGlmICh0cmFuc2FjdGlvbi5ub25jZUluZm8gJiYgc2lnbmVycykge1xuICAgICAgdHJhbnNhY3Rpb24uc2lnbiguLi5zaWduZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGRpc2FibGVDYWNoZSA9IHRoaXMuX2Rpc2FibGVCbG9ja2hhc2hDYWNoaW5nO1xuICAgICAgZm9yICg7Oykge1xuICAgICAgICBjb25zdCBsYXRlc3RCbG9ja2hhc2ggPSBhd2FpdCB0aGlzLl9ibG9ja2hhc2hXaXRoRXhwaXJ5QmxvY2tIZWlnaHQoZGlzYWJsZUNhY2hlKTtcbiAgICAgICAgdHJhbnNhY3Rpb24ubGFzdFZhbGlkQmxvY2tIZWlnaHQgPSBsYXRlc3RCbG9ja2hhc2gubGFzdFZhbGlkQmxvY2tIZWlnaHQ7XG4gICAgICAgIHRyYW5zYWN0aW9uLnJlY2VudEJsb2NraGFzaCA9IGxhdGVzdEJsb2NraGFzaC5ibG9ja2hhc2g7XG4gICAgICAgIGlmICghc2lnbmVycykgYnJlYWs7XG4gICAgICAgIHRyYW5zYWN0aW9uLnNpZ24oLi4uc2lnbmVycyk7XG4gICAgICAgIGlmICghdHJhbnNhY3Rpb24uc2lnbmF0dXJlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCchc2lnbmF0dXJlJyk7IC8vIHNob3VsZCBuZXZlciBoYXBwZW5cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSB0cmFuc2FjdGlvbi5zaWduYXR1cmUudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgICAgICBpZiAoIXRoaXMuX2Jsb2NraGFzaEluZm8uc2ltdWxhdGVkU2lnbmF0dXJlcy5pbmNsdWRlcyhzaWduYXR1cmUpICYmICF0aGlzLl9ibG9ja2hhc2hJbmZvLnRyYW5zYWN0aW9uU2lnbmF0dXJlcy5pbmNsdWRlcyhzaWduYXR1cmUpKSB7XG4gICAgICAgICAgLy8gVGhlIHNpZ25hdHVyZSBvZiB0aGlzIHRyYW5zYWN0aW9uIGhhcyBub3QgYmVlbiBzZWVuIGJlZm9yZSB3aXRoIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgcmVjZW50QmxvY2toYXNoLCBhbGwgZG9uZS4gTGV0J3MgYnJlYWtcbiAgICAgICAgICB0aGlzLl9ibG9ja2hhc2hJbmZvLnNpbXVsYXRlZFNpZ25hdHVyZXMucHVzaChzaWduYXR1cmUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoaXMgdHJhbnNhY3Rpb24gd291bGQgYmUgdHJlYXRlZCBhcyBkdXBsaWNhdGUgKGl0cyBkZXJpdmVkIHNpZ25hdHVyZVxuICAgICAgICAgIC8vIG1hdGNoZWQgdG8gb25lIG9mIGFscmVhZHkgcmVjb3JkZWQgc2lnbmF0dXJlcykuXG4gICAgICAgICAgLy8gU28sIHdlIG11c3QgZmV0Y2ggYSBuZXcgYmxvY2toYXNoIGZvciBhIGRpZmZlcmVudCBzaWduYXR1cmUgYnkgZGlzYWJsaW5nXG4gICAgICAgICAgLy8gb3VyIGNhY2hlIG5vdCB0byB3YWl0IGZvciB0aGUgY2FjaGUgZXhwaXJhdGlvbiAoQkxPQ0tIQVNIX0NBQ0hFX1RJTUVPVVRfTVMpLlxuICAgICAgICAgIGRpc2FibGVDYWNoZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZSA9IHRyYW5zYWN0aW9uLl9jb21waWxlKCk7XG4gICAgY29uc3Qgc2lnbkRhdGEgPSBtZXNzYWdlLnNlcmlhbGl6ZSgpO1xuICAgIGNvbnN0IHdpcmVUcmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uLl9zZXJpYWxpemUoc2lnbkRhdGEpO1xuICAgIGNvbnN0IGVuY29kZWRUcmFuc2FjdGlvbiA9IHdpcmVUcmFuc2FjdGlvbi50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgZW5jb2Rpbmc6ICdiYXNlNjQnLFxuICAgICAgY29tbWl0bWVudDogdGhpcy5jb21taXRtZW50XG4gICAgfTtcbiAgICBpZiAoaW5jbHVkZUFjY291bnRzKSB7XG4gICAgICBjb25zdCBhZGRyZXNzZXMgPSAoQXJyYXkuaXNBcnJheShpbmNsdWRlQWNjb3VudHMpID8gaW5jbHVkZUFjY291bnRzIDogbWVzc2FnZS5ub25Qcm9ncmFtSWRzKCkpLm1hcChrZXkgPT4ga2V5LnRvQmFzZTU4KCkpO1xuICAgICAgY29uZmlnWydhY2NvdW50cyddID0ge1xuICAgICAgICBlbmNvZGluZzogJ2Jhc2U2NCcsXG4gICAgICAgIGFkZHJlc3Nlc1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHNpZ25lcnMpIHtcbiAgICAgIGNvbmZpZy5zaWdWZXJpZnkgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoY29uZmlnT3JTaWduZXJzICYmIHR5cGVvZiBjb25maWdPclNpZ25lcnMgPT09ICdvYmplY3QnICYmICdpbm5lckluc3RydWN0aW9ucycgaW4gY29uZmlnT3JTaWduZXJzKSB7XG4gICAgICBjb25maWcuaW5uZXJJbnN0cnVjdGlvbnMgPSBjb25maWdPclNpZ25lcnMuaW5uZXJJbnN0cnVjdGlvbnM7XG4gICAgfVxuICAgIGNvbnN0IGFyZ3MgPSBbZW5jb2RlZFRyYW5zYWN0aW9uLCBjb25maWddO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ3NpbXVsYXRlVHJhbnNhY3Rpb24nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBTaW11bGF0ZWRUcmFuc2FjdGlvblJlc3BvbnNlU3RydWN0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIGxldCBsb2dzO1xuICAgICAgaWYgKCdkYXRhJyBpbiByZXMuZXJyb3IpIHtcbiAgICAgICAgbG9ncyA9IHJlcy5lcnJvci5kYXRhLmxvZ3M7XG4gICAgICAgIGlmIChsb2dzICYmIEFycmF5LmlzQXJyYXkobG9ncykpIHtcbiAgICAgICAgICBjb25zdCB0cmFjZUluZGVudCA9ICdcXG4gICAgJztcbiAgICAgICAgICBjb25zdCBsb2dUcmFjZSA9IHRyYWNlSW5kZW50ICsgbG9ncy5qb2luKHRyYWNlSW5kZW50KTtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKHJlcy5lcnJvci5tZXNzYWdlLCBsb2dUcmFjZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBTZW5kVHJhbnNhY3Rpb25FcnJvcih7XG4gICAgICAgIGFjdGlvbjogJ3NpbXVsYXRlJyxcbiAgICAgICAgc2lnbmF0dXJlOiAnJyxcbiAgICAgICAgdHJhbnNhY3Rpb25NZXNzYWdlOiByZXMuZXJyb3IubWVzc2FnZSxcbiAgICAgICAgbG9nczogbG9nc1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFNpZ24gYW5kIHNlbmQgYSB0cmFuc2FjdGlvblxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBJbnN0ZWFkLCBjYWxsIHtAbGluayBzZW5kVHJhbnNhY3Rpb259IHdpdGggYSB7QGxpbmtcbiAgICogVmVyc2lvbmVkVHJhbnNhY3Rpb259XG4gICAqL1xuXG4gIC8qKlxuICAgKiBTZW5kIGEgc2lnbmVkIHRyYW5zYWN0aW9uXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG5cbiAgLyoqXG4gICAqIFNpZ24gYW5kIHNlbmQgYSB0cmFuc2FjdGlvblxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuICBhc3luYyBzZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIHNpZ25lcnNPck9wdGlvbnMsIG9wdGlvbnMpIHtcbiAgICBpZiAoJ3ZlcnNpb24nIGluIHRyYW5zYWN0aW9uKSB7XG4gICAgICBpZiAoc2lnbmVyc09yT3B0aW9ucyAmJiBBcnJheS5pc0FycmF5KHNpZ25lcnNPck9wdGlvbnMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHdpcmVUcmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uLnNlcmlhbGl6ZSgpO1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VuZFJhd1RyYW5zYWN0aW9uKHdpcmVUcmFuc2FjdGlvbiwgc2lnbmVyc09yT3B0aW9ucyk7XG4gICAgfVxuICAgIGlmIChzaWduZXJzT3JPcHRpb25zID09PSB1bmRlZmluZWQgfHwgIUFycmF5LmlzQXJyYXkoc2lnbmVyc09yT3B0aW9ucykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMnKTtcbiAgICB9XG4gICAgY29uc3Qgc2lnbmVycyA9IHNpZ25lcnNPck9wdGlvbnM7XG4gICAgaWYgKHRyYW5zYWN0aW9uLm5vbmNlSW5mbykge1xuICAgICAgdHJhbnNhY3Rpb24uc2lnbiguLi5zaWduZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGRpc2FibGVDYWNoZSA9IHRoaXMuX2Rpc2FibGVCbG9ja2hhc2hDYWNoaW5nO1xuICAgICAgZm9yICg7Oykge1xuICAgICAgICBjb25zdCBsYXRlc3RCbG9ja2hhc2ggPSBhd2FpdCB0aGlzLl9ibG9ja2hhc2hXaXRoRXhwaXJ5QmxvY2tIZWlnaHQoZGlzYWJsZUNhY2hlKTtcbiAgICAgICAgdHJhbnNhY3Rpb24ubGFzdFZhbGlkQmxvY2tIZWlnaHQgPSBsYXRlc3RCbG9ja2hhc2gubGFzdFZhbGlkQmxvY2tIZWlnaHQ7XG4gICAgICAgIHRyYW5zYWN0aW9uLnJlY2VudEJsb2NraGFzaCA9IGxhdGVzdEJsb2NraGFzaC5ibG9ja2hhc2g7XG4gICAgICAgIHRyYW5zYWN0aW9uLnNpZ24oLi4uc2lnbmVycyk7XG4gICAgICAgIGlmICghdHJhbnNhY3Rpb24uc2lnbmF0dXJlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCchc2lnbmF0dXJlJyk7IC8vIHNob3VsZCBuZXZlciBoYXBwZW5cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSB0cmFuc2FjdGlvbi5zaWduYXR1cmUudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgICAgICBpZiAoIXRoaXMuX2Jsb2NraGFzaEluZm8udHJhbnNhY3Rpb25TaWduYXR1cmVzLmluY2x1ZGVzKHNpZ25hdHVyZSkpIHtcbiAgICAgICAgICAvLyBUaGUgc2lnbmF0dXJlIG9mIHRoaXMgdHJhbnNhY3Rpb24gaGFzIG5vdCBiZWVuIHNlZW4gYmVmb3JlIHdpdGggdGhlXG4gICAgICAgICAgLy8gY3VycmVudCByZWNlbnRCbG9ja2hhc2gsIGFsbCBkb25lLiBMZXQncyBicmVha1xuICAgICAgICAgIHRoaXMuX2Jsb2NraGFzaEluZm8udHJhbnNhY3Rpb25TaWduYXR1cmVzLnB1c2goc2lnbmF0dXJlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUaGlzIHRyYW5zYWN0aW9uIHdvdWxkIGJlIHRyZWF0ZWQgYXMgZHVwbGljYXRlIChpdHMgZGVyaXZlZCBzaWduYXR1cmVcbiAgICAgICAgICAvLyBtYXRjaGVkIHRvIG9uZSBvZiBhbHJlYWR5IHJlY29yZGVkIHNpZ25hdHVyZXMpLlxuICAgICAgICAgIC8vIFNvLCB3ZSBtdXN0IGZldGNoIGEgbmV3IGJsb2NraGFzaCBmb3IgYSBkaWZmZXJlbnQgc2lnbmF0dXJlIGJ5IGRpc2FibGluZ1xuICAgICAgICAgIC8vIG91ciBjYWNoZSBub3QgdG8gd2FpdCBmb3IgdGhlIGNhY2hlIGV4cGlyYXRpb24gKEJMT0NLSEFTSF9DQUNIRV9USU1FT1VUX01TKS5cbiAgICAgICAgICBkaXNhYmxlQ2FjaGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHdpcmVUcmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uLnNlcmlhbGl6ZSgpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlbmRSYXdUcmFuc2FjdGlvbih3aXJlVHJhbnNhY3Rpb24sIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSB0cmFuc2FjdGlvbiB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gc2lnbmVkIGFuZCBzZXJpYWxpemVkIGludG8gdGhlXG4gICAqIHdpcmUgZm9ybWF0XG4gICAqL1xuICBhc3luYyBzZW5kUmF3VHJhbnNhY3Rpb24ocmF3VHJhbnNhY3Rpb24sIG9wdGlvbnMpIHtcbiAgICBjb25zdCBlbmNvZGVkVHJhbnNhY3Rpb24gPSB0b0J1ZmZlcihyYXdUcmFuc2FjdGlvbikudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuc2VuZEVuY29kZWRUcmFuc2FjdGlvbihlbmNvZGVkVHJhbnNhY3Rpb24sIG9wdGlvbnMpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIHRyYW5zYWN0aW9uIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBzaWduZWQsIHNlcmlhbGl6ZWQgaW50byB0aGVcbiAgICogd2lyZSBmb3JtYXQsIGFuZCBlbmNvZGVkIGFzIGEgYmFzZTY0IHN0cmluZ1xuICAgKi9cbiAgYXN5bmMgc2VuZEVuY29kZWRUcmFuc2FjdGlvbihlbmNvZGVkVHJhbnNhY3Rpb24sIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICBlbmNvZGluZzogJ2Jhc2U2NCdcbiAgICB9O1xuICAgIGNvbnN0IHNraXBQcmVmbGlnaHQgPSBvcHRpb25zICYmIG9wdGlvbnMuc2tpcFByZWZsaWdodDtcbiAgICBjb25zdCBwcmVmbGlnaHRDb21taXRtZW50ID0gc2tpcFByZWZsaWdodCA9PT0gdHJ1ZSA/ICdwcm9jZXNzZWQnIC8vIEZJWE1FIFJlbW92ZSB3aGVuIGh0dHBzOi8vZ2l0aHViLmNvbS9hbnphLXh5ei9hZ2F2ZS9wdWxsLzQ4MyBpcyBkZXBsb3llZC5cbiAgICA6IG9wdGlvbnMgJiYgb3B0aW9ucy5wcmVmbGlnaHRDb21taXRtZW50IHx8IHRoaXMuY29tbWl0bWVudDtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm1heFJldHJpZXMgIT0gbnVsbCkge1xuICAgICAgY29uZmlnLm1heFJldHJpZXMgPSBvcHRpb25zLm1heFJldHJpZXM7XG4gICAgfVxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMubWluQ29udGV4dFNsb3QgIT0gbnVsbCkge1xuICAgICAgY29uZmlnLm1pbkNvbnRleHRTbG90ID0gb3B0aW9ucy5taW5Db250ZXh0U2xvdDtcbiAgICB9XG4gICAgaWYgKHNraXBQcmVmbGlnaHQpIHtcbiAgICAgIGNvbmZpZy5za2lwUHJlZmxpZ2h0ID0gc2tpcFByZWZsaWdodDtcbiAgICB9XG4gICAgaWYgKHByZWZsaWdodENvbW1pdG1lbnQpIHtcbiAgICAgIGNvbmZpZy5wcmVmbGlnaHRDb21taXRtZW50ID0gcHJlZmxpZ2h0Q29tbWl0bWVudDtcbiAgICB9XG4gICAgY29uc3QgYXJncyA9IFtlbmNvZGVkVHJhbnNhY3Rpb24sIGNvbmZpZ107XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnc2VuZFRyYW5zYWN0aW9uJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgU2VuZFRyYW5zYWN0aW9uUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIGxldCBsb2dzID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKCdkYXRhJyBpbiByZXMuZXJyb3IpIHtcbiAgICAgICAgbG9ncyA9IHJlcy5lcnJvci5kYXRhLmxvZ3M7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgU2VuZFRyYW5zYWN0aW9uRXJyb3Ioe1xuICAgICAgICBhY3Rpb246IHNraXBQcmVmbGlnaHQgPyAnc2VuZCcgOiAnc2ltdWxhdGUnLFxuICAgICAgICBzaWduYXR1cmU6ICcnLFxuICAgICAgICB0cmFuc2FjdGlvbk1lc3NhZ2U6IHJlcy5lcnJvci5tZXNzYWdlLFxuICAgICAgICBsb2dzOiBsb2dzXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfd3NPbk9wZW4oKSB7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Q29ubmVjdGVkID0gdHJ1ZTtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXRIZWFydGJlYXQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAvLyBQaW5nIHNlcnZlciBldmVyeSA1cyB0byBwcmV2ZW50IGlkbGUgdGltZW91dHNcbiAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5fcnBjV2ViU29ja2V0Lm5vdGlmeSgncGluZycpO1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICAgICAgICB9IGNhdGNoIHt9XG4gICAgICB9KSgpO1xuICAgIH0sIDUwMDApO1xuICAgIHRoaXMuX3VwZGF0ZVN1YnNjcmlwdGlvbnMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF93c09uRXJyb3IoZXJyKSB7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Q29ubmVjdGVkID0gZmFsc2U7XG4gICAgY29uc29sZS5lcnJvcignd3MgZXJyb3I6JywgZXJyLm1lc3NhZ2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3dzT25DbG9zZShjb2RlKSB7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Q29ubmVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0R2VuZXJhdGlvbiA9ICh0aGlzLl9ycGNXZWJTb2NrZXRHZW5lcmF0aW9uICsgMSkgJSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICBpZiAodGhpcy5fcnBjV2ViU29ja2V0SWRsZVRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9ycGNXZWJTb2NrZXRJZGxlVGltZW91dCk7XG4gICAgICB0aGlzLl9ycGNXZWJTb2NrZXRJZGxlVGltZW91dCA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLl9ycGNXZWJTb2NrZXRIZWFydGJlYXQpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fcnBjV2ViU29ja2V0SGVhcnRiZWF0KTtcbiAgICAgIHRoaXMuX3JwY1dlYlNvY2tldEhlYXJ0YmVhdCA9IG51bGw7XG4gICAgfVxuICAgIGlmIChjb2RlID09PSAxMDAwKSB7XG4gICAgICAvLyBleHBsaWNpdCBjbG9zZSwgY2hlY2sgaWYgYW55IHN1YnNjcmlwdGlvbnMgaGF2ZSBiZWVuIG1hZGUgc2luY2UgY2xvc2VcbiAgICAgIHRoaXMuX3VwZGF0ZVN1YnNjcmlwdGlvbnMoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBpbXBsaWNpdCBjbG9zZSwgcHJlcGFyZSBzdWJzY3JpcHRpb25zIGZvciBhdXRvLXJlY29ubmVjdFxuICAgIHRoaXMuX3N1YnNjcmlwdGlvbkNhbGxiYWNrc0J5U2VydmVyU3Vic2NyaXB0aW9uSWQgPSB7fTtcbiAgICBPYmplY3QuZW50cmllcyh0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoKS5mb3JFYWNoKChbaGFzaCwgc3Vic2NyaXB0aW9uXSkgPT4ge1xuICAgICAgdGhpcy5fc2V0U3Vic2NyaXB0aW9uKGhhc2gsIHtcbiAgICAgICAgLi4uc3Vic2NyaXB0aW9uLFxuICAgICAgICBzdGF0ZTogJ3BlbmRpbmcnXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9zZXRTdWJzY3JpcHRpb24oaGFzaCwgbmV4dFN1YnNjcmlwdGlvbikge1xuICAgIGNvbnN0IHByZXZTdGF0ZSA9IHRoaXMuX3N1YnNjcmlwdGlvbnNCeUhhc2hbaGFzaF0/LnN0YXRlO1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnNCeUhhc2hbaGFzaF0gPSBuZXh0U3Vic2NyaXB0aW9uO1xuICAgIGlmIChwcmV2U3RhdGUgIT09IG5leHRTdWJzY3JpcHRpb24uc3RhdGUpIHtcbiAgICAgIGNvbnN0IHN0YXRlQ2hhbmdlQ2FsbGJhY2tzID0gdGhpcy5fc3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2VDYWxsYmFja3NCeUhhc2hbaGFzaF07XG4gICAgICBpZiAoc3RhdGVDaGFuZ2VDYWxsYmFja3MpIHtcbiAgICAgICAgc3RhdGVDaGFuZ2VDYWxsYmFja3MuZm9yRWFjaChjYiA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNiKG5leHRTdWJzY3JpcHRpb24uc3RhdGUpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgICAgICAgfSBjYXRjaCB7fVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfb25TdWJzY3JpcHRpb25TdGF0ZUNoYW5nZShjbGllbnRTdWJzY3JpcHRpb25JZCwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBoYXNoID0gdGhpcy5fc3Vic2NyaXB0aW9uSGFzaEJ5Q2xpZW50U3Vic2NyaXB0aW9uSWRbY2xpZW50U3Vic2NyaXB0aW9uSWRdO1xuICAgIGlmIChoYXNoID09IG51bGwpIHtcbiAgICAgIHJldHVybiAoKSA9PiB7fTtcbiAgICB9XG4gICAgY29uc3Qgc3RhdGVDaGFuZ2VDYWxsYmFja3MgPSB0aGlzLl9zdWJzY3JpcHRpb25TdGF0ZUNoYW5nZUNhbGxiYWNrc0J5SGFzaFtoYXNoXSB8fD0gbmV3IFNldCgpO1xuICAgIHN0YXRlQ2hhbmdlQ2FsbGJhY2tzLmFkZChjYWxsYmFjayk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHN0YXRlQ2hhbmdlQ2FsbGJhY2tzLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgICBpZiAoc3RhdGVDaGFuZ2VDYWxsYmFja3Muc2l6ZSA9PT0gMCkge1xuICAgICAgICBkZWxldGUgdGhpcy5fc3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2VDYWxsYmFja3NCeUhhc2hbaGFzaF07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGFzeW5jIF91cGRhdGVTdWJzY3JpcHRpb25zKCkge1xuICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmICh0aGlzLl9ycGNXZWJTb2NrZXRDb25uZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5fcnBjV2ViU29ja2V0Q29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3JwY1dlYlNvY2tldElkbGVUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fcnBjV2ViU29ja2V0SWRsZVRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9ycGNXZWJTb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIC8vIHN3YWxsb3cgZXJyb3IgaWYgc29ja2V0IGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkLlxuICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBFcnJvciB3aGVuIGNsb3Npbmcgc29ja2V0IGNvbm5lY3Rpb246ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCA1MDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcnBjV2ViU29ja2V0SWRsZVRpbWVvdXQgIT09IG51bGwpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9ycGNXZWJTb2NrZXRJZGxlVGltZW91dCk7XG4gICAgICB0aGlzLl9ycGNXZWJTb2NrZXRJZGxlVGltZW91dCA9IG51bGw7XG4gICAgICB0aGlzLl9ycGNXZWJTb2NrZXRDb25uZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX3JwY1dlYlNvY2tldENvbm5lY3RlZCkge1xuICAgICAgdGhpcy5fcnBjV2ViU29ja2V0LmNvbm5lY3QoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYWN0aXZlV2ViU29ja2V0R2VuZXJhdGlvbiA9IHRoaXMuX3JwY1dlYlNvY2tldEdlbmVyYXRpb247XG4gICAgY29uc3QgaXNDdXJyZW50Q29ubmVjdGlvblN0aWxsQWN0aXZlID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIGFjdGl2ZVdlYlNvY2tldEdlbmVyYXRpb24gPT09IHRoaXMuX3JwY1dlYlNvY2tldEdlbmVyYXRpb247XG4gICAgfTtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAvLyBEb24ndCBiZSB0ZW1wdGVkIHRvIGNoYW5nZSB0aGlzIHRvIGBPYmplY3QuZW50cmllc2AuIFdlIGNhbGxcbiAgICAvLyBgX3VwZGF0ZVN1YnNjcmlwdGlvbnNgIHJlY3Vyc2l2ZWx5IHdoZW4gcHJvY2Vzc2luZyB0aGUgc3RhdGUsXG4gICAgLy8gc28gaXQncyBpbXBvcnRhbnQgdGhhdCB3ZSBsb29rIHVwIHRoZSAqY3VycmVudCogdmVyc2lvbiBvZlxuICAgIC8vIGVhY2ggc3Vic2NyaXB0aW9uLCBldmVyeSB0aW1lIHdlIHByb2Nlc3MgYSBoYXNoLlxuICAgIE9iamVjdC5rZXlzKHRoaXMuX3N1YnNjcmlwdGlvbnNCeUhhc2gpLm1hcChhc3luYyBoYXNoID0+IHtcbiAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHRoaXMuX3N1YnNjcmlwdGlvbnNCeUhhc2hbaGFzaF07XG4gICAgICBpZiAoc3Vic2NyaXB0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gVGhpcyBlbnRyeSBoYXMgc2luY2UgYmVlbiBkZWxldGVkLiBTa2lwLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHN1YnNjcmlwdGlvbi5zdGF0ZSkge1xuICAgICAgICBjYXNlICdwZW5kaW5nJzpcbiAgICAgICAgY2FzZSAndW5zdWJzY3JpYmVkJzpcbiAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uLmNhbGxiYWNrcy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFlvdSBjYW4gZW5kIHVwIGhlcmUgd2hlbjpcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAtIGEgc3Vic2NyaXB0aW9uIGhhcyByZWNlbnRseSB1bnN1YnNjcmliZWRcbiAgICAgICAgICAgICAqICAgd2l0aG91dCBoYXZpbmcgbmV3IGNhbGxiYWNrcyBhZGRlZCB0byBpdFxuICAgICAgICAgICAgICogICB3aGlsZSB0aGUgdW5zdWJzY3JpYmUgd2FzIGluIGZsaWdodCwgb3JcbiAgICAgICAgICAgICAqIC0gd2hlbiBhIHBlbmRpbmcgc3Vic2NyaXB0aW9uIGhhcyBpdHNcbiAgICAgICAgICAgICAqICAgbGlzdGVuZXJzIHJlbW92ZWQgYmVmb3JlIGEgcmVxdWVzdCB3YXNcbiAgICAgICAgICAgICAqICAgc2VudCB0byB0aGUgc2VydmVyLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEJlaW5nIHRoYXQgbm9ib2R5IGlzIGludGVyZXN0ZWQgaW4gdGhpc1xuICAgICAgICAgICAgICogc3Vic2NyaXB0aW9uIGFueSBsb25nZXIsIGRlbGV0ZSBpdC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3N1YnNjcmlwdGlvbnNCeUhhc2hbaGFzaF07XG4gICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uLnN0YXRlID09PSAndW5zdWJzY3JpYmVkJykge1xuICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fc3Vic2NyaXB0aW9uQ2FsbGJhY2tzQnlTZXJ2ZXJTdWJzY3JpcHRpb25JZFtzdWJzY3JpcHRpb24uc2VydmVyU3Vic2NyaXB0aW9uSWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5fdXBkYXRlU3Vic2NyaXB0aW9ucygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhd2FpdCAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgICBtZXRob2RcbiAgICAgICAgICAgIH0gPSBzdWJzY3JpcHRpb247XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB0aGlzLl9zZXRTdWJzY3JpcHRpb24oaGFzaCwge1xuICAgICAgICAgICAgICAgIC4uLnN1YnNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ3N1YnNjcmliaW5nJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29uc3Qgc2VydmVyU3Vic2NyaXB0aW9uSWQgPSBhd2FpdCB0aGlzLl9ycGNXZWJTb2NrZXQuY2FsbChtZXRob2QsIGFyZ3MpO1xuICAgICAgICAgICAgICB0aGlzLl9zZXRTdWJzY3JpcHRpb24oaGFzaCwge1xuICAgICAgICAgICAgICAgIC4uLnN1YnNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICBzZXJ2ZXJTdWJzY3JpcHRpb25JZCxcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ3N1YnNjcmliZWQnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25DYWxsYmFja3NCeVNlcnZlclN1YnNjcmlwdGlvbklkW3NlcnZlclN1YnNjcmlwdGlvbklkXSA9IHN1YnNjcmlwdGlvbi5jYWxsYmFja3M7XG4gICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3VwZGF0ZVN1YnNjcmlwdGlvbnMoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgUmVjZWl2ZWQgJHtlIGluc3RhbmNlb2YgRXJyb3IgPyAnJyA6ICdKU09OLVJQQyAnfWVycm9yIGNhbGxpbmcgXFxgJHttZXRob2R9XFxgYCwge1xuICAgICAgICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmICghaXNDdXJyZW50Q29ubmVjdGlvblN0aWxsQWN0aXZlKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gVE9ETzogTWF5YmUgYWRkIGFuICdlcnJvcmVkJyBzdGF0ZSBvciBhIHJldHJ5IGxpbWl0P1xuICAgICAgICAgICAgICB0aGlzLl9zZXRTdWJzY3JpcHRpb24oaGFzaCwge1xuICAgICAgICAgICAgICAgIC4uLnN1YnNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ3BlbmRpbmcnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBhd2FpdCB0aGlzLl91cGRhdGVTdWJzY3JpcHRpb25zKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc3Vic2NyaWJlZCc6XG4gICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi5jYWxsYmFja3Muc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gQnkgdGhlIHRpbWUgd2Ugc3VjY2Vzc2Z1bGx5IHNldCB1cCBhIHN1YnNjcmlwdGlvblxuICAgICAgICAgICAgLy8gd2l0aCB0aGUgc2VydmVyLCB0aGUgY2xpZW50IHN0b3BwZWQgY2FyaW5nIGFib3V0IGl0LlxuICAgICAgICAgICAgLy8gVGVhciBpdCBkb3duIG5vdy5cbiAgICAgICAgICAgIGF3YWl0IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICBzZXJ2ZXJTdWJzY3JpcHRpb25JZCxcbiAgICAgICAgICAgICAgICB1bnN1YnNjcmliZU1ldGhvZFxuICAgICAgICAgICAgICB9ID0gc3Vic2NyaXB0aW9uO1xuICAgICAgICAgICAgICBpZiAodGhpcy5fc3Vic2NyaXB0aW9uc0F1dG9EaXNwb3NlZEJ5UnBjLmhhcyhzZXJ2ZXJTdWJzY3JpcHRpb25JZCkpIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBTcGVjaWFsIGNhc2UuXG4gICAgICAgICAgICAgICAgICogSWYgd2UncmUgZGVhbGluZyB3aXRoIGEgc3Vic2NyaXB0aW9uIHRoYXQgaGFzIGJlZW4gYXV0by1cbiAgICAgICAgICAgICAgICAgKiBkaXNwb3NlZCBieSB0aGUgUlBDLCB0aGVuIHdlIGNhbiBza2lwIHRoZSBSUEMgY2FsbCB0b1xuICAgICAgICAgICAgICAgICAqIHRlYXIgZG93biB0aGUgc3Vic2NyaXB0aW9uIGhlcmUuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBOT1RFOiBUaGVyZSBpcyBhIHByb3Bvc2FsIHRvIGVsaW1pbmF0ZSB0aGlzIHNwZWNpYWwgY2FzZSwgaGVyZTpcbiAgICAgICAgICAgICAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hL2lzc3Vlcy8xODg5MlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnNBdXRvRGlzcG9zZWRCeVJwYy5kZWxldGUoc2VydmVyU3Vic2NyaXB0aW9uSWQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFN1YnNjcmlwdGlvbihoYXNoLCB7XG4gICAgICAgICAgICAgICAgICAuLi5zdWJzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICBzdGF0ZTogJ3Vuc3Vic2NyaWJpbmcnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0U3Vic2NyaXB0aW9uKGhhc2gsIHtcbiAgICAgICAgICAgICAgICAgIC4uLnN1YnNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgIHN0YXRlOiAndW5zdWJzY3JpYmluZydcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fcnBjV2ViU29ja2V0LmNhbGwodW5zdWJzY3JpYmVNZXRob2QsIFtzZXJ2ZXJTdWJzY3JpcHRpb25JZF0pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgJHt1bnN1YnNjcmliZU1ldGhvZH0gZXJyb3I6YCwgZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmICghaXNDdXJyZW50Q29ubmVjdGlvblN0aWxsQWN0aXZlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gVE9ETzogTWF5YmUgYWRkIGFuICdlcnJvcmVkJyBzdGF0ZSBvciBhIHJldHJ5IGxpbWl0P1xuICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0U3Vic2NyaXB0aW9uKGhhc2gsIHtcbiAgICAgICAgICAgICAgICAgICAgLi4uc3Vic2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZTogJ3N1YnNjcmliZWQnXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3VwZGF0ZVN1YnNjcmlwdGlvbnMoKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5fc2V0U3Vic2NyaXB0aW9uKGhhc2gsIHtcbiAgICAgICAgICAgICAgICAuLi5zdWJzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgc3RhdGU6ICd1bnN1YnNjcmliZWQnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBhd2FpdCB0aGlzLl91cGRhdGVTdWJzY3JpcHRpb25zKCk7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9KSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfaGFuZGxlU2VydmVyTm90aWZpY2F0aW9uKHNlcnZlclN1YnNjcmlwdGlvbklkLCBjYWxsYmFja0FyZ3MpIHtcbiAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzLl9zdWJzY3JpcHRpb25DYWxsYmFja3NCeVNlcnZlclN1YnNjcmlwdGlvbklkW3NlcnZlclN1YnNjcmlwdGlvbklkXTtcbiAgICBpZiAoY2FsbGJhY2tzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGJhY2tzLmZvckVhY2goY2IgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2IoXG4gICAgICAgIC8vIEkgZmFpbGVkIHRvIGZpbmQgYSB3YXkgdG8gY29udmluY2UgVHlwZVNjcmlwdCB0aGF0IGBjYmAgaXMgb2YgdHlwZVxuICAgICAgICAvLyBgVENhbGxiYWNrYCB3aGljaCBpcyBjZXJ0YWlubHkgY29tcGF0aWJsZSB3aXRoIGBQYXJhbWV0ZXJzPFRDYWxsYmFjaz5gLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy80NzYxNVxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIC4uLmNhbGxiYWNrQXJncyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfd3NPbkFjY291bnROb3RpZmljYXRpb24obm90aWZpY2F0aW9uKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVzdWx0LFxuICAgICAgc3Vic2NyaXB0aW9uXG4gICAgfSA9IGNyZWF0ZShub3RpZmljYXRpb24sIEFjY291bnROb3RpZmljYXRpb25SZXN1bHQpO1xuICAgIHRoaXMuX2hhbmRsZVNlcnZlck5vdGlmaWNhdGlvbihzdWJzY3JpcHRpb24sIFtyZXN1bHQudmFsdWUsIHJlc3VsdC5jb250ZXh0XSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfbWFrZVN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb25Db25maWcsXG4gIC8qKlxuICAgKiBXaGVuIHByZXBhcmluZyBgYXJnc2AgZm9yIGEgY2FsbCB0byBgX21ha2VTdWJzY3JpcHRpb25gLCBiZSBzdXJlXG4gICAqIHRvIGNhcmVmdWxseSBhcHBseSBhIGRlZmF1bHQgYGNvbW1pdG1lbnRgIHByb3BlcnR5LCBpZiBuZWNlc3NhcnkuXG4gICAqXG4gICAqIC0gSWYgdGhlIHVzZXIgc3VwcGxpZWQgYSBgY29tbWl0bWVudGAgdXNlIHRoYXQuXG4gICAqIC0gT3RoZXJ3aXNlLCBpZiB0aGUgYENvbm5lY3Rpb246OmNvbW1pdG1lbnRgIGlzIHNldCwgdXNlIHRoYXQuXG4gICAqIC0gT3RoZXJ3aXNlLCBzZXQgaXQgdG8gdGhlIFJQQyBzZXJ2ZXIgZGVmYXVsdDogYGZpbmFsaXplZGAuXG4gICAqXG4gICAqIFRoaXMgaXMgZXh0cmVtZWx5IGltcG9ydGFudCB0byBlbnN1cmUgdGhhdCB0aGVzZSB0d28gZnVuZGFtZW50YWxseVxuICAgKiBpZGVudGljYWwgc3Vic2NyaXB0aW9ucyBwcm9kdWNlIHRoZSBzYW1lIGlkZW50aWZ5aW5nIGhhc2g6XG4gICAqXG4gICAqIC0gQSBzdWJzY3JpcHRpb24gbWFkZSB3aXRob3V0IHNwZWNpZnlpbmcgYSBjb21taXRtZW50LlxuICAgKiAtIEEgc3Vic2NyaXB0aW9uIG1hZGUgd2hlcmUgdGhlIGNvbW1pdG1lbnQgc3BlY2lmaWVkIGlzIHRoZSBzYW1lXG4gICAqICAgYXMgdGhlIGRlZmF1bHQgYXBwbGllZCB0byB0aGUgc3Vic2NyaXB0aW9uIGFib3ZlLlxuICAgKlxuICAgKiBFeGFtcGxlOyB0aGVzZSB0d28gc3Vic2NyaXB0aW9ucyBtdXN0IHByb2R1Y2UgdGhlIHNhbWUgaGFzaDpcbiAgICpcbiAgICogLSBBbiBgYWNjb3VudFN1YnNjcmliZWAgc3Vic2NyaXB0aW9uIGZvciBgJ1BVQktFWSdgXG4gICAqIC0gQW4gYGFjY291bnRTdWJzY3JpYmVgIHN1YnNjcmlwdGlvbiBmb3IgYCdQVUJLRVknYCB3aXRoIGNvbW1pdG1lbnRcbiAgICogICBgJ2ZpbmFsaXplZCdgLlxuICAgKlxuICAgKiBTZWUgdGhlICdtYWtpbmcgYSBzdWJzY3JpcHRpb24gd2l0aCBkZWZhdWx0ZWQgcGFyYW1zIG9taXR0ZWQnIHRlc3RcbiAgICogaW4gYGNvbm5lY3Rpb24tc3Vic2NyaXB0aW9ucy50c2AgZm9yIG1vcmUuXG4gICAqL1xuICBhcmdzKSB7XG4gICAgY29uc3QgY2xpZW50U3Vic2NyaXB0aW9uSWQgPSB0aGlzLl9uZXh0Q2xpZW50U3Vic2NyaXB0aW9uSWQrKztcbiAgICBjb25zdCBoYXNoID0gZmFzdFN0YWJsZVN0cmluZ2lmeShbc3Vic2NyaXB0aW9uQ29uZmlnLm1ldGhvZCwgYXJnc10pO1xuICAgIGNvbnN0IGV4aXN0aW5nU3Vic2NyaXB0aW9uID0gdGhpcy5fc3Vic2NyaXB0aW9uc0J5SGFzaFtoYXNoXTtcbiAgICBpZiAoZXhpc3RpbmdTdWJzY3JpcHRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uc0J5SGFzaFtoYXNoXSA9IHtcbiAgICAgICAgLi4uc3Vic2NyaXB0aW9uQ29uZmlnLFxuICAgICAgICBhcmdzLFxuICAgICAgICBjYWxsYmFja3M6IG5ldyBTZXQoW3N1YnNjcmlwdGlvbkNvbmZpZy5jYWxsYmFja10pLFxuICAgICAgICBzdGF0ZTogJ3BlbmRpbmcnXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdGluZ1N1YnNjcmlwdGlvbi5jYWxsYmFja3MuYWRkKHN1YnNjcmlwdGlvbkNvbmZpZy5jYWxsYmFjayk7XG4gICAgfVxuICAgIHRoaXMuX3N1YnNjcmlwdGlvbkhhc2hCeUNsaWVudFN1YnNjcmlwdGlvbklkW2NsaWVudFN1YnNjcmlwdGlvbklkXSA9IGhhc2g7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uRGlzcG9zZUZ1bmN0aW9uc0J5Q2xpZW50U3Vic2NyaXB0aW9uSWRbY2xpZW50U3Vic2NyaXB0aW9uSWRdID0gYXN5bmMgKCkgPT4ge1xuICAgICAgZGVsZXRlIHRoaXMuX3N1YnNjcmlwdGlvbkRpc3Bvc2VGdW5jdGlvbnNCeUNsaWVudFN1YnNjcmlwdGlvbklkW2NsaWVudFN1YnNjcmlwdGlvbklkXTtcbiAgICAgIGRlbGV0ZSB0aGlzLl9zdWJzY3JpcHRpb25IYXNoQnlDbGllbnRTdWJzY3JpcHRpb25JZFtjbGllbnRTdWJzY3JpcHRpb25JZF07XG4gICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSB0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoW2hhc2hdO1xuICAgICAgYXNzZXJ0KHN1YnNjcmlwdGlvbiAhPT0gdW5kZWZpbmVkLCBgQ291bGQgbm90IGZpbmQgYSBcXGBTdWJzY3JpcHRpb25cXGAgd2hlbiB0ZWFyaW5nIGRvd24gY2xpZW50IHN1YnNjcmlwdGlvbiAjJHtjbGllbnRTdWJzY3JpcHRpb25JZH1gKTtcbiAgICAgIHN1YnNjcmlwdGlvbi5jYWxsYmFja3MuZGVsZXRlKHN1YnNjcmlwdGlvbkNvbmZpZy5jYWxsYmFjayk7XG4gICAgICBhd2FpdCB0aGlzLl91cGRhdGVTdWJzY3JpcHRpb25zKCk7XG4gICAgfTtcbiAgICB0aGlzLl91cGRhdGVTdWJzY3JpcHRpb25zKCk7XG4gICAgcmV0dXJuIGNsaWVudFN1YnNjcmlwdGlvbklkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuZXZlciB0aGUgc3BlY2lmaWVkIGFjY291bnQgY2hhbmdlc1xuICAgKlxuICAgKiBAcGFyYW0gcHVibGljS2V5IFB1YmxpYyBrZXkgb2YgdGhlIGFjY291bnQgdG8gbW9uaXRvclxuICAgKiBAcGFyYW0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gaW52b2tlIHdoZW5ldmVyIHRoZSBhY2NvdW50IGlzIGNoYW5nZWRcbiAgICogQHBhcmFtIGNvbmZpZ1xuICAgKiBAcmV0dXJuIHN1YnNjcmlwdGlvbiBpZFxuICAgKi9cblxuICAvKiogQGRlcHJlY2F0ZWQgSW5zdGVhZCwgcGFzcyBpbiBhbiB7QGxpbmsgQWNjb3VudFN1YnNjcmlwdGlvbkNvbmZpZ30gKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcbiAgb25BY2NvdW50Q2hhbmdlKHB1YmxpY0tleSwgY2FsbGJhY2ssIGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbcHVibGljS2V5LnRvQmFzZTU4KCldLCBjb21taXRtZW50IHx8IHRoaXMuX2NvbW1pdG1lbnQgfHwgJ2ZpbmFsaXplZCcsXG4gICAgLy8gQXBwbHkgY29ubmVjdGlvbi9zZXJ2ZXIgZGVmYXVsdC5cbiAgICAnYmFzZTY0JywgY29uZmlnKTtcbiAgICByZXR1cm4gdGhpcy5fbWFrZVN1YnNjcmlwdGlvbih7XG4gICAgICBjYWxsYmFjayxcbiAgICAgIG1ldGhvZDogJ2FjY291bnRTdWJzY3JpYmUnLFxuICAgICAgdW5zdWJzY3JpYmVNZXRob2Q6ICdhY2NvdW50VW5zdWJzY3JpYmUnXG4gICAgfSwgYXJncyk7XG4gIH1cblxuICAvKipcbiAgICogRGVyZWdpc3RlciBhbiBhY2NvdW50IG5vdGlmaWNhdGlvbiBjYWxsYmFja1xuICAgKlxuICAgKiBAcGFyYW0gY2xpZW50U3Vic2NyaXB0aW9uSWQgY2xpZW50IHN1YnNjcmlwdGlvbiBpZCB0byBkZXJlZ2lzdGVyXG4gICAqL1xuICBhc3luYyByZW1vdmVBY2NvdW50Q2hhbmdlTGlzdGVuZXIoY2xpZW50U3Vic2NyaXB0aW9uSWQpIHtcbiAgICBhd2FpdCB0aGlzLl91bnN1YnNjcmliZUNsaWVudFN1YnNjcmlwdGlvbihjbGllbnRTdWJzY3JpcHRpb25JZCwgJ2FjY291bnQgY2hhbmdlJyk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfd3NPblByb2dyYW1BY2NvdW50Tm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbikge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlc3VsdCxcbiAgICAgIHN1YnNjcmlwdGlvblxuICAgIH0gPSBjcmVhdGUobm90aWZpY2F0aW9uLCBQcm9ncmFtQWNjb3VudE5vdGlmaWNhdGlvblJlc3VsdCk7XG4gICAgdGhpcy5faGFuZGxlU2VydmVyTm90aWZpY2F0aW9uKHN1YnNjcmlwdGlvbiwgW3tcbiAgICAgIGFjY291bnRJZDogcmVzdWx0LnZhbHVlLnB1YmtleSxcbiAgICAgIGFjY291bnRJbmZvOiByZXN1bHQudmFsdWUuYWNjb3VudFxuICAgIH0sIHJlc3VsdC5jb250ZXh0XSk7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBjYWxsYmFjayB0byBiZSBpbnZva2VkIHdoZW5ldmVyIGFjY291bnRzIG93bmVkIGJ5IHRoZVxuICAgKiBzcGVjaWZpZWQgcHJvZ3JhbSBjaGFuZ2VcbiAgICpcbiAgICogQHBhcmFtIHByb2dyYW1JZCBQdWJsaWMga2V5IG9mIHRoZSBwcm9ncmFtIHRvIG1vbml0b3JcbiAgICogQHBhcmFtIGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGludm9rZSB3aGVuZXZlciB0aGUgYWNjb3VudCBpcyBjaGFuZ2VkXG4gICAqIEBwYXJhbSBjb25maWdcbiAgICogQHJldHVybiBzdWJzY3JpcHRpb24gaWRcbiAgICovXG5cbiAgLyoqIEBkZXByZWNhdGVkIEluc3RlYWQsIHBhc3MgaW4gYSB7QGxpbmsgUHJvZ3JhbUFjY291bnRTdWJzY3JpcHRpb25Db25maWd9ICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG4gIG9uUHJvZ3JhbUFjY291bnRDaGFuZ2UocHJvZ3JhbUlkLCBjYWxsYmFjaywgY29tbWl0bWVudE9yQ29uZmlnLCBtYXliZUZpbHRlcnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3Byb2dyYW1JZC50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCB8fCB0aGlzLl9jb21taXRtZW50IHx8ICdmaW5hbGl6ZWQnLFxuICAgIC8vIEFwcGx5IGNvbm5lY3Rpb24vc2VydmVyIGRlZmF1bHQuXG4gICAgJ2Jhc2U2NCcgLyogZW5jb2RpbmcgKi8sIGNvbmZpZyA/IGNvbmZpZyA6IG1heWJlRmlsdGVycyA/IHtcbiAgICAgIGZpbHRlcnM6IGFwcGx5RGVmYXVsdE1lbWNtcEVuY29kaW5nVG9GaWx0ZXJzKG1heWJlRmlsdGVycylcbiAgICB9IDogdW5kZWZpbmVkIC8qIGV4dHJhICovKTtcbiAgICByZXR1cm4gdGhpcy5fbWFrZVN1YnNjcmlwdGlvbih7XG4gICAgICBjYWxsYmFjayxcbiAgICAgIG1ldGhvZDogJ3Byb2dyYW1TdWJzY3JpYmUnLFxuICAgICAgdW5zdWJzY3JpYmVNZXRob2Q6ICdwcm9ncmFtVW5zdWJzY3JpYmUnXG4gICAgfSwgYXJncyk7XG4gIH1cblxuICAvKipcbiAgICogRGVyZWdpc3RlciBhbiBhY2NvdW50IG5vdGlmaWNhdGlvbiBjYWxsYmFja1xuICAgKlxuICAgKiBAcGFyYW0gY2xpZW50U3Vic2NyaXB0aW9uSWQgY2xpZW50IHN1YnNjcmlwdGlvbiBpZCB0byBkZXJlZ2lzdGVyXG4gICAqL1xuICBhc3luYyByZW1vdmVQcm9ncmFtQWNjb3VudENoYW5nZUxpc3RlbmVyKGNsaWVudFN1YnNjcmlwdGlvbklkKSB7XG4gICAgYXdhaXQgdGhpcy5fdW5zdWJzY3JpYmVDbGllbnRTdWJzY3JpcHRpb24oY2xpZW50U3Vic2NyaXB0aW9uSWQsICdwcm9ncmFtIGFjY291bnQgY2hhbmdlJyk7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuZXZlciBsb2dzIGFyZSBlbWl0dGVkLlxuICAgKi9cbiAgb25Mb2dzKGZpbHRlciwgY2FsbGJhY2ssIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFt0eXBlb2YgZmlsdGVyID09PSAnb2JqZWN0JyA/IHtcbiAgICAgIG1lbnRpb25zOiBbZmlsdGVyLnRvU3RyaW5nKCldXG4gICAgfSA6IGZpbHRlcl0sIGNvbW1pdG1lbnQgfHwgdGhpcy5fY29tbWl0bWVudCB8fCAnZmluYWxpemVkJyAvLyBBcHBseSBjb25uZWN0aW9uL3NlcnZlciBkZWZhdWx0LlxuICAgICk7XG4gICAgcmV0dXJuIHRoaXMuX21ha2VTdWJzY3JpcHRpb24oe1xuICAgICAgY2FsbGJhY2ssXG4gICAgICBtZXRob2Q6ICdsb2dzU3Vic2NyaWJlJyxcbiAgICAgIHVuc3Vic2NyaWJlTWV0aG9kOiAnbG9nc1Vuc3Vic2NyaWJlJ1xuICAgIH0sIGFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXIgYSBsb2dzIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAcGFyYW0gY2xpZW50U3Vic2NyaXB0aW9uSWQgY2xpZW50IHN1YnNjcmlwdGlvbiBpZCB0byBkZXJlZ2lzdGVyLlxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlT25Mb2dzTGlzdGVuZXIoY2xpZW50U3Vic2NyaXB0aW9uSWQpIHtcbiAgICBhd2FpdCB0aGlzLl91bnN1YnNjcmliZUNsaWVudFN1YnNjcmlwdGlvbihjbGllbnRTdWJzY3JpcHRpb25JZCwgJ2xvZ3MnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF93c09uTG9nc05vdGlmaWNhdGlvbihub3RpZmljYXRpb24pIHtcbiAgICBjb25zdCB7XG4gICAgICByZXN1bHQsXG4gICAgICBzdWJzY3JpcHRpb25cbiAgICB9ID0gY3JlYXRlKG5vdGlmaWNhdGlvbiwgTG9nc05vdGlmaWNhdGlvblJlc3VsdCk7XG4gICAgdGhpcy5faGFuZGxlU2VydmVyTm90aWZpY2F0aW9uKHN1YnNjcmlwdGlvbiwgW3Jlc3VsdC52YWx1ZSwgcmVzdWx0LmNvbnRleHRdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF93c09uU2xvdE5vdGlmaWNhdGlvbihub3RpZmljYXRpb24pIHtcbiAgICBjb25zdCB7XG4gICAgICByZXN1bHQsXG4gICAgICBzdWJzY3JpcHRpb25cbiAgICB9ID0gY3JlYXRlKG5vdGlmaWNhdGlvbiwgU2xvdE5vdGlmaWNhdGlvblJlc3VsdCk7XG4gICAgdGhpcy5faGFuZGxlU2VydmVyTm90aWZpY2F0aW9uKHN1YnNjcmlwdGlvbiwgW3Jlc3VsdF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB1cG9uIHNsb3QgY2hhbmdlc1xuICAgKlxuICAgKiBAcGFyYW0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gaW52b2tlIHdoZW5ldmVyIHRoZSBzbG90IGNoYW5nZXNcbiAgICogQHJldHVybiBzdWJzY3JpcHRpb24gaWRcbiAgICovXG4gIG9uU2xvdENoYW5nZShjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLl9tYWtlU3Vic2NyaXB0aW9uKHtcbiAgICAgIGNhbGxiYWNrLFxuICAgICAgbWV0aG9kOiAnc2xvdFN1YnNjcmliZScsXG4gICAgICB1bnN1YnNjcmliZU1ldGhvZDogJ3Nsb3RVbnN1YnNjcmliZSdcbiAgICB9LCBbXSAvKiBhcmdzICovKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVyIGEgc2xvdCBub3RpZmljYXRpb24gY2FsbGJhY2tcbiAgICpcbiAgICogQHBhcmFtIGNsaWVudFN1YnNjcmlwdGlvbklkIGNsaWVudCBzdWJzY3JpcHRpb24gaWQgdG8gZGVyZWdpc3RlclxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlU2xvdENoYW5nZUxpc3RlbmVyKGNsaWVudFN1YnNjcmlwdGlvbklkKSB7XG4gICAgYXdhaXQgdGhpcy5fdW5zdWJzY3JpYmVDbGllbnRTdWJzY3JpcHRpb24oY2xpZW50U3Vic2NyaXB0aW9uSWQsICdzbG90IGNoYW5nZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3dzT25TbG90VXBkYXRlc05vdGlmaWNhdGlvbihub3RpZmljYXRpb24pIHtcbiAgICBjb25zdCB7XG4gICAgICByZXN1bHQsXG4gICAgICBzdWJzY3JpcHRpb25cbiAgICB9ID0gY3JlYXRlKG5vdGlmaWNhdGlvbiwgU2xvdFVwZGF0ZU5vdGlmaWNhdGlvblJlc3VsdCk7XG4gICAgdGhpcy5faGFuZGxlU2VydmVyTm90aWZpY2F0aW9uKHN1YnNjcmlwdGlvbiwgW3Jlc3VsdF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB1cG9uIHNsb3QgdXBkYXRlcy4ge0BsaW5rIFNsb3RVcGRhdGV9J3NcbiAgICogbWF5IGJlIHVzZWZ1bCB0byB0cmFjayBsaXZlIHByb2dyZXNzIG9mIGEgY2x1c3Rlci5cbiAgICpcbiAgICogQHBhcmFtIGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGludm9rZSB3aGVuZXZlciB0aGUgc2xvdCB1cGRhdGVzXG4gICAqIEByZXR1cm4gc3Vic2NyaXB0aW9uIGlkXG4gICAqL1xuICBvblNsb3RVcGRhdGUoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5fbWFrZVN1YnNjcmlwdGlvbih7XG4gICAgICBjYWxsYmFjayxcbiAgICAgIG1ldGhvZDogJ3Nsb3RzVXBkYXRlc1N1YnNjcmliZScsXG4gICAgICB1bnN1YnNjcmliZU1ldGhvZDogJ3Nsb3RzVXBkYXRlc1Vuc3Vic2NyaWJlJ1xuICAgIH0sIFtdIC8qIGFyZ3MgKi8pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXIgYSBzbG90IHVwZGF0ZSBub3RpZmljYXRpb24gY2FsbGJhY2tcbiAgICpcbiAgICogQHBhcmFtIGNsaWVudFN1YnNjcmlwdGlvbklkIGNsaWVudCBzdWJzY3JpcHRpb24gaWQgdG8gZGVyZWdpc3RlclxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlU2xvdFVwZGF0ZUxpc3RlbmVyKGNsaWVudFN1YnNjcmlwdGlvbklkKSB7XG4gICAgYXdhaXQgdGhpcy5fdW5zdWJzY3JpYmVDbGllbnRTdWJzY3JpcHRpb24oY2xpZW50U3Vic2NyaXB0aW9uSWQsICdzbG90IHVwZGF0ZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuICBhc3luYyBfdW5zdWJzY3JpYmVDbGllbnRTdWJzY3JpcHRpb24oY2xpZW50U3Vic2NyaXB0aW9uSWQsIHN1YnNjcmlwdGlvbk5hbWUpIHtcbiAgICBjb25zdCBkaXNwb3NlID0gdGhpcy5fc3Vic2NyaXB0aW9uRGlzcG9zZUZ1bmN0aW9uc0J5Q2xpZW50U3Vic2NyaXB0aW9uSWRbY2xpZW50U3Vic2NyaXB0aW9uSWRdO1xuICAgIGlmIChkaXNwb3NlKSB7XG4gICAgICBhd2FpdCBkaXNwb3NlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybignSWdub3JlZCB1bnN1YnNjcmliZSByZXF1ZXN0IGJlY2F1c2UgYW4gYWN0aXZlIHN1YnNjcmlwdGlvbiB3aXRoIGlkICcgKyBgXFxgJHtjbGllbnRTdWJzY3JpcHRpb25JZH1cXGAgZm9yICcke3N1YnNjcmlwdGlvbk5hbWV9JyBldmVudHMgYCArICdjb3VsZCBub3QgYmUgZm91bmQuJyk7XG4gICAgfVxuICB9XG4gIF9idWlsZEFyZ3MoYXJncywgb3ZlcnJpZGUsIGVuY29kaW5nLCBleHRyYSkge1xuICAgIGNvbnN0IGNvbW1pdG1lbnQgPSBvdmVycmlkZSB8fCB0aGlzLl9jb21taXRtZW50O1xuICAgIGlmIChjb21taXRtZW50IHx8IGVuY29kaW5nIHx8IGV4dHJhKSB7XG4gICAgICBsZXQgb3B0aW9ucyA9IHt9O1xuICAgICAgaWYgKGVuY29kaW5nKSB7XG4gICAgICAgIG9wdGlvbnMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgICAgIH1cbiAgICAgIGlmIChjb21taXRtZW50KSB7XG4gICAgICAgIG9wdGlvbnMuY29tbWl0bWVudCA9IGNvbW1pdG1lbnQ7XG4gICAgICB9XG4gICAgICBpZiAoZXh0cmEpIHtcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24ob3B0aW9ucywgZXh0cmEpO1xuICAgICAgfVxuICAgICAgYXJncy5wdXNoKG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gYXJncztcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKGFyZ3MsIG92ZXJyaWRlLCBlbmNvZGluZywgZXh0cmEpIHtcbiAgICBjb25zdCBjb21taXRtZW50ID0gb3ZlcnJpZGUgfHwgdGhpcy5fY29tbWl0bWVudDtcbiAgICBpZiAoY29tbWl0bWVudCAmJiAhWydjb25maXJtZWQnLCAnZmluYWxpemVkJ10uaW5jbHVkZXMoY29tbWl0bWVudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVXNpbmcgQ29ubmVjdGlvbiB3aXRoIGRlZmF1bHQgY29tbWl0bWVudDogYCcgKyB0aGlzLl9jb21taXRtZW50ICsgJ2AsIGJ1dCBtZXRob2QgcmVxdWlyZXMgYXQgbGVhc3QgYGNvbmZpcm1lZGAnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2J1aWxkQXJncyhhcmdzLCBvdmVycmlkZSwgZW5jb2RpbmcsIGV4dHJhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF93c09uU2lnbmF0dXJlTm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbikge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlc3VsdCxcbiAgICAgIHN1YnNjcmlwdGlvblxuICAgIH0gPSBjcmVhdGUobm90aWZpY2F0aW9uLCBTaWduYXR1cmVOb3RpZmljYXRpb25SZXN1bHQpO1xuICAgIGlmIChyZXN1bHQudmFsdWUgIT09ICdyZWNlaXZlZFNpZ25hdHVyZScpIHtcbiAgICAgIC8qKlxuICAgICAgICogU3BlY2lhbCBjYXNlLlxuICAgICAgICogQWZ0ZXIgYSBzaWduYXR1cmUgaXMgcHJvY2Vzc2VkLCBSUENzIGF1dG9tYXRpY2FsbHkgZGlzcG9zZSBvZiB0aGVcbiAgICAgICAqIHN1YnNjcmlwdGlvbiBvbiB0aGUgc2VydmVyIHNpZGUuIFdlIG5lZWQgdG8gdHJhY2sgd2hpY2ggb2YgdGhlc2VcbiAgICAgICAqIHN1YnNjcmlwdGlvbnMgaGF2ZSBiZWVuIGRpc3Bvc2VkIGluIHN1Y2ggYSB3YXksIHNvIHRoYXQgd2Uga25vd1xuICAgICAgICogd2hldGhlciB0aGUgY2xpZW50IGlzIGRlYWxpbmcgd2l0aCBhIG5vdC15ZXQtcHJvY2Vzc2VkIHNpZ25hdHVyZVxuICAgICAgICogKGluIHdoaWNoIGNhc2Ugd2UgbXVzdCB0ZWFyIGRvd24gdGhlIHNlcnZlciBzdWJzY3JpcHRpb24pIG9yIGFuXG4gICAgICAgKiBhbHJlYWR5LXByb2Nlc3NlZCBzaWduYXR1cmUgKGluIHdoaWNoIGNhc2UgdGhlIGNsaWVudCBjYW4gc2ltcGx5XG4gICAgICAgKiBjbGVhciBvdXQgdGhlIHN1YnNjcmlwdGlvbiBsb2NhbGx5IHdpdGhvdXQgdGVsbGluZyB0aGUgc2VydmVyKS5cbiAgICAgICAqXG4gICAgICAgKiBOT1RFOiBUaGVyZSBpcyBhIHByb3Bvc2FsIHRvIGVsaW1pbmF0ZSB0aGlzIHNwZWNpYWwgY2FzZSwgaGVyZTpcbiAgICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xhbmEtbGFicy9zb2xhbmEvaXNzdWVzLzE4ODkyXG4gICAgICAgKi9cbiAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnNBdXRvRGlzcG9zZWRCeVJwYy5hZGQoc3Vic2NyaXB0aW9uKTtcbiAgICB9XG4gICAgdGhpcy5faGFuZGxlU2VydmVyTm90aWZpY2F0aW9uKHN1YnNjcmlwdGlvbiwgcmVzdWx0LnZhbHVlID09PSAncmVjZWl2ZWRTaWduYXR1cmUnID8gW3tcbiAgICAgIHR5cGU6ICdyZWNlaXZlZCdcbiAgICB9LCByZXN1bHQuY29udGV4dF0gOiBbe1xuICAgICAgdHlwZTogJ3N0YXR1cycsXG4gICAgICByZXN1bHQ6IHJlc3VsdC52YWx1ZVxuICAgIH0sIHJlc3VsdC5jb250ZXh0XSk7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBjYWxsYmFjayB0byBiZSBpbnZva2VkIHVwb24gc2lnbmF0dXJlIHVwZGF0ZXNcbiAgICpcbiAgICogQHBhcmFtIHNpZ25hdHVyZSBUcmFuc2FjdGlvbiBzaWduYXR1cmUgc3RyaW5nIGluIGJhc2UgNThcbiAgICogQHBhcmFtIGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGludm9rZSBvbiBzaWduYXR1cmUgbm90aWZpY2F0aW9uc1xuICAgKiBAcGFyYW0gY29tbWl0bWVudCBTcGVjaWZ5IHRoZSBjb21taXRtZW50IGxldmVsIHNpZ25hdHVyZSBtdXN0IHJlYWNoIGJlZm9yZSBub3RpZmljYXRpb25cbiAgICogQHJldHVybiBzdWJzY3JpcHRpb24gaWRcbiAgICovXG4gIG9uU2lnbmF0dXJlKHNpZ25hdHVyZSwgY2FsbGJhY2ssIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtzaWduYXR1cmVdLCBjb21taXRtZW50IHx8IHRoaXMuX2NvbW1pdG1lbnQgfHwgJ2ZpbmFsaXplZCcgLy8gQXBwbHkgY29ubmVjdGlvbi9zZXJ2ZXIgZGVmYXVsdC5cbiAgICApO1xuICAgIGNvbnN0IGNsaWVudFN1YnNjcmlwdGlvbklkID0gdGhpcy5fbWFrZVN1YnNjcmlwdGlvbih7XG4gICAgICBjYWxsYmFjazogKG5vdGlmaWNhdGlvbiwgY29udGV4dCkgPT4ge1xuICAgICAgICBpZiAobm90aWZpY2F0aW9uLnR5cGUgPT09ICdzdGF0dXMnKSB7XG4gICAgICAgICAgY2FsbGJhY2sobm90aWZpY2F0aW9uLnJlc3VsdCwgY29udGV4dCk7XG4gICAgICAgICAgLy8gU2lnbmF0dXJlcyBzdWJzY3JpcHRpb25zIGFyZSBhdXRvLXJlbW92ZWQgYnkgdGhlIFJQQyBzZXJ2aWNlXG4gICAgICAgICAgLy8gc28gbm8gbmVlZCB0byBleHBsaWNpdGx5IHNlbmQgYW4gdW5zdWJzY3JpYmUgbWVzc2FnZS5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVTaWduYXR1cmVMaXN0ZW5lcihjbGllbnRTdWJzY3JpcHRpb25JZCk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICAgICAgICB9IGNhdGNoIChfZXJyKSB7XG4gICAgICAgICAgICAvLyBBbHJlYWR5IHJlbW92ZWQuXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbWV0aG9kOiAnc2lnbmF0dXJlU3Vic2NyaWJlJyxcbiAgICAgIHVuc3Vic2NyaWJlTWV0aG9kOiAnc2lnbmF0dXJlVW5zdWJzY3JpYmUnXG4gICAgfSwgYXJncyk7XG4gICAgcmV0dXJuIGNsaWVudFN1YnNjcmlwdGlvbklkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuIGEgdHJhbnNhY3Rpb24gaXNcbiAgICogcmVjZWl2ZWQgYW5kL29yIHByb2Nlc3NlZC5cbiAgICpcbiAgICogQHBhcmFtIHNpZ25hdHVyZSBUcmFuc2FjdGlvbiBzaWduYXR1cmUgc3RyaW5nIGluIGJhc2UgNThcbiAgICogQHBhcmFtIGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGludm9rZSBvbiBzaWduYXR1cmUgbm90aWZpY2F0aW9uc1xuICAgKiBAcGFyYW0gb3B0aW9ucyBFbmFibGUgcmVjZWl2ZWQgbm90aWZpY2F0aW9ucyBhbmQgc2V0IHRoZSBjb21taXRtZW50XG4gICAqICAgbGV2ZWwgdGhhdCBzaWduYXR1cmUgbXVzdCByZWFjaCBiZWZvcmUgbm90aWZpY2F0aW9uXG4gICAqIEByZXR1cm4gc3Vic2NyaXB0aW9uIGlkXG4gICAqL1xuICBvblNpZ25hdHVyZVdpdGhPcHRpb25zKHNpZ25hdHVyZSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgLi4uZXh0cmFcbiAgICB9ID0ge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGNvbW1pdG1lbnQ6IG9wdGlvbnMgJiYgb3B0aW9ucy5jb21taXRtZW50IHx8IHRoaXMuX2NvbW1pdG1lbnQgfHwgJ2ZpbmFsaXplZCcgLy8gQXBwbHkgY29ubmVjdGlvbi9zZXJ2ZXIgZGVmYXVsdC5cbiAgICB9O1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3NpZ25hdHVyZV0sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywgZXh0cmEpO1xuICAgIGNvbnN0IGNsaWVudFN1YnNjcmlwdGlvbklkID0gdGhpcy5fbWFrZVN1YnNjcmlwdGlvbih7XG4gICAgICBjYWxsYmFjazogKG5vdGlmaWNhdGlvbiwgY29udGV4dCkgPT4ge1xuICAgICAgICBjYWxsYmFjayhub3RpZmljYXRpb24sIGNvbnRleHQpO1xuICAgICAgICAvLyBTaWduYXR1cmVzIHN1YnNjcmlwdGlvbnMgYXJlIGF1dG8tcmVtb3ZlZCBieSB0aGUgUlBDIHNlcnZpY2VcbiAgICAgICAgLy8gc28gbm8gbmVlZCB0byBleHBsaWNpdGx5IHNlbmQgYW4gdW5zdWJzY3JpYmUgbWVzc2FnZS5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLnJlbW92ZVNpZ25hdHVyZUxpc3RlbmVyKGNsaWVudFN1YnNjcmlwdGlvbklkKTtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICAgICAgfSBjYXRjaCAoX2Vycikge1xuICAgICAgICAgIC8vIEFscmVhZHkgcmVtb3ZlZC5cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG1ldGhvZDogJ3NpZ25hdHVyZVN1YnNjcmliZScsXG4gICAgICB1bnN1YnNjcmliZU1ldGhvZDogJ3NpZ25hdHVyZVVuc3Vic2NyaWJlJ1xuICAgIH0sIGFyZ3MpO1xuICAgIHJldHVybiBjbGllbnRTdWJzY3JpcHRpb25JZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVyIGEgc2lnbmF0dXJlIG5vdGlmaWNhdGlvbiBjYWxsYmFja1xuICAgKlxuICAgKiBAcGFyYW0gY2xpZW50U3Vic2NyaXB0aW9uSWQgY2xpZW50IHN1YnNjcmlwdGlvbiBpZCB0byBkZXJlZ2lzdGVyXG4gICAqL1xuICBhc3luYyByZW1vdmVTaWduYXR1cmVMaXN0ZW5lcihjbGllbnRTdWJzY3JpcHRpb25JZCkge1xuICAgIGF3YWl0IHRoaXMuX3Vuc3Vic2NyaWJlQ2xpZW50U3Vic2NyaXB0aW9uKGNsaWVudFN1YnNjcmlwdGlvbklkLCAnc2lnbmF0dXJlIHJlc3VsdCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3dzT25Sb290Tm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbikge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlc3VsdCxcbiAgICAgIHN1YnNjcmlwdGlvblxuICAgIH0gPSBjcmVhdGUobm90aWZpY2F0aW9uLCBSb290Tm90aWZpY2F0aW9uUmVzdWx0KTtcbiAgICB0aGlzLl9oYW5kbGVTZXJ2ZXJOb3RpZmljYXRpb24oc3Vic2NyaXB0aW9uLCBbcmVzdWx0XSk7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBjYWxsYmFjayB0byBiZSBpbnZva2VkIHVwb24gcm9vdCBjaGFuZ2VzXG4gICAqXG4gICAqIEBwYXJhbSBjYWxsYmFjayBGdW5jdGlvbiB0byBpbnZva2Ugd2hlbmV2ZXIgdGhlIHJvb3QgY2hhbmdlc1xuICAgKiBAcmV0dXJuIHN1YnNjcmlwdGlvbiBpZFxuICAgKi9cbiAgb25Sb290Q2hhbmdlKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuX21ha2VTdWJzY3JpcHRpb24oe1xuICAgICAgY2FsbGJhY2ssXG4gICAgICBtZXRob2Q6ICdyb290U3Vic2NyaWJlJyxcbiAgICAgIHVuc3Vic2NyaWJlTWV0aG9kOiAncm9vdFVuc3Vic2NyaWJlJ1xuICAgIH0sIFtdIC8qIGFyZ3MgKi8pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXIgYSByb290IG5vdGlmaWNhdGlvbiBjYWxsYmFja1xuICAgKlxuICAgKiBAcGFyYW0gY2xpZW50U3Vic2NyaXB0aW9uSWQgY2xpZW50IHN1YnNjcmlwdGlvbiBpZCB0byBkZXJlZ2lzdGVyXG4gICAqL1xuICBhc3luYyByZW1vdmVSb290Q2hhbmdlTGlzdGVuZXIoY2xpZW50U3Vic2NyaXB0aW9uSWQpIHtcbiAgICBhd2FpdCB0aGlzLl91bnN1YnNjcmliZUNsaWVudFN1YnNjcmlwdGlvbihjbGllbnRTdWJzY3JpcHRpb25JZCwgJ3Jvb3QgY2hhbmdlJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBLZXlwYWlyIHNpZ25lciBpbnRlcmZhY2VcbiAqL1xuXG4vKipcbiAqIEFuIGFjY291bnQga2V5cGFpciB1c2VkIGZvciBzaWduaW5nIHRyYW5zYWN0aW9ucy5cbiAqL1xuY2xhc3MgS2V5cGFpciB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcga2V5cGFpciBpbnN0YW5jZS5cbiAgICogR2VuZXJhdGUgcmFuZG9tIGtleXBhaXIgaWYgbm8ge0BsaW5rIEVkMjU1MTlLZXlwYWlyfSBpcyBwcm92aWRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtFZDI1NTE5S2V5cGFpcn0ga2V5cGFpciBlZDI1NTE5IGtleXBhaXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGtleXBhaXIpIHtcbiAgICB0aGlzLl9rZXlwYWlyID0gdm9pZCAwO1xuICAgIHRoaXMuX2tleXBhaXIgPSBrZXlwYWlyID8/IGdlbmVyYXRlS2V5cGFpcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgbmV3IHJhbmRvbSBrZXlwYWlyXG4gICAqXG4gICAqIEByZXR1cm5zIHtLZXlwYWlyfSBLZXlwYWlyXG4gICAqL1xuICBzdGF0aWMgZ2VuZXJhdGUoKSB7XG4gICAgcmV0dXJuIG5ldyBLZXlwYWlyKGdlbmVyYXRlS2V5cGFpcigpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBrZXlwYWlyIGZyb20gYSByYXcgc2VjcmV0IGtleSBieXRlIGFycmF5LlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSB1c2VkIHRvIHJlY3JlYXRlIGEga2V5cGFpciBmcm9tIGEgcHJldmlvdXNseVxuICAgKiBnZW5lcmF0ZWQgc2VjcmV0IGtleS4gR2VuZXJhdGluZyBrZXlwYWlycyBmcm9tIGEgcmFuZG9tIHNlZWQgc2hvdWxkIGJlIGRvbmVcbiAgICogd2l0aCB0aGUge0BsaW5rIEtleXBhaXIuZnJvbVNlZWR9IG1ldGhvZC5cbiAgICpcbiAgICogQHRocm93cyBlcnJvciBpZiB0aGUgcHJvdmlkZWQgc2VjcmV0IGtleSBpcyBpbnZhbGlkIGFuZCB2YWxpZGF0aW9uIGlzIG5vdCBza2lwcGVkLlxuICAgKlxuICAgKiBAcGFyYW0gc2VjcmV0S2V5IHNlY3JldCBrZXkgYnl0ZSBhcnJheVxuICAgKiBAcGFyYW0gb3B0aW9ucyBza2lwIHNlY3JldCBrZXkgdmFsaWRhdGlvblxuICAgKlxuICAgKiBAcmV0dXJucyB7S2V5cGFpcn0gS2V5cGFpclxuICAgKi9cbiAgc3RhdGljIGZyb21TZWNyZXRLZXkoc2VjcmV0S2V5LCBvcHRpb25zKSB7XG4gICAgaWYgKHNlY3JldEtleS5ieXRlTGVuZ3RoICE9PSA2NCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgc2VjcmV0IGtleSBzaXplJyk7XG4gICAgfVxuICAgIGNvbnN0IHB1YmxpY0tleSA9IHNlY3JldEtleS5zbGljZSgzMiwgNjQpO1xuICAgIGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5za2lwVmFsaWRhdGlvbikge1xuICAgICAgY29uc3QgcHJpdmF0ZVNjYWxhciA9IHNlY3JldEtleS5zbGljZSgwLCAzMik7XG4gICAgICBjb25zdCBjb21wdXRlZFB1YmxpY0tleSA9IGdldFB1YmxpY0tleShwcml2YXRlU2NhbGFyKTtcbiAgICAgIGZvciAobGV0IGlpID0gMDsgaWkgPCAzMjsgaWkrKykge1xuICAgICAgICBpZiAocHVibGljS2V5W2lpXSAhPT0gY29tcHV0ZWRQdWJsaWNLZXlbaWldKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcm92aWRlZCBzZWNyZXRLZXkgaXMgaW52YWxpZCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgS2V5cGFpcih7XG4gICAgICBwdWJsaWNLZXksXG4gICAgICBzZWNyZXRLZXlcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIGtleXBhaXIgZnJvbSBhIDMyIGJ5dGUgc2VlZC5cbiAgICpcbiAgICogQHBhcmFtIHNlZWQgc2VlZCBieXRlIGFycmF5XG4gICAqXG4gICAqIEByZXR1cm5zIHtLZXlwYWlyfSBLZXlwYWlyXG4gICAqL1xuICBzdGF0aWMgZnJvbVNlZWQoc2VlZCkge1xuICAgIGNvbnN0IHB1YmxpY0tleSA9IGdldFB1YmxpY0tleShzZWVkKTtcbiAgICBjb25zdCBzZWNyZXRLZXkgPSBuZXcgVWludDhBcnJheSg2NCk7XG4gICAgc2VjcmV0S2V5LnNldChzZWVkKTtcbiAgICBzZWNyZXRLZXkuc2V0KHB1YmxpY0tleSwgMzIpO1xuICAgIHJldHVybiBuZXcgS2V5cGFpcih7XG4gICAgICBwdWJsaWNLZXksXG4gICAgICBzZWNyZXRLZXlcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgcHVibGljIGtleSBmb3IgdGhpcyBrZXlwYWlyXG4gICAqXG4gICAqIEByZXR1cm5zIHtQdWJsaWNLZXl9IFB1YmxpY0tleVxuICAgKi9cbiAgZ2V0IHB1YmxpY0tleSgpIHtcbiAgICByZXR1cm4gbmV3IFB1YmxpY0tleSh0aGlzLl9rZXlwYWlyLnB1YmxpY0tleSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHJhdyBzZWNyZXQga2V5IGZvciB0aGlzIGtleXBhaXJcbiAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9IFNlY3JldCBrZXkgaW4gYW4gYXJyYXkgb2YgVWludDggYnl0ZXNcbiAgICovXG4gIGdldCBzZWNyZXRLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHRoaXMuX2tleXBhaXIuc2VjcmV0S2V5KTtcbiAgfVxufVxuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIG9mIHZhbGlkIExvb2t1cFRhYmxlSW5zdHJ1Y3Rpb25UeXBlJ3NcbiAqL1xuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIG9mIHZhbGlkIGFkZHJlc3MgbG9va3VwIHRhYmxlIEluc3RydWN0aW9uVHlwZSdzXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgTE9PS1VQX1RBQkxFX0lOU1RSVUNUSU9OX0xBWU9VVFMgPSBPYmplY3QuZnJlZXplKHtcbiAgQ3JlYXRlTG9va3VwVGFibGU6IHtcbiAgICBpbmRleDogMCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIHU2NCgncmVjZW50U2xvdCcpLCBCdWZmZXJMYXlvdXQudTgoJ2J1bXBTZWVkJyldKVxuICB9LFxuICBGcmVlemVMb29rdXBUYWJsZToge1xuICAgIGluZGV4OiAxLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKV0pXG4gIH0sXG4gIEV4dGVuZExvb2t1cFRhYmxlOiB7XG4gICAgaW5kZXg6IDIsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCB1NjQoKSwgQnVmZmVyTGF5b3V0LnNlcShwdWJsaWNLZXkoKSwgQnVmZmVyTGF5b3V0Lm9mZnNldChCdWZmZXJMYXlvdXQudTMyKCksIC04KSwgJ2FkZHJlc3NlcycpXSlcbiAgfSxcbiAgRGVhY3RpdmF0ZUxvb2t1cFRhYmxlOiB7XG4gICAgaW5kZXg6IDMsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpXSlcbiAgfSxcbiAgQ2xvc2VMb29rdXBUYWJsZToge1xuICAgIGluZGV4OiA0LFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKV0pXG4gIH1cbn0pO1xuY2xhc3MgQWRkcmVzc0xvb2t1cFRhYmxlSW5zdHJ1Y3Rpb24ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHt9XG4gIHN0YXRpYyBkZWNvZGVJbnN0cnVjdGlvblR5cGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25UeXBlTGF5b3V0ID0gQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKTtcbiAgICBjb25zdCBpbmRleCA9IGluc3RydWN0aW9uVHlwZUxheW91dC5kZWNvZGUoaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgbGV0IHR5cGU7XG4gICAgZm9yIChjb25zdCBbbGF5b3V0VHlwZSwgbGF5b3V0XSBvZiBPYmplY3QuZW50cmllcyhMT09LVVBfVEFCTEVfSU5TVFJVQ1RJT05fTEFZT1VUUykpIHtcbiAgICAgIGlmIChsYXlvdXQuaW5kZXggPT0gaW5kZXgpIHtcbiAgICAgICAgdHlwZSA9IGxheW91dFR5cGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBJbnN0cnVjdGlvbi4gU2hvdWxkIGJlIGEgTG9va3VwVGFibGUgSW5zdHJ1Y3Rpb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbiAgc3RhdGljIGRlY29kZUNyZWF0ZUxvb2t1cFRhYmxlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlzTGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDQpO1xuICAgIGNvbnN0IHtcbiAgICAgIHJlY2VudFNsb3RcbiAgICB9ID0gZGVjb2RlRGF0YSQxKExPT0tVUF9UQUJMRV9JTlNUUlVDVElPTl9MQVlPVVRTLkNyZWF0ZUxvb2t1cFRhYmxlLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgYXV0aG9yaXR5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgIHBheWVyOiBpbnN0cnVjdGlvbi5rZXlzWzJdLnB1YmtleSxcbiAgICAgIHJlY2VudFNsb3Q6IE51bWJlcihyZWNlbnRTbG90KVxuICAgIH07XG4gIH1cbiAgc3RhdGljIGRlY29kZUV4dGVuZExvb2t1cFRhYmxlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIGlmIChpbnN0cnVjdGlvbi5rZXlzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpbnN0cnVjdGlvbjsgZm91bmQgJHtpbnN0cnVjdGlvbi5rZXlzLmxlbmd0aH0ga2V5cywgZXhwZWN0ZWQgYXQgbGVhc3QgMmApO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBhZGRyZXNzZXNcbiAgICB9ID0gZGVjb2RlRGF0YSQxKExPT0tVUF9UQUJMRV9JTlNUUlVDVElPTl9MQVlPVVRTLkV4dGVuZExvb2t1cFRhYmxlLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgbG9va3VwVGFibGU6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYXV0aG9yaXR5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgIHBheWVyOiBpbnN0cnVjdGlvbi5rZXlzLmxlbmd0aCA+IDIgPyBpbnN0cnVjdGlvbi5rZXlzWzJdLnB1YmtleSA6IHVuZGVmaW5lZCxcbiAgICAgIGFkZHJlc3NlczogYWRkcmVzc2VzLm1hcChidWZmZXIgPT4gbmV3IFB1YmxpY0tleShidWZmZXIpKVxuICAgIH07XG4gIH1cbiAgc3RhdGljIGRlY29kZUNsb3NlTG9va3VwVGFibGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleXNMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvb2t1cFRhYmxlOiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGF1dGhvcml0eTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICByZWNpcGllbnQ6IGluc3RydWN0aW9uLmtleXNbMl0ucHVia2V5XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgZGVjb2RlRnJlZXplTG9va3VwVGFibGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleXNMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMik7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvb2t1cFRhYmxlOiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGF1dGhvcml0eTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXlcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBkZWNvZGVEZWFjdGl2YXRlTG9va3VwVGFibGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleXNMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMik7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvb2t1cFRhYmxlOiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGF1dGhvcml0eTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXlcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RhdGljIGNoZWNrUHJvZ3JhbUlkKHByb2dyYW1JZCkge1xuICAgIGlmICghcHJvZ3JhbUlkLmVxdWFscyhBZGRyZXNzTG9va3VwVGFibGVQcm9ncmFtLnByb2dyYW1JZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnN0cnVjdGlvbjsgcHJvZ3JhbUlkIGlzIG5vdCBBZGRyZXNzTG9va3VwVGFibGUgUHJvZ3JhbScpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdGF0aWMgY2hlY2tLZXlzTGVuZ3RoKGtleXMsIGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgaWYgKGtleXMubGVuZ3RoIDwgZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpbnN0cnVjdGlvbjsgZm91bmQgJHtrZXlzLmxlbmd0aH0ga2V5cywgZXhwZWN0ZWQgYXQgbGVhc3QgJHtleHBlY3RlZExlbmd0aH1gKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIEFkZHJlc3NMb29rdXBUYWJsZVByb2dyYW0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHt9XG4gIHN0YXRpYyBjcmVhdGVMb29rdXBUYWJsZShwYXJhbXMpIHtcbiAgICBjb25zdCBbbG9va3VwVGFibGVBZGRyZXNzLCBidW1wU2VlZF0gPSBQdWJsaWNLZXkuZmluZFByb2dyYW1BZGRyZXNzU3luYyhbcGFyYW1zLmF1dGhvcml0eS50b0J1ZmZlcigpLCBnZXRVNjRFbmNvZGVyKCkuZW5jb2RlKHBhcmFtcy5yZWNlbnRTbG90KV0sIHRoaXMucHJvZ3JhbUlkKTtcbiAgICBjb25zdCB0eXBlID0gTE9PS1VQX1RBQkxFX0lOU1RSVUNUSU9OX0xBWU9VVFMuQ3JlYXRlTG9va3VwVGFibGU7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgcmVjZW50U2xvdDogQmlnSW50KHBhcmFtcy5yZWNlbnRTbG90KSxcbiAgICAgIGJ1bXBTZWVkOiBidW1wU2VlZFxuICAgIH0pO1xuICAgIGNvbnN0IGtleXMgPSBbe1xuICAgICAgcHVia2V5OiBsb29rdXBUYWJsZUFkZHJlc3MsXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBwYXJhbXMuYXV0aG9yaXR5LFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogcGFyYW1zLnBheWVyLFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBTeXN0ZW1Qcm9ncmFtLnByb2dyYW1JZCxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfV07XG4gICAgcmV0dXJuIFtuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAga2V5czoga2V5cyxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KSwgbG9va3VwVGFibGVBZGRyZXNzXTtcbiAgfVxuICBzdGF0aWMgZnJlZXplTG9va3VwVGFibGUocGFyYW1zKSB7XG4gICAgY29uc3QgdHlwZSA9IExPT0tVUF9UQUJMRV9JTlNUUlVDVElPTl9MQVlPVVRTLkZyZWV6ZUxvb2t1cFRhYmxlO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUpO1xuICAgIGNvbnN0IGtleXMgPSBbe1xuICAgICAgcHVia2V5OiBwYXJhbXMubG9va3VwVGFibGUsXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBwYXJhbXMuYXV0aG9yaXR5LFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH1dO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAga2V5czoga2V5cyxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZXh0ZW5kTG9va3VwVGFibGUocGFyYW1zKSB7XG4gICAgY29uc3QgdHlwZSA9IExPT0tVUF9UQUJMRV9JTlNUUlVDVElPTl9MQVlPVVRTLkV4dGVuZExvb2t1cFRhYmxlO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIGFkZHJlc3NlczogcGFyYW1zLmFkZHJlc3Nlcy5tYXAoYWRkciA9PiBhZGRyLnRvQnl0ZXMoKSlcbiAgICB9KTtcbiAgICBjb25zdCBrZXlzID0gW3tcbiAgICAgIHB1YmtleTogcGFyYW1zLmxvb2t1cFRhYmxlLFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogcGFyYW1zLmF1dGhvcml0eSxcbiAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9XTtcbiAgICBpZiAocGFyYW1zLnBheWVyKSB7XG4gICAgICBrZXlzLnB1c2goe1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5wYXllcixcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBTeXN0ZW1Qcm9ncmFtLnByb2dyYW1JZCxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAga2V5czoga2V5cyxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZGVhY3RpdmF0ZUxvb2t1cFRhYmxlKHBhcmFtcykge1xuICAgIGNvbnN0IHR5cGUgPSBMT09LVVBfVEFCTEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5EZWFjdGl2YXRlTG9va3VwVGFibGU7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSk7XG4gICAgY29uc3Qga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IHBhcmFtcy5sb29rdXBUYWJsZSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IHBhcmFtcy5hdXRob3JpdHksXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfV07XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBrZXlzOiBrZXlzLFxuICAgICAgZGF0YTogZGF0YVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBjbG9zZUxvb2t1cFRhYmxlKHBhcmFtcykge1xuICAgIGNvbnN0IHR5cGUgPSBMT09LVVBfVEFCTEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5DbG9zZUxvb2t1cFRhYmxlO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUpO1xuICAgIGNvbnN0IGtleXMgPSBbe1xuICAgICAgcHVia2V5OiBwYXJhbXMubG9va3VwVGFibGUsXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBwYXJhbXMuYXV0aG9yaXR5LFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogcGFyYW1zLnJlY2lwaWVudCxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9XTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGtleXM6IGtleXMsXG4gICAgICBkYXRhOiBkYXRhXG4gICAgfSk7XG4gIH1cbn1cbkFkZHJlc3NMb29rdXBUYWJsZVByb2dyYW0ucHJvZ3JhbUlkID0gbmV3IFB1YmxpY0tleSgnQWRkcmVzc0xvb2t1cFRhYjFlMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuXG4vKipcbiAqIENvbXB1dGUgQnVkZ2V0IEluc3RydWN0aW9uIGNsYXNzXG4gKi9cbmNsYXNzIENvbXB1dGVCdWRnZXRJbnN0cnVjdGlvbiB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogRGVjb2RlIGEgY29tcHV0ZSBidWRnZXQgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiB0eXBlLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUluc3RydWN0aW9uVHlwZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICBjb25zdCBpbnN0cnVjdGlvblR5cGVMYXlvdXQgPSBCdWZmZXJMYXlvdXQudTgoJ2luc3RydWN0aW9uJyk7XG4gICAgY29uc3QgdHlwZUluZGV4ID0gaW5zdHJ1Y3Rpb25UeXBlTGF5b3V0LmRlY29kZShpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICBsZXQgdHlwZTtcbiAgICBmb3IgKGNvbnN0IFtpeFR5cGUsIGxheW91dF0gb2YgT2JqZWN0LmVudHJpZXMoQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUykpIHtcbiAgICAgIGlmIChsYXlvdXQuaW5kZXggPT0gdHlwZUluZGV4KSB7XG4gICAgICAgIHR5cGUgPSBpeFR5cGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5zdHJ1Y3Rpb24gdHlwZSBpbmNvcnJlY3Q7IG5vdCBhIENvbXB1dGVCdWRnZXRJbnN0cnVjdGlvbicpO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgcmVxdWVzdCB1bml0cyBjb21wdXRlIGJ1ZGdldCBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVSZXF1ZXN0VW5pdHMoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgY29uc3Qge1xuICAgICAgdW5pdHMsXG4gICAgICBhZGRpdGlvbmFsRmVlXG4gICAgfSA9IGRlY29kZURhdGEkMShDT01QVVRFX0JVREdFVF9JTlNUUlVDVElPTl9MQVlPVVRTLlJlcXVlc3RVbml0cywgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVuaXRzLFxuICAgICAgYWRkaXRpb25hbEZlZVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIHJlcXVlc3QgaGVhcCBmcmFtZSBjb21wdXRlIGJ1ZGdldCBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVSZXF1ZXN0SGVhcEZyYW1lKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIGNvbnN0IHtcbiAgICAgIGJ5dGVzXG4gICAgfSA9IGRlY29kZURhdGEkMShDT01QVVRFX0JVREdFVF9JTlNUUlVDVElPTl9MQVlPVVRTLlJlcXVlc3RIZWFwRnJhbWUsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBieXRlc1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIHNldCBjb21wdXRlIHVuaXQgbGltaXQgY29tcHV0ZSBidWRnZXQgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlU2V0Q29tcHV0ZVVuaXRMaW1pdChpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICBjb25zdCB7XG4gICAgICB1bml0c1xuICAgIH0gPSBkZWNvZGVEYXRhJDEoQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUy5TZXRDb21wdXRlVW5pdExpbWl0LCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgdW5pdHNcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBzZXQgY29tcHV0ZSB1bml0IHByaWNlIGNvbXB1dGUgYnVkZ2V0IGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZVNldENvbXB1dGVVbml0UHJpY2UoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgY29uc3Qge1xuICAgICAgbWljcm9MYW1wb3J0c1xuICAgIH0gPSBkZWNvZGVEYXRhJDEoQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUy5TZXRDb21wdXRlVW5pdFByaWNlLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgbWljcm9MYW1wb3J0c1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdGF0aWMgY2hlY2tQcm9ncmFtSWQocHJvZ3JhbUlkKSB7XG4gICAgaWYgKCFwcm9ncmFtSWQuZXF1YWxzKENvbXB1dGVCdWRnZXRQcm9ncmFtLnByb2dyYW1JZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnN0cnVjdGlvbjsgcHJvZ3JhbUlkIGlzIG5vdCBDb21wdXRlQnVkZ2V0UHJvZ3JhbScpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIG9mIHZhbGlkIENvbXB1dGVCdWRnZXRJbnN0cnVjdGlvblR5cGUnc1xuICovXG5cbi8qKlxuICogUmVxdWVzdCB1bml0cyBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIFJlcXVlc3QgaGVhcCBmcmFtZSBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIFNldCBjb21wdXRlIHVuaXQgbGltaXQgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBTZXQgY29tcHV0ZSB1bml0IHByaWNlIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgdmFsaWQgQ29tcHV0ZUJ1ZGdldCBJbnN0cnVjdGlvblR5cGUnc1xuICogQGludGVybmFsXG4gKi9cbmNvbnN0IENPTVBVVEVfQlVER0VUX0lOU1RSVUNUSU9OX0xBWU9VVFMgPSBPYmplY3QuZnJlZXplKHtcbiAgUmVxdWVzdFVuaXRzOiB7XG4gICAgaW5kZXg6IDAsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTgoJ2luc3RydWN0aW9uJyksIEJ1ZmZlckxheW91dC51MzIoJ3VuaXRzJyksIEJ1ZmZlckxheW91dC51MzIoJ2FkZGl0aW9uYWxGZWUnKV0pXG4gIH0sXG4gIFJlcXVlc3RIZWFwRnJhbWU6IHtcbiAgICBpbmRleDogMSxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51OCgnaW5zdHJ1Y3Rpb24nKSwgQnVmZmVyTGF5b3V0LnUzMignYnl0ZXMnKV0pXG4gIH0sXG4gIFNldENvbXB1dGVVbml0TGltaXQ6IHtcbiAgICBpbmRleDogMixcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51OCgnaW5zdHJ1Y3Rpb24nKSwgQnVmZmVyTGF5b3V0LnUzMigndW5pdHMnKV0pXG4gIH0sXG4gIFNldENvbXB1dGVVbml0UHJpY2U6IHtcbiAgICBpbmRleDogMyxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51OCgnaW5zdHJ1Y3Rpb24nKSwgdTY0KCdtaWNyb0xhbXBvcnRzJyldKVxuICB9XG59KTtcblxuLyoqXG4gKiBGYWN0b3J5IGNsYXNzIGZvciB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvbnMgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgQ29tcHV0ZSBCdWRnZXQgcHJvZ3JhbVxuICovXG5jbGFzcyBDb21wdXRlQnVkZ2V0UHJvZ3JhbSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogUHVibGljIGtleSB0aGF0IGlkZW50aWZpZXMgdGhlIENvbXB1dGUgQnVkZ2V0IHByb2dyYW1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIEluc3RlYWQsIGNhbGwge0BsaW5rIHNldENvbXB1dGVVbml0TGltaXR9IGFuZC9vciB7QGxpbmsgc2V0Q29tcHV0ZVVuaXRQcmljZX1cbiAgICovXG4gIHN0YXRpYyByZXF1ZXN0VW5pdHMocGFyYW1zKSB7XG4gICAgY29uc3QgdHlwZSA9IENPTVBVVEVfQlVER0VUX0lOU1RSVUNUSU9OX0xBWU9VVFMuUmVxdWVzdFVuaXRzO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHBhcmFtcyk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXM6IFtdLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgcmVxdWVzdEhlYXBGcmFtZShwYXJhbXMpIHtcbiAgICBjb25zdCB0eXBlID0gQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUy5SZXF1ZXN0SGVhcEZyYW1lO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHBhcmFtcyk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXM6IFtdLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgc2V0Q29tcHV0ZVVuaXRMaW1pdChwYXJhbXMpIHtcbiAgICBjb25zdCB0eXBlID0gQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUy5TZXRDb21wdXRlVW5pdExpbWl0O1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHBhcmFtcyk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXM6IFtdLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgc2V0Q29tcHV0ZVVuaXRQcmljZShwYXJhbXMpIHtcbiAgICBjb25zdCB0eXBlID0gQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUy5TZXRDb21wdXRlVW5pdFByaWNlO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIG1pY3JvTGFtcG9ydHM6IEJpZ0ludChwYXJhbXMubWljcm9MYW1wb3J0cylcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5czogW10sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG59XG5Db21wdXRlQnVkZ2V0UHJvZ3JhbS5wcm9ncmFtSWQgPSBuZXcgUHVibGljS2V5KCdDb21wdXRlQnVkZ2V0MTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5cbmNvbnN0IFBSSVZBVEVfS0VZX0JZVEVTJDEgPSA2NDtcbmNvbnN0IFBVQkxJQ19LRVlfQllURVMkMSA9IDMyO1xuY29uc3QgU0lHTkFUVVJFX0JZVEVTID0gNjQ7XG5cbi8qKlxuICogUGFyYW1zIGZvciBjcmVhdGluZyBhbiBlZDI1NTE5IGluc3RydWN0aW9uIHVzaW5nIGEgcHVibGljIGtleVxuICovXG5cbi8qKlxuICogUGFyYW1zIGZvciBjcmVhdGluZyBhbiBlZDI1NTE5IGluc3RydWN0aW9uIHVzaW5nIGEgcHJpdmF0ZSBrZXlcbiAqL1xuXG5jb25zdCBFRDI1NTE5X0lOU1RSVUNUSU9OX0xBWU9VVCA9IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51OCgnbnVtU2lnbmF0dXJlcycpLCBCdWZmZXJMYXlvdXQudTgoJ3BhZGRpbmcnKSwgQnVmZmVyTGF5b3V0LnUxNignc2lnbmF0dXJlT2Zmc2V0JyksIEJ1ZmZlckxheW91dC51MTYoJ3NpZ25hdHVyZUluc3RydWN0aW9uSW5kZXgnKSwgQnVmZmVyTGF5b3V0LnUxNigncHVibGljS2V5T2Zmc2V0JyksIEJ1ZmZlckxheW91dC51MTYoJ3B1YmxpY0tleUluc3RydWN0aW9uSW5kZXgnKSwgQnVmZmVyTGF5b3V0LnUxNignbWVzc2FnZURhdGFPZmZzZXQnKSwgQnVmZmVyTGF5b3V0LnUxNignbWVzc2FnZURhdGFTaXplJyksIEJ1ZmZlckxheW91dC51MTYoJ21lc3NhZ2VJbnN0cnVjdGlvbkluZGV4JyldKTtcbmNsYXNzIEVkMjU1MTlQcm9ncmFtIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBQdWJsaWMga2V5IHRoYXQgaWRlbnRpZmllcyB0aGUgZWQyNTUxOSBwcm9ncmFtXG4gICAqL1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gZWQyNTUxOSBpbnN0cnVjdGlvbiB3aXRoIGEgcHVibGljIGtleSBhbmQgc2lnbmF0dXJlLiBUaGVcbiAgICogcHVibGljIGtleSBtdXN0IGJlIGEgYnVmZmVyIHRoYXQgaXMgMzIgYnl0ZXMgbG9uZywgYW5kIHRoZSBzaWduYXR1cmVcbiAgICogbXVzdCBiZSBhIGJ1ZmZlciBvZiA2NCBieXRlcy5cbiAgICovXG4gIHN0YXRpYyBjcmVhdGVJbnN0cnVjdGlvbldpdGhQdWJsaWNLZXkocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgcHVibGljS2V5LFxuICAgICAgbWVzc2FnZSxcbiAgICAgIHNpZ25hdHVyZSxcbiAgICAgIGluc3RydWN0aW9uSW5kZXhcbiAgICB9ID0gcGFyYW1zO1xuICAgIGFzc2VydChwdWJsaWNLZXkubGVuZ3RoID09PSBQVUJMSUNfS0VZX0JZVEVTJDEsIGBQdWJsaWMgS2V5IG11c3QgYmUgJHtQVUJMSUNfS0VZX0JZVEVTJDF9IGJ5dGVzIGJ1dCByZWNlaXZlZCAke3B1YmxpY0tleS5sZW5ndGh9IGJ5dGVzYCk7XG4gICAgYXNzZXJ0KHNpZ25hdHVyZS5sZW5ndGggPT09IFNJR05BVFVSRV9CWVRFUywgYFNpZ25hdHVyZSBtdXN0IGJlICR7U0lHTkFUVVJFX0JZVEVTfSBieXRlcyBidXQgcmVjZWl2ZWQgJHtzaWduYXR1cmUubGVuZ3RofSBieXRlc2ApO1xuICAgIGNvbnN0IHB1YmxpY0tleU9mZnNldCA9IEVEMjU1MTlfSU5TVFJVQ1RJT05fTEFZT1VULnNwYW47XG4gICAgY29uc3Qgc2lnbmF0dXJlT2Zmc2V0ID0gcHVibGljS2V5T2Zmc2V0ICsgcHVibGljS2V5Lmxlbmd0aDtcbiAgICBjb25zdCBtZXNzYWdlRGF0YU9mZnNldCA9IHNpZ25hdHVyZU9mZnNldCArIHNpZ25hdHVyZS5sZW5ndGg7XG4gICAgY29uc3QgbnVtU2lnbmF0dXJlcyA9IDE7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25EYXRhID0gQnVmZmVyLmFsbG9jKG1lc3NhZ2VEYXRhT2Zmc2V0ICsgbWVzc2FnZS5sZW5ndGgpO1xuICAgIGNvbnN0IGluZGV4ID0gaW5zdHJ1Y3Rpb25JbmRleCA9PSBudWxsID8gMHhmZmZmIC8vIEFuIGluZGV4IG9mIGB1MTY6Ok1BWGAgbWFrZXMgaXQgZGVmYXVsdCB0byB0aGUgY3VycmVudCBpbnN0cnVjdGlvbi5cbiAgICA6IGluc3RydWN0aW9uSW5kZXg7XG4gICAgRUQyNTUxOV9JTlNUUlVDVElPTl9MQVlPVVQuZW5jb2RlKHtcbiAgICAgIG51bVNpZ25hdHVyZXMsXG4gICAgICBwYWRkaW5nOiAwLFxuICAgICAgc2lnbmF0dXJlT2Zmc2V0LFxuICAgICAgc2lnbmF0dXJlSW5zdHJ1Y3Rpb25JbmRleDogaW5kZXgsXG4gICAgICBwdWJsaWNLZXlPZmZzZXQsXG4gICAgICBwdWJsaWNLZXlJbnN0cnVjdGlvbkluZGV4OiBpbmRleCxcbiAgICAgIG1lc3NhZ2VEYXRhT2Zmc2V0LFxuICAgICAgbWVzc2FnZURhdGFTaXplOiBtZXNzYWdlLmxlbmd0aCxcbiAgICAgIG1lc3NhZ2VJbnN0cnVjdGlvbkluZGV4OiBpbmRleFxuICAgIH0sIGluc3RydWN0aW9uRGF0YSk7XG4gICAgaW5zdHJ1Y3Rpb25EYXRhLmZpbGwocHVibGljS2V5LCBwdWJsaWNLZXlPZmZzZXQpO1xuICAgIGluc3RydWN0aW9uRGF0YS5maWxsKHNpZ25hdHVyZSwgc2lnbmF0dXJlT2Zmc2V0KTtcbiAgICBpbnN0cnVjdGlvbkRhdGEuZmlsbChtZXNzYWdlLCBtZXNzYWdlRGF0YU9mZnNldCk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXM6IFtdLFxuICAgICAgcHJvZ3JhbUlkOiBFZDI1NTE5UHJvZ3JhbS5wcm9ncmFtSWQsXG4gICAgICBkYXRhOiBpbnN0cnVjdGlvbkRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gZWQyNTUxOSBpbnN0cnVjdGlvbiB3aXRoIGEgcHJpdmF0ZSBrZXkuIFRoZSBwcml2YXRlIGtleVxuICAgKiBtdXN0IGJlIGEgYnVmZmVyIHRoYXQgaXMgNjQgYnl0ZXMgbG9uZy5cbiAgICovXG4gIHN0YXRpYyBjcmVhdGVJbnN0cnVjdGlvbldpdGhQcml2YXRlS2V5KHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHByaXZhdGVLZXksXG4gICAgICBtZXNzYWdlLFxuICAgICAgaW5zdHJ1Y3Rpb25JbmRleFxuICAgIH0gPSBwYXJhbXM7XG4gICAgYXNzZXJ0KHByaXZhdGVLZXkubGVuZ3RoID09PSBQUklWQVRFX0tFWV9CWVRFUyQxLCBgUHJpdmF0ZSBrZXkgbXVzdCBiZSAke1BSSVZBVEVfS0VZX0JZVEVTJDF9IGJ5dGVzIGJ1dCByZWNlaXZlZCAke3ByaXZhdGVLZXkubGVuZ3RofSBieXRlc2ApO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBrZXlwYWlyID0gS2V5cGFpci5mcm9tU2VjcmV0S2V5KHByaXZhdGVLZXkpO1xuICAgICAgY29uc3QgcHVibGljS2V5ID0ga2V5cGFpci5wdWJsaWNLZXkudG9CeXRlcygpO1xuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gc2lnbihtZXNzYWdlLCBrZXlwYWlyLnNlY3JldEtleSk7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVJbnN0cnVjdGlvbldpdGhQdWJsaWNLZXkoe1xuICAgICAgICBwdWJsaWNLZXksXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgaW5zdHJ1Y3Rpb25JbmRleFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgY3JlYXRpbmcgaW5zdHJ1Y3Rpb247ICR7ZXJyb3J9YCk7XG4gICAgfVxuICB9XG59XG5FZDI1NTE5UHJvZ3JhbS5wcm9ncmFtSWQgPSBuZXcgUHVibGljS2V5KCdFZDI1NTE5U2lnVmVyaWZ5MTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5cbmNvbnN0IGVjZHNhU2lnbiA9IChtc2dIYXNoLCBwcml2S2V5KSA9PiB7XG4gIGNvbnN0IHNpZ25hdHVyZSA9IHNlY3AyNTZrMS5zaWduKG1zZ0hhc2gsIHByaXZLZXkpO1xuICByZXR1cm4gW3NpZ25hdHVyZS50b0NvbXBhY3RSYXdCeXRlcygpLCBzaWduYXR1cmUucmVjb3ZlcnldO1xufTtcbnNlY3AyNTZrMS51dGlscy5pc1ZhbGlkUHJpdmF0ZUtleTtcbmNvbnN0IHB1YmxpY0tleUNyZWF0ZSA9IHNlY3AyNTZrMS5nZXRQdWJsaWNLZXk7XG5cbmNvbnN0IFBSSVZBVEVfS0VZX0JZVEVTID0gMzI7XG5jb25zdCBFVEhFUkVVTV9BRERSRVNTX0JZVEVTID0gMjA7XG5jb25zdCBQVUJMSUNfS0VZX0JZVEVTID0gNjQ7XG5jb25zdCBTSUdOQVRVUkVfT0ZGU0VUU19TRVJJQUxJWkVEX1NJWkUgPSAxMTtcblxuLyoqXG4gKiBQYXJhbXMgZm9yIGNyZWF0aW5nIGFuIHNlY3AyNTZrMSBpbnN0cnVjdGlvbiB1c2luZyBhIHB1YmxpYyBrZXlcbiAqL1xuXG4vKipcbiAqIFBhcmFtcyBmb3IgY3JlYXRpbmcgYW4gc2VjcDI1NmsxIGluc3RydWN0aW9uIHVzaW5nIGFuIEV0aGVyZXVtIGFkZHJlc3NcbiAqL1xuXG4vKipcbiAqIFBhcmFtcyBmb3IgY3JlYXRpbmcgYW4gc2VjcDI1NmsxIGluc3RydWN0aW9uIHVzaW5nIGEgcHJpdmF0ZSBrZXlcbiAqL1xuXG5jb25zdCBTRUNQMjU2SzFfSU5TVFJVQ1RJT05fTEFZT1VUID0gQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnU4KCdudW1TaWduYXR1cmVzJyksIEJ1ZmZlckxheW91dC51MTYoJ3NpZ25hdHVyZU9mZnNldCcpLCBCdWZmZXJMYXlvdXQudTgoJ3NpZ25hdHVyZUluc3RydWN0aW9uSW5kZXgnKSwgQnVmZmVyTGF5b3V0LnUxNignZXRoQWRkcmVzc09mZnNldCcpLCBCdWZmZXJMYXlvdXQudTgoJ2V0aEFkZHJlc3NJbnN0cnVjdGlvbkluZGV4JyksIEJ1ZmZlckxheW91dC51MTYoJ21lc3NhZ2VEYXRhT2Zmc2V0JyksIEJ1ZmZlckxheW91dC51MTYoJ21lc3NhZ2VEYXRhU2l6ZScpLCBCdWZmZXJMYXlvdXQudTgoJ21lc3NhZ2VJbnN0cnVjdGlvbkluZGV4JyksIEJ1ZmZlckxheW91dC5ibG9iKDIwLCAnZXRoQWRkcmVzcycpLCBCdWZmZXJMYXlvdXQuYmxvYig2NCwgJ3NpZ25hdHVyZScpLCBCdWZmZXJMYXlvdXQudTgoJ3JlY292ZXJ5SWQnKV0pO1xuY2xhc3MgU2VjcDI1NmsxUHJvZ3JhbSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogUHVibGljIGtleSB0aGF0IGlkZW50aWZpZXMgdGhlIHNlY3AyNTZrMSBwcm9ncmFtXG4gICAqL1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYW4gRXRoZXJldW0gYWRkcmVzcyBmcm9tIGEgc2VjcDI1NmsxIHB1YmxpYyBrZXkgYnVmZmVyLlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5IGEgNjQgYnl0ZSBzZWNwMjU2azEgcHVibGljIGtleSBidWZmZXJcbiAgICovXG4gIHN0YXRpYyBwdWJsaWNLZXlUb0V0aEFkZHJlc3MocHVibGljS2V5KSB7XG4gICAgYXNzZXJ0KHB1YmxpY0tleS5sZW5ndGggPT09IFBVQkxJQ19LRVlfQllURVMsIGBQdWJsaWMga2V5IG11c3QgYmUgJHtQVUJMSUNfS0VZX0JZVEVTfSBieXRlcyBidXQgcmVjZWl2ZWQgJHtwdWJsaWNLZXkubGVuZ3RofSBieXRlc2ApO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20oa2VjY2FrXzI1Nih0b0J1ZmZlcihwdWJsaWNLZXkpKSkuc2xpY2UoLUVUSEVSRVVNX0FERFJFU1NfQllURVMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGNvbnN0cnVjdGluZyBFdGhlcmV1bSBhZGRyZXNzOiAke2Vycm9yfWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gc2VjcDI1NmsxIGluc3RydWN0aW9uIHdpdGggYSBwdWJsaWMga2V5LiBUaGUgcHVibGljIGtleVxuICAgKiBtdXN0IGJlIGEgYnVmZmVyIHRoYXQgaXMgNjQgYnl0ZXMgbG9uZy5cbiAgICovXG4gIHN0YXRpYyBjcmVhdGVJbnN0cnVjdGlvbldpdGhQdWJsaWNLZXkocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgcHVibGljS2V5LFxuICAgICAgbWVzc2FnZSxcbiAgICAgIHNpZ25hdHVyZSxcbiAgICAgIHJlY292ZXJ5SWQsXG4gICAgICBpbnN0cnVjdGlvbkluZGV4XG4gICAgfSA9IHBhcmFtcztcbiAgICByZXR1cm4gU2VjcDI1NmsxUHJvZ3JhbS5jcmVhdGVJbnN0cnVjdGlvbldpdGhFdGhBZGRyZXNzKHtcbiAgICAgIGV0aEFkZHJlc3M6IFNlY3AyNTZrMVByb2dyYW0ucHVibGljS2V5VG9FdGhBZGRyZXNzKHB1YmxpY0tleSksXG4gICAgICBtZXNzYWdlLFxuICAgICAgc2lnbmF0dXJlLFxuICAgICAgcmVjb3ZlcnlJZCxcbiAgICAgIGluc3RydWN0aW9uSW5kZXhcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gc2VjcDI1NmsxIGluc3RydWN0aW9uIHdpdGggYW4gRXRoZXJldW0gYWRkcmVzcy4gVGhlIGFkZHJlc3NcbiAgICogbXVzdCBiZSBhIGhleCBzdHJpbmcgb3IgYSBidWZmZXIgdGhhdCBpcyAyMCBieXRlcyBsb25nLlxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUluc3RydWN0aW9uV2l0aEV0aEFkZHJlc3MocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgZXRoQWRkcmVzczogcmF3QWRkcmVzcyxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBzaWduYXR1cmUsXG4gICAgICByZWNvdmVyeUlkLFxuICAgICAgaW5zdHJ1Y3Rpb25JbmRleCA9IDBcbiAgICB9ID0gcGFyYW1zO1xuICAgIGxldCBldGhBZGRyZXNzO1xuICAgIGlmICh0eXBlb2YgcmF3QWRkcmVzcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChyYXdBZGRyZXNzLnN0YXJ0c1dpdGgoJzB4JykpIHtcbiAgICAgICAgZXRoQWRkcmVzcyA9IEJ1ZmZlci5mcm9tKHJhd0FkZHJlc3Muc3Vic3RyKDIpLCAnaGV4Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBldGhBZGRyZXNzID0gQnVmZmVyLmZyb20ocmF3QWRkcmVzcywgJ2hleCcpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBldGhBZGRyZXNzID0gcmF3QWRkcmVzcztcbiAgICB9XG4gICAgYXNzZXJ0KGV0aEFkZHJlc3MubGVuZ3RoID09PSBFVEhFUkVVTV9BRERSRVNTX0JZVEVTLCBgQWRkcmVzcyBtdXN0IGJlICR7RVRIRVJFVU1fQUREUkVTU19CWVRFU30gYnl0ZXMgYnV0IHJlY2VpdmVkICR7ZXRoQWRkcmVzcy5sZW5ndGh9IGJ5dGVzYCk7XG4gICAgY29uc3QgZGF0YVN0YXJ0ID0gMSArIFNJR05BVFVSRV9PRkZTRVRTX1NFUklBTElaRURfU0laRTtcbiAgICBjb25zdCBldGhBZGRyZXNzT2Zmc2V0ID0gZGF0YVN0YXJ0O1xuICAgIGNvbnN0IHNpZ25hdHVyZU9mZnNldCA9IGRhdGFTdGFydCArIGV0aEFkZHJlc3MubGVuZ3RoO1xuICAgIGNvbnN0IG1lc3NhZ2VEYXRhT2Zmc2V0ID0gc2lnbmF0dXJlT2Zmc2V0ICsgc2lnbmF0dXJlLmxlbmd0aCArIDE7XG4gICAgY29uc3QgbnVtU2lnbmF0dXJlcyA9IDE7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25EYXRhID0gQnVmZmVyLmFsbG9jKFNFQ1AyNTZLMV9JTlNUUlVDVElPTl9MQVlPVVQuc3BhbiArIG1lc3NhZ2UubGVuZ3RoKTtcbiAgICBTRUNQMjU2SzFfSU5TVFJVQ1RJT05fTEFZT1VULmVuY29kZSh7XG4gICAgICBudW1TaWduYXR1cmVzLFxuICAgICAgc2lnbmF0dXJlT2Zmc2V0LFxuICAgICAgc2lnbmF0dXJlSW5zdHJ1Y3Rpb25JbmRleDogaW5zdHJ1Y3Rpb25JbmRleCxcbiAgICAgIGV0aEFkZHJlc3NPZmZzZXQsXG4gICAgICBldGhBZGRyZXNzSW5zdHJ1Y3Rpb25JbmRleDogaW5zdHJ1Y3Rpb25JbmRleCxcbiAgICAgIG1lc3NhZ2VEYXRhT2Zmc2V0LFxuICAgICAgbWVzc2FnZURhdGFTaXplOiBtZXNzYWdlLmxlbmd0aCxcbiAgICAgIG1lc3NhZ2VJbnN0cnVjdGlvbkluZGV4OiBpbnN0cnVjdGlvbkluZGV4LFxuICAgICAgc2lnbmF0dXJlOiB0b0J1ZmZlcihzaWduYXR1cmUpLFxuICAgICAgZXRoQWRkcmVzczogdG9CdWZmZXIoZXRoQWRkcmVzcyksXG4gICAgICByZWNvdmVyeUlkXG4gICAgfSwgaW5zdHJ1Y3Rpb25EYXRhKTtcbiAgICBpbnN0cnVjdGlvbkRhdGEuZmlsbCh0b0J1ZmZlcihtZXNzYWdlKSwgU0VDUDI1NksxX0lOU1RSVUNUSU9OX0xBWU9VVC5zcGFuKTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5czogW10sXG4gICAgICBwcm9ncmFtSWQ6IFNlY3AyNTZrMVByb2dyYW0ucHJvZ3JhbUlkLFxuICAgICAgZGF0YTogaW5zdHJ1Y3Rpb25EYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIHNlY3AyNTZrMSBpbnN0cnVjdGlvbiB3aXRoIGEgcHJpdmF0ZSBrZXkuIFRoZSBwcml2YXRlIGtleVxuICAgKiBtdXN0IGJlIGEgYnVmZmVyIHRoYXQgaXMgMzIgYnl0ZXMgbG9uZy5cbiAgICovXG4gIHN0YXRpYyBjcmVhdGVJbnN0cnVjdGlvbldpdGhQcml2YXRlS2V5KHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHByaXZhdGVLZXk6IHBrZXksXG4gICAgICBtZXNzYWdlLFxuICAgICAgaW5zdHJ1Y3Rpb25JbmRleFxuICAgIH0gPSBwYXJhbXM7XG4gICAgYXNzZXJ0KHBrZXkubGVuZ3RoID09PSBQUklWQVRFX0tFWV9CWVRFUywgYFByaXZhdGUga2V5IG11c3QgYmUgJHtQUklWQVRFX0tFWV9CWVRFU30gYnl0ZXMgYnV0IHJlY2VpdmVkICR7cGtleS5sZW5ndGh9IGJ5dGVzYCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHByaXZhdGVLZXkgPSB0b0J1ZmZlcihwa2V5KTtcbiAgICAgIGNvbnN0IHB1YmxpY0tleSA9IHB1YmxpY0tleUNyZWF0ZShwcml2YXRlS2V5LCBmYWxzZSAvKiBpc0NvbXByZXNzZWQgKi8pLnNsaWNlKDEpOyAvLyB0aHJvdyBhd2F5IGxlYWRpbmcgYnl0ZVxuICAgICAgY29uc3QgbWVzc2FnZUhhc2ggPSBCdWZmZXIuZnJvbShrZWNjYWtfMjU2KHRvQnVmZmVyKG1lc3NhZ2UpKSk7XG4gICAgICBjb25zdCBbc2lnbmF0dXJlLCByZWNvdmVyeUlkXSA9IGVjZHNhU2lnbihtZXNzYWdlSGFzaCwgcHJpdmF0ZUtleSk7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVJbnN0cnVjdGlvbldpdGhQdWJsaWNLZXkoe1xuICAgICAgICBwdWJsaWNLZXksXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgcmVjb3ZlcnlJZCxcbiAgICAgICAgaW5zdHJ1Y3Rpb25JbmRleFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgY3JlYXRpbmcgaW5zdHJ1Y3Rpb247ICR7ZXJyb3J9YCk7XG4gICAgfVxuICB9XG59XG5TZWNwMjU2azFQcm9ncmFtLnByb2dyYW1JZCA9IG5ldyBQdWJsaWNLZXkoJ0tlY2Nha1NlY3AyNTZrMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcblxudmFyIF9Mb2NrdXA7XG5cbi8qKlxuICogQWRkcmVzcyBvZiB0aGUgc3Rha2UgY29uZmlnIGFjY291bnQgd2hpY2ggY29uZmlndXJlcyB0aGUgcmF0ZVxuICogb2Ygc3Rha2Ugd2FybXVwIGFuZCBjb29sZG93biBhcyB3ZWxsIGFzIHRoZSBzbGFzaGluZyBwZW5hbHR5LlxuICovXG5jb25zdCBTVEFLRV9DT05GSUdfSUQgPSBuZXcgUHVibGljS2V5KCdTdGFrZUNvbmZpZzExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5cbi8qKlxuICogU3Rha2UgYWNjb3VudCBhdXRob3JpdHkgaW5mb1xuICovXG5jbGFzcyBBdXRob3JpemVkIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBBdXRob3JpemVkIG9iamVjdFxuICAgKiBAcGFyYW0gc3Rha2VyIHRoZSBzdGFrZSBhdXRob3JpdHlcbiAgICogQHBhcmFtIHdpdGhkcmF3ZXIgdGhlIHdpdGhkcmF3IGF1dGhvcml0eVxuICAgKi9cbiAgY29uc3RydWN0b3Ioc3Rha2VyLCB3aXRoZHJhd2VyKSB7XG4gICAgLyoqIHN0YWtlIGF1dGhvcml0eSAqL1xuICAgIHRoaXMuc3Rha2VyID0gdm9pZCAwO1xuICAgIC8qKiB3aXRoZHJhdyBhdXRob3JpdHkgKi9cbiAgICB0aGlzLndpdGhkcmF3ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5zdGFrZXIgPSBzdGFrZXI7XG4gICAgdGhpcy53aXRoZHJhd2VyID0gd2l0aGRyYXdlcjtcbiAgfVxufVxuLyoqXG4gKiBTdGFrZSBhY2NvdW50IGxvY2t1cCBpbmZvXG4gKi9cbmNsYXNzIExvY2t1cCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgTG9ja3VwIG9iamVjdFxuICAgKi9cbiAgY29uc3RydWN0b3IodW5peFRpbWVzdGFtcCwgZXBvY2gsIGN1c3RvZGlhbikge1xuICAgIC8qKiBVbml4IHRpbWVzdGFtcCBvZiBsb2NrdXAgZXhwaXJhdGlvbiAqL1xuICAgIHRoaXMudW5peFRpbWVzdGFtcCA9IHZvaWQgMDtcbiAgICAvKiogRXBvY2ggb2YgbG9ja3VwIGV4cGlyYXRpb24gKi9cbiAgICB0aGlzLmVwb2NoID0gdm9pZCAwO1xuICAgIC8qKiBMb2NrdXAgY3VzdG9kaWFuIGF1dGhvcml0eSAqL1xuICAgIHRoaXMuY3VzdG9kaWFuID0gdm9pZCAwO1xuICAgIHRoaXMudW5peFRpbWVzdGFtcCA9IHVuaXhUaW1lc3RhbXA7XG4gICAgdGhpcy5lcG9jaCA9IGVwb2NoO1xuICAgIHRoaXMuY3VzdG9kaWFuID0gY3VzdG9kaWFuO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmF1bHQsIGluYWN0aXZlIExvY2t1cCB2YWx1ZVxuICAgKi9cbn1cbl9Mb2NrdXAgPSBMb2NrdXA7XG5Mb2NrdXAuZGVmYXVsdCA9IG5ldyBfTG9ja3VwKDAsIDAsIFB1YmxpY0tleS5kZWZhdWx0KTtcbi8qKlxuICogQ3JlYXRlIHN0YWtlIGFjY291bnQgdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cbi8qKlxuICogQ3JlYXRlIHN0YWtlIGFjY291bnQgd2l0aCBzZWVkIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG4vKipcbiAqIEluaXRpYWxpemUgc3Rha2UgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cbi8qKlxuICogRGVsZWdhdGUgc3Rha2UgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cbi8qKlxuICogQXV0aG9yaXplIHN0YWtlIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG4vKipcbiAqIEF1dGhvcml6ZSBzdGFrZSBpbnN0cnVjdGlvbiBwYXJhbXMgdXNpbmcgYSBkZXJpdmVkIGtleVxuICovXG4vKipcbiAqIFNwbGl0IHN0YWtlIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG4vKipcbiAqIFNwbGl0IHdpdGggc2VlZCB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuLyoqXG4gKiBXaXRoZHJhdyBzdGFrZSBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuLyoqXG4gKiBEZWFjdGl2YXRlIHN0YWtlIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG4vKipcbiAqIE1lcmdlIHN0YWtlIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG4vKipcbiAqIFN0YWtlIEluc3RydWN0aW9uIGNsYXNzXG4gKi9cbmNsYXNzIFN0YWtlSW5zdHJ1Y3Rpb24ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIHN0YWtlIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gdHlwZS5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVJbnN0cnVjdGlvblR5cGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25UeXBlTGF5b3V0ID0gQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKTtcbiAgICBjb25zdCB0eXBlSW5kZXggPSBpbnN0cnVjdGlvblR5cGVMYXlvdXQuZGVjb2RlKGluc3RydWN0aW9uLmRhdGEpO1xuICAgIGxldCB0eXBlO1xuICAgIGZvciAoY29uc3QgW2l4VHlwZSwgbGF5b3V0XSBvZiBPYmplY3QuZW50cmllcyhTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTKSkge1xuICAgICAgaWYgKGxheW91dC5pbmRleCA9PSB0eXBlSW5kZXgpIHtcbiAgICAgICAgdHlwZSA9IGl4VHlwZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnN0cnVjdGlvbiB0eXBlIGluY29ycmVjdDsgbm90IGEgU3Rha2VJbnN0cnVjdGlvbicpO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBpbml0aWFsaXplIHN0YWtlIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUluaXRpYWxpemUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAyKTtcbiAgICBjb25zdCB7XG4gICAgICBhdXRob3JpemVkLFxuICAgICAgbG9ja3VwXG4gICAgfSA9IGRlY29kZURhdGEkMShTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLkluaXRpYWxpemUsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBzdGFrZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkOiBuZXcgQXV0aG9yaXplZChuZXcgUHVibGljS2V5KGF1dGhvcml6ZWQuc3Rha2VyKSwgbmV3IFB1YmxpY0tleShhdXRob3JpemVkLndpdGhkcmF3ZXIpKSxcbiAgICAgIGxvY2t1cDogbmV3IExvY2t1cChsb2NrdXAudW5peFRpbWVzdGFtcCwgbG9ja3VwLmVwb2NoLCBuZXcgUHVibGljS2V5KGxvY2t1cC5jdXN0b2RpYW4pKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgZGVsZWdhdGUgc3Rha2UgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlRGVsZWdhdGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCA2KTtcbiAgICBkZWNvZGVEYXRhJDEoU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5EZWxlZ2F0ZSwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YWtlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIHZvdGVQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1s1XS5wdWJrZXlcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhbiBhdXRob3JpemUgc3Rha2UgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlQXV0aG9yaXplKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMyk7XG4gICAgY29uc3Qge1xuICAgICAgbmV3QXV0aG9yaXplZCxcbiAgICAgIHN0YWtlQXV0aG9yaXphdGlvblR5cGVcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXV0aG9yaXplLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICBjb25zdCBvID0ge1xuICAgICAgc3Rha2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1syXS5wdWJrZXksXG4gICAgICBuZXdBdXRob3JpemVkUHVia2V5OiBuZXcgUHVibGljS2V5KG5ld0F1dGhvcml6ZWQpLFxuICAgICAgc3Rha2VBdXRob3JpemF0aW9uVHlwZToge1xuICAgICAgICBpbmRleDogc3Rha2VBdXRob3JpemF0aW9uVHlwZVxuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGluc3RydWN0aW9uLmtleXMubGVuZ3RoID4gMykge1xuICAgICAgby5jdXN0b2RpYW5QdWJrZXkgPSBpbnN0cnVjdGlvbi5rZXlzWzNdLnB1YmtleTtcbiAgICB9XG4gICAgcmV0dXJuIG87XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGFuIGF1dGhvcml6ZS13aXRoLXNlZWQgc3Rha2UgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlQXV0aG9yaXplV2l0aFNlZWQoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAyKTtcbiAgICBjb25zdCB7XG4gICAgICBuZXdBdXRob3JpemVkLFxuICAgICAgc3Rha2VBdXRob3JpemF0aW9uVHlwZSxcbiAgICAgIGF1dGhvcml0eVNlZWQsXG4gICAgICBhdXRob3JpdHlPd25lclxuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5BdXRob3JpemVXaXRoU2VlZCwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgY29uc3QgbyA9IHtcbiAgICAgIHN0YWtlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGF1dGhvcml0eUJhc2U6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgYXV0aG9yaXR5U2VlZDogYXV0aG9yaXR5U2VlZCxcbiAgICAgIGF1dGhvcml0eU93bmVyOiBuZXcgUHVibGljS2V5KGF1dGhvcml0eU93bmVyKSxcbiAgICAgIG5ld0F1dGhvcml6ZWRQdWJrZXk6IG5ldyBQdWJsaWNLZXkobmV3QXV0aG9yaXplZCksXG4gICAgICBzdGFrZUF1dGhvcml6YXRpb25UeXBlOiB7XG4gICAgICAgIGluZGV4OiBzdGFrZUF1dGhvcml6YXRpb25UeXBlXG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoaW5zdHJ1Y3Rpb24ua2V5cy5sZW5ndGggPiAzKSB7XG4gICAgICBvLmN1c3RvZGlhblB1YmtleSA9IGluc3RydWN0aW9uLmtleXNbM10ucHVia2V5O1xuICAgIH1cbiAgICByZXR1cm4gbztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBzcGxpdCBzdGFrZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVTcGxpdChpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDMpO1xuICAgIGNvbnN0IHtcbiAgICAgIGxhbXBvcnRzXG4gICAgfSA9IGRlY29kZURhdGEkMShTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLlNwbGl0LCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3Rha2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgc3BsaXRTdGFrZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzJdLnB1YmtleSxcbiAgICAgIGxhbXBvcnRzXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBtZXJnZSBzdGFrZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVNZXJnZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDMpO1xuICAgIGRlY29kZURhdGEkMShTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLk1lcmdlLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3Rha2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgc291cmNlU3Rha2VQdWJLZXk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1s0XS5wdWJrZXlcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIHdpdGhkcmF3IHN0YWtlIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZVdpdGhkcmF3KGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgNSk7XG4gICAgY29uc3Qge1xuICAgICAgbGFtcG9ydHNcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuV2l0aGRyYXcsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIGNvbnN0IG8gPSB7XG4gICAgICBzdGFrZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICB0b1B1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzRdLnB1YmtleSxcbiAgICAgIGxhbXBvcnRzXG4gICAgfTtcbiAgICBpZiAoaW5zdHJ1Y3Rpb24ua2V5cy5sZW5ndGggPiA1KSB7XG4gICAgICBvLmN1c3RvZGlhblB1YmtleSA9IGluc3RydWN0aW9uLmtleXNbNV0ucHVia2V5O1xuICAgIH1cbiAgICByZXR1cm4gbztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBkZWFjdGl2YXRlIHN0YWtlIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZURlYWN0aXZhdGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAzKTtcbiAgICBkZWNvZGVEYXRhJDEoU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5EZWFjdGl2YXRlLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3Rha2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1syXS5wdWJrZXlcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RhdGljIGNoZWNrUHJvZ3JhbUlkKHByb2dyYW1JZCkge1xuICAgIGlmICghcHJvZ3JhbUlkLmVxdWFscyhTdGFrZVByb2dyYW0ucHJvZ3JhbUlkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluc3RydWN0aW9uOyBwcm9ncmFtSWQgaXMgbm90IFN0YWtlUHJvZ3JhbScpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHN0YXRpYyBjaGVja0tleUxlbmd0aChrZXlzLCBleHBlY3RlZExlbmd0aCkge1xuICAgIGlmIChrZXlzLmxlbmd0aCA8IGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW5zdHJ1Y3Rpb247IGZvdW5kICR7a2V5cy5sZW5ndGh9IGtleXMsIGV4cGVjdGVkIGF0IGxlYXN0ICR7ZXhwZWN0ZWRMZW5ndGh9YCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgdmFsaWQgU3Rha2VJbnN0cnVjdGlvblR5cGUnc1xuICovXG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgdmFsaWQgc3Rha2UgSW5zdHJ1Y3Rpb25UeXBlJ3NcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTID0gT2JqZWN0LmZyZWV6ZSh7XG4gIEluaXRpYWxpemU6IHtcbiAgICBpbmRleDogMCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIGF1dGhvcml6ZWQoKSwgbG9ja3VwKCldKVxuICB9LFxuICBBdXRob3JpemU6IHtcbiAgICBpbmRleDogMSxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIHB1YmxpY0tleSgnbmV3QXV0aG9yaXplZCcpLCBCdWZmZXJMYXlvdXQudTMyKCdzdGFrZUF1dGhvcml6YXRpb25UeXBlJyldKVxuICB9LFxuICBEZWxlZ2F0ZToge1xuICAgIGluZGV4OiAyLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKV0pXG4gIH0sXG4gIFNwbGl0OiB7XG4gICAgaW5kZXg6IDMsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBCdWZmZXJMYXlvdXQubnM2NCgnbGFtcG9ydHMnKV0pXG4gIH0sXG4gIFdpdGhkcmF3OiB7XG4gICAgaW5kZXg6IDQsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBCdWZmZXJMYXlvdXQubnM2NCgnbGFtcG9ydHMnKV0pXG4gIH0sXG4gIERlYWN0aXZhdGU6IHtcbiAgICBpbmRleDogNSxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyldKVxuICB9LFxuICBNZXJnZToge1xuICAgIGluZGV4OiA3LFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKV0pXG4gIH0sXG4gIEF1dGhvcml6ZVdpdGhTZWVkOiB7XG4gICAgaW5kZXg6IDgsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBwdWJsaWNLZXkoJ25ld0F1dGhvcml6ZWQnKSwgQnVmZmVyTGF5b3V0LnUzMignc3Rha2VBdXRob3JpemF0aW9uVHlwZScpLCBydXN0U3RyaW5nKCdhdXRob3JpdHlTZWVkJyksIHB1YmxpY0tleSgnYXV0aG9yaXR5T3duZXInKV0pXG4gIH1cbn0pO1xuXG4vKipcbiAqIFN0YWtlIGF1dGhvcml6YXRpb24gdHlwZVxuICovXG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgdmFsaWQgU3Rha2VBdXRob3JpemF0aW9uTGF5b3V0J3NcbiAqL1xuY29uc3QgU3Rha2VBdXRob3JpemF0aW9uTGF5b3V0ID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFN0YWtlcjoge1xuICAgIGluZGV4OiAwXG4gIH0sXG4gIFdpdGhkcmF3ZXI6IHtcbiAgICBpbmRleDogMVxuICB9XG59KTtcblxuLyoqXG4gKiBGYWN0b3J5IGNsYXNzIGZvciB0cmFuc2FjdGlvbnMgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgU3Rha2UgcHJvZ3JhbVxuICovXG5jbGFzcyBTdGFrZVByb2dyYW0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBrZXkgdGhhdCBpZGVudGlmaWVzIHRoZSBTdGFrZSBwcm9ncmFtXG4gICAqL1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhbiBJbml0aWFsaXplIGluc3RydWN0aW9uIHRvIGFkZCB0byBhIFN0YWtlIENyZWF0ZSB0cmFuc2FjdGlvblxuICAgKi9cbiAgc3RhdGljIGluaXRpYWxpemUocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3Rha2VQdWJrZXksXG4gICAgICBhdXRob3JpemVkLFxuICAgICAgbG9ja3VwOiBtYXliZUxvY2t1cFxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgbG9ja3VwID0gbWF5YmVMb2NrdXAgfHwgTG9ja3VwLmRlZmF1bHQ7XG4gICAgY29uc3QgdHlwZSA9IFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuSW5pdGlhbGl6ZTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICBhdXRob3JpemVkOiB7XG4gICAgICAgIHN0YWtlcjogdG9CdWZmZXIoYXV0aG9yaXplZC5zdGFrZXIudG9CdWZmZXIoKSksXG4gICAgICAgIHdpdGhkcmF3ZXI6IHRvQnVmZmVyKGF1dGhvcml6ZWQud2l0aGRyYXdlci50b0J1ZmZlcigpKVxuICAgICAgfSxcbiAgICAgIGxvY2t1cDoge1xuICAgICAgICB1bml4VGltZXN0YW1wOiBsb2NrdXAudW5peFRpbWVzdGFtcCxcbiAgICAgICAgZXBvY2g6IGxvY2t1cC5lcG9jaCxcbiAgICAgICAgY3VzdG9kaWFuOiB0b0J1ZmZlcihsb2NrdXAuY3VzdG9kaWFuLnRvQnVmZmVyKCkpXG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25EYXRhID0ge1xuICAgICAga2V5czogW3tcbiAgICAgICAgcHVia2V5OiBzdGFrZVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX1JFTlRfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9XSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb25EYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIFRyYW5zYWN0aW9uIHRoYXQgY3JlYXRlcyBhIG5ldyBTdGFrZSBhY2NvdW50IGF0XG4gICAqICAgYW4gYWRkcmVzcyBnZW5lcmF0ZWQgd2l0aCBgZnJvbWAsIGEgc2VlZCwgYW5kIHRoZSBTdGFrZSBwcm9ncmFtSWRcbiAgICovXG4gIHN0YXRpYyBjcmVhdGVBY2NvdW50V2l0aFNlZWQocGFyYW1zKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS5jcmVhdGVBY2NvdW50V2l0aFNlZWQoe1xuICAgICAgZnJvbVB1YmtleTogcGFyYW1zLmZyb21QdWJrZXksXG4gICAgICBuZXdBY2NvdW50UHVia2V5OiBwYXJhbXMuc3Rha2VQdWJrZXksXG4gICAgICBiYXNlUHVia2V5OiBwYXJhbXMuYmFzZVB1YmtleSxcbiAgICAgIHNlZWQ6IHBhcmFtcy5zZWVkLFxuICAgICAgbGFtcG9ydHM6IHBhcmFtcy5sYW1wb3J0cyxcbiAgICAgIHNwYWNlOiB0aGlzLnNwYWNlLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZFxuICAgIH0pKTtcbiAgICBjb25zdCB7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWQsXG4gICAgICBsb2NrdXBcbiAgICB9ID0gcGFyYW1zO1xuICAgIHJldHVybiB0cmFuc2FjdGlvbi5hZGQodGhpcy5pbml0aWFsaXplKHtcbiAgICAgIHN0YWtlUHVia2V5LFxuICAgICAgYXV0aG9yaXplZCxcbiAgICAgIGxvY2t1cFxuICAgIH0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIFRyYW5zYWN0aW9uIHRoYXQgY3JlYXRlcyBhIG5ldyBTdGFrZSBhY2NvdW50XG4gICAqL1xuICBzdGF0aWMgY3JlYXRlQWNjb3VudChwYXJhbXMpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpO1xuICAgIHRyYW5zYWN0aW9uLmFkZChTeXN0ZW1Qcm9ncmFtLmNyZWF0ZUFjY291bnQoe1xuICAgICAgZnJvbVB1YmtleTogcGFyYW1zLmZyb21QdWJrZXksXG4gICAgICBuZXdBY2NvdW50UHVia2V5OiBwYXJhbXMuc3Rha2VQdWJrZXksXG4gICAgICBsYW1wb3J0czogcGFyYW1zLmxhbXBvcnRzLFxuICAgICAgc3BhY2U6IHRoaXMuc3BhY2UsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkXG4gICAgfSkpO1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YWtlUHVia2V5LFxuICAgICAgYXV0aG9yaXplZCxcbiAgICAgIGxvY2t1cFxuICAgIH0gPSBwYXJhbXM7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uLmFkZCh0aGlzLmluaXRpYWxpemUoe1xuICAgICAgc3Rha2VQdWJrZXksXG4gICAgICBhdXRob3JpemVkLFxuICAgICAgbG9ja3VwXG4gICAgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCBkZWxlZ2F0ZXMgU3Rha2UgdG9rZW5zIHRvIGEgdmFsaWRhdG9yXG4gICAqIFZvdGUgUHVibGljS2V5LiBUaGlzIHRyYW5zYWN0aW9uIGNhbiBhbHNvIGJlIHVzZWQgdG8gcmVkZWxlZ2F0ZSBTdGFrZVxuICAgKiB0byBhIG5ldyB2YWxpZGF0b3IgVm90ZSBQdWJsaWNLZXkuXG4gICAqL1xuICBzdGF0aWMgZGVsZWdhdGUocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3Rha2VQdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5LFxuICAgICAgdm90ZVB1YmtleVxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuRGVsZWdhdGU7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbigpLmFkZCh7XG4gICAgICBrZXlzOiBbe1xuICAgICAgICBwdWJrZXk6IHN0YWtlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiB2b3RlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX0NMT0NLX1BVQktFWSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IFNZU1ZBUl9TVEFLRV9ISVNUT1JZX1BVQktFWSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IFNUQUtFX0NPTkZJR19JRCxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfV0sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCBhdXRob3JpemVzIGEgbmV3IFB1YmxpY0tleSBhcyBTdGFrZXJcbiAgICogb3IgV2l0aGRyYXdlciBvbiB0aGUgU3Rha2UgYWNjb3VudC5cbiAgICovXG4gIHN0YXRpYyBhdXRob3JpemUocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3Rha2VQdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5LFxuICAgICAgbmV3QXV0aG9yaXplZFB1YmtleSxcbiAgICAgIHN0YWtlQXV0aG9yaXphdGlvblR5cGUsXG4gICAgICBjdXN0b2RpYW5QdWJrZXlcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHR5cGUgPSBTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLkF1dGhvcml6ZTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICBuZXdBdXRob3JpemVkOiB0b0J1ZmZlcihuZXdBdXRob3JpemVkUHVia2V5LnRvQnVmZmVyKCkpLFxuICAgICAgc3Rha2VBdXRob3JpemF0aW9uVHlwZTogc3Rha2VBdXRob3JpemF0aW9uVHlwZS5pbmRleFxuICAgIH0pO1xuICAgIGNvbnN0IGtleXMgPSBbe1xuICAgICAgcHVia2V5OiBzdGFrZVB1YmtleSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IFNZU1ZBUl9DTE9DS19QVUJLRVksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBhdXRob3JpemVkUHVia2V5LFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH1dO1xuICAgIGlmIChjdXN0b2RpYW5QdWJrZXkpIHtcbiAgICAgIGtleXMucHVzaCh7XG4gICAgICAgIHB1YmtleTogY3VzdG9kaWFuUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCBhdXRob3JpemVzIGEgbmV3IFB1YmxpY0tleSBhcyBTdGFrZXJcbiAgICogb3IgV2l0aGRyYXdlciBvbiB0aGUgU3Rha2UgYWNjb3VudC5cbiAgICovXG4gIHN0YXRpYyBhdXRob3JpemVXaXRoU2VlZChwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml0eUJhc2UsXG4gICAgICBhdXRob3JpdHlTZWVkLFxuICAgICAgYXV0aG9yaXR5T3duZXIsXG4gICAgICBuZXdBdXRob3JpemVkUHVia2V5LFxuICAgICAgc3Rha2VBdXRob3JpemF0aW9uVHlwZSxcbiAgICAgIGN1c3RvZGlhblB1YmtleVxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXV0aG9yaXplV2l0aFNlZWQ7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgbmV3QXV0aG9yaXplZDogdG9CdWZmZXIobmV3QXV0aG9yaXplZFB1YmtleS50b0J1ZmZlcigpKSxcbiAgICAgIHN0YWtlQXV0aG9yaXphdGlvblR5cGU6IHN0YWtlQXV0aG9yaXphdGlvblR5cGUuaW5kZXgsXG4gICAgICBhdXRob3JpdHlTZWVkOiBhdXRob3JpdHlTZWVkLFxuICAgICAgYXV0aG9yaXR5T3duZXI6IHRvQnVmZmVyKGF1dGhvcml0eU93bmVyLnRvQnVmZmVyKCkpXG4gICAgfSk7XG4gICAgY29uc3Qga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IHN0YWtlUHVia2V5LFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogYXV0aG9yaXR5QmFzZSxcbiAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IFNZU1ZBUl9DTE9DS19QVUJLRVksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH1dO1xuICAgIGlmIChjdXN0b2RpYW5QdWJrZXkpIHtcbiAgICAgIGtleXMucHVzaCh7XG4gICAgICAgIHB1YmtleTogY3VzdG9kaWFuUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RhdGljIHNwbGl0SW5zdHJ1Y3Rpb24ocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3Rha2VQdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5LFxuICAgICAgc3BsaXRTdGFrZVB1YmtleSxcbiAgICAgIGxhbXBvcnRzXG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCB0eXBlID0gU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5TcGxpdDtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICBsYW1wb3J0c1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzOiBbe1xuICAgICAgICBwdWJrZXk6IHN0YWtlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBzcGxpdFN0YWtlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBhdXRob3JpemVkUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH1dLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIFRyYW5zYWN0aW9uIHRoYXQgc3BsaXRzIFN0YWtlIHRva2VucyBpbnRvIGFub3RoZXIgc3Rha2UgYWNjb3VudFxuICAgKi9cbiAgc3RhdGljIHNwbGl0KHBhcmFtcyxcbiAgLy8gQ29tcHV0ZSB0aGUgY29zdCBvZiBhbGxvY2F0aW5nIHRoZSBuZXcgc3Rha2UgYWNjb3VudCBpbiBsYW1wb3J0c1xuICByZW50RXhlbXB0UmVzZXJ2ZSkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgdHJhbnNhY3Rpb24uYWRkKFN5c3RlbVByb2dyYW0uY3JlYXRlQWNjb3VudCh7XG4gICAgICBmcm9tUHVia2V5OiBwYXJhbXMuYXV0aG9yaXplZFB1YmtleSxcbiAgICAgIG5ld0FjY291bnRQdWJrZXk6IHBhcmFtcy5zcGxpdFN0YWtlUHVia2V5LFxuICAgICAgbGFtcG9ydHM6IHJlbnRFeGVtcHRSZXNlcnZlLFxuICAgICAgc3BhY2U6IHRoaXMuc3BhY2UsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkXG4gICAgfSkpO1xuICAgIHJldHVybiB0cmFuc2FjdGlvbi5hZGQodGhpcy5zcGxpdEluc3RydWN0aW9uKHBhcmFtcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCBzcGxpdHMgU3Rha2UgdG9rZW5zIGludG8gYW5vdGhlciBhY2NvdW50XG4gICAqIGRlcml2ZWQgZnJvbSBhIGJhc2UgcHVibGljIGtleSBhbmQgc2VlZFxuICAgKi9cbiAgc3RhdGljIHNwbGl0V2l0aFNlZWQocGFyYW1zLFxuICAvLyBJZiB0aGlzIHN0YWtlIGFjY291bnQgaXMgbmV3LCBjb21wdXRlIHRoZSBjb3N0IG9mIGFsbG9jYXRpbmcgaXQgaW4gbGFtcG9ydHNcbiAgcmVudEV4ZW1wdFJlc2VydmUpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICBzcGxpdFN0YWtlUHVia2V5LFxuICAgICAgYmFzZVB1YmtleSxcbiAgICAgIHNlZWQsXG4gICAgICBsYW1wb3J0c1xuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS5hbGxvY2F0ZSh7XG4gICAgICBhY2NvdW50UHVia2V5OiBzcGxpdFN0YWtlUHVia2V5LFxuICAgICAgYmFzZVB1YmtleSxcbiAgICAgIHNlZWQsXG4gICAgICBzcGFjZTogdGhpcy5zcGFjZSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWRcbiAgICB9KSk7XG4gICAgaWYgKHJlbnRFeGVtcHRSZXNlcnZlICYmIHJlbnRFeGVtcHRSZXNlcnZlID4gMCkge1xuICAgICAgdHJhbnNhY3Rpb24uYWRkKFN5c3RlbVByb2dyYW0udHJhbnNmZXIoe1xuICAgICAgICBmcm9tUHVia2V5OiBwYXJhbXMuYXV0aG9yaXplZFB1YmtleSxcbiAgICAgICAgdG9QdWJrZXk6IHNwbGl0U3Rha2VQdWJrZXksXG4gICAgICAgIGxhbXBvcnRzOiByZW50RXhlbXB0UmVzZXJ2ZVxuICAgICAgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNhY3Rpb24uYWRkKHRoaXMuc3BsaXRJbnN0cnVjdGlvbih7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICBzcGxpdFN0YWtlUHVia2V5LFxuICAgICAgbGFtcG9ydHNcbiAgICB9KSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBUcmFuc2FjdGlvbiB0aGF0IG1lcmdlcyBTdGFrZSBhY2NvdW50cy5cbiAgICovXG4gIHN0YXRpYyBtZXJnZShwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIHNvdXJjZVN0YWtlUHViS2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleVxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuTWVyZ2U7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbigpLmFkZCh7XG4gICAgICBrZXlzOiBbe1xuICAgICAgICBwdWJrZXk6IHN0YWtlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBzb3VyY2VTdGFrZVB1YktleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX0NMT0NLX1BVQktFWSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IFNZU1ZBUl9TVEFLRV9ISVNUT1JZX1BVQktFWSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfV0sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCB3aXRoZHJhd3MgZGVhY3RpdmF0ZWQgU3Rha2UgdG9rZW5zLlxuICAgKi9cbiAgc3RhdGljIHdpdGhkcmF3KHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YWtlUHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleSxcbiAgICAgIHRvUHVia2V5LFxuICAgICAgbGFtcG9ydHMsXG4gICAgICBjdXN0b2RpYW5QdWJrZXlcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHR5cGUgPSBTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLldpdGhkcmF3O1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIGxhbXBvcnRzXG4gICAgfSk7XG4gICAgY29uc3Qga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IHN0YWtlUHVia2V5LFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogdG9QdWJrZXksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBTWVNWQVJfQ0xPQ0tfUFVCS0VZLFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IFNZU1ZBUl9TVEFLRV9ISVNUT1JZX1BVQktFWSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBhdXRob3JpemVkUHVia2V5LFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH1dO1xuICAgIGlmIChjdXN0b2RpYW5QdWJrZXkpIHtcbiAgICAgIGtleXMucHVzaCh7XG4gICAgICAgIHB1YmtleTogY3VzdG9kaWFuUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCBkZWFjdGl2YXRlcyBTdGFrZSB0b2tlbnMuXG4gICAqL1xuICBzdGF0aWMgZGVhY3RpdmF0ZShwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXlcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHR5cGUgPSBTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLkRlYWN0aXZhdGU7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbigpLmFkZCh7XG4gICAgICBrZXlzOiBbe1xuICAgICAgICBwdWJrZXk6IHN0YWtlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBTWVNWQVJfQ0xPQ0tfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogYXV0aG9yaXplZFB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9XSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cbn1cblN0YWtlUHJvZ3JhbS5wcm9ncmFtSWQgPSBuZXcgUHVibGljS2V5KCdTdGFrZTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG4vKipcbiAqIE1heCBzcGFjZSBvZiBhIFN0YWtlIGFjY291bnRcbiAqXG4gKiBUaGlzIGlzIGdlbmVyYXRlZCBmcm9tIHRoZSBzb2xhbmEtc3Rha2UtcHJvZ3JhbSBTdGFrZVN0YXRlIHN0cnVjdCBhc1xuICogYFN0YWtlU3RhdGVWMjo6c2l6ZV9vZigpYDpcbiAqIGh0dHBzOi8vZG9jcy5ycy9zb2xhbmEtc3Rha2UtcHJvZ3JhbS9sYXRlc3Qvc29sYW5hX3N0YWtlX3Byb2dyYW0vc3Rha2Vfc3RhdGUvZW51bS5TdGFrZVN0YXRlVjIuaHRtbFxuICovXG5TdGFrZVByb2dyYW0uc3BhY2UgPSAyMDA7XG5cbi8qKlxuICogVm90ZSBhY2NvdW50IGluZm9cbiAqL1xuY2xhc3MgVm90ZUluaXQge1xuICAvKiogWzAsIDEwMF0gKi9cblxuICBjb25zdHJ1Y3Rvcihub2RlUHVia2V5LCBhdXRob3JpemVkVm90ZXIsIGF1dGhvcml6ZWRXaXRoZHJhd2VyLCBjb21taXNzaW9uKSB7XG4gICAgdGhpcy5ub2RlUHVia2V5ID0gdm9pZCAwO1xuICAgIHRoaXMuYXV0aG9yaXplZFZvdGVyID0gdm9pZCAwO1xuICAgIHRoaXMuYXV0aG9yaXplZFdpdGhkcmF3ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5jb21taXNzaW9uID0gdm9pZCAwO1xuICAgIHRoaXMubm9kZVB1YmtleSA9IG5vZGVQdWJrZXk7XG4gICAgdGhpcy5hdXRob3JpemVkVm90ZXIgPSBhdXRob3JpemVkVm90ZXI7XG4gICAgdGhpcy5hdXRob3JpemVkV2l0aGRyYXdlciA9IGF1dGhvcml6ZWRXaXRoZHJhd2VyO1xuICAgIHRoaXMuY29tbWlzc2lvbiA9IGNvbW1pc3Npb247XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgdm90ZSBhY2NvdW50IHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogSW5pdGlhbGl6ZUFjY291bnQgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBBdXRob3JpemUgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBBdXRob3JpemVXaXRoU2VlZCBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIFdpdGhkcmF3IGZyb20gdm90ZSBhY2NvdW50IHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogVXBkYXRlIHZhbGlkYXRvciBpZGVudGl0eSAobm9kZSBwdWJrZXkpIHZvdGUgYWNjb3VudCBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gKi9cblxuLyoqXG4gKiBWb3RlIEluc3RydWN0aW9uIGNsYXNzXG4gKi9cbmNsYXNzIFZvdGVJbnN0cnVjdGlvbiB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogRGVjb2RlIGEgdm90ZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHR5cGUuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlSW5zdHJ1Y3Rpb25UeXBlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIGNvbnN0IGluc3RydWN0aW9uVHlwZUxheW91dCA9IEJ1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyk7XG4gICAgY29uc3QgdHlwZUluZGV4ID0gaW5zdHJ1Y3Rpb25UeXBlTGF5b3V0LmRlY29kZShpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICBsZXQgdHlwZTtcbiAgICBmb3IgKGNvbnN0IFtpeFR5cGUsIGxheW91dF0gb2YgT2JqZWN0LmVudHJpZXMoVk9URV9JTlNUUlVDVElPTl9MQVlPVVRTKSkge1xuICAgICAgaWYgKGxheW91dC5pbmRleCA9PSB0eXBlSW5kZXgpIHtcbiAgICAgICAgdHlwZSA9IGl4VHlwZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnN0cnVjdGlvbiB0eXBlIGluY29ycmVjdDsgbm90IGEgVm90ZUluc3RydWN0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhbiBpbml0aWFsaXplIHZvdGUgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlSW5pdGlhbGl6ZUFjY291bnQoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCA0KTtcbiAgICBjb25zdCB7XG4gICAgICB2b3RlSW5pdFxuICAgIH0gPSBkZWNvZGVEYXRhJDEoVk9URV9JTlNUUlVDVElPTl9MQVlPVVRTLkluaXRpYWxpemVBY2NvdW50LCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgdm90ZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBub2RlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzNdLnB1YmtleSxcbiAgICAgIHZvdGVJbml0OiBuZXcgVm90ZUluaXQobmV3IFB1YmxpY0tleSh2b3RlSW5pdC5ub2RlUHVia2V5KSwgbmV3IFB1YmxpY0tleSh2b3RlSW5pdC5hdXRob3JpemVkVm90ZXIpLCBuZXcgUHVibGljS2V5KHZvdGVJbml0LmF1dGhvcml6ZWRXaXRoZHJhd2VyKSwgdm90ZUluaXQuY29tbWlzc2lvbilcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhbiBhdXRob3JpemUgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlQXV0aG9yaXplKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMyk7XG4gICAgY29uc3Qge1xuICAgICAgbmV3QXV0aG9yaXplZCxcbiAgICAgIHZvdGVBdXRob3JpemF0aW9uVHlwZVxuICAgIH0gPSBkZWNvZGVEYXRhJDEoVk9URV9JTlNUUlVDVElPTl9MQVlPVVRTLkF1dGhvcml6ZSwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZvdGVQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1syXS5wdWJrZXksXG4gICAgICBuZXdBdXRob3JpemVkUHVia2V5OiBuZXcgUHVibGljS2V5KG5ld0F1dGhvcml6ZWQpLFxuICAgICAgdm90ZUF1dGhvcml6YXRpb25UeXBlOiB7XG4gICAgICAgIGluZGV4OiB2b3RlQXV0aG9yaXphdGlvblR5cGVcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhbiBhdXRob3JpemUgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlQXV0aG9yaXplV2l0aFNlZWQoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAzKTtcbiAgICBjb25zdCB7XG4gICAgICB2b3RlQXV0aG9yaXplV2l0aFNlZWRBcmdzOiB7XG4gICAgICAgIGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5T3duZXJQdWJrZXksXG4gICAgICAgIGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5U2VlZCxcbiAgICAgICAgbmV3QXV0aG9yaXplZCxcbiAgICAgICAgdm90ZUF1dGhvcml6YXRpb25UeXBlXG4gICAgICB9XG4gICAgfSA9IGRlY29kZURhdGEkMShWT1RFX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXV0aG9yaXplV2l0aFNlZWQsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleUJhc2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMl0ucHVia2V5LFxuICAgICAgY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlPd25lclB1YmtleTogbmV3IFB1YmxpY0tleShjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleU93bmVyUHVia2V5KSxcbiAgICAgIGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5U2VlZDogY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlTZWVkLFxuICAgICAgbmV3QXV0aG9yaXplZFB1YmtleTogbmV3IFB1YmxpY0tleShuZXdBdXRob3JpemVkKSxcbiAgICAgIHZvdGVBdXRob3JpemF0aW9uVHlwZToge1xuICAgICAgICBpbmRleDogdm90ZUF1dGhvcml6YXRpb25UeXBlXG4gICAgICB9LFxuICAgICAgdm90ZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXlcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIHdpdGhkcmF3IGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZVdpdGhkcmF3KGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMyk7XG4gICAgY29uc3Qge1xuICAgICAgbGFtcG9ydHNcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFZPVEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5XaXRoZHJhdywgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZvdGVQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFdpdGhkcmF3ZXJQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMl0ucHVia2V5LFxuICAgICAgbGFtcG9ydHMsXG4gICAgICB0b1B1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXlcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RhdGljIGNoZWNrUHJvZ3JhbUlkKHByb2dyYW1JZCkge1xuICAgIGlmICghcHJvZ3JhbUlkLmVxdWFscyhWb3RlUHJvZ3JhbS5wcm9ncmFtSWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5zdHJ1Y3Rpb247IHByb2dyYW1JZCBpcyBub3QgVm90ZVByb2dyYW0nKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdGF0aWMgY2hlY2tLZXlMZW5ndGgoa2V5cywgZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICBpZiAoa2V5cy5sZW5ndGggPCBleHBlY3RlZExlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGluc3RydWN0aW9uOyBmb3VuZCAke2tleXMubGVuZ3RofSBrZXlzLCBleHBlY3RlZCBhdCBsZWFzdCAke2V4cGVjdGVkTGVuZ3RofWApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIG9mIHZhbGlkIFZvdGVJbnN0cnVjdGlvblR5cGUnc1xuICovXG5cbi8qKiBAaW50ZXJuYWwgKi9cblxuY29uc3QgVk9URV9JTlNUUlVDVElPTl9MQVlPVVRTID0gT2JqZWN0LmZyZWV6ZSh7XG4gIEluaXRpYWxpemVBY2NvdW50OiB7XG4gICAgaW5kZXg6IDAsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCB2b3RlSW5pdCgpXSlcbiAgfSxcbiAgQXV0aG9yaXplOiB7XG4gICAgaW5kZXg6IDEsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBwdWJsaWNLZXkoJ25ld0F1dGhvcml6ZWQnKSwgQnVmZmVyTGF5b3V0LnUzMigndm90ZUF1dGhvcml6YXRpb25UeXBlJyldKVxuICB9LFxuICBXaXRoZHJhdzoge1xuICAgIGluZGV4OiAzLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgQnVmZmVyTGF5b3V0Lm5zNjQoJ2xhbXBvcnRzJyldKVxuICB9LFxuICBVcGRhdGVWYWxpZGF0b3JJZGVudGl0eToge1xuICAgIGluZGV4OiA0LFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKV0pXG4gIH0sXG4gIEF1dGhvcml6ZVdpdGhTZWVkOiB7XG4gICAgaW5kZXg6IDEwLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgdm90ZUF1dGhvcml6ZVdpdGhTZWVkQXJncygpXSlcbiAgfVxufSk7XG5cbi8qKlxuICogVm90ZUF1dGhvcml6ZSB0eXBlXG4gKi9cblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiB2YWxpZCBWb3RlQXV0aG9yaXphdGlvbiBsYXlvdXRzLlxuICovXG5jb25zdCBWb3RlQXV0aG9yaXphdGlvbkxheW91dCA9IE9iamVjdC5mcmVlemUoe1xuICBWb3Rlcjoge1xuICAgIGluZGV4OiAwXG4gIH0sXG4gIFdpdGhkcmF3ZXI6IHtcbiAgICBpbmRleDogMVxuICB9XG59KTtcblxuLyoqXG4gKiBGYWN0b3J5IGNsYXNzIGZvciB0cmFuc2FjdGlvbnMgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgVm90ZSBwcm9ncmFtXG4gKi9cbmNsYXNzIFZvdGVQcm9ncmFtIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBQdWJsaWMga2V5IHRoYXQgaWRlbnRpZmllcyB0aGUgVm90ZSBwcm9ncmFtXG4gICAqL1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhbiBJbml0aWFsaXplIGluc3RydWN0aW9uLlxuICAgKi9cbiAgc3RhdGljIGluaXRpYWxpemVBY2NvdW50KHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHZvdGVQdWJrZXksXG4gICAgICBub2RlUHVia2V5LFxuICAgICAgdm90ZUluaXRcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHR5cGUgPSBWT1RFX0lOU1RSVUNUSU9OX0xBWU9VVFMuSW5pdGlhbGl6ZUFjY291bnQ7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgdm90ZUluaXQ6IHtcbiAgICAgICAgbm9kZVB1YmtleTogdG9CdWZmZXIodm90ZUluaXQubm9kZVB1YmtleS50b0J1ZmZlcigpKSxcbiAgICAgICAgYXV0aG9yaXplZFZvdGVyOiB0b0J1ZmZlcih2b3RlSW5pdC5hdXRob3JpemVkVm90ZXIudG9CdWZmZXIoKSksXG4gICAgICAgIGF1dGhvcml6ZWRXaXRoZHJhd2VyOiB0b0J1ZmZlcih2b3RlSW5pdC5hdXRob3JpemVkV2l0aGRyYXdlci50b0J1ZmZlcigpKSxcbiAgICAgICAgY29tbWlzc2lvbjogdm90ZUluaXQuY29tbWlzc2lvblxuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGluc3RydWN0aW9uRGF0YSA9IHtcbiAgICAgIGtleXM6IFt7XG4gICAgICAgIHB1YmtleTogdm90ZVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX1JFTlRfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX0NMT0NLX1BVQktFWSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IG5vZGVQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfV0sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH07XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKGluc3RydWN0aW9uRGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiB0aGF0IGNyZWF0ZXMgYSBuZXcgVm90ZSBhY2NvdW50LlxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUFjY291bnQocGFyYW1zKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS5jcmVhdGVBY2NvdW50KHtcbiAgICAgIGZyb21QdWJrZXk6IHBhcmFtcy5mcm9tUHVia2V5LFxuICAgICAgbmV3QWNjb3VudFB1YmtleTogcGFyYW1zLnZvdGVQdWJrZXksXG4gICAgICBsYW1wb3J0czogcGFyYW1zLmxhbXBvcnRzLFxuICAgICAgc3BhY2U6IHRoaXMuc3BhY2UsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkXG4gICAgfSkpO1xuICAgIHJldHVybiB0cmFuc2FjdGlvbi5hZGQodGhpcy5pbml0aWFsaXplQWNjb3VudCh7XG4gICAgICB2b3RlUHVia2V5OiBwYXJhbXMudm90ZVB1YmtleSxcbiAgICAgIG5vZGVQdWJrZXk6IHBhcmFtcy52b3RlSW5pdC5ub2RlUHVia2V5LFxuICAgICAgdm90ZUluaXQ6IHBhcmFtcy52b3RlSW5pdFxuICAgIH0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIHRoYXQgYXV0aG9yaXplcyBhIG5ldyBWb3RlciBvciBXaXRoZHJhd2VyIG9uIHRoZSBWb3RlIGFjY291bnQuXG4gICAqL1xuICBzdGF0aWMgYXV0aG9yaXplKHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHZvdGVQdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5LFxuICAgICAgbmV3QXV0aG9yaXplZFB1YmtleSxcbiAgICAgIHZvdGVBdXRob3JpemF0aW9uVHlwZVxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFZPVEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5BdXRob3JpemU7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgbmV3QXV0aG9yaXplZDogdG9CdWZmZXIobmV3QXV0aG9yaXplZFB1YmtleS50b0J1ZmZlcigpKSxcbiAgICAgIHZvdGVBdXRob3JpemF0aW9uVHlwZTogdm90ZUF1dGhvcml6YXRpb25UeXBlLmluZGV4XG4gICAgfSk7XG4gICAgY29uc3Qga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IHZvdGVQdWJrZXksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBTWVNWQVJfQ0xPQ0tfUFVCS0VZLFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfV07XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbigpLmFkZCh7XG4gICAgICBrZXlzLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIHRoYXQgYXV0aG9yaXplcyBhIG5ldyBWb3RlciBvciBXaXRoZHJhd2VyIG9uIHRoZSBWb3RlIGFjY291bnRcbiAgICogd2hlcmUgdGhlIGN1cnJlbnQgVm90ZXIgb3IgV2l0aGRyYXdlciBhdXRob3JpdHkgaXMgYSBkZXJpdmVkIGtleS5cbiAgICovXG4gIHN0YXRpYyBhdXRob3JpemVXaXRoU2VlZChwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleUJhc2VQdWJrZXksXG4gICAgICBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleU93bmVyUHVia2V5LFxuICAgICAgY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlTZWVkLFxuICAgICAgbmV3QXV0aG9yaXplZFB1YmtleSxcbiAgICAgIHZvdGVBdXRob3JpemF0aW9uVHlwZSxcbiAgICAgIHZvdGVQdWJrZXlcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHR5cGUgPSBWT1RFX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXV0aG9yaXplV2l0aFNlZWQ7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgdm90ZUF1dGhvcml6ZVdpdGhTZWVkQXJnczoge1xuICAgICAgICBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleU93bmVyUHVia2V5OiB0b0J1ZmZlcihjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleU93bmVyUHVia2V5LnRvQnVmZmVyKCkpLFxuICAgICAgICBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleVNlZWQ6IGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5U2VlZCxcbiAgICAgICAgbmV3QXV0aG9yaXplZDogdG9CdWZmZXIobmV3QXV0aG9yaXplZFB1YmtleS50b0J1ZmZlcigpKSxcbiAgICAgICAgdm90ZUF1dGhvcml6YXRpb25UeXBlOiB2b3RlQXV0aG9yaXphdGlvblR5cGUuaW5kZXhcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBrZXlzID0gW3tcbiAgICAgIHB1YmtleTogdm90ZVB1YmtleSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IFNZU1ZBUl9DTE9DS19QVUJLRVksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlCYXNlUHVia2V5LFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH1dO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoe1xuICAgICAga2V5cyxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiB0byB3aXRoZHJhdyBmcm9tIGEgVm90ZSBhY2NvdW50LlxuICAgKi9cbiAgc3RhdGljIHdpdGhkcmF3KHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHZvdGVQdWJrZXksXG4gICAgICBhdXRob3JpemVkV2l0aGRyYXdlclB1YmtleSxcbiAgICAgIGxhbXBvcnRzLFxuICAgICAgdG9QdWJrZXlcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHR5cGUgPSBWT1RFX0lOU1RSVUNUSU9OX0xBWU9VVFMuV2l0aGRyYXc7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgbGFtcG9ydHNcbiAgICB9KTtcbiAgICBjb25zdCBrZXlzID0gW3tcbiAgICAgIHB1YmtleTogdm90ZVB1YmtleSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IHRvUHVia2V5LFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogYXV0aG9yaXplZFdpdGhkcmF3ZXJQdWJrZXksXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfV07XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbigpLmFkZCh7XG4gICAgICBrZXlzLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIHRvIHdpdGhkcmF3IHNhZmVseSBmcm9tIGEgVm90ZSBhY2NvdW50LlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHdhcyBjcmVhdGVkIGFzIGEgc2FmZWd1YXJkIGZvciB2b3RlIGFjY291bnRzIHJ1bm5pbmcgdmFsaWRhdG9ycywgYHNhZmVXaXRoZHJhd2BcbiAgICogY2hlY2tzIHRoYXQgdGhlIHdpdGhkcmF3IGFtb3VudCB3aWxsIG5vdCBleGNlZWQgdGhlIHNwZWNpZmllZCBiYWxhbmNlIHdoaWxlIGxlYXZpbmcgZW5vdWdoIGxlZnRcbiAgICogdG8gY292ZXIgcmVudC4gSWYgeW91IHdpc2ggdG8gY2xvc2UgdGhlIHZvdGUgYWNjb3VudCBieSB3aXRoZHJhd2luZyB0aGUgZnVsbCBhbW91bnQsIGNhbGwgdGhlXG4gICAqIGB3aXRoZHJhd2AgbWV0aG9kIGRpcmVjdGx5LlxuICAgKi9cbiAgc3RhdGljIHNhZmVXaXRoZHJhdyhwYXJhbXMsIGN1cnJlbnRWb3RlQWNjb3VudEJhbGFuY2UsIHJlbnRFeGVtcHRNaW5pbXVtKSB7XG4gICAgaWYgKHBhcmFtcy5sYW1wb3J0cyA+IGN1cnJlbnRWb3RlQWNjb3VudEJhbGFuY2UgLSByZW50RXhlbXB0TWluaW11bSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXaXRoZHJhdyB3aWxsIGxlYXZlIHZvdGUgYWNjb3VudCB3aXRoIGluc3VmZmljaWVudCBmdW5kcy4nKTtcbiAgICB9XG4gICAgcmV0dXJuIFZvdGVQcm9ncmFtLndpdGhkcmF3KHBhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiB0byB1cGRhdGUgdGhlIHZhbGlkYXRvciBpZGVudGl0eSAobm9kZSBwdWJrZXkpIG9mIGEgVm90ZSBhY2NvdW50LlxuICAgKi9cbiAgc3RhdGljIHVwZGF0ZVZhbGlkYXRvcklkZW50aXR5KHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHZvdGVQdWJrZXksXG4gICAgICBhdXRob3JpemVkV2l0aGRyYXdlclB1YmtleSxcbiAgICAgIG5vZGVQdWJrZXlcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHR5cGUgPSBWT1RFX0lOU1RSVUNUSU9OX0xBWU9VVFMuVXBkYXRlVmFsaWRhdG9ySWRlbnRpdHk7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSk7XG4gICAgY29uc3Qga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IHZvdGVQdWJrZXksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBub2RlUHVia2V5LFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogYXV0aG9yaXplZFdpdGhkcmF3ZXJQdWJrZXksXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfV07XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbigpLmFkZCh7XG4gICAgICBrZXlzLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxufVxuVm90ZVByb2dyYW0ucHJvZ3JhbUlkID0gbmV3IFB1YmxpY0tleSgnVm90ZTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuLyoqXG4gKiBNYXggc3BhY2Ugb2YgYSBWb3RlIGFjY291bnRcbiAqXG4gKiBUaGlzIGlzIGdlbmVyYXRlZCBmcm9tIHRoZSBzb2xhbmEtdm90ZS1wcm9ncmFtIFZvdGVTdGF0ZSBzdHJ1Y3QgYXNcbiAqIGBWb3RlU3RhdGU6OnNpemVfb2YoKWA6XG4gKiBodHRwczovL2RvY3MucnMvc29sYW5hLXZvdGUtcHJvZ3JhbS8xLjkuNS9zb2xhbmFfdm90ZV9wcm9ncmFtL3ZvdGVfc3RhdGUvc3RydWN0LlZvdGVTdGF0ZS5odG1sI21ldGhvZC5zaXplX29mXG4gKlxuICogS0VFUCBJTiBTWU5DIFdJVEggYFZvdGVTdGF0ZTo6c2l6ZV9vZigpYCBpbiBodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hL2Jsb2IvYTQ3NGNiMjRiOTIzOGY1ZWRjYzk4MmY2NWMwYjM3ZDRhMTA0NmY3ZS9zZGsvcHJvZ3JhbS9zcmMvdm90ZS9zdGF0ZS9tb2QucnMjTDM0MC1MMzQyXG4gKi9cblZvdGVQcm9ncmFtLnNwYWNlID0gMzc2MjtcblxuY29uc3QgVkFMSURBVE9SX0lORk9fS0VZID0gbmV3IFB1YmxpY0tleSgnVmExaWRhdG9yMW5mbzExMTExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5cbi8qKlxuICogSW5mbyB1c2VkIHRvIGlkZW50aXR5IHZhbGlkYXRvcnMuXG4gKi9cblxuY29uc3QgSW5mb1N0cmluZyA9IHR5cGUoe1xuICBuYW1lOiBzdHJpbmcoKSxcbiAgd2Vic2l0ZTogb3B0aW9uYWwoc3RyaW5nKCkpLFxuICBkZXRhaWxzOiBvcHRpb25hbChzdHJpbmcoKSksXG4gIGljb25Vcmw6IG9wdGlvbmFsKHN0cmluZygpKSxcbiAga2V5YmFzZVVzZXJuYW1lOiBvcHRpb25hbChzdHJpbmcoKSlcbn0pO1xuXG4vKipcbiAqIFZhbGlkYXRvckluZm8gY2xhc3NcbiAqL1xuY2xhc3MgVmFsaWRhdG9ySW5mbyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSB2YWxpZCBWYWxpZGF0b3JJbmZvXG4gICAqXG4gICAqIEBwYXJhbSBrZXkgdmFsaWRhdG9yIHB1YmxpYyBrZXlcbiAgICogQHBhcmFtIGluZm8gdmFsaWRhdG9yIGluZm9ybWF0aW9uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihrZXksIGluZm8pIHtcbiAgICAvKipcbiAgICAgKiB2YWxpZGF0b3IgcHVibGljIGtleVxuICAgICAqL1xuICAgIHRoaXMua2V5ID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIHZhbGlkYXRvciBpbmZvcm1hdGlvblxuICAgICAqL1xuICAgIHRoaXMuaW5mbyA9IHZvaWQgMDtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLmluZm8gPSBpbmZvO1xuICB9XG5cbiAgLyoqXG4gICAqIERlc2VyaWFsaXplIFZhbGlkYXRvckluZm8gZnJvbSB0aGUgY29uZmlnIGFjY291bnQgZGF0YS4gRXhhY3RseSB0d28gY29uZmlnXG4gICAqIGtleXMgYXJlIHJlcXVpcmVkIGluIHRoZSBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0gYnVmZmVyIGNvbmZpZyBhY2NvdW50IGRhdGFcbiAgICogQHJldHVybiBudWxsIGlmIGluZm8gd2FzIG5vdCBmb3VuZFxuICAgKi9cbiAgc3RhdGljIGZyb21Db25maWdEYXRhKGJ1ZmZlcikge1xuICAgIGxldCBieXRlQXJyYXkgPSBbLi4uYnVmZmVyXTtcbiAgICBjb25zdCBjb25maWdLZXlDb3VudCA9IGRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgIGlmIChjb25maWdLZXlDb3VudCAhPT0gMikgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgY29uZmlnS2V5cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgICBjb25zdCBwdWJsaWNLZXkgPSBuZXcgUHVibGljS2V5KGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAwLCBQVUJMSUNfS0VZX0xFTkdUSCkpO1xuICAgICAgY29uc3QgaXNTaWduZXIgPSBndWFyZGVkU2hpZnQoYnl0ZUFycmF5KSA9PT0gMTtcbiAgICAgIGNvbmZpZ0tleXMucHVzaCh7XG4gICAgICAgIHB1YmxpY0tleSxcbiAgICAgICAgaXNTaWduZXJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoY29uZmlnS2V5c1swXS5wdWJsaWNLZXkuZXF1YWxzKFZBTElEQVRPUl9JTkZPX0tFWSkpIHtcbiAgICAgIGlmIChjb25maWdLZXlzWzFdLmlzU2lnbmVyKSB7XG4gICAgICAgIGNvbnN0IHJhd0luZm8gPSBydXN0U3RyaW5nKCkuZGVjb2RlKEJ1ZmZlci5mcm9tKGJ5dGVBcnJheSkpO1xuICAgICAgICBjb25zdCBpbmZvID0gSlNPTi5wYXJzZShyYXdJbmZvKTtcbiAgICAgICAgYXNzZXJ0JDEoaW5mbywgSW5mb1N0cmluZyk7XG4gICAgICAgIHJldHVybiBuZXcgVmFsaWRhdG9ySW5mbyhjb25maWdLZXlzWzFdLnB1YmxpY0tleSwgaW5mbyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmNvbnN0IFZPVEVfUFJPR1JBTV9JRCA9IG5ldyBQdWJsaWNLZXkoJ1ZvdGUxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcblxuLyoqXG4gKiBIaXN0b3J5IG9mIGhvdyBtYW55IGNyZWRpdHMgZWFybmVkIGJ5IHRoZSBlbmQgb2YgZWFjaCBlcG9jaFxuICovXG5cbi8qKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xhbmEtbGFicy9zb2xhbmEvYmxvYi84YTEyZWQwMjljZmEzOGQ0YTQ1NDAwOTE2YzI0NjNmYjgyYmJlYzhjL3Byb2dyYW1zL3ZvdGVfYXBpL3NyYy92b3RlX3N0YXRlLnJzI0w2OC1MODhcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgVm90ZUFjY291bnRMYXlvdXQgPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtwdWJsaWNLZXkoJ25vZGVQdWJrZXknKSwgcHVibGljS2V5KCdhdXRob3JpemVkV2l0aGRyYXdlcicpLCBCdWZmZXJMYXlvdXQudTgoJ2NvbW1pc3Npb24nKSwgQnVmZmVyTGF5b3V0Lm51NjQoKSxcbi8vIHZvdGVzLmxlbmd0aFxuQnVmZmVyTGF5b3V0LnNlcShCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQubnU2NCgnc2xvdCcpLCBCdWZmZXJMYXlvdXQudTMyKCdjb25maXJtYXRpb25Db3VudCcpXSksIEJ1ZmZlckxheW91dC5vZmZzZXQoQnVmZmVyTGF5b3V0LnUzMigpLCAtOCksICd2b3RlcycpLCBCdWZmZXJMYXlvdXQudTgoJ3Jvb3RTbG90VmFsaWQnKSwgQnVmZmVyTGF5b3V0Lm51NjQoJ3Jvb3RTbG90JyksIEJ1ZmZlckxheW91dC5udTY0KCksXG4vLyBhdXRob3JpemVkVm90ZXJzLmxlbmd0aFxuQnVmZmVyTGF5b3V0LnNlcShCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQubnU2NCgnZXBvY2gnKSwgcHVibGljS2V5KCdhdXRob3JpemVkVm90ZXInKV0pLCBCdWZmZXJMYXlvdXQub2Zmc2V0KEJ1ZmZlckxheW91dC51MzIoKSwgLTgpLCAnYXV0aG9yaXplZFZvdGVycycpLCBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQuc2VxKEJ1ZmZlckxheW91dC5zdHJ1Y3QoW3B1YmxpY0tleSgnYXV0aG9yaXplZFB1YmtleScpLCBCdWZmZXJMYXlvdXQubnU2NCgnZXBvY2hPZkxhc3RBdXRob3JpemVkU3dpdGNoJyksIEJ1ZmZlckxheW91dC5udTY0KCd0YXJnZXRFcG9jaCcpXSksIDMyLCAnYnVmJyksIEJ1ZmZlckxheW91dC5udTY0KCdpZHgnKSwgQnVmZmVyTGF5b3V0LnU4KCdpc0VtcHR5JyldLCAncHJpb3JWb3RlcnMnKSwgQnVmZmVyTGF5b3V0Lm51NjQoKSxcbi8vIGVwb2NoQ3JlZGl0cy5sZW5ndGhcbkJ1ZmZlckxheW91dC5zZXEoQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0Lm51NjQoJ2Vwb2NoJyksIEJ1ZmZlckxheW91dC5udTY0KCdjcmVkaXRzJyksIEJ1ZmZlckxheW91dC5udTY0KCdwcmV2Q3JlZGl0cycpXSksIEJ1ZmZlckxheW91dC5vZmZzZXQoQnVmZmVyTGF5b3V0LnUzMigpLCAtOCksICdlcG9jaENyZWRpdHMnKSwgQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0Lm51NjQoJ3Nsb3QnKSwgQnVmZmVyTGF5b3V0Lm51NjQoJ3RpbWVzdGFtcCcpXSwgJ2xhc3RUaW1lc3RhbXAnKV0pO1xuLyoqXG4gKiBWb3RlQWNjb3VudCBjbGFzc1xuICovXG5jbGFzcyBWb3RlQWNjb3VudCB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICB0aGlzLm5vZGVQdWJrZXkgPSB2b2lkIDA7XG4gICAgdGhpcy5hdXRob3JpemVkV2l0aGRyYXdlciA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbW1pc3Npb24gPSB2b2lkIDA7XG4gICAgdGhpcy5yb290U2xvdCA9IHZvaWQgMDtcbiAgICB0aGlzLnZvdGVzID0gdm9pZCAwO1xuICAgIHRoaXMuYXV0aG9yaXplZFZvdGVycyA9IHZvaWQgMDtcbiAgICB0aGlzLnByaW9yVm90ZXJzID0gdm9pZCAwO1xuICAgIHRoaXMuZXBvY2hDcmVkaXRzID0gdm9pZCAwO1xuICAgIHRoaXMubGFzdFRpbWVzdGFtcCA9IHZvaWQgMDtcbiAgICB0aGlzLm5vZGVQdWJrZXkgPSBhcmdzLm5vZGVQdWJrZXk7XG4gICAgdGhpcy5hdXRob3JpemVkV2l0aGRyYXdlciA9IGFyZ3MuYXV0aG9yaXplZFdpdGhkcmF3ZXI7XG4gICAgdGhpcy5jb21taXNzaW9uID0gYXJncy5jb21taXNzaW9uO1xuICAgIHRoaXMucm9vdFNsb3QgPSBhcmdzLnJvb3RTbG90O1xuICAgIHRoaXMudm90ZXMgPSBhcmdzLnZvdGVzO1xuICAgIHRoaXMuYXV0aG9yaXplZFZvdGVycyA9IGFyZ3MuYXV0aG9yaXplZFZvdGVycztcbiAgICB0aGlzLnByaW9yVm90ZXJzID0gYXJncy5wcmlvclZvdGVycztcbiAgICB0aGlzLmVwb2NoQ3JlZGl0cyA9IGFyZ3MuZXBvY2hDcmVkaXRzO1xuICAgIHRoaXMubGFzdFRpbWVzdGFtcCA9IGFyZ3MubGFzdFRpbWVzdGFtcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZSBWb3RlQWNjb3VudCBmcm9tIHRoZSBhY2NvdW50IGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSBidWZmZXIgYWNjb3VudCBkYXRhXG4gICAqIEByZXR1cm4gVm90ZUFjY291bnRcbiAgICovXG4gIHN0YXRpYyBmcm9tQWNjb3VudERhdGEoYnVmZmVyKSB7XG4gICAgY29uc3QgdmVyc2lvbk9mZnNldCA9IDQ7XG4gICAgY29uc3QgdmEgPSBWb3RlQWNjb3VudExheW91dC5kZWNvZGUodG9CdWZmZXIoYnVmZmVyKSwgdmVyc2lvbk9mZnNldCk7XG4gICAgbGV0IHJvb3RTbG90ID0gdmEucm9vdFNsb3Q7XG4gICAgaWYgKCF2YS5yb290U2xvdFZhbGlkKSB7XG4gICAgICByb290U2xvdCA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVm90ZUFjY291bnQoe1xuICAgICAgbm9kZVB1YmtleTogbmV3IFB1YmxpY0tleSh2YS5ub2RlUHVia2V5KSxcbiAgICAgIGF1dGhvcml6ZWRXaXRoZHJhd2VyOiBuZXcgUHVibGljS2V5KHZhLmF1dGhvcml6ZWRXaXRoZHJhd2VyKSxcbiAgICAgIGNvbW1pc3Npb246IHZhLmNvbW1pc3Npb24sXG4gICAgICB2b3RlczogdmEudm90ZXMsXG4gICAgICByb290U2xvdCxcbiAgICAgIGF1dGhvcml6ZWRWb3RlcnM6IHZhLmF1dGhvcml6ZWRWb3RlcnMubWFwKHBhcnNlQXV0aG9yaXplZFZvdGVyKSxcbiAgICAgIHByaW9yVm90ZXJzOiBnZXRQcmlvclZvdGVycyh2YS5wcmlvclZvdGVycyksXG4gICAgICBlcG9jaENyZWRpdHM6IHZhLmVwb2NoQ3JlZGl0cyxcbiAgICAgIGxhc3RUaW1lc3RhbXA6IHZhLmxhc3RUaW1lc3RhbXBcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VBdXRob3JpemVkVm90ZXIoe1xuICBhdXRob3JpemVkVm90ZXIsXG4gIGVwb2NoXG59KSB7XG4gIHJldHVybiB7XG4gICAgZXBvY2gsXG4gICAgYXV0aG9yaXplZFZvdGVyOiBuZXcgUHVibGljS2V5KGF1dGhvcml6ZWRWb3RlcilcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlUHJpb3JWb3RlcnMoe1xuICBhdXRob3JpemVkUHVia2V5LFxuICBlcG9jaE9mTGFzdEF1dGhvcml6ZWRTd2l0Y2gsXG4gIHRhcmdldEVwb2NoXG59KSB7XG4gIHJldHVybiB7XG4gICAgYXV0aG9yaXplZFB1YmtleTogbmV3IFB1YmxpY0tleShhdXRob3JpemVkUHVia2V5KSxcbiAgICBlcG9jaE9mTGFzdEF1dGhvcml6ZWRTd2l0Y2gsXG4gICAgdGFyZ2V0RXBvY2hcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFByaW9yVm90ZXJzKHtcbiAgYnVmLFxuICBpZHgsXG4gIGlzRW1wdHlcbn0pIHtcbiAgaWYgKGlzRW1wdHkpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIFsuLi5idWYuc2xpY2UoaWR4ICsgMSkubWFwKHBhcnNlUHJpb3JWb3RlcnMpLCAuLi5idWYuc2xpY2UoMCwgaWR4KS5tYXAocGFyc2VQcmlvclZvdGVycyldO1xufVxuXG5jb25zdCBlbmRwb2ludCA9IHtcbiAgaHR0cDoge1xuICAgIGRldm5ldDogJ2h0dHA6Ly9hcGkuZGV2bmV0LnNvbGFuYS5jb20nLFxuICAgIHRlc3RuZXQ6ICdodHRwOi8vYXBpLnRlc3RuZXQuc29sYW5hLmNvbScsXG4gICAgJ21haW5uZXQtYmV0YSc6ICdodHRwOi8vYXBpLm1haW5uZXQtYmV0YS5zb2xhbmEuY29tLydcbiAgfSxcbiAgaHR0cHM6IHtcbiAgICBkZXZuZXQ6ICdodHRwczovL2FwaS5kZXZuZXQuc29sYW5hLmNvbScsXG4gICAgdGVzdG5ldDogJ2h0dHBzOi8vYXBpLnRlc3RuZXQuc29sYW5hLmNvbScsXG4gICAgJ21haW5uZXQtYmV0YSc6ICdodHRwczovL2FwaS5tYWlubmV0LWJldGEuc29sYW5hLmNvbS8nXG4gIH1cbn07XG4vKipcbiAqIFJldHJpZXZlcyB0aGUgUlBDIEFQSSBVUkwgZm9yIHRoZSBzcGVjaWZpZWQgY2x1c3RlclxuICogQHBhcmFtIHtDbHVzdGVyfSBbY2x1c3Rlcj1cImRldm5ldFwiXSAtIFRoZSBjbHVzdGVyIG5hbWUgb2YgdGhlIFJQQyBBUEkgVVJMIHRvIHVzZS4gUG9zc2libGUgb3B0aW9uczogJ2Rldm5ldCcgfCAndGVzdG5ldCcgfCAnbWFpbm5ldC1iZXRhJ1xuICogQHBhcmFtIHtib29sZWFufSBbdGxzPVwiaHR0cFwiXSAtIFVzZSBUTFMgd2hlbiBjb25uZWN0aW5nIHRvIGNsdXN0ZXIuXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gVVJMIHN0cmluZyBvZiB0aGUgUlBDIGVuZHBvaW50XG4gKi9cbmZ1bmN0aW9uIGNsdXN0ZXJBcGlVcmwoY2x1c3RlciwgdGxzKSB7XG4gIGNvbnN0IGtleSA9IHRscyA9PT0gZmFsc2UgPyAnaHR0cCcgOiAnaHR0cHMnO1xuICBpZiAoIWNsdXN0ZXIpIHtcbiAgICByZXR1cm4gZW5kcG9pbnRba2V5XVsnZGV2bmV0J107XG4gIH1cbiAgY29uc3QgdXJsID0gZW5kcG9pbnRba2V5XVtjbHVzdGVyXTtcbiAgaWYgKCF1cmwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gJHtrZXl9IGNsdXN0ZXI6ICR7Y2x1c3Rlcn1gKTtcbiAgfVxuICByZXR1cm4gdXJsO1xufVxuXG4vKipcbiAqIFNlbmQgYW5kIGNvbmZpcm0gYSByYXcgdHJhbnNhY3Rpb25cbiAqXG4gKiBJZiBgY29tbWl0bWVudGAgb3B0aW9uIGlzIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvICdtYXgnIGNvbW1pdG1lbnQuXG4gKlxuICogQHBhcmFtIHtDb25uZWN0aW9ufSBjb25uZWN0aW9uXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcmF3VHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb25Db25maXJtYXRpb25TdHJhdGVneX0gY29uZmlybWF0aW9uU3RyYXRlZ3lcbiAqIEBwYXJhbSB7Q29uZmlybU9wdGlvbnN9IFtvcHRpb25zXVxuICogQHJldHVybnMge1Byb21pc2U8VHJhbnNhY3Rpb25TaWduYXR1cmU+fVxuICovXG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgQ2FsbGluZyBgc2VuZEFuZENvbmZpcm1SYXdUcmFuc2FjdGlvbigpYCB3aXRob3V0IGEgYGNvbmZpcm1hdGlvblN0cmF0ZWd5YFxuICogaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuYXN5bmMgZnVuY3Rpb24gc2VuZEFuZENvbmZpcm1SYXdUcmFuc2FjdGlvbihjb25uZWN0aW9uLCByYXdUcmFuc2FjdGlvbiwgY29uZmlybWF0aW9uU3RyYXRlZ3lPckNvbmZpcm1PcHRpb25zLCBtYXliZUNvbmZpcm1PcHRpb25zKSB7XG4gIGxldCBjb25maXJtYXRpb25TdHJhdGVneTtcbiAgbGV0IG9wdGlvbnM7XG4gIGlmIChjb25maXJtYXRpb25TdHJhdGVneU9yQ29uZmlybU9wdGlvbnMgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpcm1hdGlvblN0cmF0ZWd5T3JDb25maXJtT3B0aW9ucywgJ2xhc3RWYWxpZEJsb2NrSGVpZ2h0JykpIHtcbiAgICBjb25maXJtYXRpb25TdHJhdGVneSA9IGNvbmZpcm1hdGlvblN0cmF0ZWd5T3JDb25maXJtT3B0aW9ucztcbiAgICBvcHRpb25zID0gbWF5YmVDb25maXJtT3B0aW9ucztcbiAgfSBlbHNlIGlmIChjb25maXJtYXRpb25TdHJhdGVneU9yQ29uZmlybU9wdGlvbnMgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpcm1hdGlvblN0cmF0ZWd5T3JDb25maXJtT3B0aW9ucywgJ25vbmNlVmFsdWUnKSkge1xuICAgIGNvbmZpcm1hdGlvblN0cmF0ZWd5ID0gY29uZmlybWF0aW9uU3RyYXRlZ3lPckNvbmZpcm1PcHRpb25zO1xuICAgIG9wdGlvbnMgPSBtYXliZUNvbmZpcm1PcHRpb25zO1xuICB9IGVsc2Uge1xuICAgIG9wdGlvbnMgPSBjb25maXJtYXRpb25TdHJhdGVneU9yQ29uZmlybU9wdGlvbnM7XG4gIH1cbiAgY29uc3Qgc2VuZE9wdGlvbnMgPSBvcHRpb25zICYmIHtcbiAgICBza2lwUHJlZmxpZ2h0OiBvcHRpb25zLnNraXBQcmVmbGlnaHQsXG4gICAgcHJlZmxpZ2h0Q29tbWl0bWVudDogb3B0aW9ucy5wcmVmbGlnaHRDb21taXRtZW50IHx8IG9wdGlvbnMuY29tbWl0bWVudCxcbiAgICBtaW5Db250ZXh0U2xvdDogb3B0aW9ucy5taW5Db250ZXh0U2xvdFxuICB9O1xuICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBjb25uZWN0aW9uLnNlbmRSYXdUcmFuc2FjdGlvbihyYXdUcmFuc2FjdGlvbiwgc2VuZE9wdGlvbnMpO1xuICBjb25zdCBjb21taXRtZW50ID0gb3B0aW9ucyAmJiBvcHRpb25zLmNvbW1pdG1lbnQ7XG4gIGNvbnN0IGNvbmZpcm1hdGlvblByb21pc2UgPSBjb25maXJtYXRpb25TdHJhdGVneSA/IGNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKGNvbmZpcm1hdGlvblN0cmF0ZWd5LCBjb21taXRtZW50KSA6IGNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKHNpZ25hdHVyZSwgY29tbWl0bWVudCk7XG4gIGNvbnN0IHN0YXR1cyA9IChhd2FpdCBjb25maXJtYXRpb25Qcm9taXNlKS52YWx1ZTtcbiAgaWYgKHN0YXR1cy5lcnIpIHtcbiAgICBpZiAoc2lnbmF0dXJlICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBTZW5kVHJhbnNhY3Rpb25FcnJvcih7XG4gICAgICAgIGFjdGlvbjogc2VuZE9wdGlvbnM/LnNraXBQcmVmbGlnaHQgPyAnc2VuZCcgOiAnc2ltdWxhdGUnLFxuICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZSxcbiAgICAgICAgdHJhbnNhY3Rpb25NZXNzYWdlOiBgU3RhdHVzOiAoJHtKU09OLnN0cmluZ2lmeShzdGF0dXMpfSlgXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBSYXcgdHJhbnNhY3Rpb24gJHtzaWduYXR1cmV9IGZhaWxlZCAoJHtKU09OLnN0cmluZ2lmeShzdGF0dXMpfSlgKTtcbiAgfVxuICByZXR1cm4gc2lnbmF0dXJlO1xufVxuXG4vKipcbiAqIFRoZXJlIGFyZSAxLWJpbGxpb24gbGFtcG9ydHMgaW4gb25lIFNPTFxuICovXG5jb25zdCBMQU1QT1JUU19QRVJfU09MID0gMTAwMDAwMDAwMDtcblxuZXhwb3J0IHsgQWNjb3VudCwgQWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudCwgQWRkcmVzc0xvb2t1cFRhYmxlSW5zdHJ1Y3Rpb24sIEFkZHJlc3NMb29rdXBUYWJsZVByb2dyYW0sIEF1dGhvcml6ZWQsIEJMT0NLSEFTSF9DQUNIRV9USU1FT1VUX01TLCBCUEZfTE9BREVSX0RFUFJFQ0FURURfUFJPR1JBTV9JRCwgQlBGX0xPQURFUl9QUk9HUkFNX0lELCBCcGZMb2FkZXIsIENPTVBVVEVfQlVER0VUX0lOU1RSVUNUSU9OX0xBWU9VVFMsIENvbXB1dGVCdWRnZXRJbnN0cnVjdGlvbiwgQ29tcHV0ZUJ1ZGdldFByb2dyYW0sIENvbm5lY3Rpb24sIEVkMjU1MTlQcm9ncmFtLCBFbnVtLCBFcG9jaFNjaGVkdWxlLCBGZWVDYWxjdWxhdG9yTGF5b3V0LCBLZXlwYWlyLCBMQU1QT1JUU19QRVJfU09MLCBMT09LVVBfVEFCTEVfSU5TVFJVQ1RJT05fTEFZT1VUUywgTG9hZGVyLCBMb2NrdXAsIE1BWF9TRUVEX0xFTkdUSCwgTWVzc2FnZSwgTWVzc2FnZUFjY291bnRLZXlzLCBNZXNzYWdlVjAsIE5PTkNFX0FDQ09VTlRfTEVOR1RILCBOb25jZUFjY291bnQsIFBBQ0tFVF9EQVRBX1NJWkUsIFBVQkxJQ19LRVlfTEVOR1RILCBQdWJsaWNLZXksIFNJR05BVFVSRV9MRU5HVEhfSU5fQllURVMsIFNPTEFOQV9TQ0hFTUEsIFNUQUtFX0NPTkZJR19JRCwgU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUywgU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMsIFNZU1ZBUl9DTE9DS19QVUJLRVksIFNZU1ZBUl9FUE9DSF9TQ0hFRFVMRV9QVUJLRVksIFNZU1ZBUl9JTlNUUlVDVElPTlNfUFVCS0VZLCBTWVNWQVJfUkVDRU5UX0JMT0NLSEFTSEVTX1BVQktFWSwgU1lTVkFSX1JFTlRfUFVCS0VZLCBTWVNWQVJfUkVXQVJEU19QVUJLRVksIFNZU1ZBUl9TTE9UX0hBU0hFU19QVUJLRVksIFNZU1ZBUl9TTE9UX0hJU1RPUllfUFVCS0VZLCBTWVNWQVJfU1RBS0VfSElTVE9SWV9QVUJLRVksIFNlY3AyNTZrMVByb2dyYW0sIFNlbmRUcmFuc2FjdGlvbkVycm9yLCBTb2xhbmFKU09OUlBDRXJyb3IsIFNvbGFuYUpTT05SUENFcnJvckNvZGUsIFN0YWtlQXV0aG9yaXphdGlvbkxheW91dCwgU3Rha2VJbnN0cnVjdGlvbiwgU3Rha2VQcm9ncmFtLCBTdHJ1Y3QsIFN5c3RlbUluc3RydWN0aW9uLCBTeXN0ZW1Qcm9ncmFtLCBUcmFuc2FjdGlvbiwgVHJhbnNhY3Rpb25FeHBpcmVkQmxvY2toZWlnaHRFeGNlZWRlZEVycm9yLCBUcmFuc2FjdGlvbkV4cGlyZWROb25jZUludmFsaWRFcnJvciwgVHJhbnNhY3Rpb25FeHBpcmVkVGltZW91dEVycm9yLCBUcmFuc2FjdGlvbkluc3RydWN0aW9uLCBUcmFuc2FjdGlvbk1lc3NhZ2UsIFRyYW5zYWN0aW9uU3RhdHVzLCBWQUxJREFUT1JfSU5GT19LRVksIFZFUlNJT05fUFJFRklYX01BU0ssIFZPVEVfUFJPR1JBTV9JRCwgVmFsaWRhdG9ySW5mbywgVmVyc2lvbmVkTWVzc2FnZSwgVmVyc2lvbmVkVHJhbnNhY3Rpb24sIFZvdGVBY2NvdW50LCBWb3RlQXV0aG9yaXphdGlvbkxheW91dCwgVm90ZUluaXQsIFZvdGVJbnN0cnVjdGlvbiwgVm90ZVByb2dyYW0sIGNsdXN0ZXJBcGlVcmwsIHNlbmRBbmRDb25maXJtUmF3VHJhbnNhY3Rpb24sIHNlbmRBbmRDb25maXJtVHJhbnNhY3Rpb24gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJCdWZmZXIiLCJlZDI1NTE5IiwiQk4iLCJiczU4Iiwic2hhMjU2Iiwic2VyaWFsaXplIiwiZGVzZXJpYWxpemUiLCJkZXNlcmlhbGl6ZVVuY2hlY2tlZCIsIkJ1ZmZlckxheW91dCIsImJsb2IiLCJnZXRVNjRDb2RlYyIsImdldFU2NEVuY29kZXIiLCJyZXF1aXJlJCQwIiwicmVxdWlyZSQkMCQxIiwicmVxdWlyZSQkMCQyIiwiQWdlbnQiLCJjb2VyY2UiLCJpbnN0YW5jZSIsInN0cmluZyIsInR1cGxlIiwibGl0ZXJhbCIsInVua25vd24iLCJ0eXBlIiwibnVtYmVyIiwiYXJyYXkiLCJudWxsYWJsZSIsIm9wdGlvbmFsIiwiYm9vbGVhbiIsInJlY29yZCIsInVuaW9uIiwiY3JlYXRlIiwiYW55IiwiYXNzZXJ0IiwiYXNzZXJ0JDEiLCJScGNDbGllbnQiLCJub2RlRmV0Y2giLCJDb21tb25DbGllbnQiLCJXZWJTb2NrZXQiLCJrZWNjYWtfMjU2Iiwic2VjcDI1NmsxIiwiZ2VuZXJhdGVQcml2YXRlS2V5IiwidXRpbHMiLCJyYW5kb21Qcml2YXRlS2V5IiwiZ2VuZXJhdGVLZXlwYWlyIiwicHJpdmF0ZVNjYWxhciIsInB1YmxpY0tleSIsImdldFB1YmxpY0tleSIsInNlY3JldEtleSIsIlVpbnQ4QXJyYXkiLCJzZXQiLCJpc09uQ3VydmUiLCJFeHRlbmRlZFBvaW50IiwiZnJvbUhleCIsInNpZ24iLCJtZXNzYWdlIiwic2xpY2UiLCJ2ZXJpZnkiLCJ0b0J1ZmZlciIsImFyciIsImlzQnVmZmVyIiwiZnJvbSIsImJ1ZmZlciIsImJ5dGVPZmZzZXQiLCJieXRlTGVuZ3RoIiwiU3RydWN0IiwiY29uc3RydWN0b3IiLCJwcm9wZXJ0aWVzIiwiT2JqZWN0IiwiYXNzaWduIiwiZW5jb2RlIiwiU09MQU5BX1NDSEVNQSIsImRlY29kZSIsImRhdGEiLCJkZWNvZGVVbmNoZWNrZWQiLCJFbnVtIiwiZW51bSIsImtleXMiLCJsZW5ndGgiLCJFcnJvciIsIm1hcCIsImtleSIsIk1hcCIsIl9QdWJsaWNLZXkiLCJNQVhfU0VFRF9MRU5HVEgiLCJQVUJMSUNfS0VZX0xFTkdUSCIsImlzUHVibGljS2V5RGF0YSIsInZhbHVlIiwiX2JuIiwidW5kZWZpbmVkIiwidW5pcXVlUHVibGljS2V5Q291bnRlciIsIlB1YmxpY0tleSIsImRlY29kZWQiLCJ1bmlxdWUiLCJlcXVhbHMiLCJlcSIsInRvQmFzZTU4IiwidG9CeXRlcyIsInRvSlNPTiIsImJ1ZiIsImIiLCJ0b0FycmF5TGlrZSIsInplcm9QYWQiLCJhbGxvYyIsImNvcHkiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsInRvU3RyaW5nIiwiY3JlYXRlV2l0aFNlZWQiLCJmcm9tUHVibGljS2V5Iiwic2VlZCIsInByb2dyYW1JZCIsImNvbmNhdCIsInB1YmxpY0tleUJ5dGVzIiwiY3JlYXRlUHJvZ3JhbUFkZHJlc3NTeW5jIiwic2VlZHMiLCJmb3JFYWNoIiwiVHlwZUVycm9yIiwiY3JlYXRlUHJvZ3JhbUFkZHJlc3MiLCJmaW5kUHJvZ3JhbUFkZHJlc3NTeW5jIiwibm9uY2UiLCJhZGRyZXNzIiwic2VlZHNXaXRoTm9uY2UiLCJlcnIiLCJmaW5kUHJvZ3JhbUFkZHJlc3MiLCJwdWJrZXlEYXRhIiwicHVia2V5IiwiZGVmYXVsdCIsImtpbmQiLCJmaWVsZHMiLCJBY2NvdW50IiwiX3B1YmxpY0tleSIsIl9zZWNyZXRLZXkiLCJzZWNyZXRLZXlCdWZmZXIiLCJCUEZfTE9BREVSX0RFUFJFQ0FURURfUFJPR1JBTV9JRCIsIlBBQ0tFVF9EQVRBX1NJWkUiLCJWRVJTSU9OX1BSRUZJWF9NQVNLIiwiU0lHTkFUVVJFX0xFTkdUSF9JTl9CWVRFUyIsIlRyYW5zYWN0aW9uRXhwaXJlZEJsb2NraGVpZ2h0RXhjZWVkZWRFcnJvciIsInNpZ25hdHVyZSIsImRlZmluZVByb3BlcnR5IiwicHJvdG90eXBlIiwiVHJhbnNhY3Rpb25FeHBpcmVkVGltZW91dEVycm9yIiwidGltZW91dFNlY29uZHMiLCJ0b0ZpeGVkIiwiVHJhbnNhY3Rpb25FeHBpcmVkTm9uY2VJbnZhbGlkRXJyb3IiLCJNZXNzYWdlQWNjb3VudEtleXMiLCJzdGF0aWNBY2NvdW50S2V5cyIsImFjY291bnRLZXlzRnJvbUxvb2t1cHMiLCJrZXlTZWdtZW50cyIsInB1c2giLCJ3cml0YWJsZSIsInJlYWRvbmx5IiwiZ2V0IiwiaW5kZXgiLCJrZXlTZWdtZW50IiwiZmxhdCIsImNvbXBpbGVJbnN0cnVjdGlvbnMiLCJpbnN0cnVjdGlvbnMiLCJVOF9NQVgiLCJrZXlJbmRleE1hcCIsImZpbmRLZXlJbmRleCIsImtleUluZGV4IiwiaW5zdHJ1Y3Rpb24iLCJwcm9ncmFtSWRJbmRleCIsImFjY291bnRLZXlJbmRleGVzIiwibWV0YSIsInByb3BlcnR5IiwicnVzdFN0cmluZyIsInJzbCIsInN0cnVjdCIsInUzMiIsIm9mZnNldCIsIl9kZWNvZGUiLCJiaW5kIiwiX2VuY29kZSIsInJzbFNoaW0iLCJzdHIiLCJjaGFycyIsInNwYW4iLCJhdXRob3JpemVkIiwibG9ja3VwIiwibnM2NCIsInZvdGVJbml0IiwidTgiLCJ2b3RlQXV0aG9yaXplV2l0aFNlZWRBcmdzIiwiZ2V0QWxsb2MiLCJnZXRJdGVtQWxsb2MiLCJpdGVtIiwiZmllbGQiLCJBcnJheSIsImlzQXJyYXkiLCJlbGVtZW50TGF5b3V0IiwibGF5b3V0IiwiZGVjb2RlTGVuZ3RoIiwiYnl0ZXMiLCJsZW4iLCJzaXplIiwiZWxlbSIsInNoaWZ0IiwiZW5jb2RlTGVuZ3RoIiwicmVtX2xlbiIsImNvbmRpdGlvbiIsIkNvbXBpbGVkS2V5cyIsInBheWVyIiwia2V5TWV0YU1hcCIsImNvbXBpbGUiLCJnZXRPckluc2VydERlZmF1bHQiLCJrZXlNZXRhIiwiaXNTaWduZXIiLCJpc1dyaXRhYmxlIiwiaXNJbnZva2VkIiwicGF5ZXJLZXlNZXRhIiwiaXgiLCJhY2NvdW50TWV0YSIsImdldE1lc3NhZ2VDb21wb25lbnRzIiwibWFwRW50cmllcyIsImVudHJpZXMiLCJ3cml0YWJsZVNpZ25lcnMiLCJmaWx0ZXIiLCJyZWFkb25seVNpZ25lcnMiLCJ3cml0YWJsZU5vblNpZ25lcnMiLCJyZWFkb25seU5vblNpZ25lcnMiLCJoZWFkZXIiLCJudW1SZXF1aXJlZFNpZ25hdHVyZXMiLCJudW1SZWFkb25seVNpZ25lZEFjY291bnRzIiwibnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzIiwicGF5ZXJBZGRyZXNzIiwiZXh0cmFjdFRhYmxlTG9va3VwIiwibG9va3VwVGFibGUiLCJ3cml0YWJsZUluZGV4ZXMiLCJkcmFpbmVkV3JpdGFibGVLZXlzIiwiZHJhaW5LZXlzRm91bmRJbkxvb2t1cFRhYmxlIiwic3RhdGUiLCJhZGRyZXNzZXMiLCJyZWFkb25seUluZGV4ZXMiLCJkcmFpbmVkUmVhZG9ubHlLZXlzIiwiYWNjb3VudEtleSIsImxvb2t1cFRhYmxlRW50cmllcyIsImtleU1ldGFGaWx0ZXIiLCJsb29rdXBUYWJsZUluZGV4ZXMiLCJkcmFpbmVkS2V5cyIsImxvb2t1cFRhYmxlSW5kZXgiLCJmaW5kSW5kZXgiLCJlbnRyeSIsImRlbGV0ZSIsIkVORF9PRl9CVUZGRVJfRVJST1JfTUVTU0FHRSIsImd1YXJkZWRTaGlmdCIsImJ5dGVBcnJheSIsImd1YXJkZWRTcGxpY2UiLCJhcmdzIiwic3RhcnQiLCJzcGxpY2UiLCJNZXNzYWdlIiwiYWNjb3VudEtleXMiLCJyZWNlbnRCbG9ja2hhc2giLCJpbmRleFRvUHJvZ3JhbUlkcyIsImFjY291bnQiLCJ2ZXJzaW9uIiwiY29tcGlsZWRJbnN0cnVjdGlvbnMiLCJhY2NvdW50cyIsImFkZHJlc3NUYWJsZUxvb2t1cHMiLCJnZXRBY2NvdW50S2V5cyIsImNvbXBpbGVkS2V5cyIsInBheWVyS2V5IiwiaXNBY2NvdW50U2lnbmVyIiwiaXNBY2NvdW50V3JpdGFibGUiLCJudW1TaWduZWRBY2NvdW50cyIsInVuc2lnbmVkQWNjb3VudEluZGV4IiwibnVtVW5zaWduZWRBY2NvdW50cyIsIm51bVdyaXRhYmxlVW5zaWduZWRBY2NvdW50cyIsIm51bVdyaXRhYmxlU2lnbmVkQWNjb3VudHMiLCJpc1Byb2dyYW1JZCIsImhhcyIsInByb2dyYW1JZHMiLCJ2YWx1ZXMiLCJub25Qcm9ncmFtSWRzIiwiXyIsIm51bUtleXMiLCJrZXlDb3VudCIsImtleUluZGljZXNDb3VudCIsImRhdGFDb3VudCIsImtleUluZGljZXMiLCJkYXRhTGVuZ3RoIiwiaW5zdHJ1Y3Rpb25Db3VudCIsImluc3RydWN0aW9uQnVmZmVyIiwiaW5zdHJ1Y3Rpb25CdWZmZXJMZW5ndGgiLCJpbnN0cnVjdGlvbkxheW91dCIsInNlcSIsInNpZ25EYXRhTGF5b3V0IiwidHJhbnNhY3Rpb24iLCJzaWduRGF0YSIsImFjY291bnRDb3VudCIsImkiLCJkYXRhU2xpY2UiLCJtZXNzYWdlQXJncyIsIk1lc3NhZ2VWMCIsIm51bUFjY291bnRLZXlzRnJvbUxvb2t1cHMiLCJjb3VudCIsImxvb2t1cCIsImFkZHJlc3NMb29rdXBUYWJsZUFjY291bnRzIiwicmVzb2x2ZUFkZHJlc3NUYWJsZUxvb2t1cHMiLCJudW1TdGF0aWNBY2NvdW50S2V5cyIsImxvb2t1cEFjY291bnRLZXlzSW5kZXgiLCJudW1Xcml0YWJsZUxvb2t1cEFjY291bnRLZXlzIiwicmVkdWNlIiwidGFibGVMb29rdXAiLCJ0YWJsZUFjY291bnQiLCJmaW5kIiwibG9va3VwVGFibGVBY2NvdW50cyIsImV4dHJhY3RSZXN1bHQiLCJhZGRyZXNzVGFibGVMb29rdXAiLCJlbmNvZGVkU3RhdGljQWNjb3VudEtleXNMZW5ndGgiLCJzZXJpYWxpemVkSW5zdHJ1Y3Rpb25zIiwic2VyaWFsaXplSW5zdHJ1Y3Rpb25zIiwiZW5jb2RlZEluc3RydWN0aW9uc0xlbmd0aCIsInNlcmlhbGl6ZWRBZGRyZXNzVGFibGVMb29rdXBzIiwic2VyaWFsaXplQWRkcmVzc1RhYmxlTG9va3VwcyIsImVuY29kZWRBZGRyZXNzVGFibGVMb29rdXBzTGVuZ3RoIiwibWVzc2FnZUxheW91dCIsInNlcmlhbGl6ZWRNZXNzYWdlIiwiTUVTU0FHRV9WRVJTSU9OXzBfUFJFRklYIiwic2VyaWFsaXplZE1lc3NhZ2VMZW5ndGgiLCJwcmVmaXgiLCJzdGF0aWNBY2NvdW50S2V5c0xlbmd0aCIsImluc3RydWN0aW9uc0xlbmd0aCIsImFkZHJlc3NUYWJsZUxvb2t1cHNMZW5ndGgiLCJzZXJpYWxpemVkTGVuZ3RoIiwiZW5jb2RlZEFjY291bnRLZXlJbmRleGVzTGVuZ3RoIiwiZW5jb2RlZERhdGFMZW5ndGgiLCJlbmNvZGVkV3JpdGFibGVJbmRleGVzTGVuZ3RoIiwiZW5jb2RlZFJlYWRvbmx5SW5kZXhlc0xlbmd0aCIsImFkZHJlc3NUYWJsZUxvb2t1cExheW91dCIsIm1hc2tlZFByZWZpeCIsImFjY291bnRLZXlJbmRleGVzTGVuZ3RoIiwiYWRkcmVzc1RhYmxlTG9va3Vwc0NvdW50Iiwid3JpdGFibGVJbmRleGVzTGVuZ3RoIiwicmVhZG9ubHlJbmRleGVzTGVuZ3RoIiwiVmVyc2lvbmVkTWVzc2FnZSIsImRlc2VyaWFsaXplTWVzc2FnZVZlcnNpb24iLCJUcmFuc2FjdGlvblN0YXR1cyIsIkRFRkFVTFRfU0lHTkFUVVJFIiwiZmlsbCIsIlRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24iLCJvcHRzIiwiVHJhbnNhY3Rpb24iLCJzaWduYXR1cmVzIiwiZmVlUGF5ZXIiLCJsYXN0VmFsaWRCbG9ja0hlaWdodCIsIm5vbmNlSW5mbyIsIm1pbk5vbmNlQ29udGV4dFNsb3QiLCJfbWVzc2FnZSIsIl9qc29uIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwibWluQ29udGV4dFNsb3QiLCJibG9ja2hhc2giLCJub25jZUluc3RydWN0aW9uIiwic2lnbmVycyIsImFkZCIsIml0ZW1zIiwiY29tcGlsZU1lc3NhZ2UiLCJKU09OIiwic3RyaW5naWZ5IiwiY29uc29sZSIsIndhcm4iLCJhY2NvdW50TWV0YXMiLCJpbmNsdWRlcyIsInVuaXF1ZU1ldGFzIiwicHVia2V5U3RyaW5nIiwidW5pcXVlSW5kZXgiLCJ4Iiwic29ydCIsInkiLCJvcHRpb25zIiwibG9jYWxlTWF0Y2hlciIsInVzYWdlIiwic2Vuc2l0aXZpdHkiLCJpZ25vcmVQdW5jdHVhdGlvbiIsIm51bWVyaWMiLCJjYXNlRmlyc3QiLCJsb2NhbGVDb21wYXJlIiwiZmVlUGF5ZXJJbmRleCIsInBheWVyTWV0YSIsInVuc2hpZnQiLCJzaWduZWRLZXlzIiwidW5zaWduZWRLZXlzIiwiaW5kZXhPZiIsIl9jb21waWxlIiwidmFsaWQiLCJldmVyeSIsInBhaXIiLCJzZXJpYWxpemVNZXNzYWdlIiwiZ2V0RXN0aW1hdGVkRmVlIiwiY29ubmVjdGlvbiIsImdldEZlZUZvck1lc3NhZ2UiLCJzZXRTaWduZXJzIiwic2VlbiIsIlNldCIsInVuaXF1ZVNpZ25lcnMiLCJzaWduZXIiLCJfcGFydGlhbFNpZ24iLCJwYXJ0aWFsU2lnbiIsIl9hZGRTaWduYXR1cmUiLCJhZGRTaWduYXR1cmUiLCJzaWdwYWlyIiwidmVyaWZ5U2lnbmF0dXJlcyIsInJlcXVpcmVBbGxTaWduYXR1cmVzIiwic2lnbmF0dXJlRXJyb3JzIiwiX2dldE1lc3NhZ2VTaWduZWRuZXNzRXJyb3JzIiwiZXJyb3JzIiwibWlzc2luZyIsImludmFsaWQiLCJjb25maWciLCJzaWdFcnJvcnMiLCJlcnJvck1lc3NhZ2UiLCJwIiwiam9pbiIsIl9zZXJpYWxpemUiLCJzaWduYXR1cmVDb3VudCIsInRyYW5zYWN0aW9uTGVuZ3RoIiwid2lyZVRyYW5zYWN0aW9uIiwia2V5T2JqIiwicG9wdWxhdGUiLCJzaWdQdWJrZXlQYWlyIiwic29tZSIsIlRyYW5zYWN0aW9uTWVzc2FnZSIsImRlY29tcGlsZSIsImNvbXBpbGVkSXgiLCJjb21waWxlVG9MZWdhY3lNZXNzYWdlIiwiY29tcGlsZVRvVjBNZXNzYWdlIiwiVmVyc2lvbmVkVHJhbnNhY3Rpb24iLCJkZWZhdWx0U2lnbmF0dXJlcyIsImVuY29kZWRTaWduYXR1cmVzTGVuZ3RoIiwidHJhbnNhY3Rpb25MYXlvdXQiLCJzZXJpYWxpemVkVHJhbnNhY3Rpb24iLCJzZXJpYWxpemVkVHJhbnNhY3Rpb25MZW5ndGgiLCJzaWduYXR1cmVzTGVuZ3RoIiwibWVzc2FnZURhdGEiLCJzaWduZXJQdWJrZXlzIiwic2lnbmVySW5kZXgiLCJOVU1fVElDS1NfUEVSX1NFQ09ORCIsIkRFRkFVTFRfVElDS1NfUEVSX1NMT1QiLCJOVU1fU0xPVFNfUEVSX1NFQ09ORCIsIk1TX1BFUl9TTE9UIiwiU1lTVkFSX0NMT0NLX1BVQktFWSIsIlNZU1ZBUl9FUE9DSF9TQ0hFRFVMRV9QVUJLRVkiLCJTWVNWQVJfSU5TVFJVQ1RJT05TX1BVQktFWSIsIlNZU1ZBUl9SRUNFTlRfQkxPQ0tIQVNIRVNfUFVCS0VZIiwiU1lTVkFSX1JFTlRfUFVCS0VZIiwiU1lTVkFSX1JFV0FSRFNfUFVCS0VZIiwiU1lTVkFSX1NMT1RfSEFTSEVTX1BVQktFWSIsIlNZU1ZBUl9TTE9UX0hJU1RPUllfUFVCS0VZIiwiU1lTVkFSX1NUQUtFX0hJU1RPUllfUFVCS0VZIiwiU2VuZFRyYW5zYWN0aW9uRXJyb3IiLCJhY3Rpb24iLCJ0cmFuc2FjdGlvbk1lc3NhZ2UiLCJsb2dzIiwibWF5YmVMb2dzT3V0cHV0IiwiZ3VpZGVUZXh0IiwiYSIsInRyYW5zYWN0aW9uTG9ncyIsInRyYW5zYWN0aW9uRXJyb3IiLCJjYWNoZWRMb2dzIiwiZ2V0TG9ncyIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiZ2V0VHJhbnNhY3Rpb24iLCJ0aGVuIiwidHgiLCJsb2dNZXNzYWdlcyIsImNhdGNoIiwiU29sYW5hSlNPTlJQQ0Vycm9yQ29kZSIsIkpTT05fUlBDX1NFUlZFUl9FUlJPUl9CTE9DS19DTEVBTkVEX1VQIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX1NFTkRfVFJBTlNBQ1RJT05fUFJFRkxJR0hUX0ZBSUxVUkUiLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fU0lHTkFUVVJFX1ZFUklGSUNBVElPTl9GQUlMVVJFIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX0JMT0NLX05PVF9BVkFJTEFCTEUiLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfTk9ERV9VTkhFQUxUSFkiLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fUFJFQ09NUElMRV9WRVJJRklDQVRJT05fRkFJTFVSRSIsIkpTT05fUlBDX1NFUlZFUl9FUlJPUl9TTE9UX1NLSVBQRUQiLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfTk9fU05BUFNIT1QiLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfTE9OR19URVJNX1NUT1JBR0VfU0xPVF9TS0lQUEVEIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX0tFWV9FWENMVURFRF9GUk9NX1NFQ09OREFSWV9JTkRFWCIsIkpTT05fUlBDX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9ISVNUT1JZX05PVF9BVkFJTEFCTEUiLCJKU09OX1JQQ19TQ0FOX0VSUk9SIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX1NJR05BVFVSRV9MRU5fTUlTTUFUQ0giLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfQkxPQ0tfU1RBVFVTX05PVF9BVkFJTEFCTEVfWUVUIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX1VOU1VQUE9SVEVEX1RSQU5TQUNUSU9OX1ZFUlNJT04iLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfTUlOX0NPTlRFWFRfU0xPVF9OT1RfUkVBQ0hFRCIsIlNvbGFuYUpTT05SUENFcnJvciIsImNvZGUiLCJjdXN0b21NZXNzYWdlIiwibmFtZSIsInNlbmRBbmRDb25maXJtVHJhbnNhY3Rpb24iLCJzZW5kT3B0aW9ucyIsInNraXBQcmVmbGlnaHQiLCJwcmVmbGlnaHRDb21taXRtZW50IiwiY29tbWl0bWVudCIsIm1heFJldHJpZXMiLCJzZW5kVHJhbnNhY3Rpb24iLCJzdGF0dXMiLCJjb25maXJtVHJhbnNhY3Rpb24iLCJhYm9ydFNpZ25hbCIsIm5vbmNlQWNjb3VudFB1YmtleSIsIm5vbmNlVmFsdWUiLCJzbGVlcCIsIm1zIiwic2V0VGltZW91dCIsImVuY29kZURhdGEiLCJhbGxvY0xlbmd0aCIsImxheW91dEZpZWxkcyIsImRlY29kZURhdGEkMSIsIkZlZUNhbGN1bGF0b3JMYXlvdXQiLCJudTY0IiwiTm9uY2VBY2NvdW50TGF5b3V0IiwiTk9OQ0VfQUNDT1VOVF9MRU5HVEgiLCJOb25jZUFjY291bnQiLCJhdXRob3JpemVkUHVia2V5IiwiZmVlQ2FsY3VsYXRvciIsImZyb21BY2NvdW50RGF0YSIsIm5vbmNlQWNjb3VudCIsInU2NCIsImJpZ0ludExheW91dCIsImNvZGVjIiwic3JjIiwiYmlnSW50IiwiU3lzdGVtSW5zdHJ1Y3Rpb24iLCJkZWNvZGVJbnN0cnVjdGlvblR5cGUiLCJjaGVja1Byb2dyYW1JZCIsImluc3RydWN0aW9uVHlwZUxheW91dCIsInR5cGVJbmRleCIsIml4VHlwZSIsIlNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTIiwiZGVjb2RlQ3JlYXRlQWNjb3VudCIsImNoZWNrS2V5TGVuZ3RoIiwibGFtcG9ydHMiLCJzcGFjZSIsIkNyZWF0ZSIsImZyb21QdWJrZXkiLCJuZXdBY2NvdW50UHVia2V5IiwiZGVjb2RlVHJhbnNmZXIiLCJUcmFuc2ZlciIsInRvUHVia2V5IiwiZGVjb2RlVHJhbnNmZXJXaXRoU2VlZCIsIlRyYW5zZmVyV2l0aFNlZWQiLCJiYXNlUHVia2V5IiwiZGVjb2RlQWxsb2NhdGUiLCJBbGxvY2F0ZSIsImFjY291bnRQdWJrZXkiLCJkZWNvZGVBbGxvY2F0ZVdpdGhTZWVkIiwiYmFzZSIsIkFsbG9jYXRlV2l0aFNlZWQiLCJkZWNvZGVBc3NpZ24iLCJBc3NpZ24iLCJkZWNvZGVBc3NpZ25XaXRoU2VlZCIsIkFzc2lnbldpdGhTZWVkIiwiZGVjb2RlQ3JlYXRlV2l0aFNlZWQiLCJDcmVhdGVXaXRoU2VlZCIsImRlY29kZU5vbmNlSW5pdGlhbGl6ZSIsIkluaXRpYWxpemVOb25jZUFjY291bnQiLCJub25jZVB1YmtleSIsImRlY29kZU5vbmNlQWR2YW5jZSIsIkFkdmFuY2VOb25jZUFjY291bnQiLCJkZWNvZGVOb25jZVdpdGhkcmF3IiwiV2l0aGRyYXdOb25jZUFjY291bnQiLCJkZWNvZGVOb25jZUF1dGhvcml6ZSIsIkF1dGhvcml6ZU5vbmNlQWNjb3VudCIsIm5ld0F1dGhvcml6ZWRQdWJrZXkiLCJTeXN0ZW1Qcm9ncmFtIiwiZXhwZWN0ZWRMZW5ndGgiLCJmcmVlemUiLCJVcGdyYWRlTm9uY2VBY2NvdW50IiwiY3JlYXRlQWNjb3VudCIsInBhcmFtcyIsInRyYW5zZmVyIiwiQmlnSW50IiwiY3JlYXRlQWNjb3VudFdpdGhTZWVkIiwiY3JlYXRlTm9uY2VBY2NvdW50IiwiaW5pdFBhcmFtcyIsIm5vbmNlSW5pdGlhbGl6ZSIsImluc3RydWN0aW9uRGF0YSIsIm5vbmNlQWR2YW5jZSIsIm5vbmNlV2l0aGRyYXciLCJub25jZUF1dGhvcml6ZSIsImFsbG9jYXRlIiwiQ0hVTktfU0laRSIsIkxvYWRlciIsImdldE1pbk51bVNpZ25hdHVyZXMiLCJNYXRoIiwiY2VpbCIsImNodW5rU2l6ZSIsImxvYWQiLCJwcm9ncmFtIiwiYmFsYW5jZU5lZWRlZCIsImdldE1pbmltdW1CYWxhbmNlRm9yUmVudEV4ZW1wdGlvbiIsInByb2dyYW1JbmZvIiwiZ2V0QWNjb3VudEluZm8iLCJleGVjdXRhYmxlIiwiZXJyb3IiLCJvd25lciIsImRhdGFMYXlvdXQiLCJ0cmFuc2FjdGlvbnMiLCJieXRlc0xlbmd0aCIsImJ5dGVzTGVuZ3RoUGFkZGluZyIsIl9ycGNFbmRwb2ludCIsIlJFUVVFU1RTX1BFUl9TRUNPTkQiLCJhbGwiLCJkZXBsb3lDb21taXRtZW50IiwiZmluYWxpemVTaWduYXR1cmUiLCJjb250ZXh0IiwiY3VycmVudFNsb3QiLCJnZXRTbG90Iiwic2xvdCIsInJvdW5kIiwiQlBGX0xPQURFUl9QUk9HUkFNX0lEIiwiQnBmTG9hZGVyIiwiZWxmIiwibG9hZGVyUHJvZ3JhbUlkIiwiZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMiLCJfX2VzTW9kdWxlIiwiYWdlbnRrZWVwYWxpdmUiLCJleHBvcnRzIiwiaGFzUmVxdWlyZWRNcyIsInJlcXVpcmVNcyIsInMiLCJtIiwiaCIsImQiLCJ3IiwidmFsIiwicGFyc2UiLCJpc0Zpbml0ZSIsImxvbmciLCJmbXRMb25nIiwiZm10U2hvcnQiLCJTdHJpbmciLCJtYXRjaCIsImV4ZWMiLCJuIiwicGFyc2VGbG9hdCIsInRvTG93ZXJDYXNlIiwibXNBYnMiLCJhYnMiLCJwbHVyYWwiLCJpc1BsdXJhbCIsImh1bWFuaXplTXMiLCJoYXNSZXF1aXJlZEh1bWFuaXplTXMiLCJyZXF1aXJlSHVtYW5pemVNcyIsInV0aWwiLCJ0IiwiciIsImZvcm1hdCIsInN0YWNrIiwiY29uc3RhbnRzIiwiaGFzUmVxdWlyZWRDb25zdGFudHMiLCJyZXF1aXJlQ29uc3RhbnRzIiwiQ1VSUkVOVF9JRCIsIkNSRUFURV9JRCIsIklOSVRfU09DS0VUIiwiQ1JFQVRFX0hUVFBTX0NPTk5FQ1RJT04iLCJTT0NLRVRfQ1JFQVRFRF9USU1FIiwiU09DS0VUX05BTUUiLCJTT0NLRVRfUkVRVUVTVF9DT1VOVCIsIlNPQ0tFVF9SRVFVRVNUX0ZJTklTSEVEX0NPVU5UIiwiYWdlbnQiLCJoYXNSZXF1aXJlZEFnZW50IiwicmVxdWlyZUFnZW50IiwiT3JpZ2luYWxBZ2VudCIsImRlYnVnIiwiZGVidWdsb2ciLCJkZWZhdWx0VGltZW91dExpc3RlbmVyQ291bnQiLCJtYWpvclZlcnNpb24iLCJwYXJzZUludCIsInByb2Nlc3MiLCJzcGxpdCIsInN1YnN0cmluZyIsImRlcHJlY2F0ZSIsImxvZyIsImtlZXBBbGl2ZSIsImZyZWVTb2NrZXRUaW1lb3V0Iiwia2VlcEFsaXZlVGltZW91dCIsImZyZWVTb2NrZXRLZWVwQWxpdmVUaW1lb3V0IiwidGltZW91dCIsIm1heCIsInNvY2tldEFjdGl2ZVRUTCIsImNyZWF0ZVNvY2tldENvdW50IiwiY3JlYXRlU29ja2V0Q291bnRMYXN0Q2hlY2siLCJjcmVhdGVTb2NrZXRFcnJvckNvdW50IiwiY3JlYXRlU29ja2V0RXJyb3JDb3VudExhc3RDaGVjayIsImNsb3NlU29ja2V0Q291bnQiLCJjbG9zZVNvY2tldENvdW50TGFzdENoZWNrIiwiZXJyb3JTb2NrZXRDb3VudCIsImVycm9yU29ja2V0Q291bnRMYXN0Q2hlY2siLCJyZXF1ZXN0Q291bnQiLCJyZXF1ZXN0Q291bnRMYXN0Q2hlY2siLCJ0aW1lb3V0U29ja2V0Q291bnQiLCJ0aW1lb3V0U29ja2V0Q291bnRMYXN0Q2hlY2siLCJvbiIsInNvY2tldCIsImNhbGNTb2NrZXRUaW1lb3V0IiwiYWxpdmVUaW1lIiwiRGF0ZSIsIm5vdyIsImRpZmYiLCJjdXN0b21GcmVlU29ja2V0VGltZW91dCIsImtlZXBTb2NrZXRBbGl2ZSIsInJlc3VsdCIsImN1c3RvbVRpbWVvdXQiLCJyZXVzZVNvY2tldCIsInJlcSIsInJldXNlZFNvY2tldCIsImFnZW50VGltZW91dCIsImdldFNvY2tldFRpbWVvdXQiLCJpZCIsIk51bWJlciIsIk1BWF9TQUZFX0lOVEVHRVIiLCJzZXROb0RlbGF5IiwiX2FnZW50S2V5IiwiaW5zdGFsbExpc3RlbmVycyIsImNyZWF0ZUNvbm5lY3Rpb24iLCJvbmNyZWF0ZSIsImNhbGxlZCIsIm9uTmV3Q3JlYXRlIiwibmV3U29ja2V0Iiwic3RhdHVzQ2hhbmdlZCIsImNoYW5nZWQiLCJnZXRDdXJyZW50U3RhdHVzIiwiZnJlZVNvY2tldHMiLCJpbnNwZWN0Iiwic29ja2V0cyIsInJlcXVlc3RzIiwiX2lkbGVUaW1lb3V0Iiwib25GcmVlIiwiX2h0dHBNZXNzYWdlIiwiZ2V0TmFtZSIsIm9uQ2xvc2UiLCJpc0Vycm9yIiwib25UaW1lb3V0IiwibGlzdGVuZXJDb3VudCIsImxpc3RlbmVycyIsInJlcVRpbWVvdXRMaXN0ZW5lckNvdW50IiwiZW5hYmxlZCIsImYiLCJkZXN0cm95IiwicmVtb3ZlU29ja2V0Iiwib25FcnJvciIsInJlbW92ZUxpc3RlbmVyIiwiZW1pdCIsIm9uUmVtb3ZlIiwib2JqIiwicmVzIiwiaHR0cHNfYWdlbnQiLCJoYXNSZXF1aXJlZEh0dHBzX2FnZW50IiwicmVxdWlyZUh0dHBzX2FnZW50IiwiT3JpZ2luYWxIdHRwc0FnZW50IiwiSHR0cEFnZW50IiwiSHR0cHNBZ2VudCIsImRlZmF1bHRQb3J0IiwicHJvdG9jb2wiLCJtYXhDYWNoZWRTZXNzaW9ucyIsIl9zZXNzaW9uQ2FjaGUiLCJsaXN0IiwibWV0aG9kIiwiaGFzUmVxdWlyZWRBZ2VudGtlZXBhbGl2ZSIsInJlcXVpcmVBZ2VudGtlZXBhbGl2ZSIsImFnZW50a2VlcGFsaXZlRXhwb3J0cyIsIkh0dHBLZWVwQWxpdmVBZ2VudCIsImZhc3RTdGFibGVTdHJpbmdpZnkkMSIsImhhc1JlcXVpcmVkRmFzdFN0YWJsZVN0cmluZ2lmeSIsInJlcXVpcmVGYXN0U3RhYmxlU3RyaW5naWZ5Iiwib2JqVG9TdHJpbmciLCJvYmpLZXlzIiwiaXNBcnJheVByb3AiLCJwcm9wVmFsIiwidG9TdHIiLCJyZXR1cm5WYWwiLCJmYXN0U3RhYmxlU3RyaW5naWZ5RXhwb3J0cyIsImZhc3RTdGFibGVTdHJpbmdpZnkiLCJNSU5JTVVNX1NMT1RfUEVSX0VQT0NIIiwidHJhaWxpbmdaZXJvcyIsIm5leHRQb3dlck9mVHdvIiwiRXBvY2hTY2hlZHVsZSIsInNsb3RzUGVyRXBvY2giLCJsZWFkZXJTY2hlZHVsZVNsb3RPZmZzZXQiLCJ3YXJtdXAiLCJmaXJzdE5vcm1hbEVwb2NoIiwiZmlyc3ROb3JtYWxTbG90IiwiZ2V0RXBvY2giLCJnZXRFcG9jaEFuZFNsb3RJbmRleCIsImVwb2NoIiwiZXBvY2hMZW4iLCJnZXRTbG90c0luRXBvY2giLCJzbG90SW5kZXgiLCJub3JtYWxTbG90SW5kZXgiLCJub3JtYWxFcG9jaEluZGV4IiwiZmxvb3IiLCJnZXRGaXJzdFNsb3RJbkVwb2NoIiwicG93IiwiZ2V0TGFzdFNsb3RJbkVwb2NoIiwiZmV0Y2hJbXBsIiwiZ2xvYmFsVGhpcyIsImZldGNoIiwiaW5wdXQiLCJpbml0IiwicHJvY2Vzc2VkSW5wdXQiLCJScGNXZWJTb2NrZXRDbGllbnQiLCJnZW5lcmF0ZV9yZXF1ZXN0X2lkIiwid2ViU29ja2V0RmFjdG9yeSIsInVybCIsInJwYyIsImF1dG9jb25uZWN0IiwibWF4X3JlY29ubmVjdHMiLCJyZWNvbm5lY3QiLCJyZWNvbm5lY3RfaW50ZXJ2YWwiLCJ1bmRlcmx5aW5nU29ja2V0IiwicmVhZHlTdGF0ZSIsIm5vdGlmeSIsImRlY29kZURhdGEiLCJMT09LVVBfVEFCTEVfTUVUQV9TSVpFIiwiQWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudCIsImlzQWN0aXZlIiwiVTY0X01BWCIsImRlYWN0aXZhdGlvblNsb3QiLCJhY2NvdW50RGF0YSIsIkxvb2t1cFRhYmxlTWV0YUxheW91dCIsInNlcmlhbGl6ZWRBZGRyZXNzZXNMZW4iLCJudW1TZXJpYWxpemVkQWRkcmVzc2VzIiwibGFzdEV4dGVuZGVkU2xvdCIsImxhc3RFeHRlbmRlZFNsb3RTdGFydEluZGV4IiwibGFzdEV4dGVuZGVkU3RhcnRJbmRleCIsImF1dGhvcml0eSIsIlVSTF9SRSIsIm1ha2VXZWJzb2NrZXRVcmwiLCJlbmRwb2ludCIsIm1hdGNoZXMiLCJob3N0aXNoIiwicG9ydFdpdGhDb2xvbiIsInJlc3QiLCJzdGFydHNXaXRoIiwic3RhcnRQb3J0Iiwid2Vic29ja2V0UG9ydCIsIlB1YmxpY0tleUZyb21TdHJpbmciLCJSYXdBY2NvdW50RGF0YVJlc3VsdCIsIkJ1ZmZlckZyb21SYXdBY2NvdW50RGF0YSIsIkJMT0NLSEFTSF9DQUNIRV9USU1FT1VUX01TIiwiYXNzZXJ0RW5kcG9pbnRVcmwiLCJwdXRhdGl2ZVVybCIsInRlc3QiLCJleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWciLCJjb21taXRtZW50T3JDb25maWciLCJzcGVjaWZpZWRDb21taXRtZW50Iiwic3BlY2lmaWVkQ29uZmlnIiwiYXBwbHlEZWZhdWx0TWVtY21wRW5jb2RpbmdUb0ZpbHRlcnMiLCJmaWx0ZXJzIiwibWVtY21wIiwiZW5jb2RpbmciLCJjcmVhdGVScGNSZXN1bHQiLCJqc29ucnBjIiwiVW5rbm93blJwY1Jlc3VsdCIsImpzb25ScGNSZXN1bHQiLCJzY2hlbWEiLCJqc29uUnBjUmVzdWx0QW5kQ29udGV4dCIsIm5vdGlmaWNhdGlvblJlc3VsdEFuZENvbnRleHQiLCJ2ZXJzaW9uZWRNZXNzYWdlRnJvbVJlc3BvbnNlIiwicmVzcG9uc2UiLCJHZXRJbmZsYXRpb25Hb3Zlcm5vclJlc3VsdCIsImZvdW5kYXRpb24iLCJmb3VuZGF0aW9uVGVybSIsImluaXRpYWwiLCJ0YXBlciIsInRlcm1pbmFsIiwiR2V0SW5mbGF0aW9uUmV3YXJkUmVzdWx0IiwiZWZmZWN0aXZlU2xvdCIsImFtb3VudCIsInBvc3RCYWxhbmNlIiwiY29tbWlzc2lvbiIsIkdldFJlY2VudFByaW9yaXRpemF0aW9uRmVlc1Jlc3VsdCIsInByaW9yaXRpemF0aW9uRmVlIiwiR2V0SW5mbGF0aW9uUmF0ZVJlc3VsdCIsInRvdGFsIiwidmFsaWRhdG9yIiwiR2V0RXBvY2hJbmZvUmVzdWx0Iiwic2xvdHNJbkVwb2NoIiwiYWJzb2x1dGVTbG90IiwiYmxvY2tIZWlnaHQiLCJ0cmFuc2FjdGlvbkNvdW50IiwiR2V0RXBvY2hTY2hlZHVsZVJlc3VsdCIsIkdldExlYWRlclNjaGVkdWxlUmVzdWx0IiwiVHJhbnNhY3Rpb25FcnJvclJlc3VsdCIsIlNpZ25hdHVyZVN0YXR1c1Jlc3VsdCIsIlNpZ25hdHVyZVJlY2VpdmVkUmVzdWx0IiwiVmVyc2lvblJlc3VsdCIsIlBhcnNlZEluc3RydWN0aW9uU3RydWN0IiwicGFyc2VkIiwiUGFydGlhbGx5RGVjb2RlZEluc3RydWN0aW9uU3RydWN0IiwiU2ltdWxhdGVkVHJhbnNhY3Rpb25SZXNwb25zZVN0cnVjdCIsInJlbnRFcG9jaCIsInVuaXRzQ29uc3VtZWQiLCJyZXR1cm5EYXRhIiwiaW5uZXJJbnN0cnVjdGlvbnMiLCJCbG9ja1Byb2R1Y3Rpb25SZXNwb25zZVN0cnVjdCIsImJ5SWRlbnRpdHkiLCJyYW5nZSIsImZpcnN0U2xvdCIsImxhc3RTbG90IiwiY3JlYXRlUnBjQ2xpZW50IiwiaHR0cEhlYWRlcnMiLCJjdXN0b21GZXRjaCIsImZldGNoTWlkZGxld2FyZSIsImRpc2FibGVSZXRyeU9uUmF0ZUxpbWl0IiwiaHR0cEFnZW50IiwiYWdlbnRPcHRpb25zIiwibWF4U29ja2V0cyIsImlzSHR0cHMiLCJmZXRjaFdpdGhNaWRkbGV3YXJlIiwiaW5mbyIsIm1vZGlmaWVkRmV0Y2hBcmdzIiwibW9kaWZpZWRJbmZvIiwibW9kaWZpZWRJbml0IiwiY2xpZW50QnJvd3NlciIsInJlcXVlc3QiLCJjYWxsYmFjayIsImJvZHkiLCJoZWFkZXJzIiwiQ09NTU9OX0hUVFBfSEVBREVSUyIsInRvb19tYW55X3JlcXVlc3RzX3JldHJpZXMiLCJ3YWl0VGltZSIsInN0YXR1c1RleHQiLCJ0ZXh0Iiwib2siLCJjcmVhdGVScGNSZXF1ZXN0IiwiY2xpZW50IiwiY3JlYXRlUnBjQmF0Y2hSZXF1ZXN0IiwiYmF0Y2giLCJtZXRob2ROYW1lIiwiR2V0SW5mbGF0aW9uR292ZXJub3JScGNSZXN1bHQiLCJHZXRJbmZsYXRpb25SYXRlUnBjUmVzdWx0IiwiR2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzUnBjUmVzdWx0IiwiR2V0RXBvY2hJbmZvUnBjUmVzdWx0IiwiR2V0RXBvY2hTY2hlZHVsZVJwY1Jlc3VsdCIsIkdldExlYWRlclNjaGVkdWxlUnBjUmVzdWx0IiwiU2xvdFJwY1Jlc3VsdCIsIkdldFN1cHBseVJwY1Jlc3VsdCIsImNpcmN1bGF0aW5nIiwibm9uQ2lyY3VsYXRpbmciLCJub25DaXJjdWxhdGluZ0FjY291bnRzIiwiVG9rZW5BbW91bnRSZXN1bHQiLCJ1aUFtb3VudCIsImRlY2ltYWxzIiwidWlBbW91bnRTdHJpbmciLCJHZXRUb2tlbkxhcmdlc3RBY2NvdW50c1Jlc3VsdCIsIkdldFRva2VuQWNjb3VudHNCeU93bmVyIiwiUGFyc2VkQWNjb3VudERhdGFSZXN1bHQiLCJHZXRQYXJzZWRUb2tlbkFjY291bnRzQnlPd25lciIsIkdldExhcmdlc3RBY2NvdW50c1JwY1Jlc3VsdCIsIkFjY291bnRJbmZvUmVzdWx0IiwiS2V5ZWRBY2NvdW50SW5mb1Jlc3VsdCIsIlBhcnNlZE9yUmF3QWNjb3VudERhdGEiLCJQYXJzZWRBY2NvdW50SW5mb1Jlc3VsdCIsIktleWVkUGFyc2VkQWNjb3VudEluZm9SZXN1bHQiLCJTdGFrZUFjdGl2YXRpb25SZXN1bHQiLCJhY3RpdmUiLCJpbmFjdGl2ZSIsIkdldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzMlJwY1Jlc3VsdCIsIm1lbW8iLCJibG9ja1RpbWUiLCJHZXRTaWduYXR1cmVzRm9yQWRkcmVzc1JwY1Jlc3VsdCIsIkFjY291bnROb3RpZmljYXRpb25SZXN1bHQiLCJzdWJzY3JpcHRpb24iLCJQcm9ncmFtQWNjb3VudEluZm9SZXN1bHQiLCJQcm9ncmFtQWNjb3VudE5vdGlmaWNhdGlvblJlc3VsdCIsIlNsb3RJbmZvUmVzdWx0IiwicGFyZW50Iiwicm9vdCIsIlNsb3ROb3RpZmljYXRpb25SZXN1bHQiLCJTbG90VXBkYXRlUmVzdWx0IiwidGltZXN0YW1wIiwic3RhdHMiLCJudW1UcmFuc2FjdGlvbkVudHJpZXMiLCJudW1TdWNjZXNzZnVsVHJhbnNhY3Rpb25zIiwibnVtRmFpbGVkVHJhbnNhY3Rpb25zIiwibWF4VHJhbnNhY3Rpb25zUGVyRW50cnkiLCJTbG90VXBkYXRlTm90aWZpY2F0aW9uUmVzdWx0IiwiU2lnbmF0dXJlTm90aWZpY2F0aW9uUmVzdWx0IiwiUm9vdE5vdGlmaWNhdGlvblJlc3VsdCIsIkNvbnRhY3RJbmZvUmVzdWx0IiwiZ29zc2lwIiwidHB1IiwiVm90ZUFjY291bnRJbmZvUmVzdWx0Iiwidm90ZVB1YmtleSIsIm5vZGVQdWJrZXkiLCJhY3RpdmF0ZWRTdGFrZSIsImVwb2NoVm90ZUFjY291bnQiLCJlcG9jaENyZWRpdHMiLCJsYXN0Vm90ZSIsInJvb3RTbG90IiwiR2V0Vm90ZUFjY291bnRzIiwiY3VycmVudCIsImRlbGlucXVlbnQiLCJDb25maXJtYXRpb25TdGF0dXMiLCJTaWduYXR1cmVTdGF0dXNSZXNwb25zZSIsImNvbmZpcm1hdGlvbnMiLCJjb25maXJtYXRpb25TdGF0dXMiLCJHZXRTaWduYXR1cmVTdGF0dXNlc1JwY1Jlc3VsdCIsIkdldE1pbmltdW1CYWxhbmNlRm9yUmVudEV4ZW1wdGlvblJwY1Jlc3VsdCIsIkFkZHJlc3NUYWJsZUxvb2t1cFN0cnVjdCIsIkNvbmZpcm1lZFRyYW5zYWN0aW9uUmVzdWx0IiwiQW5ub3RhdGVkQWNjb3VudEtleSIsInNvdXJjZSIsIkNvbmZpcm1lZFRyYW5zYWN0aW9uQWNjb3VudHNNb2RlUmVzdWx0IiwiUGFyc2VkSW5zdHJ1Y3Rpb25SZXN1bHQiLCJSYXdJbnN0cnVjdGlvblJlc3VsdCIsIkluc3RydWN0aW9uUmVzdWx0IiwiVW5rbm93bkluc3RydWN0aW9uUmVzdWx0IiwiUGFyc2VkT3JSYXdJbnN0cnVjdGlvbiIsIlBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9uUmVzdWx0IiwiVG9rZW5CYWxhbmNlUmVzdWx0IiwiYWNjb3VudEluZGV4IiwibWludCIsInVpVG9rZW5BbW91bnQiLCJMb2FkZWRBZGRyZXNzZXNSZXN1bHQiLCJDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQiLCJmZWUiLCJwcmVCYWxhbmNlcyIsInBvc3RCYWxhbmNlcyIsInByZVRva2VuQmFsYW5jZXMiLCJwb3N0VG9rZW5CYWxhbmNlcyIsImxvYWRlZEFkZHJlc3NlcyIsImNvbXB1dGVVbml0c0NvbnN1bWVkIiwiY29zdFVuaXRzIiwiUGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb25NZXRhUmVzdWx0IiwiVHJhbnNhY3Rpb25WZXJzaW9uU3RydWN0IiwiUmV3YXJkc1Jlc3VsdCIsInJld2FyZFR5cGUiLCJHZXRCbG9ja1JwY1Jlc3VsdCIsInByZXZpb3VzQmxvY2toYXNoIiwicGFyZW50U2xvdCIsInJld2FyZHMiLCJHZXROb25lTW9kZUJsb2NrUnBjUmVzdWx0IiwiR2V0QWNjb3VudHNNb2RlQmxvY2tScGNSZXN1bHQiLCJHZXRQYXJzZWRCbG9ja1JwY1Jlc3VsdCIsIkdldFBhcnNlZEFjY291bnRzTW9kZUJsb2NrUnBjUmVzdWx0IiwiR2V0UGFyc2VkTm9uZU1vZGVCbG9ja1JwY1Jlc3VsdCIsIkdldENvbmZpcm1lZEJsb2NrUnBjUmVzdWx0IiwiR2V0QmxvY2tTaWduYXR1cmVzUnBjUmVzdWx0IiwiR2V0VHJhbnNhY3Rpb25ScGNSZXN1bHQiLCJHZXRQYXJzZWRUcmFuc2FjdGlvblJwY1Jlc3VsdCIsIkdldExhdGVzdEJsb2NraGFzaFJwY1Jlc3VsdCIsIklzQmxvY2toYXNoVmFsaWRScGNSZXN1bHQiLCJQZXJmU2FtcGxlUmVzdWx0IiwibnVtVHJhbnNhY3Rpb25zIiwibnVtU2xvdHMiLCJzYW1wbGVQZXJpb2RTZWNzIiwiR2V0UmVjZW50UGVyZm9ybWFuY2VTYW1wbGVzUnBjUmVzdWx0IiwiR2V0RmVlQ2FsY3VsYXRvclJwY1Jlc3VsdCIsImxhbXBvcnRzUGVyU2lnbmF0dXJlIiwiUmVxdWVzdEFpcmRyb3BScGNSZXN1bHQiLCJTZW5kVHJhbnNhY3Rpb25ScGNSZXN1bHQiLCJMb2dzUmVzdWx0IiwiTG9nc05vdGlmaWNhdGlvblJlc3VsdCIsIkNvbm5lY3Rpb24iLCJfY29tbWl0bWVudE9yQ29uZmlnIiwiX2NvbW1pdG1lbnQiLCJfY29uZmlybVRyYW5zYWN0aW9uSW5pdGlhbFRpbWVvdXQiLCJfcnBjV3NFbmRwb2ludCIsIl9ycGNDbGllbnQiLCJfcnBjUmVxdWVzdCIsIl9ycGNCYXRjaFJlcXVlc3QiLCJfcnBjV2ViU29ja2V0IiwiX3JwY1dlYlNvY2tldENvbm5lY3RlZCIsIl9ycGNXZWJTb2NrZXRIZWFydGJlYXQiLCJfcnBjV2ViU29ja2V0SWRsZVRpbWVvdXQiLCJfcnBjV2ViU29ja2V0R2VuZXJhdGlvbiIsIl9kaXNhYmxlQmxvY2toYXNoQ2FjaGluZyIsIl9wb2xsaW5nQmxvY2toYXNoIiwiX2Jsb2NraGFzaEluZm8iLCJsYXRlc3RCbG9ja2hhc2giLCJsYXN0RmV0Y2giLCJ0cmFuc2FjdGlvblNpZ25hdHVyZXMiLCJzaW11bGF0ZWRTaWduYXR1cmVzIiwiX25leHRDbGllbnRTdWJzY3JpcHRpb25JZCIsIl9zdWJzY3JpcHRpb25EaXNwb3NlRnVuY3Rpb25zQnlDbGllbnRTdWJzY3JpcHRpb25JZCIsIl9zdWJzY3JpcHRpb25IYXNoQnlDbGllbnRTdWJzY3JpcHRpb25JZCIsIl9zdWJzY3JpcHRpb25TdGF0ZUNoYW5nZUNhbGxiYWNrc0J5SGFzaCIsIl9zdWJzY3JpcHRpb25DYWxsYmFja3NCeVNlcnZlclN1YnNjcmlwdGlvbklkIiwiX3N1YnNjcmlwdGlvbnNCeUhhc2giLCJfc3Vic2NyaXB0aW9uc0F1dG9EaXNwb3NlZEJ5UnBjIiwiZ2V0QmxvY2tIZWlnaHQiLCJyZXF1ZXN0UHJvbWlzZXMiLCJfYnVpbGRBcmdzIiwicmVxdWVzdEhhc2giLCJ1bnNhZmVSZXMiLCJ3c0VuZHBvaW50IiwiY29uZmlybVRyYW5zYWN0aW9uSW5pdGlhbFRpbWVvdXQiLCJJbmZpbml0eSIsIl93c09uT3BlbiIsIl93c09uRXJyb3IiLCJfd3NPbkNsb3NlIiwiX3dzT25BY2NvdW50Tm90aWZpY2F0aW9uIiwiX3dzT25Qcm9ncmFtQWNjb3VudE5vdGlmaWNhdGlvbiIsIl93c09uU2xvdE5vdGlmaWNhdGlvbiIsIl93c09uU2xvdFVwZGF0ZXNOb3RpZmljYXRpb24iLCJfd3NPblNpZ25hdHVyZU5vdGlmaWNhdGlvbiIsIl93c09uUm9vdE5vdGlmaWNhdGlvbiIsIl93c09uTG9nc05vdGlmaWNhdGlvbiIsInJwY0VuZHBvaW50IiwiZ2V0QmFsYW5jZUFuZENvbnRleHQiLCJnZXRCYWxhbmNlIiwiZSIsImdldEJsb2NrVGltZSIsImdldE1pbmltdW1MZWRnZXJTbG90IiwiZ2V0Rmlyc3RBdmFpbGFibGVCbG9jayIsImdldFN1cHBseSIsImNvbmZpZ0FyZyIsImdldFRva2VuU3VwcGx5IiwidG9rZW5NaW50QWRkcmVzcyIsImdldFRva2VuQWNjb3VudEJhbGFuY2UiLCJ0b2tlbkFkZHJlc3MiLCJnZXRUb2tlbkFjY291bnRzQnlPd25lciIsIm93bmVyQWRkcmVzcyIsIl9hcmdzIiwiZ2V0UGFyc2VkVG9rZW5BY2NvdW50c0J5T3duZXIiLCJnZXRMYXJnZXN0QWNjb3VudHMiLCJhcmciLCJnZXRUb2tlbkxhcmdlc3RBY2NvdW50cyIsIm1pbnRBZGRyZXNzIiwiZ2V0QWNjb3VudEluZm9BbmRDb250ZXh0IiwiZ2V0UGFyc2VkQWNjb3VudEluZm8iLCJnZXRNdWx0aXBsZVBhcnNlZEFjY291bnRzIiwicHVibGljS2V5cyIsInJhd0NvbmZpZyIsImdldE11bHRpcGxlQWNjb3VudHNJbmZvQW5kQ29udGV4dCIsImdldE11bHRpcGxlQWNjb3VudHNJbmZvIiwiZ2V0U3Rha2VBY3RpdmF0aW9uIiwiZ2V0UHJvZ3JhbUFjY291bnRzIiwiY29uZmlnT3JDb21taXRtZW50IiwiY29uZmlnV2l0aG91dEVuY29kaW5nIiwiYmFzZVNjaGVtYSIsIndpdGhDb250ZXh0IiwiZ2V0UGFyc2VkUHJvZ3JhbUFjY291bnRzIiwic3RyYXRlZ3kiLCJyYXdTaWduYXR1cmUiLCJhYm9ydGVkIiwicmVhc29uIiwiZGVjb2RlZFNpZ25hdHVyZSIsImNvbmZpcm1UcmFuc2FjdGlvblVzaW5nTGVnYWN5VGltZW91dFN0cmF0ZWd5IiwiY29uZmlybVRyYW5zYWN0aW9uVXNpbmdCbG9ja0hlaWdodEV4Y2VlZGFuY2VTdHJhdGVneSIsImNvbmZpcm1UcmFuc2FjdGlvblVzaW5nRHVyYWJsZU5vbmNlU3RyYXRlZ3kiLCJnZXRDYW5jZWxsYXRpb25Qcm9taXNlIiwic2lnbmFsIiwiYWRkRXZlbnRMaXN0ZW5lciIsImdldFRyYW5zYWN0aW9uQ29uZmlybWF0aW9uUHJvbWlzZSIsInNpZ25hdHVyZVN1YnNjcmlwdGlvbklkIiwiZGlzcG9zZVNpZ25hdHVyZVN1YnNjcmlwdGlvblN0YXRlQ2hhbmdlT2JzZXJ2ZXIiLCJkb25lIiwiY29uZmlybWF0aW9uUHJvbWlzZSIsIm9uU2lnbmF0dXJlIiwiX190eXBlIiwiUFJPQ0VTU0VEIiwic3Vic2NyaXB0aW9uU2V0dXBQcm9taXNlIiwicmVzb2x2ZVN1YnNjcmlwdGlvblNldHVwIiwiX29uU3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2UiLCJuZXh0U3RhdGUiLCJnZXRTaWduYXR1cmVTdGF0dXMiLCJhYm9ydENvbmZpcm1hdGlvbiIsInJlbW92ZVNpZ25hdHVyZUxpc3RlbmVyIiwiZXhwaXJ5UHJvbWlzZSIsImNoZWNrQmxvY2tIZWlnaHQiLCJfZSIsImN1cnJlbnRCbG9ja0hlaWdodCIsIkJMT0NLSEVJR0hUX0VYQ0VFREVEIiwiY2FuY2VsbGF0aW9uUHJvbWlzZSIsIm91dGNvbWUiLCJyYWNlIiwiY3VycmVudE5vbmNlVmFsdWUiLCJsYXN0Q2hlY2tlZFNsb3QiLCJnZXRDdXJyZW50Tm9uY2VWYWx1ZSIsImdldE5vbmNlQW5kQ29udGV4dCIsIk5PTkNFX0lOVkFMSUQiLCJzbG90SW5XaGljaE5vbmNlRGlkQWR2YW5jZSIsInNpZ25hdHVyZVN0YXR1cyIsImNvbW1pdG1lbnRGb3JTdGF0dXMiLCJ0aW1lb3V0SWQiLCJ0aW1lb3V0TXMiLCJUSU1FRF9PVVQiLCJjbGVhclRpbWVvdXQiLCJnZXRDbHVzdGVyTm9kZXMiLCJnZXRWb3RlQWNjb3VudHMiLCJnZXRTbG90TGVhZGVyIiwiZ2V0U2xvdExlYWRlcnMiLCJzdGFydFNsb3QiLCJsaW1pdCIsImdldFNpZ25hdHVyZVN0YXR1c2VzIiwiZ2V0VHJhbnNhY3Rpb25Db3VudCIsImdldFRvdGFsU3VwcGx5IiwiZXhjbHVkZU5vbkNpcmN1bGF0aW5nQWNjb3VudHNMaXN0IiwiZ2V0SW5mbGF0aW9uR292ZXJub3IiLCJnZXRJbmZsYXRpb25SZXdhcmQiLCJnZXRJbmZsYXRpb25SYXRlIiwiZ2V0RXBvY2hJbmZvIiwiZ2V0RXBvY2hTY2hlZHVsZSIsImVwb2NoU2NoZWR1bGUiLCJnZXRMZWFkZXJTY2hlZHVsZSIsImdldFJlY2VudEJsb2NraGFzaEFuZENvbnRleHQiLCJnZXRMYXRlc3RCbG9ja2hhc2hBbmRDb250ZXh0IiwiZ2V0UmVjZW50UGVyZm9ybWFuY2VTYW1wbGVzIiwiZ2V0RmVlQ2FsY3VsYXRvckZvckJsb2NraGFzaCIsIndpcmVNZXNzYWdlIiwiZ2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzIiwibG9ja2VkV3JpdGFibGVBY2NvdW50cyIsImdldFJlY2VudEJsb2NraGFzaCIsImdldExhdGVzdEJsb2NraGFzaCIsImlzQmxvY2toYXNoVmFsaWQiLCJnZXRWZXJzaW9uIiwiZ2V0R2VuZXNpc0hhc2giLCJnZXRCbG9jayIsIl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkIiwidHJhbnNhY3Rpb25EZXRhaWxzIiwiZ2V0UGFyc2VkQmxvY2siLCJnZXRCbG9ja1Byb2R1Y3Rpb24iLCJleHRyYSIsImMiLCJnZXRQYXJzZWRUcmFuc2FjdGlvbiIsImdldFBhcnNlZFRyYW5zYWN0aW9ucyIsImdldFRyYW5zYWN0aW9ucyIsImdldENvbmZpcm1lZEJsb2NrIiwiYmxvY2siLCJnZXRCbG9ja3MiLCJlbmRTbG90IiwiZ2V0QmxvY2tTaWduYXR1cmVzIiwiZ2V0Q29uZmlybWVkQmxvY2tTaWduYXR1cmVzIiwiZ2V0Q29uZmlybWVkVHJhbnNhY3Rpb24iLCJnZXRQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvbiIsImdldFBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9ucyIsImdldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzIiwiZmlyc3RBdmFpbGFibGVCbG9jayIsInVudGlsIiwiaGlnaGVzdENvbmZpcm1lZFJvb3QiLCJiZWZvcmUiLCJjb25maXJtZWRTaWduYXR1cmVJbmZvIiwiZ2V0Q29uZmlybWVkU2lnbmF0dXJlc0ZvckFkZHJlc3MyIiwiZ2V0U2lnbmF0dXJlc0ZvckFkZHJlc3MiLCJnZXRBZGRyZXNzTG9va3VwVGFibGUiLCJhY2NvdW50SW5mbyIsImdldE5vbmNlIiwicmVxdWVzdEFpcmRyb3AiLCJ0byIsIl9ibG9ja2hhc2hXaXRoRXhwaXJ5QmxvY2tIZWlnaHQiLCJkaXNhYmxlQ2FjaGUiLCJ0aW1lU2luY2VGZXRjaCIsImV4cGlyZWQiLCJfcG9sbE5ld0Jsb2NraGFzaCIsInN0YXJ0VGltZSIsImNhY2hlZExhdGVzdEJsb2NraGFzaCIsImNhY2hlZEJsb2NraGFzaCIsImdldFN0YWtlTWluaW11bURlbGVnYXRpb24iLCJzaW11bGF0ZVRyYW5zYWN0aW9uIiwidHJhbnNhY3Rpb25Pck1lc3NhZ2UiLCJjb25maWdPclNpZ25lcnMiLCJpbmNsdWRlQWNjb3VudHMiLCJ2ZXJzaW9uZWRUeCIsImVuY29kZWRUcmFuc2FjdGlvbiIsIm9yaWdpbmFsVHgiLCJzaWdWZXJpZnkiLCJ0cmFjZUluZGVudCIsImxvZ1RyYWNlIiwic2lnbmVyc09yT3B0aW9ucyIsInNlbmRSYXdUcmFuc2FjdGlvbiIsInJhd1RyYW5zYWN0aW9uIiwic2VuZEVuY29kZWRUcmFuc2FjdGlvbiIsInNldEludGVydmFsIiwiX3VwZGF0ZVN1YnNjcmlwdGlvbnMiLCJjbGVhckludGVydmFsIiwiaGFzaCIsIl9zZXRTdWJzY3JpcHRpb24iLCJuZXh0U3Vic2NyaXB0aW9uIiwicHJldlN0YXRlIiwic3RhdGVDaGFuZ2VDYWxsYmFja3MiLCJjYiIsImNsaWVudFN1YnNjcmlwdGlvbklkIiwiY2xvc2UiLCJjb25uZWN0IiwiYWN0aXZlV2ViU29ja2V0R2VuZXJhdGlvbiIsImlzQ3VycmVudENvbm5lY3Rpb25TdGlsbEFjdGl2ZSIsImNhbGxiYWNrcyIsInNlcnZlclN1YnNjcmlwdGlvbklkIiwidW5zdWJzY3JpYmVNZXRob2QiLCJfaGFuZGxlU2VydmVyTm90aWZpY2F0aW9uIiwiY2FsbGJhY2tBcmdzIiwibm90aWZpY2F0aW9uIiwiX21ha2VTdWJzY3JpcHRpb24iLCJzdWJzY3JpcHRpb25Db25maWciLCJleGlzdGluZ1N1YnNjcmlwdGlvbiIsIm9uQWNjb3VudENoYW5nZSIsInJlbW92ZUFjY291bnRDaGFuZ2VMaXN0ZW5lciIsIl91bnN1YnNjcmliZUNsaWVudFN1YnNjcmlwdGlvbiIsImFjY291bnRJZCIsIm9uUHJvZ3JhbUFjY291bnRDaGFuZ2UiLCJtYXliZUZpbHRlcnMiLCJyZW1vdmVQcm9ncmFtQWNjb3VudENoYW5nZUxpc3RlbmVyIiwib25Mb2dzIiwibWVudGlvbnMiLCJyZW1vdmVPbkxvZ3NMaXN0ZW5lciIsIm9uU2xvdENoYW5nZSIsInJlbW92ZVNsb3RDaGFuZ2VMaXN0ZW5lciIsIm9uU2xvdFVwZGF0ZSIsInJlbW92ZVNsb3RVcGRhdGVMaXN0ZW5lciIsInN1YnNjcmlwdGlvbk5hbWUiLCJkaXNwb3NlIiwib3ZlcnJpZGUiLCJfZXJyIiwib25TaWduYXR1cmVXaXRoT3B0aW9ucyIsIm9uUm9vdENoYW5nZSIsInJlbW92ZVJvb3RDaGFuZ2VMaXN0ZW5lciIsIktleXBhaXIiLCJrZXlwYWlyIiwiX2tleXBhaXIiLCJnZW5lcmF0ZSIsImZyb21TZWNyZXRLZXkiLCJza2lwVmFsaWRhdGlvbiIsImNvbXB1dGVkUHVibGljS2V5IiwiaWkiLCJmcm9tU2VlZCIsIkxPT0tVUF9UQUJMRV9JTlNUUlVDVElPTl9MQVlPVVRTIiwiQ3JlYXRlTG9va3VwVGFibGUiLCJGcmVlemVMb29rdXBUYWJsZSIsIkV4dGVuZExvb2t1cFRhYmxlIiwiRGVhY3RpdmF0ZUxvb2t1cFRhYmxlIiwiQ2xvc2VMb29rdXBUYWJsZSIsIkFkZHJlc3NMb29rdXBUYWJsZUluc3RydWN0aW9uIiwibGF5b3V0VHlwZSIsImRlY29kZUNyZWF0ZUxvb2t1cFRhYmxlIiwiY2hlY2tLZXlzTGVuZ3RoIiwicmVjZW50U2xvdCIsImRlY29kZUV4dGVuZExvb2t1cFRhYmxlIiwiZGVjb2RlQ2xvc2VMb29rdXBUYWJsZSIsInJlY2lwaWVudCIsImRlY29kZUZyZWV6ZUxvb2t1cFRhYmxlIiwiZGVjb2RlRGVhY3RpdmF0ZUxvb2t1cFRhYmxlIiwiQWRkcmVzc0xvb2t1cFRhYmxlUHJvZ3JhbSIsImNyZWF0ZUxvb2t1cFRhYmxlIiwibG9va3VwVGFibGVBZGRyZXNzIiwiYnVtcFNlZWQiLCJmcmVlemVMb29rdXBUYWJsZSIsImV4dGVuZExvb2t1cFRhYmxlIiwiYWRkciIsImRlYWN0aXZhdGVMb29rdXBUYWJsZSIsImNsb3NlTG9va3VwVGFibGUiLCJDb21wdXRlQnVkZ2V0SW5zdHJ1Y3Rpb24iLCJDT01QVVRFX0JVREdFVF9JTlNUUlVDVElPTl9MQVlPVVRTIiwiZGVjb2RlUmVxdWVzdFVuaXRzIiwidW5pdHMiLCJhZGRpdGlvbmFsRmVlIiwiUmVxdWVzdFVuaXRzIiwiZGVjb2RlUmVxdWVzdEhlYXBGcmFtZSIsIlJlcXVlc3RIZWFwRnJhbWUiLCJkZWNvZGVTZXRDb21wdXRlVW5pdExpbWl0IiwiU2V0Q29tcHV0ZVVuaXRMaW1pdCIsImRlY29kZVNldENvbXB1dGVVbml0UHJpY2UiLCJtaWNyb0xhbXBvcnRzIiwiU2V0Q29tcHV0ZVVuaXRQcmljZSIsIkNvbXB1dGVCdWRnZXRQcm9ncmFtIiwicmVxdWVzdFVuaXRzIiwicmVxdWVzdEhlYXBGcmFtZSIsInNldENvbXB1dGVVbml0TGltaXQiLCJzZXRDb21wdXRlVW5pdFByaWNlIiwiUFJJVkFURV9LRVlfQllURVMkMSIsIlBVQkxJQ19LRVlfQllURVMkMSIsIlNJR05BVFVSRV9CWVRFUyIsIkVEMjU1MTlfSU5TVFJVQ1RJT05fTEFZT1VUIiwidTE2IiwiRWQyNTUxOVByb2dyYW0iLCJjcmVhdGVJbnN0cnVjdGlvbldpdGhQdWJsaWNLZXkiLCJpbnN0cnVjdGlvbkluZGV4IiwicHVibGljS2V5T2Zmc2V0Iiwic2lnbmF0dXJlT2Zmc2V0IiwibWVzc2FnZURhdGFPZmZzZXQiLCJudW1TaWduYXR1cmVzIiwicGFkZGluZyIsInNpZ25hdHVyZUluc3RydWN0aW9uSW5kZXgiLCJwdWJsaWNLZXlJbnN0cnVjdGlvbkluZGV4IiwibWVzc2FnZURhdGFTaXplIiwibWVzc2FnZUluc3RydWN0aW9uSW5kZXgiLCJjcmVhdGVJbnN0cnVjdGlvbldpdGhQcml2YXRlS2V5IiwicHJpdmF0ZUtleSIsImVjZHNhU2lnbiIsIm1zZ0hhc2giLCJwcml2S2V5IiwidG9Db21wYWN0UmF3Qnl0ZXMiLCJyZWNvdmVyeSIsImlzVmFsaWRQcml2YXRlS2V5IiwicHVibGljS2V5Q3JlYXRlIiwiUFJJVkFURV9LRVlfQllURVMiLCJFVEhFUkVVTV9BRERSRVNTX0JZVEVTIiwiUFVCTElDX0tFWV9CWVRFUyIsIlNJR05BVFVSRV9PRkZTRVRTX1NFUklBTElaRURfU0laRSIsIlNFQ1AyNTZLMV9JTlNUUlVDVElPTl9MQVlPVVQiLCJTZWNwMjU2azFQcm9ncmFtIiwicHVibGljS2V5VG9FdGhBZGRyZXNzIiwicmVjb3ZlcnlJZCIsImNyZWF0ZUluc3RydWN0aW9uV2l0aEV0aEFkZHJlc3MiLCJldGhBZGRyZXNzIiwicmF3QWRkcmVzcyIsInN1YnN0ciIsImRhdGFTdGFydCIsImV0aEFkZHJlc3NPZmZzZXQiLCJldGhBZGRyZXNzSW5zdHJ1Y3Rpb25JbmRleCIsInBrZXkiLCJtZXNzYWdlSGFzaCIsIl9Mb2NrdXAiLCJTVEFLRV9DT05GSUdfSUQiLCJBdXRob3JpemVkIiwic3Rha2VyIiwid2l0aGRyYXdlciIsIkxvY2t1cCIsInVuaXhUaW1lc3RhbXAiLCJjdXN0b2RpYW4iLCJTdGFrZUluc3RydWN0aW9uIiwiU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUyIsImRlY29kZUluaXRpYWxpemUiLCJJbml0aWFsaXplIiwic3Rha2VQdWJrZXkiLCJkZWNvZGVEZWxlZ2F0ZSIsIkRlbGVnYXRlIiwiZGVjb2RlQXV0aG9yaXplIiwibmV3QXV0aG9yaXplZCIsInN0YWtlQXV0aG9yaXphdGlvblR5cGUiLCJBdXRob3JpemUiLCJvIiwiY3VzdG9kaWFuUHVia2V5IiwiZGVjb2RlQXV0aG9yaXplV2l0aFNlZWQiLCJhdXRob3JpdHlTZWVkIiwiYXV0aG9yaXR5T3duZXIiLCJBdXRob3JpemVXaXRoU2VlZCIsImF1dGhvcml0eUJhc2UiLCJkZWNvZGVTcGxpdCIsIlNwbGl0Iiwic3BsaXRTdGFrZVB1YmtleSIsImRlY29kZU1lcmdlIiwiTWVyZ2UiLCJzb3VyY2VTdGFrZVB1YktleSIsImRlY29kZVdpdGhkcmF3IiwiV2l0aGRyYXciLCJkZWNvZGVEZWFjdGl2YXRlIiwiRGVhY3RpdmF0ZSIsIlN0YWtlUHJvZ3JhbSIsIlN0YWtlQXV0aG9yaXphdGlvbkxheW91dCIsIlN0YWtlciIsIldpdGhkcmF3ZXIiLCJpbml0aWFsaXplIiwibWF5YmVMb2NrdXAiLCJkZWxlZ2F0ZSIsImF1dGhvcml6ZSIsImF1dGhvcml6ZVdpdGhTZWVkIiwic3BsaXRJbnN0cnVjdGlvbiIsInJlbnRFeGVtcHRSZXNlcnZlIiwic3BsaXRXaXRoU2VlZCIsIm1lcmdlIiwid2l0aGRyYXciLCJkZWFjdGl2YXRlIiwiVm90ZUluaXQiLCJhdXRob3JpemVkVm90ZXIiLCJhdXRob3JpemVkV2l0aGRyYXdlciIsIlZvdGVJbnN0cnVjdGlvbiIsIlZPVEVfSU5TVFJVQ1RJT05fTEFZT1VUUyIsImRlY29kZUluaXRpYWxpemVBY2NvdW50IiwiSW5pdGlhbGl6ZUFjY291bnQiLCJ2b3RlQXV0aG9yaXphdGlvblR5cGUiLCJjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleU93bmVyUHVia2V5IiwiY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlTZWVkIiwiY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlCYXNlUHVia2V5IiwiYXV0aG9yaXplZFdpdGhkcmF3ZXJQdWJrZXkiLCJWb3RlUHJvZ3JhbSIsIlVwZGF0ZVZhbGlkYXRvcklkZW50aXR5IiwiVm90ZUF1dGhvcml6YXRpb25MYXlvdXQiLCJWb3RlciIsImluaXRpYWxpemVBY2NvdW50Iiwic2FmZVdpdGhkcmF3IiwiY3VycmVudFZvdGVBY2NvdW50QmFsYW5jZSIsInJlbnRFeGVtcHRNaW5pbXVtIiwidXBkYXRlVmFsaWRhdG9ySWRlbnRpdHkiLCJWQUxJREFUT1JfSU5GT19LRVkiLCJJbmZvU3RyaW5nIiwid2Vic2l0ZSIsImRldGFpbHMiLCJpY29uVXJsIiwia2V5YmFzZVVzZXJuYW1lIiwiVmFsaWRhdG9ySW5mbyIsImZyb21Db25maWdEYXRhIiwiY29uZmlnS2V5Q291bnQiLCJjb25maWdLZXlzIiwicmF3SW5mbyIsIlZPVEVfUFJPR1JBTV9JRCIsIlZvdGVBY2NvdW50TGF5b3V0IiwiVm90ZUFjY291bnQiLCJ2b3RlcyIsImF1dGhvcml6ZWRWb3RlcnMiLCJwcmlvclZvdGVycyIsImxhc3RUaW1lc3RhbXAiLCJ2ZXJzaW9uT2Zmc2V0IiwidmEiLCJyb290U2xvdFZhbGlkIiwicGFyc2VBdXRob3JpemVkVm90ZXIiLCJnZXRQcmlvclZvdGVycyIsInBhcnNlUHJpb3JWb3RlcnMiLCJlcG9jaE9mTGFzdEF1dGhvcml6ZWRTd2l0Y2giLCJ0YXJnZXRFcG9jaCIsImlkeCIsImlzRW1wdHkiLCJodHRwIiwiZGV2bmV0IiwidGVzdG5ldCIsImh0dHBzIiwiY2x1c3RlckFwaVVybCIsImNsdXN0ZXIiLCJ0bHMiLCJzZW5kQW5kQ29uZmlybVJhd1RyYW5zYWN0aW9uIiwiY29uZmlybWF0aW9uU3RyYXRlZ3lPckNvbmZpcm1PcHRpb25zIiwibWF5YmVDb25maXJtT3B0aW9ucyIsImNvbmZpcm1hdGlvblN0cmF0ZWd5IiwiTEFNUE9SVFNfUEVSX1NPTCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@solana/web3.js/lib/index.esm.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@solana/codecs-core/dist/index.node.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@solana/codecs-core/dist/index.node.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addCodecSentinel: () => (/* binding */ addCodecSentinel),\n/* harmony export */   addCodecSizePrefix: () => (/* binding */ addCodecSizePrefix),\n/* harmony export */   addDecoderSentinel: () => (/* binding */ addDecoderSentinel),\n/* harmony export */   addDecoderSizePrefix: () => (/* binding */ addDecoderSizePrefix),\n/* harmony export */   addEncoderSentinel: () => (/* binding */ addEncoderSentinel),\n/* harmony export */   addEncoderSizePrefix: () => (/* binding */ addEncoderSizePrefix),\n/* harmony export */   assertByteArrayHasEnoughBytesForCodec: () => (/* binding */ assertByteArrayHasEnoughBytesForCodec),\n/* harmony export */   assertByteArrayIsNotEmptyForCodec: () => (/* binding */ assertByteArrayIsNotEmptyForCodec),\n/* harmony export */   assertByteArrayOffsetIsNotOutOfRange: () => (/* binding */ assertByteArrayOffsetIsNotOutOfRange),\n/* harmony export */   assertIsFixedSize: () => (/* binding */ assertIsFixedSize),\n/* harmony export */   assertIsVariableSize: () => (/* binding */ assertIsVariableSize),\n/* harmony export */   combineCodec: () => (/* binding */ combineCodec),\n/* harmony export */   containsBytes: () => (/* binding */ containsBytes),\n/* harmony export */   createCodec: () => (/* binding */ createCodec),\n/* harmony export */   createDecoder: () => (/* binding */ createDecoder),\n/* harmony export */   createEncoder: () => (/* binding */ createEncoder),\n/* harmony export */   fixBytes: () => (/* binding */ fixBytes),\n/* harmony export */   fixCodecSize: () => (/* binding */ fixCodecSize),\n/* harmony export */   fixDecoderSize: () => (/* binding */ fixDecoderSize),\n/* harmony export */   fixEncoderSize: () => (/* binding */ fixEncoderSize),\n/* harmony export */   getEncodedSize: () => (/* binding */ getEncodedSize),\n/* harmony export */   isFixedSize: () => (/* binding */ isFixedSize),\n/* harmony export */   isVariableSize: () => (/* binding */ isVariableSize),\n/* harmony export */   mergeBytes: () => (/* binding */ mergeBytes),\n/* harmony export */   offsetCodec: () => (/* binding */ offsetCodec),\n/* harmony export */   offsetDecoder: () => (/* binding */ offsetDecoder),\n/* harmony export */   offsetEncoder: () => (/* binding */ offsetEncoder),\n/* harmony export */   padBytes: () => (/* binding */ padBytes),\n/* harmony export */   padLeftCodec: () => (/* binding */ padLeftCodec),\n/* harmony export */   padLeftDecoder: () => (/* binding */ padLeftDecoder),\n/* harmony export */   padLeftEncoder: () => (/* binding */ padLeftEncoder),\n/* harmony export */   padRightCodec: () => (/* binding */ padRightCodec),\n/* harmony export */   padRightDecoder: () => (/* binding */ padRightDecoder),\n/* harmony export */   padRightEncoder: () => (/* binding */ padRightEncoder),\n/* harmony export */   resizeCodec: () => (/* binding */ resizeCodec),\n/* harmony export */   resizeDecoder: () => (/* binding */ resizeDecoder),\n/* harmony export */   resizeEncoder: () => (/* binding */ resizeEncoder),\n/* harmony export */   reverseCodec: () => (/* binding */ reverseCodec),\n/* harmony export */   reverseDecoder: () => (/* binding */ reverseDecoder),\n/* harmony export */   reverseEncoder: () => (/* binding */ reverseEncoder),\n/* harmony export */   transformCodec: () => (/* binding */ transformCodec),\n/* harmony export */   transformDecoder: () => (/* binding */ transformDecoder),\n/* harmony export */   transformEncoder: () => (/* binding */ transformEncoder)\n/* harmony export */ });\n/* harmony import */ var _solana_errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/errors */ \"(rsc)/./node_modules/@solana/errors/dist/index.node.mjs\");\n\n// src/add-codec-sentinel.ts\n// src/bytes.ts\nvar mergeBytes = (byteArrays)=>{\n    const nonEmptyByteArrays = byteArrays.filter((arr)=>arr.length);\n    if (nonEmptyByteArrays.length === 0) {\n        return byteArrays.length ? byteArrays[0] : new Uint8Array();\n    }\n    if (nonEmptyByteArrays.length === 1) {\n        return nonEmptyByteArrays[0];\n    }\n    const totalLength = nonEmptyByteArrays.reduce((total, arr)=>total + arr.length, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    nonEmptyByteArrays.forEach((arr)=>{\n        result.set(arr, offset);\n        offset += arr.length;\n    });\n    return result;\n};\nvar padBytes = (bytes, length)=>{\n    if (bytes.length >= length) return bytes;\n    const paddedBytes = new Uint8Array(length).fill(0);\n    paddedBytes.set(bytes);\n    return paddedBytes;\n};\nvar fixBytes = (bytes, length)=>padBytes(bytes.length <= length ? bytes : bytes.slice(0, length), length);\nfunction containsBytes(data, bytes, offset) {\n    const slice = offset === 0 && data.length === bytes.length ? data : data.slice(offset, offset + bytes.length);\n    if (slice.length !== bytes.length) return false;\n    return bytes.every((b, i)=>b === slice[i]);\n}\nfunction getEncodedSize(value, encoder) {\n    return \"fixedSize\" in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);\n}\nfunction createEncoder(encoder) {\n    return Object.freeze({\n        ...encoder,\n        encode: (value)=>{\n            const bytes = new Uint8Array(getEncodedSize(value, encoder));\n            encoder.write(value, bytes, 0);\n            return bytes;\n        }\n    });\n}\nfunction createDecoder(decoder) {\n    return Object.freeze({\n        ...decoder,\n        decode: (bytes, offset = 0)=>decoder.read(bytes, offset)[0]\n    });\n}\nfunction createCodec(codec) {\n    return Object.freeze({\n        ...codec,\n        decode: (bytes, offset = 0)=>codec.read(bytes, offset)[0],\n        encode: (value)=>{\n            const bytes = new Uint8Array(getEncodedSize(value, codec));\n            codec.write(value, bytes, 0);\n            return bytes;\n        }\n    });\n}\nfunction isFixedSize(codec) {\n    return \"fixedSize\" in codec && typeof codec.fixedSize === \"number\";\n}\nfunction assertIsFixedSize(codec) {\n    if (!isFixedSize(codec)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH);\n    }\n}\nfunction isVariableSize(codec) {\n    return !isFixedSize(codec);\n}\nfunction assertIsVariableSize(codec) {\n    if (!isVariableSize(codec)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH);\n    }\n}\nfunction combineCodec(encoder, decoder) {\n    if (isFixedSize(encoder) !== isFixedSize(decoder)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);\n    }\n    if (isFixedSize(encoder) && isFixedSize(decoder) && encoder.fixedSize !== decoder.fixedSize) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {\n            decoderFixedSize: decoder.fixedSize,\n            encoderFixedSize: encoder.fixedSize\n        });\n    }\n    if (!isFixedSize(encoder) && !isFixedSize(decoder) && encoder.maxSize !== decoder.maxSize) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {\n            decoderMaxSize: decoder.maxSize,\n            encoderMaxSize: encoder.maxSize\n        });\n    }\n    return {\n        ...decoder,\n        ...encoder,\n        decode: decoder.decode,\n        encode: encoder.encode,\n        read: decoder.read,\n        write: encoder.write\n    };\n}\n// src/add-codec-sentinel.ts\nfunction addEncoderSentinel(encoder, sentinel) {\n    const write = (value, bytes, offset)=>{\n        const encoderBytes = encoder.encode(value);\n        if (findSentinelIndex(encoderBytes, sentinel) >= 0) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL, {\n                encodedBytes: encoderBytes,\n                hexEncodedBytes: hexBytes(encoderBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel\n            });\n        }\n        bytes.set(encoderBytes, offset);\n        offset += encoderBytes.length;\n        bytes.set(sentinel, offset);\n        offset += sentinel.length;\n        return offset;\n    };\n    if (isFixedSize(encoder)) {\n        return createEncoder({\n            ...encoder,\n            fixedSize: encoder.fixedSize + sentinel.length,\n            write\n        });\n    }\n    return createEncoder({\n        ...encoder,\n        ...encoder.maxSize != null ? {\n            maxSize: encoder.maxSize + sentinel.length\n        } : {},\n        getSizeFromValue: (value)=>encoder.getSizeFromValue(value) + sentinel.length,\n        write\n    });\n}\nfunction addDecoderSentinel(decoder, sentinel) {\n    const read = (bytes, offset)=>{\n        const candidateBytes = offset === 0 ? bytes : bytes.slice(offset);\n        const sentinelIndex = findSentinelIndex(candidateBytes, sentinel);\n        if (sentinelIndex === -1) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES, {\n                decodedBytes: candidateBytes,\n                hexDecodedBytes: hexBytes(candidateBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel\n            });\n        }\n        const preSentinelBytes = candidateBytes.slice(0, sentinelIndex);\n        return [\n            decoder.decode(preSentinelBytes),\n            offset + preSentinelBytes.length + sentinel.length\n        ];\n    };\n    if (isFixedSize(decoder)) {\n        return createDecoder({\n            ...decoder,\n            fixedSize: decoder.fixedSize + sentinel.length,\n            read\n        });\n    }\n    return createDecoder({\n        ...decoder,\n        ...decoder.maxSize != null ? {\n            maxSize: decoder.maxSize + sentinel.length\n        } : {},\n        read\n    });\n}\nfunction addCodecSentinel(codec, sentinel) {\n    return combineCodec(addEncoderSentinel(codec, sentinel), addDecoderSentinel(codec, sentinel));\n}\nfunction findSentinelIndex(bytes, sentinel) {\n    return bytes.findIndex((byte, index, arr)=>{\n        if (sentinel.length === 1) return byte === sentinel[0];\n        return containsBytes(arr, sentinel, index);\n    });\n}\nfunction hexBytes(bytes) {\n    return bytes.reduce((str, byte)=>str + byte.toString(16).padStart(2, \"0\"), \"\");\n}\nfunction assertByteArrayIsNotEmptyForCodec(codecDescription, bytes, offset = 0) {\n    if (bytes.length - offset <= 0) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, {\n            codecDescription\n        });\n    }\n}\nfunction assertByteArrayHasEnoughBytesForCodec(codecDescription, expected, bytes, offset = 0) {\n    const bytesLength = bytes.length - offset;\n    if (bytesLength < expected) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {\n            bytesLength,\n            codecDescription,\n            expected\n        });\n    }\n}\nfunction assertByteArrayOffsetIsNotOutOfRange(codecDescription, offset, bytesLength) {\n    if (offset < 0 || offset > bytesLength) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, {\n            bytesLength,\n            codecDescription,\n            offset\n        });\n    }\n}\n// src/add-codec-size-prefix.ts\nfunction addEncoderSizePrefix(encoder, prefix) {\n    const write = (value, bytes, offset)=>{\n        const encoderBytes = encoder.encode(value);\n        offset = prefix.write(encoderBytes.length, bytes, offset);\n        bytes.set(encoderBytes, offset);\n        return offset + encoderBytes.length;\n    };\n    if (isFixedSize(prefix) && isFixedSize(encoder)) {\n        return createEncoder({\n            ...encoder,\n            fixedSize: prefix.fixedSize + encoder.fixedSize,\n            write\n        });\n    }\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;\n    const encoderMaxSize = isFixedSize(encoder) ? encoder.fixedSize : encoder.maxSize ?? null;\n    const maxSize = prefixMaxSize !== null && encoderMaxSize !== null ? prefixMaxSize + encoderMaxSize : null;\n    return createEncoder({\n        ...encoder,\n        ...maxSize !== null ? {\n            maxSize\n        } : {},\n        getSizeFromValue: (value)=>{\n            const encoderSize = getEncodedSize(value, encoder);\n            return getEncodedSize(encoderSize, prefix) + encoderSize;\n        },\n        write\n    });\n}\nfunction addDecoderSizePrefix(decoder, prefix) {\n    const read = (bytes, offset)=>{\n        const [bigintSize, decoderOffset] = prefix.read(bytes, offset);\n        const size = Number(bigintSize);\n        offset = decoderOffset;\n        if (offset > 0 || bytes.length > size) {\n            bytes = bytes.slice(offset, offset + size);\n        }\n        assertByteArrayHasEnoughBytesForCodec(\"addDecoderSizePrefix\", size, bytes);\n        return [\n            decoder.decode(bytes),\n            offset + size\n        ];\n    };\n    if (isFixedSize(prefix) && isFixedSize(decoder)) {\n        return createDecoder({\n            ...decoder,\n            fixedSize: prefix.fixedSize + decoder.fixedSize,\n            read\n        });\n    }\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;\n    const decoderMaxSize = isFixedSize(decoder) ? decoder.fixedSize : decoder.maxSize ?? null;\n    const maxSize = prefixMaxSize !== null && decoderMaxSize !== null ? prefixMaxSize + decoderMaxSize : null;\n    return createDecoder({\n        ...decoder,\n        ...maxSize !== null ? {\n            maxSize\n        } : {},\n        read\n    });\n}\nfunction addCodecSizePrefix(codec, prefix) {\n    return combineCodec(addEncoderSizePrefix(codec, prefix), addDecoderSizePrefix(codec, prefix));\n}\n// src/fix-codec-size.ts\nfunction fixEncoderSize(encoder, fixedBytes) {\n    return createEncoder({\n        fixedSize: fixedBytes,\n        write: (value, bytes, offset)=>{\n            const variableByteArray = encoder.encode(value);\n            const fixedByteArray = variableByteArray.length > fixedBytes ? variableByteArray.slice(0, fixedBytes) : variableByteArray;\n            bytes.set(fixedByteArray, offset);\n            return offset + fixedBytes;\n        }\n    });\n}\nfunction fixDecoderSize(decoder, fixedBytes) {\n    return createDecoder({\n        fixedSize: fixedBytes,\n        read: (bytes, offset)=>{\n            assertByteArrayHasEnoughBytesForCodec(\"fixCodecSize\", fixedBytes, bytes, offset);\n            if (offset > 0 || bytes.length > fixedBytes) {\n                bytes = bytes.slice(offset, offset + fixedBytes);\n            }\n            if (isFixedSize(decoder)) {\n                bytes = fixBytes(bytes, decoder.fixedSize);\n            }\n            const [value] = decoder.read(bytes, 0);\n            return [\n                value,\n                offset + fixedBytes\n            ];\n        }\n    });\n}\nfunction fixCodecSize(codec, fixedBytes) {\n    return combineCodec(fixEncoderSize(codec, fixedBytes), fixDecoderSize(codec, fixedBytes));\n}\n// src/offset-codec.ts\nfunction offsetEncoder(encoder, config) {\n    return createEncoder({\n        ...encoder,\n        write: (value, bytes, preOffset)=>{\n            const wrapBytes = (offset)=>modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({\n                bytes,\n                preOffset,\n                wrapBytes\n            }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange(\"offsetEncoder\", newPreOffset, bytes.length);\n            const postOffset = encoder.write(value, bytes, newPreOffset);\n            const newPostOffset = config.postOffset ? config.postOffset({\n                bytes,\n                newPreOffset,\n                postOffset,\n                preOffset,\n                wrapBytes\n            }) : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange(\"offsetEncoder\", newPostOffset, bytes.length);\n            return newPostOffset;\n        }\n    });\n}\nfunction offsetDecoder(decoder, config) {\n    return createDecoder({\n        ...decoder,\n        read: (bytes, preOffset)=>{\n            const wrapBytes = (offset)=>modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({\n                bytes,\n                preOffset,\n                wrapBytes\n            }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange(\"offsetDecoder\", newPreOffset, bytes.length);\n            const [value, postOffset] = decoder.read(bytes, newPreOffset);\n            const newPostOffset = config.postOffset ? config.postOffset({\n                bytes,\n                newPreOffset,\n                postOffset,\n                preOffset,\n                wrapBytes\n            }) : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange(\"offsetDecoder\", newPostOffset, bytes.length);\n            return [\n                value,\n                newPostOffset\n            ];\n        }\n    });\n}\nfunction offsetCodec(codec, config) {\n    return combineCodec(offsetEncoder(codec, config), offsetDecoder(codec, config));\n}\nfunction modulo(dividend, divisor) {\n    if (divisor === 0) return 0;\n    return (dividend % divisor + divisor) % divisor;\n}\nfunction resizeEncoder(encoder, resize) {\n    if (isFixedSize(encoder)) {\n        const fixedSize = resize(encoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: \"resizeEncoder\"\n            });\n        }\n        return createEncoder({\n            ...encoder,\n            fixedSize\n        });\n    }\n    return createEncoder({\n        ...encoder,\n        getSizeFromValue: (value)=>{\n            const newSize = resize(encoder.getSizeFromValue(value));\n            if (newSize < 0) {\n                throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                    bytesLength: newSize,\n                    codecDescription: \"resizeEncoder\"\n                });\n            }\n            return newSize;\n        }\n    });\n}\nfunction resizeDecoder(decoder, resize) {\n    if (isFixedSize(decoder)) {\n        const fixedSize = resize(decoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: \"resizeDecoder\"\n            });\n        }\n        return createDecoder({\n            ...decoder,\n            fixedSize\n        });\n    }\n    return decoder;\n}\nfunction resizeCodec(codec, resize) {\n    return combineCodec(resizeEncoder(codec, resize), resizeDecoder(codec, resize));\n}\n// src/pad-codec.ts\nfunction padLeftEncoder(encoder, offset) {\n    return offsetEncoder(resizeEncoder(encoder, (size)=>size + offset), {\n        preOffset: ({ preOffset })=>preOffset + offset\n    });\n}\nfunction padRightEncoder(encoder, offset) {\n    return offsetEncoder(resizeEncoder(encoder, (size)=>size + offset), {\n        postOffset: ({ postOffset })=>postOffset + offset\n    });\n}\nfunction padLeftDecoder(decoder, offset) {\n    return offsetDecoder(resizeDecoder(decoder, (size)=>size + offset), {\n        preOffset: ({ preOffset })=>preOffset + offset\n    });\n}\nfunction padRightDecoder(decoder, offset) {\n    return offsetDecoder(resizeDecoder(decoder, (size)=>size + offset), {\n        postOffset: ({ postOffset })=>postOffset + offset\n    });\n}\nfunction padLeftCodec(codec, offset) {\n    return combineCodec(padLeftEncoder(codec, offset), padLeftDecoder(codec, offset));\n}\nfunction padRightCodec(codec, offset) {\n    return combineCodec(padRightEncoder(codec, offset), padRightDecoder(codec, offset));\n}\n// src/reverse-codec.ts\nfunction copySourceToTargetInReverse(source, target_WILL_MUTATE, sourceOffset, sourceLength, targetOffset = 0) {\n    while(sourceOffset < --sourceLength){\n        const leftValue = source[sourceOffset];\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceLength];\n        target_WILL_MUTATE[sourceLength + targetOffset] = leftValue;\n        sourceOffset++;\n    }\n    if (sourceOffset === sourceLength) {\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceOffset];\n    }\n}\nfunction reverseEncoder(encoder) {\n    assertIsFixedSize(encoder);\n    return createEncoder({\n        ...encoder,\n        write: (value, bytes, offset)=>{\n            const newOffset = encoder.write(value, bytes, offset);\n            copySourceToTargetInReverse(bytes, bytes, offset, offset + encoder.fixedSize);\n            return newOffset;\n        }\n    });\n}\nfunction reverseDecoder(decoder) {\n    assertIsFixedSize(decoder);\n    return createDecoder({\n        ...decoder,\n        read: (bytes, offset)=>{\n            const reversedBytes = bytes.slice();\n            copySourceToTargetInReverse(bytes, reversedBytes, offset, offset + decoder.fixedSize);\n            return decoder.read(reversedBytes, offset);\n        }\n    });\n}\nfunction reverseCodec(codec) {\n    return combineCodec(reverseEncoder(codec), reverseDecoder(codec));\n}\n// src/transform-codec.ts\nfunction transformEncoder(encoder, unmap) {\n    return createEncoder({\n        ...isVariableSize(encoder) ? {\n            ...encoder,\n            getSizeFromValue: (value)=>encoder.getSizeFromValue(unmap(value))\n        } : encoder,\n        write: (value, bytes, offset)=>encoder.write(unmap(value), bytes, offset)\n    });\n}\nfunction transformDecoder(decoder, map) {\n    return createDecoder({\n        ...decoder,\n        read: (bytes, offset)=>{\n            const [value, newOffset] = decoder.read(bytes, offset);\n            return [\n                map(value, bytes, offset),\n                newOffset\n            ];\n        }\n    });\n}\nfunction transformCodec(codec, unmap, map) {\n    return createCodec({\n        ...transformEncoder(codec, unmap),\n        read: map ? transformDecoder(codec, map).read : codec.read\n    });\n}\n //# sourceMappingURL=index.node.mjs.map\n //# sourceMappingURL=index.node.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS9jb2RlY3MtY29yZS9kaXN0L2luZGV4Lm5vZGUubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTBuQjtBQUUxbkIsNEJBQTRCO0FBRTVCLGVBQWU7QUFDZixJQUFJWSxhQUFhLENBQUNDO0lBQ2hCLE1BQU1DLHFCQUFxQkQsV0FBV0UsTUFBTSxDQUFDLENBQUNDLE1BQVFBLElBQUlDLE1BQU07SUFDaEUsSUFBSUgsbUJBQW1CRyxNQUFNLEtBQUssR0FBRztRQUNuQyxPQUFPSixXQUFXSSxNQUFNLEdBQUdKLFVBQVUsQ0FBQyxFQUFFLEdBQUcsSUFBSUs7SUFDakQ7SUFDQSxJQUFJSixtQkFBbUJHLE1BQU0sS0FBSyxHQUFHO1FBQ25DLE9BQU9ILGtCQUFrQixDQUFDLEVBQUU7SUFDOUI7SUFDQSxNQUFNSyxjQUFjTCxtQkFBbUJNLE1BQU0sQ0FBQyxDQUFDQyxPQUFPTCxNQUFRSyxRQUFRTCxJQUFJQyxNQUFNLEVBQUU7SUFDbEYsTUFBTUssU0FBUyxJQUFJSixXQUFXQztJQUM5QixJQUFJSSxTQUFTO0lBQ2JULG1CQUFtQlUsT0FBTyxDQUFDLENBQUNSO1FBQzFCTSxPQUFPRyxHQUFHLENBQUNULEtBQUtPO1FBQ2hCQSxVQUFVUCxJQUFJQyxNQUFNO0lBQ3RCO0lBQ0EsT0FBT0s7QUFDVDtBQUNBLElBQUlJLFdBQVcsQ0FBQ0MsT0FBT1Y7SUFDckIsSUFBSVUsTUFBTVYsTUFBTSxJQUFJQSxRQUFRLE9BQU9VO0lBQ25DLE1BQU1DLGNBQWMsSUFBSVYsV0FBV0QsUUFBUVksSUFBSSxDQUFDO0lBQ2hERCxZQUFZSCxHQUFHLENBQUNFO0lBQ2hCLE9BQU9DO0FBQ1Q7QUFDQSxJQUFJRSxXQUFXLENBQUNILE9BQU9WLFNBQVdTLFNBQVNDLE1BQU1WLE1BQU0sSUFBSUEsU0FBU1UsUUFBUUEsTUFBTUksS0FBSyxDQUFDLEdBQUdkLFNBQVNBO0FB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Z0csTUFBTXhHLFFBQVFYLE9BQU9KO0lBQ3RFO0FBQ0Y7QUFDQSxTQUFTd0gsaUJBQWlCL0YsT0FBTyxFQUFFZ0csR0FBRztJQUNwQyxPQUFPakcsY0FBYztRQUNuQixHQUFHQyxPQUFPO1FBQ1ZFLE1BQU0sQ0FBQ3ZCLE9BQU9KO1lBQ1osTUFBTSxDQUFDZSxPQUFPbUcsVUFBVSxHQUFHekYsUUFBUUUsSUFBSSxDQUFDdkIsT0FBT0o7WUFDL0MsT0FBTztnQkFBQ3lILElBQUkxRyxPQUFPWCxPQUFPSjtnQkFBU2tIO2FBQVU7UUFDL0M7SUFDRjtBQUNGO0FBQ0EsU0FBU1EsZUFBZTdGLEtBQUssRUFBRTBGLEtBQUssRUFBRUUsR0FBRztJQUN2QyxPQUFPN0YsWUFBWTtRQUNqQixHQUFHMEYsaUJBQWlCekYsT0FBTzBGLE1BQU07UUFDakM1RixNQUFNOEYsTUFBTUQsaUJBQWlCM0YsT0FBTzRGLEtBQUs5RixJQUFJLEdBQUdFLE1BQU1GLElBQUk7SUFDNUQ7QUFDRjtBQUV1dkIsQ0FDdnZCLHVDQUF1QztDQUN2Qyx1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9za3ItZG9tYWluLXdhdGNoZXIvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS9jb2RlY3MtY29yZS9kaXN0L2luZGV4Lm5vZGUubWpzPzU0ZDgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU29sYW5hRXJyb3IsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9GSVhFRF9MRU5HVEgsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9WQVJJQUJMRV9MRU5HVEgsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfU0laRV9DT01QQVRJQklMSVRZX01JU01BVENILCBTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX0ZJWEVEX1NJWkVfTUlTTUFUQ0gsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfTUFYX1NJWkVfTUlTTUFUQ0gsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19DQU5OT1RfREVDT0RFX0VNUFRZX0JZVEVfQVJSQVksIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0JZVEVfTEVOR1RILCBTT0xBTkFfRVJST1JfX0NPREVDU19fT0ZGU0VUX09VVF9PRl9SQU5HRSwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1BPU0lUSVZFX0JZVEVfTEVOR1RILCBTT0xBTkFfRVJST1JfX0NPREVDU19fU0VOVElORUxfTUlTU0lOR19JTl9ERUNPREVEX0JZVEVTLCBTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFRF9CWVRFU19NVVNUX05PVF9JTkNMVURFX1NFTlRJTkVMIH0gZnJvbSAnQHNvbGFuYS9lcnJvcnMnO1xuXG4vLyBzcmMvYWRkLWNvZGVjLXNlbnRpbmVsLnRzXG5cbi8vIHNyYy9ieXRlcy50c1xudmFyIG1lcmdlQnl0ZXMgPSAoYnl0ZUFycmF5cykgPT4ge1xuICBjb25zdCBub25FbXB0eUJ5dGVBcnJheXMgPSBieXRlQXJyYXlzLmZpbHRlcigoYXJyKSA9PiBhcnIubGVuZ3RoKTtcbiAgaWYgKG5vbkVtcHR5Qnl0ZUFycmF5cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gYnl0ZUFycmF5cy5sZW5ndGggPyBieXRlQXJyYXlzWzBdIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgfVxuICBpZiAobm9uRW1wdHlCeXRlQXJyYXlzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBub25FbXB0eUJ5dGVBcnJheXNbMF07XG4gIH1cbiAgY29uc3QgdG90YWxMZW5ndGggPSBub25FbXB0eUJ5dGVBcnJheXMucmVkdWNlKCh0b3RhbCwgYXJyKSA9PiB0b3RhbCArIGFyci5sZW5ndGgsIDApO1xuICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheSh0b3RhbExlbmd0aCk7XG4gIGxldCBvZmZzZXQgPSAwO1xuICBub25FbXB0eUJ5dGVBcnJheXMuZm9yRWFjaCgoYXJyKSA9PiB7XG4gICAgcmVzdWx0LnNldChhcnIsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IGFyci5sZW5ndGg7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBwYWRCeXRlcyA9IChieXRlcywgbGVuZ3RoKSA9PiB7XG4gIGlmIChieXRlcy5sZW5ndGggPj0gbGVuZ3RoKSByZXR1cm4gYnl0ZXM7XG4gIGNvbnN0IHBhZGRlZEJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKS5maWxsKDApO1xuICBwYWRkZWRCeXRlcy5zZXQoYnl0ZXMpO1xuICByZXR1cm4gcGFkZGVkQnl0ZXM7XG59O1xudmFyIGZpeEJ5dGVzID0gKGJ5dGVzLCBsZW5ndGgpID0+IHBhZEJ5dGVzKGJ5dGVzLmxlbmd0aCA8PSBsZW5ndGggPyBieXRlcyA6IGJ5dGVzLnNsaWNlKDAsIGxlbmd0aCksIGxlbmd0aCk7XG5mdW5jdGlvbiBjb250YWluc0J5dGVzKGRhdGEsIGJ5dGVzLCBvZmZzZXQpIHtcbiAgY29uc3Qgc2xpY2UgPSBvZmZzZXQgPT09IDAgJiYgZGF0YS5sZW5ndGggPT09IGJ5dGVzLmxlbmd0aCA/IGRhdGEgOiBkYXRhLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgYnl0ZXMubGVuZ3RoKTtcbiAgaWYgKHNsaWNlLmxlbmd0aCAhPT0gYnl0ZXMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBieXRlcy5ldmVyeSgoYiwgaSkgPT4gYiA9PT0gc2xpY2VbaV0pO1xufVxuZnVuY3Rpb24gZ2V0RW5jb2RlZFNpemUodmFsdWUsIGVuY29kZXIpIHtcbiAgcmV0dXJuIFwiZml4ZWRTaXplXCIgaW4gZW5jb2RlciA/IGVuY29kZXIuZml4ZWRTaXplIDogZW5jb2Rlci5nZXRTaXplRnJvbVZhbHVlKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVuY29kZXIoZW5jb2Rlcikge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgLi4uZW5jb2RlcixcbiAgICBlbmNvZGU6ICh2YWx1ZSkgPT4ge1xuICAgICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShnZXRFbmNvZGVkU2l6ZSh2YWx1ZSwgZW5jb2RlcikpO1xuICAgICAgZW5jb2Rlci53cml0ZSh2YWx1ZSwgYnl0ZXMsIDApO1xuICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVEZWNvZGVyKGRlY29kZXIpIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgIC4uLmRlY29kZXIsXG4gICAgZGVjb2RlOiAoYnl0ZXMsIG9mZnNldCA9IDApID0+IGRlY29kZXIucmVhZChieXRlcywgb2Zmc2V0KVswXVxuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvZGVjKGNvZGVjKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAuLi5jb2RlYyxcbiAgICBkZWNvZGU6IChieXRlcywgb2Zmc2V0ID0gMCkgPT4gY29kZWMucmVhZChieXRlcywgb2Zmc2V0KVswXSxcbiAgICBlbmNvZGU6ICh2YWx1ZSkgPT4ge1xuICAgICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShnZXRFbmNvZGVkU2l6ZSh2YWx1ZSwgY29kZWMpKTtcbiAgICAgIGNvZGVjLndyaXRlKHZhbHVlLCBieXRlcywgMCk7XG4gICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGlzRml4ZWRTaXplKGNvZGVjKSB7XG4gIHJldHVybiBcImZpeGVkU2l6ZVwiIGluIGNvZGVjICYmIHR5cGVvZiBjb2RlYy5maXhlZFNpemUgPT09IFwibnVtYmVyXCI7XG59XG5mdW5jdGlvbiBhc3NlcnRJc0ZpeGVkU2l6ZShjb2RlYykge1xuICBpZiAoIWlzRml4ZWRTaXplKGNvZGVjKSkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfRklYRURfTEVOR1RIKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNWYXJpYWJsZVNpemUoY29kZWMpIHtcbiAgcmV0dXJuICFpc0ZpeGVkU2l6ZShjb2RlYyk7XG59XG5mdW5jdGlvbiBhc3NlcnRJc1ZhcmlhYmxlU2l6ZShjb2RlYykge1xuICBpZiAoIWlzVmFyaWFibGVTaXplKGNvZGVjKSkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfVkFSSUFCTEVfTEVOR1RIKTtcbiAgfVxufVxuZnVuY3Rpb24gY29tYmluZUNvZGVjKGVuY29kZXIsIGRlY29kZXIpIHtcbiAgaWYgKGlzRml4ZWRTaXplKGVuY29kZXIpICE9PSBpc0ZpeGVkU2l6ZShkZWNvZGVyKSkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX1NJWkVfQ09NUEFUSUJJTElUWV9NSVNNQVRDSCk7XG4gIH1cbiAgaWYgKGlzRml4ZWRTaXplKGVuY29kZXIpICYmIGlzRml4ZWRTaXplKGRlY29kZXIpICYmIGVuY29kZXIuZml4ZWRTaXplICE9PSBkZWNvZGVyLmZpeGVkU2l6ZSkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX0ZJWEVEX1NJWkVfTUlTTUFUQ0gsIHtcbiAgICAgIGRlY29kZXJGaXhlZFNpemU6IGRlY29kZXIuZml4ZWRTaXplLFxuICAgICAgZW5jb2RlckZpeGVkU2l6ZTogZW5jb2Rlci5maXhlZFNpemVcbiAgICB9KTtcbiAgfVxuICBpZiAoIWlzRml4ZWRTaXplKGVuY29kZXIpICYmICFpc0ZpeGVkU2l6ZShkZWNvZGVyKSAmJiBlbmNvZGVyLm1heFNpemUgIT09IGRlY29kZXIubWF4U2l6ZSkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX01BWF9TSVpFX01JU01BVENILCB7XG4gICAgICBkZWNvZGVyTWF4U2l6ZTogZGVjb2Rlci5tYXhTaXplLFxuICAgICAgZW5jb2Rlck1heFNpemU6IGVuY29kZXIubWF4U2l6ZVxuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4uZGVjb2RlcixcbiAgICAuLi5lbmNvZGVyLFxuICAgIGRlY29kZTogZGVjb2Rlci5kZWNvZGUsXG4gICAgZW5jb2RlOiBlbmNvZGVyLmVuY29kZSxcbiAgICByZWFkOiBkZWNvZGVyLnJlYWQsXG4gICAgd3JpdGU6IGVuY29kZXIud3JpdGVcbiAgfTtcbn1cblxuLy8gc3JjL2FkZC1jb2RlYy1zZW50aW5lbC50c1xuZnVuY3Rpb24gYWRkRW5jb2RlclNlbnRpbmVsKGVuY29kZXIsIHNlbnRpbmVsKSB7XG4gIGNvbnN0IHdyaXRlID0gKHZhbHVlLCBieXRlcywgb2Zmc2V0KSA9PiB7XG4gICAgY29uc3QgZW5jb2RlckJ5dGVzID0gZW5jb2Rlci5lbmNvZGUodmFsdWUpO1xuICAgIGlmIChmaW5kU2VudGluZWxJbmRleChlbmNvZGVyQnl0ZXMsIHNlbnRpbmVsKSA+PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERURfQllURVNfTVVTVF9OT1RfSU5DTFVERV9TRU5USU5FTCwge1xuICAgICAgICBlbmNvZGVkQnl0ZXM6IGVuY29kZXJCeXRlcyxcbiAgICAgICAgaGV4RW5jb2RlZEJ5dGVzOiBoZXhCeXRlcyhlbmNvZGVyQnl0ZXMpLFxuICAgICAgICBoZXhTZW50aW5lbDogaGV4Qnl0ZXMoc2VudGluZWwpLFxuICAgICAgICBzZW50aW5lbFxuICAgICAgfSk7XG4gICAgfVxuICAgIGJ5dGVzLnNldChlbmNvZGVyQnl0ZXMsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IGVuY29kZXJCeXRlcy5sZW5ndGg7XG4gICAgYnl0ZXMuc2V0KHNlbnRpbmVsLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSBzZW50aW5lbC5sZW5ndGg7XG4gICAgcmV0dXJuIG9mZnNldDtcbiAgfTtcbiAgaWYgKGlzRml4ZWRTaXplKGVuY29kZXIpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVuY29kZXIoeyAuLi5lbmNvZGVyLCBmaXhlZFNpemU6IGVuY29kZXIuZml4ZWRTaXplICsgc2VudGluZWwubGVuZ3RoLCB3cml0ZSB9KTtcbiAgfVxuICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7XG4gICAgLi4uZW5jb2RlcixcbiAgICAuLi5lbmNvZGVyLm1heFNpemUgIT0gbnVsbCA/IHsgbWF4U2l6ZTogZW5jb2Rlci5tYXhTaXplICsgc2VudGluZWwubGVuZ3RoIH0gOiB7fSxcbiAgICBnZXRTaXplRnJvbVZhbHVlOiAodmFsdWUpID0+IGVuY29kZXIuZ2V0U2l6ZUZyb21WYWx1ZSh2YWx1ZSkgKyBzZW50aW5lbC5sZW5ndGgsXG4gICAgd3JpdGVcbiAgfSk7XG59XG5mdW5jdGlvbiBhZGREZWNvZGVyU2VudGluZWwoZGVjb2Rlciwgc2VudGluZWwpIHtcbiAgY29uc3QgcmVhZCA9IChieXRlcywgb2Zmc2V0KSA9PiB7XG4gICAgY29uc3QgY2FuZGlkYXRlQnl0ZXMgPSBvZmZzZXQgPT09IDAgPyBieXRlcyA6IGJ5dGVzLnNsaWNlKG9mZnNldCk7XG4gICAgY29uc3Qgc2VudGluZWxJbmRleCA9IGZpbmRTZW50aW5lbEluZGV4KGNhbmRpZGF0ZUJ5dGVzLCBzZW50aW5lbCk7XG4gICAgaWYgKHNlbnRpbmVsSW5kZXggPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX1NFTlRJTkVMX01JU1NJTkdfSU5fREVDT0RFRF9CWVRFUywge1xuICAgICAgICBkZWNvZGVkQnl0ZXM6IGNhbmRpZGF0ZUJ5dGVzLFxuICAgICAgICBoZXhEZWNvZGVkQnl0ZXM6IGhleEJ5dGVzKGNhbmRpZGF0ZUJ5dGVzKSxcbiAgICAgICAgaGV4U2VudGluZWw6IGhleEJ5dGVzKHNlbnRpbmVsKSxcbiAgICAgICAgc2VudGluZWxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBwcmVTZW50aW5lbEJ5dGVzID0gY2FuZGlkYXRlQnl0ZXMuc2xpY2UoMCwgc2VudGluZWxJbmRleCk7XG4gICAgcmV0dXJuIFtkZWNvZGVyLmRlY29kZShwcmVTZW50aW5lbEJ5dGVzKSwgb2Zmc2V0ICsgcHJlU2VudGluZWxCeXRlcy5sZW5ndGggKyBzZW50aW5lbC5sZW5ndGhdO1xuICB9O1xuICBpZiAoaXNGaXhlZFNpemUoZGVjb2RlcikpIHtcbiAgICByZXR1cm4gY3JlYXRlRGVjb2Rlcih7IC4uLmRlY29kZXIsIGZpeGVkU2l6ZTogZGVjb2Rlci5maXhlZFNpemUgKyBzZW50aW5lbC5sZW5ndGgsIHJlYWQgfSk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZURlY29kZXIoe1xuICAgIC4uLmRlY29kZXIsXG4gICAgLi4uZGVjb2Rlci5tYXhTaXplICE9IG51bGwgPyB7IG1heFNpemU6IGRlY29kZXIubWF4U2l6ZSArIHNlbnRpbmVsLmxlbmd0aCB9IDoge30sXG4gICAgcmVhZFxuICB9KTtcbn1cbmZ1bmN0aW9uIGFkZENvZGVjU2VudGluZWwoY29kZWMsIHNlbnRpbmVsKSB7XG4gIHJldHVybiBjb21iaW5lQ29kZWMoYWRkRW5jb2RlclNlbnRpbmVsKGNvZGVjLCBzZW50aW5lbCksIGFkZERlY29kZXJTZW50aW5lbChjb2RlYywgc2VudGluZWwpKTtcbn1cbmZ1bmN0aW9uIGZpbmRTZW50aW5lbEluZGV4KGJ5dGVzLCBzZW50aW5lbCkge1xuICByZXR1cm4gYnl0ZXMuZmluZEluZGV4KChieXRlLCBpbmRleCwgYXJyKSA9PiB7XG4gICAgaWYgKHNlbnRpbmVsLmxlbmd0aCA9PT0gMSkgcmV0dXJuIGJ5dGUgPT09IHNlbnRpbmVsWzBdO1xuICAgIHJldHVybiBjb250YWluc0J5dGVzKGFyciwgc2VudGluZWwsIGluZGV4KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBoZXhCeXRlcyhieXRlcykge1xuICByZXR1cm4gYnl0ZXMucmVkdWNlKChzdHIsIGJ5dGUpID0+IHN0ciArIGJ5dGUudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKSwgXCJcIik7XG59XG5mdW5jdGlvbiBhc3NlcnRCeXRlQXJyYXlJc05vdEVtcHR5Rm9yQ29kZWMoY29kZWNEZXNjcmlwdGlvbiwgYnl0ZXMsIG9mZnNldCA9IDApIHtcbiAgaWYgKGJ5dGVzLmxlbmd0aCAtIG9mZnNldCA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQ09ERUNTX19DQU5OT1RfREVDT0RFX0VNUFRZX0JZVEVfQVJSQVksIHtcbiAgICAgIGNvZGVjRGVzY3JpcHRpb25cbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0Qnl0ZUFycmF5SGFzRW5vdWdoQnl0ZXNGb3JDb2RlYyhjb2RlY0Rlc2NyaXB0aW9uLCBleHBlY3RlZCwgYnl0ZXMsIG9mZnNldCA9IDApIHtcbiAgY29uc3QgYnl0ZXNMZW5ndGggPSBieXRlcy5sZW5ndGggLSBvZmZzZXQ7XG4gIGlmIChieXRlc0xlbmd0aCA8IGV4cGVjdGVkKSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0JZVEVfTEVOR1RILCB7XG4gICAgICBieXRlc0xlbmd0aCxcbiAgICAgIGNvZGVjRGVzY3JpcHRpb24sXG4gICAgICBleHBlY3RlZFxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBhc3NlcnRCeXRlQXJyYXlPZmZzZXRJc05vdE91dE9mUmFuZ2UoY29kZWNEZXNjcmlwdGlvbiwgb2Zmc2V0LCBieXRlc0xlbmd0aCkge1xuICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgPiBieXRlc0xlbmd0aCkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fT0ZGU0VUX09VVF9PRl9SQU5HRSwge1xuICAgICAgYnl0ZXNMZW5ndGgsXG4gICAgICBjb2RlY0Rlc2NyaXB0aW9uLFxuICAgICAgb2Zmc2V0XG4gICAgfSk7XG4gIH1cbn1cblxuLy8gc3JjL2FkZC1jb2RlYy1zaXplLXByZWZpeC50c1xuZnVuY3Rpb24gYWRkRW5jb2RlclNpemVQcmVmaXgoZW5jb2RlciwgcHJlZml4KSB7XG4gIGNvbnN0IHdyaXRlID0gKHZhbHVlLCBieXRlcywgb2Zmc2V0KSA9PiB7XG4gICAgY29uc3QgZW5jb2RlckJ5dGVzID0gZW5jb2Rlci5lbmNvZGUodmFsdWUpO1xuICAgIG9mZnNldCA9IHByZWZpeC53cml0ZShlbmNvZGVyQnl0ZXMubGVuZ3RoLCBieXRlcywgb2Zmc2V0KTtcbiAgICBieXRlcy5zZXQoZW5jb2RlckJ5dGVzLCBvZmZzZXQpO1xuICAgIHJldHVybiBvZmZzZXQgKyBlbmNvZGVyQnl0ZXMubGVuZ3RoO1xuICB9O1xuICBpZiAoaXNGaXhlZFNpemUocHJlZml4KSAmJiBpc0ZpeGVkU2l6ZShlbmNvZGVyKSkge1xuICAgIHJldHVybiBjcmVhdGVFbmNvZGVyKHsgLi4uZW5jb2RlciwgZml4ZWRTaXplOiBwcmVmaXguZml4ZWRTaXplICsgZW5jb2Rlci5maXhlZFNpemUsIHdyaXRlIH0pO1xuICB9XG4gIGNvbnN0IHByZWZpeE1heFNpemUgPSBpc0ZpeGVkU2l6ZShwcmVmaXgpID8gcHJlZml4LmZpeGVkU2l6ZSA6IHByZWZpeC5tYXhTaXplID8/IG51bGw7XG4gIGNvbnN0IGVuY29kZXJNYXhTaXplID0gaXNGaXhlZFNpemUoZW5jb2RlcikgPyBlbmNvZGVyLmZpeGVkU2l6ZSA6IGVuY29kZXIubWF4U2l6ZSA/PyBudWxsO1xuICBjb25zdCBtYXhTaXplID0gcHJlZml4TWF4U2l6ZSAhPT0gbnVsbCAmJiBlbmNvZGVyTWF4U2l6ZSAhPT0gbnVsbCA/IHByZWZpeE1heFNpemUgKyBlbmNvZGVyTWF4U2l6ZSA6IG51bGw7XG4gIHJldHVybiBjcmVhdGVFbmNvZGVyKHtcbiAgICAuLi5lbmNvZGVyLFxuICAgIC4uLm1heFNpemUgIT09IG51bGwgPyB7IG1heFNpemUgfSA6IHt9LFxuICAgIGdldFNpemVGcm9tVmFsdWU6ICh2YWx1ZSkgPT4ge1xuICAgICAgY29uc3QgZW5jb2RlclNpemUgPSBnZXRFbmNvZGVkU2l6ZSh2YWx1ZSwgZW5jb2Rlcik7XG4gICAgICByZXR1cm4gZ2V0RW5jb2RlZFNpemUoZW5jb2RlclNpemUsIHByZWZpeCkgKyBlbmNvZGVyU2l6ZTtcbiAgICB9LFxuICAgIHdyaXRlXG4gIH0pO1xufVxuZnVuY3Rpb24gYWRkRGVjb2RlclNpemVQcmVmaXgoZGVjb2RlciwgcHJlZml4KSB7XG4gIGNvbnN0IHJlYWQgPSAoYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgIGNvbnN0IFtiaWdpbnRTaXplLCBkZWNvZGVyT2Zmc2V0XSA9IHByZWZpeC5yZWFkKGJ5dGVzLCBvZmZzZXQpO1xuICAgIGNvbnN0IHNpemUgPSBOdW1iZXIoYmlnaW50U2l6ZSk7XG4gICAgb2Zmc2V0ID0gZGVjb2Rlck9mZnNldDtcbiAgICBpZiAob2Zmc2V0ID4gMCB8fCBieXRlcy5sZW5ndGggPiBzaXplKSB7XG4gICAgICBieXRlcyA9IGJ5dGVzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgc2l6ZSk7XG4gICAgfVxuICAgIGFzc2VydEJ5dGVBcnJheUhhc0Vub3VnaEJ5dGVzRm9yQ29kZWMoXCJhZGREZWNvZGVyU2l6ZVByZWZpeFwiLCBzaXplLCBieXRlcyk7XG4gICAgcmV0dXJuIFtkZWNvZGVyLmRlY29kZShieXRlcyksIG9mZnNldCArIHNpemVdO1xuICB9O1xuICBpZiAoaXNGaXhlZFNpemUocHJlZml4KSAmJiBpc0ZpeGVkU2l6ZShkZWNvZGVyKSkge1xuICAgIHJldHVybiBjcmVhdGVEZWNvZGVyKHsgLi4uZGVjb2RlciwgZml4ZWRTaXplOiBwcmVmaXguZml4ZWRTaXplICsgZGVjb2Rlci5maXhlZFNpemUsIHJlYWQgfSk7XG4gIH1cbiAgY29uc3QgcHJlZml4TWF4U2l6ZSA9IGlzRml4ZWRTaXplKHByZWZpeCkgPyBwcmVmaXguZml4ZWRTaXplIDogcHJlZml4Lm1heFNpemUgPz8gbnVsbDtcbiAgY29uc3QgZGVjb2Rlck1heFNpemUgPSBpc0ZpeGVkU2l6ZShkZWNvZGVyKSA/IGRlY29kZXIuZml4ZWRTaXplIDogZGVjb2Rlci5tYXhTaXplID8/IG51bGw7XG4gIGNvbnN0IG1heFNpemUgPSBwcmVmaXhNYXhTaXplICE9PSBudWxsICYmIGRlY29kZXJNYXhTaXplICE9PSBudWxsID8gcHJlZml4TWF4U2l6ZSArIGRlY29kZXJNYXhTaXplIDogbnVsbDtcbiAgcmV0dXJuIGNyZWF0ZURlY29kZXIoeyAuLi5kZWNvZGVyLCAuLi5tYXhTaXplICE9PSBudWxsID8geyBtYXhTaXplIH0gOiB7fSwgcmVhZCB9KTtcbn1cbmZ1bmN0aW9uIGFkZENvZGVjU2l6ZVByZWZpeChjb2RlYywgcHJlZml4KSB7XG4gIHJldHVybiBjb21iaW5lQ29kZWMoYWRkRW5jb2RlclNpemVQcmVmaXgoY29kZWMsIHByZWZpeCksIGFkZERlY29kZXJTaXplUHJlZml4KGNvZGVjLCBwcmVmaXgpKTtcbn1cblxuLy8gc3JjL2ZpeC1jb2RlYy1zaXplLnRzXG5mdW5jdGlvbiBmaXhFbmNvZGVyU2l6ZShlbmNvZGVyLCBmaXhlZEJ5dGVzKSB7XG4gIHJldHVybiBjcmVhdGVFbmNvZGVyKHtcbiAgICBmaXhlZFNpemU6IGZpeGVkQnl0ZXMsXG4gICAgd3JpdGU6ICh2YWx1ZSwgYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgICAgY29uc3QgdmFyaWFibGVCeXRlQXJyYXkgPSBlbmNvZGVyLmVuY29kZSh2YWx1ZSk7XG4gICAgICBjb25zdCBmaXhlZEJ5dGVBcnJheSA9IHZhcmlhYmxlQnl0ZUFycmF5Lmxlbmd0aCA+IGZpeGVkQnl0ZXMgPyB2YXJpYWJsZUJ5dGVBcnJheS5zbGljZSgwLCBmaXhlZEJ5dGVzKSA6IHZhcmlhYmxlQnl0ZUFycmF5O1xuICAgICAgYnl0ZXMuc2V0KGZpeGVkQnl0ZUFycmF5LCBvZmZzZXQpO1xuICAgICAgcmV0dXJuIG9mZnNldCArIGZpeGVkQnl0ZXM7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGZpeERlY29kZXJTaXplKGRlY29kZXIsIGZpeGVkQnl0ZXMpIHtcbiAgcmV0dXJuIGNyZWF0ZURlY29kZXIoe1xuICAgIGZpeGVkU2l6ZTogZml4ZWRCeXRlcyxcbiAgICByZWFkOiAoYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgICAgYXNzZXJ0Qnl0ZUFycmF5SGFzRW5vdWdoQnl0ZXNGb3JDb2RlYyhcImZpeENvZGVjU2l6ZVwiLCBmaXhlZEJ5dGVzLCBieXRlcywgb2Zmc2V0KTtcbiAgICAgIGlmIChvZmZzZXQgPiAwIHx8IGJ5dGVzLmxlbmd0aCA+IGZpeGVkQnl0ZXMpIHtcbiAgICAgICAgYnl0ZXMgPSBieXRlcy5zbGljZShvZmZzZXQsIG9mZnNldCArIGZpeGVkQnl0ZXMpO1xuICAgICAgfVxuICAgICAgaWYgKGlzRml4ZWRTaXplKGRlY29kZXIpKSB7XG4gICAgICAgIGJ5dGVzID0gZml4Qnl0ZXMoYnl0ZXMsIGRlY29kZXIuZml4ZWRTaXplKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IFt2YWx1ZV0gPSBkZWNvZGVyLnJlYWQoYnl0ZXMsIDApO1xuICAgICAgcmV0dXJuIFt2YWx1ZSwgb2Zmc2V0ICsgZml4ZWRCeXRlc107XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGZpeENvZGVjU2l6ZShjb2RlYywgZml4ZWRCeXRlcykge1xuICByZXR1cm4gY29tYmluZUNvZGVjKGZpeEVuY29kZXJTaXplKGNvZGVjLCBmaXhlZEJ5dGVzKSwgZml4RGVjb2RlclNpemUoY29kZWMsIGZpeGVkQnl0ZXMpKTtcbn1cblxuLy8gc3JjL29mZnNldC1jb2RlYy50c1xuZnVuY3Rpb24gb2Zmc2V0RW5jb2RlcihlbmNvZGVyLCBjb25maWcpIHtcbiAgcmV0dXJuIGNyZWF0ZUVuY29kZXIoe1xuICAgIC4uLmVuY29kZXIsXG4gICAgd3JpdGU6ICh2YWx1ZSwgYnl0ZXMsIHByZU9mZnNldCkgPT4ge1xuICAgICAgY29uc3Qgd3JhcEJ5dGVzID0gKG9mZnNldCkgPT4gbW9kdWxvKG9mZnNldCwgYnl0ZXMubGVuZ3RoKTtcbiAgICAgIGNvbnN0IG5ld1ByZU9mZnNldCA9IGNvbmZpZy5wcmVPZmZzZXQgPyBjb25maWcucHJlT2Zmc2V0KHsgYnl0ZXMsIHByZU9mZnNldCwgd3JhcEJ5dGVzIH0pIDogcHJlT2Zmc2V0O1xuICAgICAgYXNzZXJ0Qnl0ZUFycmF5T2Zmc2V0SXNOb3RPdXRPZlJhbmdlKFwib2Zmc2V0RW5jb2RlclwiLCBuZXdQcmVPZmZzZXQsIGJ5dGVzLmxlbmd0aCk7XG4gICAgICBjb25zdCBwb3N0T2Zmc2V0ID0gZW5jb2Rlci53cml0ZSh2YWx1ZSwgYnl0ZXMsIG5ld1ByZU9mZnNldCk7XG4gICAgICBjb25zdCBuZXdQb3N0T2Zmc2V0ID0gY29uZmlnLnBvc3RPZmZzZXQgPyBjb25maWcucG9zdE9mZnNldCh7IGJ5dGVzLCBuZXdQcmVPZmZzZXQsIHBvc3RPZmZzZXQsIHByZU9mZnNldCwgd3JhcEJ5dGVzIH0pIDogcG9zdE9mZnNldDtcbiAgICAgIGFzc2VydEJ5dGVBcnJheU9mZnNldElzTm90T3V0T2ZSYW5nZShcIm9mZnNldEVuY29kZXJcIiwgbmV3UG9zdE9mZnNldCwgYnl0ZXMubGVuZ3RoKTtcbiAgICAgIHJldHVybiBuZXdQb3N0T2Zmc2V0O1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBvZmZzZXREZWNvZGVyKGRlY29kZXIsIGNvbmZpZykge1xuICByZXR1cm4gY3JlYXRlRGVjb2Rlcih7XG4gICAgLi4uZGVjb2RlcixcbiAgICByZWFkOiAoYnl0ZXMsIHByZU9mZnNldCkgPT4ge1xuICAgICAgY29uc3Qgd3JhcEJ5dGVzID0gKG9mZnNldCkgPT4gbW9kdWxvKG9mZnNldCwgYnl0ZXMubGVuZ3RoKTtcbiAgICAgIGNvbnN0IG5ld1ByZU9mZnNldCA9IGNvbmZpZy5wcmVPZmZzZXQgPyBjb25maWcucHJlT2Zmc2V0KHsgYnl0ZXMsIHByZU9mZnNldCwgd3JhcEJ5dGVzIH0pIDogcHJlT2Zmc2V0O1xuICAgICAgYXNzZXJ0Qnl0ZUFycmF5T2Zmc2V0SXNOb3RPdXRPZlJhbmdlKFwib2Zmc2V0RGVjb2RlclwiLCBuZXdQcmVPZmZzZXQsIGJ5dGVzLmxlbmd0aCk7XG4gICAgICBjb25zdCBbdmFsdWUsIHBvc3RPZmZzZXRdID0gZGVjb2Rlci5yZWFkKGJ5dGVzLCBuZXdQcmVPZmZzZXQpO1xuICAgICAgY29uc3QgbmV3UG9zdE9mZnNldCA9IGNvbmZpZy5wb3N0T2Zmc2V0ID8gY29uZmlnLnBvc3RPZmZzZXQoeyBieXRlcywgbmV3UHJlT2Zmc2V0LCBwb3N0T2Zmc2V0LCBwcmVPZmZzZXQsIHdyYXBCeXRlcyB9KSA6IHBvc3RPZmZzZXQ7XG4gICAgICBhc3NlcnRCeXRlQXJyYXlPZmZzZXRJc05vdE91dE9mUmFuZ2UoXCJvZmZzZXREZWNvZGVyXCIsIG5ld1Bvc3RPZmZzZXQsIGJ5dGVzLmxlbmd0aCk7XG4gICAgICByZXR1cm4gW3ZhbHVlLCBuZXdQb3N0T2Zmc2V0XTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gb2Zmc2V0Q29kZWMoY29kZWMsIGNvbmZpZykge1xuICByZXR1cm4gY29tYmluZUNvZGVjKG9mZnNldEVuY29kZXIoY29kZWMsIGNvbmZpZyksIG9mZnNldERlY29kZXIoY29kZWMsIGNvbmZpZykpO1xufVxuZnVuY3Rpb24gbW9kdWxvKGRpdmlkZW5kLCBkaXZpc29yKSB7XG4gIGlmIChkaXZpc29yID09PSAwKSByZXR1cm4gMDtcbiAgcmV0dXJuIChkaXZpZGVuZCAlIGRpdmlzb3IgKyBkaXZpc29yKSAlIGRpdmlzb3I7XG59XG5mdW5jdGlvbiByZXNpemVFbmNvZGVyKGVuY29kZXIsIHJlc2l6ZSkge1xuICBpZiAoaXNGaXhlZFNpemUoZW5jb2RlcikpIHtcbiAgICBjb25zdCBmaXhlZFNpemUgPSByZXNpemUoZW5jb2Rlci5maXhlZFNpemUpO1xuICAgIGlmIChmaXhlZFNpemUgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1BPU0lUSVZFX0JZVEVfTEVOR1RILCB7XG4gICAgICAgIGJ5dGVzTGVuZ3RoOiBmaXhlZFNpemUsXG4gICAgICAgIGNvZGVjRGVzY3JpcHRpb246IFwicmVzaXplRW5jb2RlclwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUVuY29kZXIoeyAuLi5lbmNvZGVyLCBmaXhlZFNpemUgfSk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUVuY29kZXIoe1xuICAgIC4uLmVuY29kZXIsXG4gICAgZ2V0U2l6ZUZyb21WYWx1ZTogKHZhbHVlKSA9PiB7XG4gICAgICBjb25zdCBuZXdTaXplID0gcmVzaXplKGVuY29kZXIuZ2V0U2l6ZUZyb21WYWx1ZSh2YWx1ZSkpO1xuICAgICAgaWYgKG5ld1NpemUgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfUE9TSVRJVkVfQllURV9MRU5HVEgsIHtcbiAgICAgICAgICBieXRlc0xlbmd0aDogbmV3U2l6ZSxcbiAgICAgICAgICBjb2RlY0Rlc2NyaXB0aW9uOiBcInJlc2l6ZUVuY29kZXJcIlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdTaXplO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiByZXNpemVEZWNvZGVyKGRlY29kZXIsIHJlc2l6ZSkge1xuICBpZiAoaXNGaXhlZFNpemUoZGVjb2RlcikpIHtcbiAgICBjb25zdCBmaXhlZFNpemUgPSByZXNpemUoZGVjb2Rlci5maXhlZFNpemUpO1xuICAgIGlmIChmaXhlZFNpemUgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1BPU0lUSVZFX0JZVEVfTEVOR1RILCB7XG4gICAgICAgIGJ5dGVzTGVuZ3RoOiBmaXhlZFNpemUsXG4gICAgICAgIGNvZGVjRGVzY3JpcHRpb246IFwicmVzaXplRGVjb2RlclwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZURlY29kZXIoeyAuLi5kZWNvZGVyLCBmaXhlZFNpemUgfSk7XG4gIH1cbiAgcmV0dXJuIGRlY29kZXI7XG59XG5mdW5jdGlvbiByZXNpemVDb2RlYyhjb2RlYywgcmVzaXplKSB7XG4gIHJldHVybiBjb21iaW5lQ29kZWMocmVzaXplRW5jb2Rlcihjb2RlYywgcmVzaXplKSwgcmVzaXplRGVjb2Rlcihjb2RlYywgcmVzaXplKSk7XG59XG5cbi8vIHNyYy9wYWQtY29kZWMudHNcbmZ1bmN0aW9uIHBhZExlZnRFbmNvZGVyKGVuY29kZXIsIG9mZnNldCkge1xuICByZXR1cm4gb2Zmc2V0RW5jb2RlcihcbiAgICByZXNpemVFbmNvZGVyKGVuY29kZXIsIChzaXplKSA9PiBzaXplICsgb2Zmc2V0KSxcbiAgICB7IHByZU9mZnNldDogKHsgcHJlT2Zmc2V0IH0pID0+IHByZU9mZnNldCArIG9mZnNldCB9XG4gICk7XG59XG5mdW5jdGlvbiBwYWRSaWdodEVuY29kZXIoZW5jb2Rlciwgb2Zmc2V0KSB7XG4gIHJldHVybiBvZmZzZXRFbmNvZGVyKFxuICAgIHJlc2l6ZUVuY29kZXIoZW5jb2RlciwgKHNpemUpID0+IHNpemUgKyBvZmZzZXQpLFxuICAgIHsgcG9zdE9mZnNldDogKHsgcG9zdE9mZnNldCB9KSA9PiBwb3N0T2Zmc2V0ICsgb2Zmc2V0IH1cbiAgKTtcbn1cbmZ1bmN0aW9uIHBhZExlZnREZWNvZGVyKGRlY29kZXIsIG9mZnNldCkge1xuICByZXR1cm4gb2Zmc2V0RGVjb2RlcihcbiAgICByZXNpemVEZWNvZGVyKGRlY29kZXIsIChzaXplKSA9PiBzaXplICsgb2Zmc2V0KSxcbiAgICB7IHByZU9mZnNldDogKHsgcHJlT2Zmc2V0IH0pID0+IHByZU9mZnNldCArIG9mZnNldCB9XG4gICk7XG59XG5mdW5jdGlvbiBwYWRSaWdodERlY29kZXIoZGVjb2Rlciwgb2Zmc2V0KSB7XG4gIHJldHVybiBvZmZzZXREZWNvZGVyKFxuICAgIHJlc2l6ZURlY29kZXIoZGVjb2RlciwgKHNpemUpID0+IHNpemUgKyBvZmZzZXQpLFxuICAgIHsgcG9zdE9mZnNldDogKHsgcG9zdE9mZnNldCB9KSA9PiBwb3N0T2Zmc2V0ICsgb2Zmc2V0IH1cbiAgKTtcbn1cbmZ1bmN0aW9uIHBhZExlZnRDb2RlYyhjb2RlYywgb2Zmc2V0KSB7XG4gIHJldHVybiBjb21iaW5lQ29kZWMocGFkTGVmdEVuY29kZXIoY29kZWMsIG9mZnNldCksIHBhZExlZnREZWNvZGVyKGNvZGVjLCBvZmZzZXQpKTtcbn1cbmZ1bmN0aW9uIHBhZFJpZ2h0Q29kZWMoY29kZWMsIG9mZnNldCkge1xuICByZXR1cm4gY29tYmluZUNvZGVjKHBhZFJpZ2h0RW5jb2Rlcihjb2RlYywgb2Zmc2V0KSwgcGFkUmlnaHREZWNvZGVyKGNvZGVjLCBvZmZzZXQpKTtcbn1cblxuLy8gc3JjL3JldmVyc2UtY29kZWMudHNcbmZ1bmN0aW9uIGNvcHlTb3VyY2VUb1RhcmdldEluUmV2ZXJzZShzb3VyY2UsIHRhcmdldF9XSUxMX01VVEFURSwgc291cmNlT2Zmc2V0LCBzb3VyY2VMZW5ndGgsIHRhcmdldE9mZnNldCA9IDApIHtcbiAgd2hpbGUgKHNvdXJjZU9mZnNldCA8IC0tc291cmNlTGVuZ3RoKSB7XG4gICAgY29uc3QgbGVmdFZhbHVlID0gc291cmNlW3NvdXJjZU9mZnNldF07XG4gICAgdGFyZ2V0X1dJTExfTVVUQVRFW3NvdXJjZU9mZnNldCArIHRhcmdldE9mZnNldF0gPSBzb3VyY2Vbc291cmNlTGVuZ3RoXTtcbiAgICB0YXJnZXRfV0lMTF9NVVRBVEVbc291cmNlTGVuZ3RoICsgdGFyZ2V0T2Zmc2V0XSA9IGxlZnRWYWx1ZTtcbiAgICBzb3VyY2VPZmZzZXQrKztcbiAgfVxuICBpZiAoc291cmNlT2Zmc2V0ID09PSBzb3VyY2VMZW5ndGgpIHtcbiAgICB0YXJnZXRfV0lMTF9NVVRBVEVbc291cmNlT2Zmc2V0ICsgdGFyZ2V0T2Zmc2V0XSA9IHNvdXJjZVtzb3VyY2VPZmZzZXRdO1xuICB9XG59XG5mdW5jdGlvbiByZXZlcnNlRW5jb2RlcihlbmNvZGVyKSB7XG4gIGFzc2VydElzRml4ZWRTaXplKGVuY29kZXIpO1xuICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7XG4gICAgLi4uZW5jb2RlcixcbiAgICB3cml0ZTogKHZhbHVlLCBieXRlcywgb2Zmc2V0KSA9PiB7XG4gICAgICBjb25zdCBuZXdPZmZzZXQgPSBlbmNvZGVyLndyaXRlKHZhbHVlLCBieXRlcywgb2Zmc2V0KTtcbiAgICAgIGNvcHlTb3VyY2VUb1RhcmdldEluUmV2ZXJzZShcbiAgICAgICAgYnl0ZXMsXG4gICAgICAgIGJ5dGVzLFxuICAgICAgICBvZmZzZXQsXG4gICAgICAgIG9mZnNldCArIGVuY29kZXIuZml4ZWRTaXplXG4gICAgICApO1xuICAgICAgcmV0dXJuIG5ld09mZnNldDtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gcmV2ZXJzZURlY29kZXIoZGVjb2Rlcikge1xuICBhc3NlcnRJc0ZpeGVkU2l6ZShkZWNvZGVyKTtcbiAgcmV0dXJuIGNyZWF0ZURlY29kZXIoe1xuICAgIC4uLmRlY29kZXIsXG4gICAgcmVhZDogKGJ5dGVzLCBvZmZzZXQpID0+IHtcbiAgICAgIGNvbnN0IHJldmVyc2VkQnl0ZXMgPSBieXRlcy5zbGljZSgpO1xuICAgICAgY29weVNvdXJjZVRvVGFyZ2V0SW5SZXZlcnNlKFxuICAgICAgICBieXRlcyxcbiAgICAgICAgcmV2ZXJzZWRCeXRlcyxcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICBvZmZzZXQgKyBkZWNvZGVyLmZpeGVkU2l6ZVxuICAgICAgKTtcbiAgICAgIHJldHVybiBkZWNvZGVyLnJlYWQocmV2ZXJzZWRCeXRlcywgb2Zmc2V0KTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gcmV2ZXJzZUNvZGVjKGNvZGVjKSB7XG4gIHJldHVybiBjb21iaW5lQ29kZWMocmV2ZXJzZUVuY29kZXIoY29kZWMpLCByZXZlcnNlRGVjb2Rlcihjb2RlYykpO1xufVxuXG4vLyBzcmMvdHJhbnNmb3JtLWNvZGVjLnRzXG5mdW5jdGlvbiB0cmFuc2Zvcm1FbmNvZGVyKGVuY29kZXIsIHVubWFwKSB7XG4gIHJldHVybiBjcmVhdGVFbmNvZGVyKHtcbiAgICAuLi5pc1ZhcmlhYmxlU2l6ZShlbmNvZGVyKSA/IHsgLi4uZW5jb2RlciwgZ2V0U2l6ZUZyb21WYWx1ZTogKHZhbHVlKSA9PiBlbmNvZGVyLmdldFNpemVGcm9tVmFsdWUodW5tYXAodmFsdWUpKSB9IDogZW5jb2RlcixcbiAgICB3cml0ZTogKHZhbHVlLCBieXRlcywgb2Zmc2V0KSA9PiBlbmNvZGVyLndyaXRlKHVubWFwKHZhbHVlKSwgYnl0ZXMsIG9mZnNldClcbiAgfSk7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1EZWNvZGVyKGRlY29kZXIsIG1hcCkge1xuICByZXR1cm4gY3JlYXRlRGVjb2Rlcih7XG4gICAgLi4uZGVjb2RlcixcbiAgICByZWFkOiAoYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgICAgY29uc3QgW3ZhbHVlLCBuZXdPZmZzZXRdID0gZGVjb2Rlci5yZWFkKGJ5dGVzLCBvZmZzZXQpO1xuICAgICAgcmV0dXJuIFttYXAodmFsdWUsIGJ5dGVzLCBvZmZzZXQpLCBuZXdPZmZzZXRdO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1Db2RlYyhjb2RlYywgdW5tYXAsIG1hcCkge1xuICByZXR1cm4gY3JlYXRlQ29kZWMoe1xuICAgIC4uLnRyYW5zZm9ybUVuY29kZXIoY29kZWMsIHVubWFwKSxcbiAgICByZWFkOiBtYXAgPyB0cmFuc2Zvcm1EZWNvZGVyKGNvZGVjLCBtYXApLnJlYWQgOiBjb2RlYy5yZWFkXG4gIH0pO1xufVxuXG5leHBvcnQgeyBhZGRDb2RlY1NlbnRpbmVsLCBhZGRDb2RlY1NpemVQcmVmaXgsIGFkZERlY29kZXJTZW50aW5lbCwgYWRkRGVjb2RlclNpemVQcmVmaXgsIGFkZEVuY29kZXJTZW50aW5lbCwgYWRkRW5jb2RlclNpemVQcmVmaXgsIGFzc2VydEJ5dGVBcnJheUhhc0Vub3VnaEJ5dGVzRm9yQ29kZWMsIGFzc2VydEJ5dGVBcnJheUlzTm90RW1wdHlGb3JDb2RlYywgYXNzZXJ0Qnl0ZUFycmF5T2Zmc2V0SXNOb3RPdXRPZlJhbmdlLCBhc3NlcnRJc0ZpeGVkU2l6ZSwgYXNzZXJ0SXNWYXJpYWJsZVNpemUsIGNvbWJpbmVDb2RlYywgY29udGFpbnNCeXRlcywgY3JlYXRlQ29kZWMsIGNyZWF0ZURlY29kZXIsIGNyZWF0ZUVuY29kZXIsIGZpeEJ5dGVzLCBmaXhDb2RlY1NpemUsIGZpeERlY29kZXJTaXplLCBmaXhFbmNvZGVyU2l6ZSwgZ2V0RW5jb2RlZFNpemUsIGlzRml4ZWRTaXplLCBpc1ZhcmlhYmxlU2l6ZSwgbWVyZ2VCeXRlcywgb2Zmc2V0Q29kZWMsIG9mZnNldERlY29kZXIsIG9mZnNldEVuY29kZXIsIHBhZEJ5dGVzLCBwYWRMZWZ0Q29kZWMsIHBhZExlZnREZWNvZGVyLCBwYWRMZWZ0RW5jb2RlciwgcGFkUmlnaHRDb2RlYywgcGFkUmlnaHREZWNvZGVyLCBwYWRSaWdodEVuY29kZXIsIHJlc2l6ZUNvZGVjLCByZXNpemVEZWNvZGVyLCByZXNpemVFbmNvZGVyLCByZXZlcnNlQ29kZWMsIHJldmVyc2VEZWNvZGVyLCByZXZlcnNlRW5jb2RlciwgdHJhbnNmb3JtQ29kZWMsIHRyYW5zZm9ybURlY29kZXIsIHRyYW5zZm9ybUVuY29kZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm5vZGUubWpzLm1hcFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubm9kZS5tanMubWFwIl0sIm5hbWVzIjpbIlNvbGFuYUVycm9yIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX0ZJWEVEX0xFTkdUSCIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9WQVJJQUJMRV9MRU5HVEgiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX1NJWkVfQ09NUEFUSUJJTElUWV9NSVNNQVRDSCIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfRklYRURfU0laRV9NSVNNQVRDSCIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfTUFYX1NJWkVfTUlTTUFUQ0giLCJTT0xBTkFfRVJST1JfX0NPREVDU19fQ0FOTk9UX0RFQ09ERV9FTVBUWV9CWVRFX0FSUkFZIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfQllURV9MRU5HVEgiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fT0ZGU0VUX09VVF9PRl9SQU5HRSIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9QT1NJVElWRV9CWVRFX0xFTkdUSCIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19TRU5USU5FTF9NSVNTSU5HX0lOX0RFQ09ERURfQllURVMiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFRF9CWVRFU19NVVNUX05PVF9JTkNMVURFX1NFTlRJTkVMIiwibWVyZ2VCeXRlcyIsImJ5dGVBcnJheXMiLCJub25FbXB0eUJ5dGVBcnJheXMiLCJmaWx0ZXIiLCJhcnIiLCJsZW5ndGgiLCJVaW50OEFycmF5IiwidG90YWxMZW5ndGgiLCJyZWR1Y2UiLCJ0b3RhbCIsInJlc3VsdCIsIm9mZnNldCIsImZvckVhY2giLCJzZXQiLCJwYWRCeXRlcyIsImJ5dGVzIiwicGFkZGVkQnl0ZXMiLCJmaWxsIiwiZml4Qnl0ZXMiLCJzbGljZSIsImNvbnRhaW5zQnl0ZXMiLCJkYXRhIiwiZXZlcnkiLCJiIiwiaSIsImdldEVuY29kZWRTaXplIiwidmFsdWUiLCJlbmNvZGVyIiwiZml4ZWRTaXplIiwiZ2V0U2l6ZUZyb21WYWx1ZSIsImNyZWF0ZUVuY29kZXIiLCJPYmplY3QiLCJmcmVlemUiLCJlbmNvZGUiLCJ3cml0ZSIsImNyZWF0ZURlY29kZXIiLCJkZWNvZGVyIiwiZGVjb2RlIiwicmVhZCIsImNyZWF0ZUNvZGVjIiwiY29kZWMiLCJpc0ZpeGVkU2l6ZSIsImFzc2VydElzRml4ZWRTaXplIiwiaXNWYXJpYWJsZVNpemUiLCJhc3NlcnRJc1ZhcmlhYmxlU2l6ZSIsImNvbWJpbmVDb2RlYyIsImRlY29kZXJGaXhlZFNpemUiLCJlbmNvZGVyRml4ZWRTaXplIiwibWF4U2l6ZSIsImRlY29kZXJNYXhTaXplIiwiZW5jb2Rlck1heFNpemUiLCJhZGRFbmNvZGVyU2VudGluZWwiLCJzZW50aW5lbCIsImVuY29kZXJCeXRlcyIsImZpbmRTZW50aW5lbEluZGV4IiwiZW5jb2RlZEJ5dGVzIiwiaGV4RW5jb2RlZEJ5dGVzIiwiaGV4Qnl0ZXMiLCJoZXhTZW50aW5lbCIsImFkZERlY29kZXJTZW50aW5lbCIsImNhbmRpZGF0ZUJ5dGVzIiwic2VudGluZWxJbmRleCIsImRlY29kZWRCeXRlcyIsImhleERlY29kZWRCeXRlcyIsInByZVNlbnRpbmVsQnl0ZXMiLCJhZGRDb2RlY1NlbnRpbmVsIiwiZmluZEluZGV4IiwiYnl0ZSIsImluZGV4Iiwic3RyIiwidG9TdHJpbmciLCJwYWRTdGFydCIsImFzc2VydEJ5dGVBcnJheUlzTm90RW1wdHlGb3JDb2RlYyIsImNvZGVjRGVzY3JpcHRpb24iLCJhc3NlcnRCeXRlQXJyYXlIYXNFbm91Z2hCeXRlc0ZvckNvZGVjIiwiZXhwZWN0ZWQiLCJieXRlc0xlbmd0aCIsImFzc2VydEJ5dGVBcnJheU9mZnNldElzTm90T3V0T2ZSYW5nZSIsImFkZEVuY29kZXJTaXplUHJlZml4IiwicHJlZml4IiwicHJlZml4TWF4U2l6ZSIsImVuY29kZXJTaXplIiwiYWRkRGVjb2RlclNpemVQcmVmaXgiLCJiaWdpbnRTaXplIiwiZGVjb2Rlck9mZnNldCIsInNpemUiLCJOdW1iZXIiLCJhZGRDb2RlY1NpemVQcmVmaXgiLCJmaXhFbmNvZGVyU2l6ZSIsImZpeGVkQnl0ZXMiLCJ2YXJpYWJsZUJ5dGVBcnJheSIsImZpeGVkQnl0ZUFycmF5IiwiZml4RGVjb2RlclNpemUiLCJmaXhDb2RlY1NpemUiLCJvZmZzZXRFbmNvZGVyIiwiY29uZmlnIiwicHJlT2Zmc2V0Iiwid3JhcEJ5dGVzIiwibW9kdWxvIiwibmV3UHJlT2Zmc2V0IiwicG9zdE9mZnNldCIsIm5ld1Bvc3RPZmZzZXQiLCJvZmZzZXREZWNvZGVyIiwib2Zmc2V0Q29kZWMiLCJkaXZpZGVuZCIsImRpdmlzb3IiLCJyZXNpemVFbmNvZGVyIiwicmVzaXplIiwibmV3U2l6ZSIsInJlc2l6ZURlY29kZXIiLCJyZXNpemVDb2RlYyIsInBhZExlZnRFbmNvZGVyIiwicGFkUmlnaHRFbmNvZGVyIiwicGFkTGVmdERlY29kZXIiLCJwYWRSaWdodERlY29kZXIiLCJwYWRMZWZ0Q29kZWMiLCJwYWRSaWdodENvZGVjIiwiY29weVNvdXJjZVRvVGFyZ2V0SW5SZXZlcnNlIiwic291cmNlIiwidGFyZ2V0X1dJTExfTVVUQVRFIiwic291cmNlT2Zmc2V0Iiwic291cmNlTGVuZ3RoIiwidGFyZ2V0T2Zmc2V0IiwibGVmdFZhbHVlIiwicmV2ZXJzZUVuY29kZXIiLCJuZXdPZmZzZXQiLCJyZXZlcnNlRGVjb2RlciIsInJldmVyc2VkQnl0ZXMiLCJyZXZlcnNlQ29kZWMiLCJ0cmFuc2Zvcm1FbmNvZGVyIiwidW5tYXAiLCJ0cmFuc2Zvcm1EZWNvZGVyIiwibWFwIiwidHJhbnNmb3JtQ29kZWMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@solana/codecs-core/dist/index.node.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@solana/codecs-numbers/dist/index.node.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@solana/codecs-numbers/dist/index.node.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Endian: () => (/* binding */ Endian),\n/* harmony export */   assertNumberIsBetweenForCodec: () => (/* binding */ assertNumberIsBetweenForCodec),\n/* harmony export */   getF32Codec: () => (/* binding */ getF32Codec),\n/* harmony export */   getF32Decoder: () => (/* binding */ getF32Decoder),\n/* harmony export */   getF32Encoder: () => (/* binding */ getF32Encoder),\n/* harmony export */   getF64Codec: () => (/* binding */ getF64Codec),\n/* harmony export */   getF64Decoder: () => (/* binding */ getF64Decoder),\n/* harmony export */   getF64Encoder: () => (/* binding */ getF64Encoder),\n/* harmony export */   getI128Codec: () => (/* binding */ getI128Codec),\n/* harmony export */   getI128Decoder: () => (/* binding */ getI128Decoder),\n/* harmony export */   getI128Encoder: () => (/* binding */ getI128Encoder),\n/* harmony export */   getI16Codec: () => (/* binding */ getI16Codec),\n/* harmony export */   getI16Decoder: () => (/* binding */ getI16Decoder),\n/* harmony export */   getI16Encoder: () => (/* binding */ getI16Encoder),\n/* harmony export */   getI32Codec: () => (/* binding */ getI32Codec),\n/* harmony export */   getI32Decoder: () => (/* binding */ getI32Decoder),\n/* harmony export */   getI32Encoder: () => (/* binding */ getI32Encoder),\n/* harmony export */   getI64Codec: () => (/* binding */ getI64Codec),\n/* harmony export */   getI64Decoder: () => (/* binding */ getI64Decoder),\n/* harmony export */   getI64Encoder: () => (/* binding */ getI64Encoder),\n/* harmony export */   getI8Codec: () => (/* binding */ getI8Codec),\n/* harmony export */   getI8Decoder: () => (/* binding */ getI8Decoder),\n/* harmony export */   getI8Encoder: () => (/* binding */ getI8Encoder),\n/* harmony export */   getShortU16Codec: () => (/* binding */ getShortU16Codec),\n/* harmony export */   getShortU16Decoder: () => (/* binding */ getShortU16Decoder),\n/* harmony export */   getShortU16Encoder: () => (/* binding */ getShortU16Encoder),\n/* harmony export */   getU128Codec: () => (/* binding */ getU128Codec),\n/* harmony export */   getU128Decoder: () => (/* binding */ getU128Decoder),\n/* harmony export */   getU128Encoder: () => (/* binding */ getU128Encoder),\n/* harmony export */   getU16Codec: () => (/* binding */ getU16Codec),\n/* harmony export */   getU16Decoder: () => (/* binding */ getU16Decoder),\n/* harmony export */   getU16Encoder: () => (/* binding */ getU16Encoder),\n/* harmony export */   getU32Codec: () => (/* binding */ getU32Codec),\n/* harmony export */   getU32Decoder: () => (/* binding */ getU32Decoder),\n/* harmony export */   getU32Encoder: () => (/* binding */ getU32Encoder),\n/* harmony export */   getU64Codec: () => (/* binding */ getU64Codec),\n/* harmony export */   getU64Decoder: () => (/* binding */ getU64Decoder),\n/* harmony export */   getU64Encoder: () => (/* binding */ getU64Encoder),\n/* harmony export */   getU8Codec: () => (/* binding */ getU8Codec),\n/* harmony export */   getU8Decoder: () => (/* binding */ getU8Decoder),\n/* harmony export */   getU8Encoder: () => (/* binding */ getU8Encoder)\n/* harmony export */ });\n/* harmony import */ var _solana_errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/errors */ \"(rsc)/./node_modules/@solana/errors/dist/index.node.mjs\");\n/* harmony import */ var _solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana/codecs-core */ \"(rsc)/./node_modules/@solana/codecs-core/dist/index.node.mjs\");\n\n\n// src/assertions.ts\nfunction assertNumberIsBetweenForCodec(codecDescription, min, max, value) {\n    if (value < min || value > max) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, {\n            codecDescription,\n            max,\n            min,\n            value\n        });\n    }\n}\n// src/common.ts\nvar Endian = /* @__PURE__ */ ((Endian2)=>{\n    Endian2[Endian2[\"Little\"] = 0] = \"Little\";\n    Endian2[Endian2[\"Big\"] = 1] = \"Big\";\n    return Endian2;\n})(Endian || {});\nfunction isLittleEndian(config) {\n    return config?.endian === 1 /* Big */  ? false : true;\n}\nfunction numberEncoderFactory(input) {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.createEncoder)({\n        fixedSize: input.size,\n        write (value, bytes, offset) {\n            if (input.range) {\n                assertNumberIsBetweenForCodec(input.name, input.range[0], input.range[1], value);\n            }\n            const arrayBuffer = new ArrayBuffer(input.size);\n            input.set(new DataView(arrayBuffer), value, isLittleEndian(input.config));\n            bytes.set(new Uint8Array(arrayBuffer), offset);\n            return offset + input.size;\n        }\n    });\n}\nfunction numberDecoderFactory(input) {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.createDecoder)({\n        fixedSize: input.size,\n        read (bytes, offset = 0) {\n            (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.assertByteArrayIsNotEmptyForCodec)(input.name, bytes, offset);\n            (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.assertByteArrayHasEnoughBytesForCodec)(input.name, input.size, bytes, offset);\n            const view = new DataView(toArrayBuffer(bytes, offset, input.size));\n            return [\n                input.get(view, isLittleEndian(input.config)),\n                offset + input.size\n            ];\n        }\n    });\n}\nfunction toArrayBuffer(bytes, offset, length) {\n    const bytesOffset = bytes.byteOffset + (offset ?? 0);\n    const bytesLength = length ?? bytes.byteLength;\n    return bytes.buffer.slice(bytesOffset, bytesOffset + bytesLength);\n}\n// src/f32.ts\nvar getF32Encoder = (config = {})=>numberEncoderFactory({\n        config,\n        name: \"f32\",\n        set: (view, value, le)=>view.setFloat32(0, Number(value), le),\n        size: 4\n    });\nvar getF32Decoder = (config = {})=>numberDecoderFactory({\n        config,\n        get: (view, le)=>view.getFloat32(0, le),\n        name: \"f32\",\n        size: 4\n    });\nvar getF32Codec = (config = {})=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getF32Encoder(config), getF32Decoder(config));\nvar getF64Encoder = (config = {})=>numberEncoderFactory({\n        config,\n        name: \"f64\",\n        set: (view, value, le)=>view.setFloat64(0, Number(value), le),\n        size: 8\n    });\nvar getF64Decoder = (config = {})=>numberDecoderFactory({\n        config,\n        get: (view, le)=>view.getFloat64(0, le),\n        name: \"f64\",\n        size: 8\n    });\nvar getF64Codec = (config = {})=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getF64Encoder(config), getF64Decoder(config));\nvar getI128Encoder = (config = {})=>numberEncoderFactory({\n        config,\n        name: \"i128\",\n        range: [\n            -BigInt(\"0x7fffffffffffffffffffffffffffffff\") - 1n,\n            BigInt(\"0x7fffffffffffffffffffffffffffffff\")\n        ],\n        set: (view, value, le)=>{\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const rightMask = 0xffffffffffffffffn;\n            view.setBigInt64(leftOffset, BigInt(value) >> 64n, le);\n            view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n        },\n        size: 16\n    });\nvar getI128Decoder = (config = {})=>numberDecoderFactory({\n        config,\n        get: (view, le)=>{\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const left = view.getBigInt64(leftOffset, le);\n            const right = view.getBigUint64(rightOffset, le);\n            return (left << 64n) + right;\n        },\n        name: \"i128\",\n        size: 16\n    });\nvar getI128Codec = (config = {})=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getI128Encoder(config), getI128Decoder(config));\nvar getI16Encoder = (config = {})=>numberEncoderFactory({\n        config,\n        name: \"i16\",\n        range: [\n            -Number(\"0x7fff\") - 1,\n            Number(\"0x7fff\")\n        ],\n        set: (view, value, le)=>view.setInt16(0, Number(value), le),\n        size: 2\n    });\nvar getI16Decoder = (config = {})=>numberDecoderFactory({\n        config,\n        get: (view, le)=>view.getInt16(0, le),\n        name: \"i16\",\n        size: 2\n    });\nvar getI16Codec = (config = {})=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getI16Encoder(config), getI16Decoder(config));\nvar getI32Encoder = (config = {})=>numberEncoderFactory({\n        config,\n        name: \"i32\",\n        range: [\n            -Number(\"0x7fffffff\") - 1,\n            Number(\"0x7fffffff\")\n        ],\n        set: (view, value, le)=>view.setInt32(0, Number(value), le),\n        size: 4\n    });\nvar getI32Decoder = (config = {})=>numberDecoderFactory({\n        config,\n        get: (view, le)=>view.getInt32(0, le),\n        name: \"i32\",\n        size: 4\n    });\nvar getI32Codec = (config = {})=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getI32Encoder(config), getI32Decoder(config));\nvar getI64Encoder = (config = {})=>numberEncoderFactory({\n        config,\n        name: \"i64\",\n        range: [\n            -BigInt(\"0x7fffffffffffffff\") - 1n,\n            BigInt(\"0x7fffffffffffffff\")\n        ],\n        set: (view, value, le)=>view.setBigInt64(0, BigInt(value), le),\n        size: 8\n    });\nvar getI64Decoder = (config = {})=>numberDecoderFactory({\n        config,\n        get: (view, le)=>view.getBigInt64(0, le),\n        name: \"i64\",\n        size: 8\n    });\nvar getI64Codec = (config = {})=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getI64Encoder(config), getI64Decoder(config));\nvar getI8Encoder = ()=>numberEncoderFactory({\n        name: \"i8\",\n        range: [\n            -Number(\"0x7f\") - 1,\n            Number(\"0x7f\")\n        ],\n        set: (view, value)=>view.setInt8(0, Number(value)),\n        size: 1\n    });\nvar getI8Decoder = ()=>numberDecoderFactory({\n        get: (view)=>view.getInt8(0),\n        name: \"i8\",\n        size: 1\n    });\nvar getI8Codec = ()=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getI8Encoder(), getI8Decoder());\nvar getShortU16Encoder = ()=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.createEncoder)({\n        getSizeFromValue: (value)=>{\n            if (value <= 127) return 1;\n            if (value <= 16383) return 2;\n            return 3;\n        },\n        maxSize: 3,\n        write: (value, bytes, offset)=>{\n            assertNumberIsBetweenForCodec(\"shortU16\", 0, 65535, value);\n            const shortU16Bytes = [\n                0\n            ];\n            for(let ii = 0;; ii += 1){\n                const alignedValue = Number(value) >> ii * 7;\n                if (alignedValue === 0) {\n                    break;\n                }\n                const nextSevenBits = 127 & alignedValue;\n                shortU16Bytes[ii] = nextSevenBits;\n                if (ii > 0) {\n                    shortU16Bytes[ii - 1] |= 128;\n                }\n            }\n            bytes.set(shortU16Bytes, offset);\n            return offset + shortU16Bytes.length;\n        }\n    });\nvar getShortU16Decoder = ()=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.createDecoder)({\n        maxSize: 3,\n        read: (bytes, offset)=>{\n            let value = 0;\n            let byteCount = 0;\n            while(++byteCount){\n                const byteIndex = byteCount - 1;\n                const currentByte = bytes[offset + byteIndex];\n                const nextSevenBits = 127 & currentByte;\n                value |= nextSevenBits << byteIndex * 7;\n                if ((currentByte & 128) === 0) {\n                    break;\n                }\n            }\n            return [\n                value,\n                offset + byteCount\n            ];\n        }\n    });\nvar getShortU16Codec = ()=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getShortU16Encoder(), getShortU16Decoder());\nvar getU128Encoder = (config = {})=>numberEncoderFactory({\n        config,\n        name: \"u128\",\n        range: [\n            0n,\n            BigInt(\"0xffffffffffffffffffffffffffffffff\")\n        ],\n        set: (view, value, le)=>{\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const rightMask = 0xffffffffffffffffn;\n            view.setBigUint64(leftOffset, BigInt(value) >> 64n, le);\n            view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n        },\n        size: 16\n    });\nvar getU128Decoder = (config = {})=>numberDecoderFactory({\n        config,\n        get: (view, le)=>{\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const left = view.getBigUint64(leftOffset, le);\n            const right = view.getBigUint64(rightOffset, le);\n            return (left << 64n) + right;\n        },\n        name: \"u128\",\n        size: 16\n    });\nvar getU128Codec = (config = {})=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getU128Encoder(config), getU128Decoder(config));\nvar getU16Encoder = (config = {})=>numberEncoderFactory({\n        config,\n        name: \"u16\",\n        range: [\n            0,\n            Number(\"0xffff\")\n        ],\n        set: (view, value, le)=>view.setUint16(0, Number(value), le),\n        size: 2\n    });\nvar getU16Decoder = (config = {})=>numberDecoderFactory({\n        config,\n        get: (view, le)=>view.getUint16(0, le),\n        name: \"u16\",\n        size: 2\n    });\nvar getU16Codec = (config = {})=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getU16Encoder(config), getU16Decoder(config));\nvar getU32Encoder = (config = {})=>numberEncoderFactory({\n        config,\n        name: \"u32\",\n        range: [\n            0,\n            Number(\"0xffffffff\")\n        ],\n        set: (view, value, le)=>view.setUint32(0, Number(value), le),\n        size: 4\n    });\nvar getU32Decoder = (config = {})=>numberDecoderFactory({\n        config,\n        get: (view, le)=>view.getUint32(0, le),\n        name: \"u32\",\n        size: 4\n    });\nvar getU32Codec = (config = {})=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getU32Encoder(config), getU32Decoder(config));\nvar getU64Encoder = (config = {})=>numberEncoderFactory({\n        config,\n        name: \"u64\",\n        range: [\n            0n,\n            BigInt(\"0xffffffffffffffff\")\n        ],\n        set: (view, value, le)=>view.setBigUint64(0, BigInt(value), le),\n        size: 8\n    });\nvar getU64Decoder = (config = {})=>numberDecoderFactory({\n        config,\n        get: (view, le)=>view.getBigUint64(0, le),\n        name: \"u64\",\n        size: 8\n    });\nvar getU64Codec = (config = {})=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getU64Encoder(config), getU64Decoder(config));\nvar getU8Encoder = ()=>numberEncoderFactory({\n        name: \"u8\",\n        range: [\n            0,\n            Number(\"0xff\")\n        ],\n        set: (view, value)=>view.setUint8(0, Number(value)),\n        size: 1\n    });\nvar getU8Decoder = ()=>numberDecoderFactory({\n        get: (view)=>view.getUint8(0),\n        name: \"u8\",\n        size: 1\n    });\nvar getU8Codec = ()=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getU8Encoder(), getU8Decoder());\n //# sourceMappingURL=index.node.mjs.map\n //# sourceMappingURL=index.node.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS9jb2RlY3MtbnVtYmVycy9kaXN0L2luZGV4Lm5vZGUubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBd0Y7QUFDbUU7QUFFM0osb0JBQW9CO0FBQ3BCLFNBQVNPLDhCQUE4QkMsZ0JBQWdCLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxLQUFLO0lBQ3RFLElBQUlBLFFBQVFGLE9BQU9FLFFBQVFELEtBQUs7UUFDOUIsTUFBTSxJQUFJVix1REFBV0EsQ0FBQ0MscUZBQXlDQSxFQUFFO1lBQy9ETztZQUNBRTtZQUNBRDtZQUNBRTtRQUNGO0lBQ0Y7QUFDRjtBQUVBLGdCQUFnQjtBQUNoQixJQUFJQyxTQUF5QixhQUFILEdBQUksRUFBQ0M7SUFDN0JBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLFNBQVMsR0FBRyxFQUFFLEdBQUc7SUFDakNBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLE1BQU0sR0FBRyxFQUFFLEdBQUc7SUFDOUIsT0FBT0E7QUFDVCxHQUFHRCxVQUFVLENBQUM7QUFDZCxTQUFTRSxlQUFlQyxNQUFNO0lBQzVCLE9BQU9BLFFBQVFDLFdBQVcsRUFBRSxPQUFPLE1BQUssUUFBUTtBQUNsRDtBQUNBLFNBQVNDLHFCQUFxQkMsS0FBSztJQUNqQyxPQUFPZCxrRUFBYUEsQ0FBQztRQUNuQmUsV0FBV0QsTUFBTUUsSUFBSTtRQUNyQkMsT0FBTVYsS0FBSyxFQUFFVyxLQUFLLEVBQUVDLE1BQU07WUFDeEIsSUFBSUwsTUFBTU0sS0FBSyxFQUFFO2dCQUNmakIsOEJBQThCVyxNQUFNTyxJQUFJLEVBQUVQLE1BQU1NLEtBQUssQ0FBQyxFQUFFLEVBQUVOLE1BQU1NLEtBQUssQ0FBQyxFQUFFLEVBQUViO1lBQzVFO1lBQ0EsTUFBTWUsY0FBYyxJQUFJQyxZQUFZVCxNQUFNRSxJQUFJO1lBQzlDRixNQUFNVSxHQUFHLENBQUMsSUFBSUMsU0FBU0gs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Y2s6Ly9za3ItZG9tYWluLXdhdGNoZXIvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS9jb2RlY3MtbnVtYmVycy9kaXN0L2luZGV4Lm5vZGUubWpzP2Q3OTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU29sYW5hRXJyb3IsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19OVU1CRVJfT1VUX09GX1JBTkdFIH0gZnJvbSAnQHNvbGFuYS9lcnJvcnMnO1xuaW1wb3J0IHsgY29tYmluZUNvZGVjLCBjcmVhdGVEZWNvZGVyLCBjcmVhdGVFbmNvZGVyLCBhc3NlcnRCeXRlQXJyYXlJc05vdEVtcHR5Rm9yQ29kZWMsIGFzc2VydEJ5dGVBcnJheUhhc0Vub3VnaEJ5dGVzRm9yQ29kZWMgfSBmcm9tICdAc29sYW5hL2NvZGVjcy1jb3JlJztcblxuLy8gc3JjL2Fzc2VydGlvbnMudHNcbmZ1bmN0aW9uIGFzc2VydE51bWJlcklzQmV0d2VlbkZvckNvZGVjKGNvZGVjRGVzY3JpcHRpb24sIG1pbiwgbWF4LCB2YWx1ZSkge1xuICBpZiAodmFsdWUgPCBtaW4gfHwgdmFsdWUgPiBtYXgpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX05VTUJFUl9PVVRfT0ZfUkFOR0UsIHtcbiAgICAgIGNvZGVjRGVzY3JpcHRpb24sXG4gICAgICBtYXgsXG4gICAgICBtaW4sXG4gICAgICB2YWx1ZVxuICAgIH0pO1xuICB9XG59XG5cbi8vIHNyYy9jb21tb24udHNcbnZhciBFbmRpYW4gPSAvKiBAX19QVVJFX18gKi8gKChFbmRpYW4yKSA9PiB7XG4gIEVuZGlhbjJbRW5kaWFuMltcIkxpdHRsZVwiXSA9IDBdID0gXCJMaXR0bGVcIjtcbiAgRW5kaWFuMltFbmRpYW4yW1wiQmlnXCJdID0gMV0gPSBcIkJpZ1wiO1xuICByZXR1cm4gRW5kaWFuMjtcbn0pKEVuZGlhbiB8fCB7fSk7XG5mdW5jdGlvbiBpc0xpdHRsZUVuZGlhbihjb25maWcpIHtcbiAgcmV0dXJuIGNvbmZpZz8uZW5kaWFuID09PSAxIC8qIEJpZyAqLyA/IGZhbHNlIDogdHJ1ZTtcbn1cbmZ1bmN0aW9uIG51bWJlckVuY29kZXJGYWN0b3J5KGlucHV0KSB7XG4gIHJldHVybiBjcmVhdGVFbmNvZGVyKHtcbiAgICBmaXhlZFNpemU6IGlucHV0LnNpemUsXG4gICAgd3JpdGUodmFsdWUsIGJ5dGVzLCBvZmZzZXQpIHtcbiAgICAgIGlmIChpbnB1dC5yYW5nZSkge1xuICAgICAgICBhc3NlcnROdW1iZXJJc0JldHdlZW5Gb3JDb2RlYyhpbnB1dC5uYW1lLCBpbnB1dC5yYW5nZVswXSwgaW5wdXQucmFuZ2VbMV0sIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFycmF5QnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGlucHV0LnNpemUpO1xuICAgICAgaW5wdXQuc2V0KG5ldyBEYXRhVmlldyhhcnJheUJ1ZmZlciksIHZhbHVlLCBpc0xpdHRsZUVuZGlhbihpbnB1dC5jb25maWcpKTtcbiAgICAgIGJ5dGVzLnNldChuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlciksIG9mZnNldCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ICsgaW5wdXQuc2l6ZTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gbnVtYmVyRGVjb2RlckZhY3RvcnkoaW5wdXQpIHtcbiAgcmV0dXJuIGNyZWF0ZURlY29kZXIoe1xuICAgIGZpeGVkU2l6ZTogaW5wdXQuc2l6ZSxcbiAgICByZWFkKGJ5dGVzLCBvZmZzZXQgPSAwKSB7XG4gICAgICBhc3NlcnRCeXRlQXJyYXlJc05vdEVtcHR5Rm9yQ29kZWMoaW5wdXQubmFtZSwgYnl0ZXMsIG9mZnNldCk7XG4gICAgICBhc3NlcnRCeXRlQXJyYXlIYXNFbm91Z2hCeXRlc0ZvckNvZGVjKGlucHV0Lm5hbWUsIGlucHV0LnNpemUsIGJ5dGVzLCBvZmZzZXQpO1xuICAgICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyh0b0FycmF5QnVmZmVyKGJ5dGVzLCBvZmZzZXQsIGlucHV0LnNpemUpKTtcbiAgICAgIHJldHVybiBbaW5wdXQuZ2V0KHZpZXcsIGlzTGl0dGxlRW5kaWFuKGlucHV0LmNvbmZpZykpLCBvZmZzZXQgKyBpbnB1dC5zaXplXTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gdG9BcnJheUJ1ZmZlcihieXRlcywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgY29uc3QgYnl0ZXNPZmZzZXQgPSBieXRlcy5ieXRlT2Zmc2V0ICsgKG9mZnNldCA/PyAwKTtcbiAgY29uc3QgYnl0ZXNMZW5ndGggPSBsZW5ndGggPz8gYnl0ZXMuYnl0ZUxlbmd0aDtcbiAgcmV0dXJuIGJ5dGVzLmJ1ZmZlci5zbGljZShieXRlc09mZnNldCwgYnl0ZXNPZmZzZXQgKyBieXRlc0xlbmd0aCk7XG59XG5cbi8vIHNyYy9mMzIudHNcbnZhciBnZXRGMzJFbmNvZGVyID0gKGNvbmZpZyA9IHt9KSA9PiBudW1iZXJFbmNvZGVyRmFjdG9yeSh7XG4gIGNvbmZpZyxcbiAgbmFtZTogXCJmMzJcIixcbiAgc2V0OiAodmlldywgdmFsdWUsIGxlKSA9PiB2aWV3LnNldEZsb2F0MzIoMCwgTnVtYmVyKHZhbHVlKSwgbGUpLFxuICBzaXplOiA0XG59KTtcbnZhciBnZXRGMzJEZWNvZGVyID0gKGNvbmZpZyA9IHt9KSA9PiBudW1iZXJEZWNvZGVyRmFjdG9yeSh7XG4gIGNvbmZpZyxcbiAgZ2V0OiAodmlldywgbGUpID0+IHZpZXcuZ2V0RmxvYXQzMigwLCBsZSksXG4gIG5hbWU6IFwiZjMyXCIsXG4gIHNpemU6IDRcbn0pO1xudmFyIGdldEYzMkNvZGVjID0gKGNvbmZpZyA9IHt9KSA9PiBjb21iaW5lQ29kZWMoZ2V0RjMyRW5jb2Rlcihjb25maWcpLCBnZXRGMzJEZWNvZGVyKGNvbmZpZykpO1xudmFyIGdldEY2NEVuY29kZXIgPSAoY29uZmlnID0ge30pID0+IG51bWJlckVuY29kZXJGYWN0b3J5KHtcbiAgY29uZmlnLFxuICBuYW1lOiBcImY2NFwiLFxuICBzZXQ6ICh2aWV3LCB2YWx1ZSwgbGUpID0+IHZpZXcuc2V0RmxvYXQ2NCgwLCBOdW1iZXIodmFsdWUpLCBsZSksXG4gIHNpemU6IDhcbn0pO1xudmFyIGdldEY2NERlY29kZXIgPSAoY29uZmlnID0ge30pID0+IG51bWJlckRlY29kZXJGYWN0b3J5KHtcbiAgY29uZmlnLFxuICBnZXQ6ICh2aWV3LCBsZSkgPT4gdmlldy5nZXRGbG9hdDY0KDAsIGxlKSxcbiAgbmFtZTogXCJmNjRcIixcbiAgc2l6ZTogOFxufSk7XG52YXIgZ2V0RjY0Q29kZWMgPSAoY29uZmlnID0ge30pID0+IGNvbWJpbmVDb2RlYyhnZXRGNjRFbmNvZGVyKGNvbmZpZyksIGdldEY2NERlY29kZXIoY29uZmlnKSk7XG52YXIgZ2V0STEyOEVuY29kZXIgPSAoY29uZmlnID0ge30pID0+IG51bWJlckVuY29kZXJGYWN0b3J5KHtcbiAgY29uZmlnLFxuICBuYW1lOiBcImkxMjhcIixcbiAgcmFuZ2U6IFstQmlnSW50KFwiMHg3ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlwiKSAtIDFuLCBCaWdJbnQoXCIweDdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmXCIpXSxcbiAgc2V0OiAodmlldywgdmFsdWUsIGxlKSA9PiB7XG4gICAgY29uc3QgbGVmdE9mZnNldCA9IGxlID8gOCA6IDA7XG4gICAgY29uc3QgcmlnaHRPZmZzZXQgPSBsZSA/IDAgOiA4O1xuICAgIGNvbnN0IHJpZ2h0TWFzayA9IDB4ZmZmZmZmZmZmZmZmZmZmZm47XG4gICAgdmlldy5zZXRCaWdJbnQ2NChsZWZ0T2Zmc2V0LCBCaWdJbnQodmFsdWUpID4+IDY0biwgbGUpO1xuICAgIHZpZXcuc2V0QmlnVWludDY0KHJpZ2h0T2Zmc2V0LCBCaWdJbnQodmFsdWUpICYgcmlnaHRNYXNrLCBsZSk7XG4gIH0sXG4gIHNpemU6IDE2XG59KTtcbnZhciBnZXRJMTI4RGVjb2RlciA9IChjb25maWcgPSB7fSkgPT4gbnVtYmVyRGVjb2RlckZhY3Rvcnkoe1xuICBjb25maWcsXG4gIGdldDogKHZpZXcsIGxlKSA9PiB7XG4gICAgY29uc3QgbGVmdE9mZnNldCA9IGxlID8gOCA6IDA7XG4gICAgY29uc3QgcmlnaHRPZmZzZXQgPSBsZSA/IDAgOiA4O1xuICAgIGNvbnN0IGxlZnQgPSB2aWV3LmdldEJpZ0ludDY0KGxlZnRPZmZzZXQsIGxlKTtcbiAgICBjb25zdCByaWdodCA9IHZpZXcuZ2V0QmlnVWludDY0KHJpZ2h0T2Zmc2V0LCBsZSk7XG4gICAgcmV0dXJuIChsZWZ0IDw8IDY0bikgKyByaWdodDtcbiAgfSxcbiAgbmFtZTogXCJpMTI4XCIsXG4gIHNpemU6IDE2XG59KTtcbnZhciBnZXRJMTI4Q29kZWMgPSAoY29uZmlnID0ge30pID0+IGNvbWJpbmVDb2RlYyhnZXRJMTI4RW5jb2Rlcihjb25maWcpLCBnZXRJMTI4RGVjb2Rlcihjb25maWcpKTtcbnZhciBnZXRJMTZFbmNvZGVyID0gKGNvbmZpZyA9IHt9KSA9PiBudW1iZXJFbmNvZGVyRmFjdG9yeSh7XG4gIGNvbmZpZyxcbiAgbmFtZTogXCJpMTZcIixcbiAgcmFuZ2U6IFstTnVtYmVyKFwiMHg3ZmZmXCIpIC0gMSwgTnVtYmVyKFwiMHg3ZmZmXCIpXSxcbiAgc2V0OiAodmlldywgdmFsdWUsIGxlKSA9PiB2aWV3LnNldEludDE2KDAsIE51bWJlcih2YWx1ZSksIGxlKSxcbiAgc2l6ZTogMlxufSk7XG52YXIgZ2V0STE2RGVjb2RlciA9IChjb25maWcgPSB7fSkgPT4gbnVtYmVyRGVjb2RlckZhY3Rvcnkoe1xuICBjb25maWcsXG4gIGdldDogKHZpZXcsIGxlKSA9PiB2aWV3LmdldEludDE2KDAsIGxlKSxcbiAgbmFtZTogXCJpMTZcIixcbiAgc2l6ZTogMlxufSk7XG52YXIgZ2V0STE2Q29kZWMgPSAoY29uZmlnID0ge30pID0+IGNvbWJpbmVDb2RlYyhnZXRJMTZFbmNvZGVyKGNvbmZpZyksIGdldEkxNkRlY29kZXIoY29uZmlnKSk7XG52YXIgZ2V0STMyRW5jb2RlciA9IChjb25maWcgPSB7fSkgPT4gbnVtYmVyRW5jb2RlckZhY3Rvcnkoe1xuICBjb25maWcsXG4gIG5hbWU6IFwiaTMyXCIsXG4gIHJhbmdlOiBbLU51bWJlcihcIjB4N2ZmZmZmZmZcIikgLSAxLCBOdW1iZXIoXCIweDdmZmZmZmZmXCIpXSxcbiAgc2V0OiAodmlldywgdmFsdWUsIGxlKSA9PiB2aWV3LnNldEludDMyKDAsIE51bWJlcih2YWx1ZSksIGxlKSxcbiAgc2l6ZTogNFxufSk7XG52YXIgZ2V0STMyRGVjb2RlciA9IChjb25maWcgPSB7fSkgPT4gbnVtYmVyRGVjb2RlckZhY3Rvcnkoe1xuICBjb25maWcsXG4gIGdldDogKHZpZXcsIGxlKSA9PiB2aWV3LmdldEludDMyKDAsIGxlKSxcbiAgbmFtZTogXCJpMzJcIixcbiAgc2l6ZTogNFxufSk7XG52YXIgZ2V0STMyQ29kZWMgPSAoY29uZmlnID0ge30pID0+IGNvbWJpbmVDb2RlYyhnZXRJMzJFbmNvZGVyKGNvbmZpZyksIGdldEkzMkRlY29kZXIoY29uZmlnKSk7XG52YXIgZ2V0STY0RW5jb2RlciA9IChjb25maWcgPSB7fSkgPT4gbnVtYmVyRW5jb2RlckZhY3Rvcnkoe1xuICBjb25maWcsXG4gIG5hbWU6IFwiaTY0XCIsXG4gIHJhbmdlOiBbLUJpZ0ludChcIjB4N2ZmZmZmZmZmZmZmZmZmZlwiKSAtIDFuLCBCaWdJbnQoXCIweDdmZmZmZmZmZmZmZmZmZmZcIildLFxuICBzZXQ6ICh2aWV3LCB2YWx1ZSwgbGUpID0+IHZpZXcuc2V0QmlnSW50NjQoMCwgQmlnSW50KHZhbHVlKSwgbGUpLFxuICBzaXplOiA4XG59KTtcbnZhciBnZXRJNjREZWNvZGVyID0gKGNvbmZpZyA9IHt9KSA9PiBudW1iZXJEZWNvZGVyRmFjdG9yeSh7XG4gIGNvbmZpZyxcbiAgZ2V0OiAodmlldywgbGUpID0+IHZpZXcuZ2V0QmlnSW50NjQoMCwgbGUpLFxuICBuYW1lOiBcImk2NFwiLFxuICBzaXplOiA4XG59KTtcbnZhciBnZXRJNjRDb2RlYyA9IChjb25maWcgPSB7fSkgPT4gY29tYmluZUNvZGVjKGdldEk2NEVuY29kZXIoY29uZmlnKSwgZ2V0STY0RGVjb2Rlcihjb25maWcpKTtcbnZhciBnZXRJOEVuY29kZXIgPSAoKSA9PiBudW1iZXJFbmNvZGVyRmFjdG9yeSh7XG4gIG5hbWU6IFwiaThcIixcbiAgcmFuZ2U6IFstTnVtYmVyKFwiMHg3ZlwiKSAtIDEsIE51bWJlcihcIjB4N2ZcIildLFxuICBzZXQ6ICh2aWV3LCB2YWx1ZSkgPT4gdmlldy5zZXRJbnQ4KDAsIE51bWJlcih2YWx1ZSkpLFxuICBzaXplOiAxXG59KTtcbnZhciBnZXRJOERlY29kZXIgPSAoKSA9PiBudW1iZXJEZWNvZGVyRmFjdG9yeSh7XG4gIGdldDogKHZpZXcpID0+IHZpZXcuZ2V0SW50OCgwKSxcbiAgbmFtZTogXCJpOFwiLFxuICBzaXplOiAxXG59KTtcbnZhciBnZXRJOENvZGVjID0gKCkgPT4gY29tYmluZUNvZGVjKGdldEk4RW5jb2RlcigpLCBnZXRJOERlY29kZXIoKSk7XG52YXIgZ2V0U2hvcnRVMTZFbmNvZGVyID0gKCkgPT4gY3JlYXRlRW5jb2Rlcih7XG4gIGdldFNpemVGcm9tVmFsdWU6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA8PSAxMjcpIHJldHVybiAxO1xuICAgIGlmICh2YWx1ZSA8PSAxNjM4MykgcmV0dXJuIDI7XG4gICAgcmV0dXJuIDM7XG4gIH0sXG4gIG1heFNpemU6IDMsXG4gIHdyaXRlOiAodmFsdWUsIGJ5dGVzLCBvZmZzZXQpID0+IHtcbiAgICBhc3NlcnROdW1iZXJJc0JldHdlZW5Gb3JDb2RlYyhcInNob3J0VTE2XCIsIDAsIDY1NTM1LCB2YWx1ZSk7XG4gICAgY29uc3Qgc2hvcnRVMTZCeXRlcyA9IFswXTtcbiAgICBmb3IgKGxldCBpaSA9IDA7IDsgaWkgKz0gMSkge1xuICAgICAgY29uc3QgYWxpZ25lZFZhbHVlID0gTnVtYmVyKHZhbHVlKSA+PiBpaSAqIDc7XG4gICAgICBpZiAoYWxpZ25lZFZhbHVlID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY29uc3QgbmV4dFNldmVuQml0cyA9IDEyNyAmIGFsaWduZWRWYWx1ZTtcbiAgICAgIHNob3J0VTE2Qnl0ZXNbaWldID0gbmV4dFNldmVuQml0cztcbiAgICAgIGlmIChpaSA+IDApIHtcbiAgICAgICAgc2hvcnRVMTZCeXRlc1tpaSAtIDFdIHw9IDEyODtcbiAgICAgIH1cbiAgICB9XG4gICAgYnl0ZXMuc2V0KHNob3J0VTE2Qnl0ZXMsIG9mZnNldCk7XG4gICAgcmV0dXJuIG9mZnNldCArIHNob3J0VTE2Qnl0ZXMubGVuZ3RoO1xuICB9XG59KTtcbnZhciBnZXRTaG9ydFUxNkRlY29kZXIgPSAoKSA9PiBjcmVhdGVEZWNvZGVyKHtcbiAgbWF4U2l6ZTogMyxcbiAgcmVhZDogKGJ5dGVzLCBvZmZzZXQpID0+IHtcbiAgICBsZXQgdmFsdWUgPSAwO1xuICAgIGxldCBieXRlQ291bnQgPSAwO1xuICAgIHdoaWxlICgrK2J5dGVDb3VudCkge1xuICAgICAgY29uc3QgYnl0ZUluZGV4ID0gYnl0ZUNvdW50IC0gMTtcbiAgICAgIGNvbnN0IGN1cnJlbnRCeXRlID0gYnl0ZXNbb2Zmc2V0ICsgYnl0ZUluZGV4XTtcbiAgICAgIGNvbnN0IG5leHRTZXZlbkJpdHMgPSAxMjcgJiBjdXJyZW50Qnl0ZTtcbiAgICAgIHZhbHVlIHw9IG5leHRTZXZlbkJpdHMgPDwgYnl0ZUluZGV4ICogNztcbiAgICAgIGlmICgoY3VycmVudEJ5dGUgJiAxMjgpID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW3ZhbHVlLCBvZmZzZXQgKyBieXRlQ291bnRdO1xuICB9XG59KTtcbnZhciBnZXRTaG9ydFUxNkNvZGVjID0gKCkgPT4gY29tYmluZUNvZGVjKGdldFNob3J0VTE2RW5jb2RlcigpLCBnZXRTaG9ydFUxNkRlY29kZXIoKSk7XG52YXIgZ2V0VTEyOEVuY29kZXIgPSAoY29uZmlnID0ge30pID0+IG51bWJlckVuY29kZXJGYWN0b3J5KHtcbiAgY29uZmlnLFxuICBuYW1lOiBcInUxMjhcIixcbiAgcmFuZ2U6IFswbiwgQmlnSW50KFwiMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlwiKV0sXG4gIHNldDogKHZpZXcsIHZhbHVlLCBsZSkgPT4ge1xuICAgIGNvbnN0IGxlZnRPZmZzZXQgPSBsZSA/IDggOiAwO1xuICAgIGNvbnN0IHJpZ2h0T2Zmc2V0ID0gbGUgPyAwIDogODtcbiAgICBjb25zdCByaWdodE1hc2sgPSAweGZmZmZmZmZmZmZmZmZmZmZuO1xuICAgIHZpZXcuc2V0QmlnVWludDY0KGxlZnRPZmZzZXQsIEJpZ0ludCh2YWx1ZSkgPj4gNjRuLCBsZSk7XG4gICAgdmlldy5zZXRCaWdVaW50NjQocmlnaHRPZmZzZXQsIEJpZ0ludCh2YWx1ZSkgJiByaWdodE1hc2ssIGxlKTtcbiAgfSxcbiAgc2l6ZTogMTZcbn0pO1xudmFyIGdldFUxMjhEZWNvZGVyID0gKGNvbmZpZyA9IHt9KSA9PiBudW1iZXJEZWNvZGVyRmFjdG9yeSh7XG4gIGNvbmZpZyxcbiAgZ2V0OiAodmlldywgbGUpID0+IHtcbiAgICBjb25zdCBsZWZ0T2Zmc2V0ID0gbGUgPyA4IDogMDtcbiAgICBjb25zdCByaWdodE9mZnNldCA9IGxlID8gMCA6IDg7XG4gICAgY29uc3QgbGVmdCA9IHZpZXcuZ2V0QmlnVWludDY0KGxlZnRPZmZzZXQsIGxlKTtcbiAgICBjb25zdCByaWdodCA9IHZpZXcuZ2V0QmlnVWludDY0KHJpZ2h0T2Zmc2V0LCBsZSk7XG4gICAgcmV0dXJuIChsZWZ0IDw8IDY0bikgKyByaWdodDtcbiAgfSxcbiAgbmFtZTogXCJ1MTI4XCIsXG4gIHNpemU6IDE2XG59KTtcbnZhciBnZXRVMTI4Q29kZWMgPSAoY29uZmlnID0ge30pID0+IGNvbWJpbmVDb2RlYyhnZXRVMTI4RW5jb2Rlcihjb25maWcpLCBnZXRVMTI4RGVjb2Rlcihjb25maWcpKTtcbnZhciBnZXRVMTZFbmNvZGVyID0gKGNvbmZpZyA9IHt9KSA9PiBudW1iZXJFbmNvZGVyRmFjdG9yeSh7XG4gIGNvbmZpZyxcbiAgbmFtZTogXCJ1MTZcIixcbiAgcmFuZ2U6IFswLCBOdW1iZXIoXCIweGZmZmZcIildLFxuICBzZXQ6ICh2aWV3LCB2YWx1ZSwgbGUpID0+IHZpZXcuc2V0VWludDE2KDAsIE51bWJlcih2YWx1ZSksIGxlKSxcbiAgc2l6ZTogMlxufSk7XG52YXIgZ2V0VTE2RGVjb2RlciA9IChjb25maWcgPSB7fSkgPT4gbnVtYmVyRGVjb2RlckZhY3Rvcnkoe1xuICBjb25maWcsXG4gIGdldDogKHZpZXcsIGxlKSA9PiB2aWV3LmdldFVpbnQxNigwLCBsZSksXG4gIG5hbWU6IFwidTE2XCIsXG4gIHNpemU6IDJcbn0pO1xudmFyIGdldFUxNkNvZGVjID0gKGNvbmZpZyA9IHt9KSA9PiBjb21iaW5lQ29kZWMoZ2V0VTE2RW5jb2Rlcihjb25maWcpLCBnZXRVMTZEZWNvZGVyKGNvbmZpZykpO1xudmFyIGdldFUzMkVuY29kZXIgPSAoY29uZmlnID0ge30pID0+IG51bWJlckVuY29kZXJGYWN0b3J5KHtcbiAgY29uZmlnLFxuICBuYW1lOiBcInUzMlwiLFxuICByYW5nZTogWzAsIE51bWJlcihcIjB4ZmZmZmZmZmZcIildLFxuICBzZXQ6ICh2aWV3LCB2YWx1ZSwgbGUpID0+IHZpZXcuc2V0VWludDMyKDAsIE51bWJlcih2YWx1ZSksIGxlKSxcbiAgc2l6ZTogNFxufSk7XG52YXIgZ2V0VTMyRGVjb2RlciA9IChjb25maWcgPSB7fSkgPT4gbnVtYmVyRGVjb2RlckZhY3Rvcnkoe1xuICBjb25maWcsXG4gIGdldDogKHZpZXcsIGxlKSA9PiB2aWV3LmdldFVpbnQzMigwLCBsZSksXG4gIG5hbWU6IFwidTMyXCIsXG4gIHNpemU6IDRcbn0pO1xudmFyIGdldFUzMkNvZGVjID0gKGNvbmZpZyA9IHt9KSA9PiBjb21iaW5lQ29kZWMoZ2V0VTMyRW5jb2Rlcihjb25maWcpLCBnZXRVMzJEZWNvZGVyKGNvbmZpZykpO1xudmFyIGdldFU2NEVuY29kZXIgPSAoY29uZmlnID0ge30pID0+IG51bWJlckVuY29kZXJGYWN0b3J5KHtcbiAgY29uZmlnLFxuICBuYW1lOiBcInU2NFwiLFxuICByYW5nZTogWzBuLCBCaWdJbnQoXCIweGZmZmZmZmZmZmZmZmZmZmZcIildLFxuICBzZXQ6ICh2aWV3LCB2YWx1ZSwgbGUpID0+IHZpZXcuc2V0QmlnVWludDY0KDAsIEJpZ0ludCh2YWx1ZSksIGxlKSxcbiAgc2l6ZTogOFxufSk7XG52YXIgZ2V0VTY0RGVjb2RlciA9IChjb25maWcgPSB7fSkgPT4gbnVtYmVyRGVjb2RlckZhY3Rvcnkoe1xuICBjb25maWcsXG4gIGdldDogKHZpZXcsIGxlKSA9PiB2aWV3LmdldEJpZ1VpbnQ2NCgwLCBsZSksXG4gIG5hbWU6IFwidTY0XCIsXG4gIHNpemU6IDhcbn0pO1xudmFyIGdldFU2NENvZGVjID0gKGNvbmZpZyA9IHt9KSA9PiBjb21iaW5lQ29kZWMoZ2V0VTY0RW5jb2Rlcihjb25maWcpLCBnZXRVNjREZWNvZGVyKGNvbmZpZykpO1xudmFyIGdldFU4RW5jb2RlciA9ICgpID0+IG51bWJlckVuY29kZXJGYWN0b3J5KHtcbiAgbmFtZTogXCJ1OFwiLFxuICByYW5nZTogWzAsIE51bWJlcihcIjB4ZmZcIildLFxuICBzZXQ6ICh2aWV3LCB2YWx1ZSkgPT4gdmlldy5zZXRVaW50OCgwLCBOdW1iZXIodmFsdWUpKSxcbiAgc2l6ZTogMVxufSk7XG52YXIgZ2V0VThEZWNvZGVyID0gKCkgPT4gbnVtYmVyRGVjb2RlckZhY3Rvcnkoe1xuICBnZXQ6ICh2aWV3KSA9PiB2aWV3LmdldFVpbnQ4KDApLFxuICBuYW1lOiBcInU4XCIsXG4gIHNpemU6IDFcbn0pO1xudmFyIGdldFU4Q29kZWMgPSAoKSA9PiBjb21iaW5lQ29kZWMoZ2V0VThFbmNvZGVyKCksIGdldFU4RGVjb2RlcigpKTtcblxuZXhwb3J0IHsgRW5kaWFuLCBhc3NlcnROdW1iZXJJc0JldHdlZW5Gb3JDb2RlYywgZ2V0RjMyQ29kZWMsIGdldEYzMkRlY29kZXIsIGdldEYzMkVuY29kZXIsIGdldEY2NENvZGVjLCBnZXRGNjREZWNvZGVyLCBnZXRGNjRFbmNvZGVyLCBnZXRJMTI4Q29kZWMsIGdldEkxMjhEZWNvZGVyLCBnZXRJMTI4RW5jb2RlciwgZ2V0STE2Q29kZWMsIGdldEkxNkRlY29kZXIsIGdldEkxNkVuY29kZXIsIGdldEkzMkNvZGVjLCBnZXRJMzJEZWNvZGVyLCBnZXRJMzJFbmNvZGVyLCBnZXRJNjRDb2RlYywgZ2V0STY0RGVjb2RlciwgZ2V0STY0RW5jb2RlciwgZ2V0SThDb2RlYywgZ2V0SThEZWNvZGVyLCBnZXRJOEVuY29kZXIsIGdldFNob3J0VTE2Q29kZWMsIGdldFNob3J0VTE2RGVjb2RlciwgZ2V0U2hvcnRVMTZFbmNvZGVyLCBnZXRVMTI4Q29kZWMsIGdldFUxMjhEZWNvZGVyLCBnZXRVMTI4RW5jb2RlciwgZ2V0VTE2Q29kZWMsIGdldFUxNkRlY29kZXIsIGdldFUxNkVuY29kZXIsIGdldFUzMkNvZGVjLCBnZXRVMzJEZWNvZGVyLCBnZXRVMzJFbmNvZGVyLCBnZXRVNjRDb2RlYywgZ2V0VTY0RGVjb2RlciwgZ2V0VTY0RW5jb2RlciwgZ2V0VThDb2RlYywgZ2V0VThEZWNvZGVyLCBnZXRVOEVuY29kZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm5vZGUubWpzLm1hcFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubm9kZS5tanMubWFwIl0sIm5hbWVzIjpbIlNvbGFuYUVycm9yIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX05VTUJFUl9PVVRfT0ZfUkFOR0UiLCJjb21iaW5lQ29kZWMiLCJjcmVhdGVEZWNvZGVyIiwiY3JlYXRlRW5jb2RlciIsImFzc2VydEJ5dGVBcnJheUlzTm90RW1wdHlGb3JDb2RlYyIsImFzc2VydEJ5dGVBcnJheUhhc0Vub3VnaEJ5dGVzRm9yQ29kZWMiLCJhc3NlcnROdW1iZXJJc0JldHdlZW5Gb3JDb2RlYyIsImNvZGVjRGVzY3JpcHRpb24iLCJtaW4iLCJtYXgiLCJ2YWx1ZSIsIkVuZGlhbiIsIkVuZGlhbjIiLCJpc0xpdHRsZUVuZGlhbiIsImNvbmZpZyIsImVuZGlhbiIsIm51bWJlckVuY29kZXJGYWN0b3J5IiwiaW5wdXQiLCJmaXhlZFNpemUiLCJzaXplIiwid3JpdGUiLCJieXRlcyIsIm9mZnNldCIsInJhbmdlIiwibmFtZSIsImFycmF5QnVmZmVyIiwiQXJyYXlCdWZmZXIiLCJzZXQiLCJEYXRhVmlldyIsIlVpbnQ4QXJyYXkiLCJudW1iZXJEZWNvZGVyRmFjdG9yeSIsInJlYWQiLCJ2aWV3IiwidG9BcnJheUJ1ZmZlciIsImdldCIsImxlbmd0aCIsImJ5dGVzT2Zmc2V0IiwiYnl0ZU9mZnNldCIsImJ5dGVzTGVuZ3RoIiwiYnl0ZUxlbmd0aCIsImJ1ZmZlciIsInNsaWNlIiwiZ2V0RjMyRW5jb2RlciIsImxlIiwic2V0RmxvYXQzMiIsIk51bWJlciIsImdldEYzMkRlY29kZXIiLCJnZXRGbG9hdDMyIiwiZ2V0RjMyQ29kZWMiLCJnZXRGNjRFbmNvZGVyIiwic2V0RmxvYXQ2NCIsImdldEY2NERlY29kZXIiLCJnZXRGbG9hdDY0IiwiZ2V0RjY0Q29kZWMiLCJnZXRJMTI4RW5jb2RlciIsIkJpZ0ludCIsImxlZnRPZmZzZXQiLCJyaWdodE9mZnNldCIsInJpZ2h0TWFzayIsInNldEJpZ0ludDY0Iiwic2V0QmlnVWludDY0IiwiZ2V0STEyOERlY29kZXIiLCJsZWZ0IiwiZ2V0QmlnSW50NjQiLCJyaWdodCIsImdldEJpZ1VpbnQ2NCIsImdldEkxMjhDb2RlYyIsImdldEkxNkVuY29kZXIiLCJzZXRJbnQxNiIsImdldEkxNkRlY29kZXIiLCJnZXRJbnQxNiIsImdldEkxNkNvZGVjIiwiZ2V0STMyRW5jb2RlciIsInNldEludDMyIiwiZ2V0STMyRGVjb2RlciIsImdldEludDMyIiwiZ2V0STMyQ29kZWMiLCJnZXRJNjRFbmNvZGVyIiwiZ2V0STY0RGVjb2RlciIsImdldEk2NENvZGVjIiwiZ2V0SThFbmNvZGVyIiwic2V0SW50OCIsImdldEk4RGVjb2RlciIsImdldEludDgiLCJnZXRJOENvZGVjIiwiZ2V0U2hvcnRVMTZFbmNvZGVyIiwiZ2V0U2l6ZUZyb21WYWx1ZSIsIm1heFNpemUiLCJzaG9ydFUxNkJ5dGVzIiwiaWkiLCJhbGlnbmVkVmFsdWUiLCJuZXh0U2V2ZW5CaXRzIiwiZ2V0U2hvcnRVMTZEZWNvZGVyIiwiYnl0ZUNvdW50IiwiYnl0ZUluZGV4IiwiY3VycmVudEJ5dGUiLCJnZXRTaG9ydFUxNkNvZGVjIiwiZ2V0VTEyOEVuY29kZXIiLCJnZXRVMTI4RGVjb2RlciIsImdldFUxMjhDb2RlYyIsImdldFUxNkVuY29kZXIiLCJzZXRVaW50MTYiLCJnZXRVMTZEZWNvZGVyIiwiZ2V0VWludDE2IiwiZ2V0VTE2Q29kZWMiLCJnZXRVMzJFbmNvZGVyIiwic2V0VWludDMyIiwiZ2V0VTMyRGVjb2RlciIsImdldFVpbnQzMiIsImdldFUzMkNvZGVjIiwiZ2V0VTY0RW5jb2RlciIsImdldFU2NERlY29kZXIiLCJnZXRVNjRDb2RlYyIsImdldFU4RW5jb2RlciIsInNldFVpbnQ4IiwiZ2V0VThEZWNvZGVyIiwiZ2V0VWludDgiLCJnZXRVOENvZGVjIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@solana/codecs-numbers/dist/index.node.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@solana/errors/dist/index.node.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@solana/errors/dist/index.node.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND: () => (/* binding */ SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND),\n/* harmony export */   SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED: () => (/* binding */ SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED),\n/* harmony export */   SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT: () => (/* binding */ SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT),\n/* harmony export */   SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT: () => (/* binding */ SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT),\n/* harmony export */   SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND: () => (/* binding */ SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED: () => (/* binding */ SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS: () => (/* binding */ SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH: () => (/* binding */ SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY: () => (/* binding */ SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS: () => (/* binding */ SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE: () => (/* binding */ SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__MALFORMED_PDA: () => (/* binding */ SOLANA_ERROR__ADDRESSES__MALFORMED_PDA),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED: () => (/* binding */ SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED: () => (/* binding */ SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER: () => (/* binding */ SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED: () => (/* binding */ SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED),\n/* harmony export */   SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY: () => (/* binding */ SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY),\n/* harmony export */   SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS: () => (/* binding */ SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS),\n/* harmony export */   SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL: () => (/* binding */ SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL),\n/* harmony export */   SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH: () => (/* binding */ SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH),\n/* harmony export */   SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH: () => (/* binding */ SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH),\n/* harmony export */   SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH: () => (/* binding */ SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH),\n/* harmony export */   SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH: () => (/* binding */ SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH),\n/* harmony export */   SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH: () => (/* binding */ SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH),\n/* harmony export */   SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH: () => (/* binding */ SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH),\n/* harmony export */   SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE: () => (/* binding */ SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE),\n/* harmony export */   SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH: () => (/* binding */ SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH),\n/* harmony export */   SOLANA_ERROR__CODECS__INVALID_CONSTANT: () => (/* binding */ SOLANA_ERROR__CODECS__INVALID_CONSTANT),\n/* harmony export */   SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT: () => (/* binding */ SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT),\n/* harmony export */   SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT: () => (/* binding */ SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT),\n/* harmony export */   SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT: () => (/* binding */ SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT),\n/* harmony export */   SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS: () => (/* binding */ SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS),\n/* harmony export */   SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE: () => (/* binding */ SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE),\n/* harmony export */   SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES: () => (/* binding */ SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES),\n/* harmony export */   SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED: () => (/* binding */ SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS: () => (/* binding */ SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA: () => (/* binding */ SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH: () => (/* binding */ SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH),\n/* harmony export */   SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH: () => (/* binding */ SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH),\n/* harmony export */   SOLANA_ERROR__INVALID_NONCE: () => (/* binding */ SOLANA_ERROR__INVALID_NONCE),\n/* harmony export */   SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING: () => (/* binding */ SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING),\n/* harmony export */   SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED: () => (/* binding */ SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED),\n/* harmony export */   SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE: () => (/* binding */ SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE),\n/* harmony export */   SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING: () => (/* binding */ SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING),\n/* harmony export */   SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE: () => (/* binding */ SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR: () => (/* binding */ SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__INVALID_PARAMS: () => (/* binding */ SOLANA_ERROR__JSON_RPC__INVALID_PARAMS),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__INVALID_REQUEST: () => (/* binding */ SOLANA_ERROR__JSON_RPC__INVALID_REQUEST),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND: () => (/* binding */ SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__PARSE_ERROR: () => (/* binding */ SOLANA_ERROR__JSON_RPC__PARSE_ERROR),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SCAN_ERROR: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SCAN_ERROR),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION),\n/* harmony export */   SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH: () => (/* binding */ SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH),\n/* harmony export */   SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH: () => (/* binding */ SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH),\n/* harmony export */   SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH: () => (/* binding */ SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH),\n/* harmony export */   SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY: () => (/* binding */ SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY),\n/* harmony export */   SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__MALFORMED_BIGINT_STRING: () => (/* binding */ SOLANA_ERROR__MALFORMED_BIGINT_STRING),\n/* harmony export */   SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR: () => (/* binding */ SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR),\n/* harmony export */   SOLANA_ERROR__MALFORMED_NUMBER_STRING: () => (/* binding */ SOLANA_ERROR__MALFORMED_NUMBER_STRING),\n/* harmony export */   SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND: () => (/* binding */ SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND),\n/* harmony export */   SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN: () => (/* binding */ SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN),\n/* harmony export */   SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED: () => (/* binding */ SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED),\n/* harmony export */   SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED: () => (/* binding */ SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED),\n/* harmony export */   SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT: () => (/* binding */ SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT),\n/* harmony export */   SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID: () => (/* binding */ SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID),\n/* harmony export */   SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD: () => (/* binding */ SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD),\n/* harmony export */   SOLANA_ERROR__RPC__INTEGER_OVERFLOW: () => (/* binding */ SOLANA_ERROR__RPC__INTEGER_OVERFLOW),\n/* harmony export */   SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR: () => (/* binding */ SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR),\n/* harmony export */   SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN: () => (/* binding */ SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN),\n/* harmony export */   SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS: () => (/* binding */ SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS),\n/* harmony export */   SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER: () => (/* binding */ SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER),\n/* harmony export */   SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER: () => (/* binding */ SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER),\n/* harmony export */   SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER: () => (/* binding */ SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER),\n/* harmony export */   SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER: () => (/* binding */ SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER),\n/* harmony export */   SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER: () => (/* binding */ SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER),\n/* harmony export */   SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER: () => (/* binding */ SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER),\n/* harmony export */   SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER: () => (/* binding */ SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER),\n/* harmony export */   SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER: () => (/* binding */ SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER),\n/* harmony export */   SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS: () => (/* binding */ SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS),\n/* harmony export */   SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING: () => (/* binding */ SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING),\n/* harmony export */   SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED: () => (/* binding */ SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED),\n/* harmony export */   SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY: () => (/* binding */ SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY),\n/* harmony export */   SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED: () => (/* binding */ SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED),\n/* harmony export */   SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT: () => (/* binding */ SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT),\n/* harmony export */   SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED: () => (/* binding */ SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED),\n/* harmony export */   SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED: () => (/* binding */ SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED),\n/* harmony export */   SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED: () => (/* binding */ SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED),\n/* harmony export */   SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED: () => (/* binding */ SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED),\n/* harmony export */   SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED: () => (/* binding */ SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED),\n/* harmony export */   SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION: () => (/* binding */ SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING: () => (/* binding */ SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES: () => (/* binding */ SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT: () => (/* binding */ SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME: () => (/* binding */ SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME: () => (/* binding */ SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING: () => (/* binding */ SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING: () => (/* binding */ SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND: () => (/* binding */ SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT: () => (/* binding */ SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT: () => (/* binding */ SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING: () => (/* binding */ SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING: () => (/* binding */ SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE: () => (/* binding */ SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING: () => (/* binding */ SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES: () => (/* binding */ SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE: () => (/* binding */ SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH: () => (/* binding */ SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING: () => (/* binding */ SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE),\n/* harmony export */   SolanaError: () => (/* binding */ SolanaError),\n/* harmony export */   getSolanaErrorFromInstructionError: () => (/* binding */ getSolanaErrorFromInstructionError),\n/* harmony export */   getSolanaErrorFromJsonRpcError: () => (/* binding */ getSolanaErrorFromJsonRpcError),\n/* harmony export */   getSolanaErrorFromTransactionError: () => (/* binding */ getSolanaErrorFromTransactionError),\n/* harmony export */   isSolanaError: () => (/* binding */ isSolanaError),\n/* harmony export */   safeCaptureStackTrace: () => (/* binding */ safeCaptureStackTrace)\n/* harmony export */ });\n// src/codes.ts\nvar SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED = 1;\nvar SOLANA_ERROR__INVALID_NONCE = 2;\nvar SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND = 3;\nvar SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE = 4;\nvar SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH = 5;\nvar SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE = 6;\nvar SOLANA_ERROR__MALFORMED_BIGINT_STRING = 7;\nvar SOLANA_ERROR__MALFORMED_NUMBER_STRING = 8;\nvar SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE = 9;\nvar SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR = 10;\nvar SOLANA_ERROR__JSON_RPC__PARSE_ERROR = -32700;\nvar SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR = -32603;\nvar SOLANA_ERROR__JSON_RPC__INVALID_PARAMS = -32602;\nvar SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND = -32601;\nvar SOLANA_ERROR__JSON_RPC__INVALID_REQUEST = -32600;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED = -32016;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION = -32015;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET = -32014;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH = -32013;\nvar SOLANA_ERROR__JSON_RPC__SCAN_ERROR = -32012;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE = -32011;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX = -32010;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED = -32009;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT = -32008;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED = -32007;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE = -32006;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY = -32005;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE = -32004;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE = -32003;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE = -32002;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP = -32001;\nvar SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH = 28e5;\nvar SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE = 2800001;\nvar SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS = 2800002;\nvar SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY = 2800003;\nvar SOLANA_ERROR__ADDRESSES__MALFORMED_PDA = 2800004;\nvar SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE = 2800005;\nvar SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED = 2800006;\nvar SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED = 2800007;\nvar SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE = 2800008;\nvar SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED = 2800009;\nvar SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER = 2800010;\nvar SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS = 2800011;\nvar SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND = 323e4;\nvar SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND = 32300001;\nvar SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT = 3230002;\nvar SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT = 3230003;\nvar SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED = 3230004;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT = 361e4;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED = 3610001;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED = 3610002;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED = 3610003;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED = 3610004;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED = 3610005;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED = 3610006;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY = 3610007;\nvar SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED = 3611e3;\nvar SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH = 3704e3;\nvar SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH = 3704001;\nvar SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH = 3704002;\nvar SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE = 3704003;\nvar SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY = 3704004;\nvar SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS = 4128e3;\nvar SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA = 4128001;\nvar SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH = 4128002;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN = 4615e3;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR = 4615001;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT = 4615002;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA = 4615003;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA = 4615004;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL = 4615005;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS = 4615006;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID = 4615007;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE = 4615008;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED = 4615009;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT = 4615010;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION = 4615011;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID = 4615012;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND = 4615013;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED = 4615014;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE = 4615015;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED = 4615016;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX = 4615017;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED = 4615018;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED = 4615019;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS = 4615020;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED = 4615021;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE = 4615022;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED = 4615023;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 4615024;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC = 4615025;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM = 4615026;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR = 4615027;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED = 4615028;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE = 4615029;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT = 4615030;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID = 4615031;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH = 4615032;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT = 4615033;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED = 4615034;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED = 4615035;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS = 4615036;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC = 4615037;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED = 4615038;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION = 4615039;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE = 4615040;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE = 4615041;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE = 4615042;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE = 4615043;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY = 4615044;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR = 4615045;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT = 4615046;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER = 4615047;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW = 4615048;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR = 4615049;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER = 4615050;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED = 4615051;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED = 4615052;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED = 4615053;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS = 4615054;\nvar SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS = 5508e3;\nvar SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER = 5508001;\nvar SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER = 5508002;\nvar SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER = 5508003;\nvar SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER = 5508004;\nvar SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER = 5508005;\nvar SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER = 5508006;\nvar SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER = 5508007;\nvar SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER = 5508008;\nvar SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS = 5508009;\nvar SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING = 5508010;\nvar SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED = 5508011;\nvar SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES = 5663e3;\nvar SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE = 5663001;\nvar SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME = 5663002;\nvar SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME = 5663003;\nvar SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE = 5663004;\nvar SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING = 5663005;\nvar SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE = 5663006;\nvar SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND = 5663007;\nvar SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING = 5663008;\nvar SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING = 5663009;\nvar SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING = 5663010;\nvar SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING = 5663011;\nvar SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING = 5663012;\nvar SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING = 5663013;\nvar SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE = 5663014;\nvar SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION = 5663015;\nvar SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES = 5663016;\nvar SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH = 5663017;\nvar SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT = 5663018;\nvar SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT = 5663019;\nvar SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT = 5663020;\nvar SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN = 705e4;\nvar SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE = 7050001;\nvar SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE = 7050002;\nvar SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND = 7050003;\nvar SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND = 7050004;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE = 7050005;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE = 7050006;\nvar SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED = 7050007;\nvar SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND = 7050008;\nvar SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP = 7050009;\nvar SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE = 7050010;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX = 7050011;\nvar SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE = 7050012;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION = 7050013;\nvar SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE = 7050014;\nvar SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE = 7050015;\nvar SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 7050016;\nvar SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT = 7050017;\nvar SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION = 7050018;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT = 7050019;\nvar SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT = 7050020;\nvar SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT = 7050021;\nvar SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS = 7050022;\nvar SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND = 7050023;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER = 7050024;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA = 7050025;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX = 7050026;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT = 7050027;\nvar SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT = 7050028;\nvar SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT = 7050029;\nvar SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION = 7050030;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT = 7050031;\nvar SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED = 7050032;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT = 7050033;\nvar SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED = 7050034;\nvar SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED = 7050035;\nvar SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION = 7050036;\nvar SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY = 8078e3;\nvar SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH = 8078001;\nvar SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH = 8078002;\nvar SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH = 8078003;\nvar SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH = 8078004;\nvar SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH = 8078005;\nvar SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH = 8078006;\nvar SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS = 8078007;\nvar SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE = 8078008;\nvar SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT = 8078009;\nvar SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT = 8078010;\nvar SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE = 8078011;\nvar SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE = 8078012;\nvar SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH = 8078013;\nvar SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE = 8078014;\nvar SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT = 8078015;\nvar SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE = 8078016;\nvar SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE = 8078017;\nvar SOLANA_ERROR__CODECS__INVALID_CONSTANT = 8078018;\nvar SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE = 8078019;\nvar SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL = 8078020;\nvar SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES = 8078021;\nvar SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS = 8078022;\nvar SOLANA_ERROR__RPC__INTEGER_OVERFLOW = 81e5;\nvar SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN = 8100001;\nvar SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR = 8100002;\nvar SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD = 8100003;\nvar SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN = 819e4;\nvar SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID = 8190001;\nvar SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED = 8190002;\nvar SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED = 8190003;\nvar SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT = 8190004;\nvar SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING = 99e5;\nvar SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE = 9900001;\nvar SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING = 9900002;\nvar SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE = 9900003;\nvar SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED = 9900004;\n// src/context.ts\nfunction encodeValue(value) {\n    if (Array.isArray(value)) {\n        const commaSeparatedValues = value.map(encodeValue).join(\"%2C%20\");\n        return \"%5B\" + commaSeparatedValues + /* \"]\" */ \"%5D\";\n    } else if (typeof value === \"bigint\") {\n        return `${value}n`;\n    } else {\n        return encodeURIComponent(String(value != null && Object.getPrototypeOf(value) === null ? // Plain objects with no prototype don't have a `toString` method.\n        // Convert them before stringifying them.\n        {\n            ...value\n        } : value));\n    }\n}\nfunction encodeObjectContextEntry([key, value]) {\n    return `${key}=${encodeValue(value)}`;\n}\nfunction encodeContextObject(context) {\n    const searchParamsString = Object.entries(context).map(encodeObjectContextEntry).join(\"&\");\n    return Buffer.from(searchParamsString, \"utf8\").toString(\"base64\");\n}\n// src/messages.ts\nvar SolanaErrorMessages = {\n    [SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND]: \"Account not found at address: $address\",\n    [SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED]: \"Not all accounts were decoded. Encoded accounts found at addresses: $addresses.\",\n    [SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT]: \"Expected decoded account at address: $address\",\n    [SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT]: \"Failed to decode account data at address: $address\",\n    [SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND]: \"Accounts not found at addresses: $addresses\",\n    [SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED]: \"Unable to find a viable program address bump seed.\",\n    [SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS]: \"$putativeAddress is not a base58-encoded address.\",\n    [SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH]: \"Expected base58 encoded address to decode to a byte array of length 32. Actual length: $actualLength.\",\n    [SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY]: \"The `CryptoKey` must be an `Ed25519` public key.\",\n    [SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS]: \"$putativeOffCurveAddress is not a base58-encoded off-curve address.\",\n    [SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE]: \"Invalid seeds; point must fall off the Ed25519 curve.\",\n    [SOLANA_ERROR__ADDRESSES__MALFORMED_PDA]: \"Expected given program derived address to have the following format: [Address, ProgramDerivedAddressBump].\",\n    [SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED]: \"A maximum of $maxSeeds seeds, including the bump seed, may be supplied when creating an address. Received: $actual.\",\n    [SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED]: \"The seed at index $index with length $actual exceeds the maximum length of $maxSeedLength bytes.\",\n    [SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE]: \"Expected program derived address bump to be in the range [0, 255], got: $bump.\",\n    [SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER]: \"Program address cannot end with PDA marker.\",\n    [SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE]: \"Expected base58-encoded address string of length in the range [32, 44]. Actual length: $actualLength.\",\n    [SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE]: \"Expected base58-encoded blockash string of length in the range [32, 44]. Actual length: $actualLength.\",\n    [SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED]: \"The network has progressed past the last block for which this transaction could have been committed.\",\n    [SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY]: \"Codec [$codecDescription] cannot decode empty byte arrays.\",\n    [SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS]: \"Enum codec cannot use lexical values [$stringValues] as discriminators. Either remove all lexical values or set `useValuesAsDiscriminators` to `false`.\",\n    [SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL]: \"Sentinel [$hexSentinel] must not be present in encoded bytes [$hexEncodedBytes].\",\n    [SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH]: \"Encoder and decoder must have the same fixed size, got [$encoderFixedSize] and [$decoderFixedSize].\",\n    [SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH]: \"Encoder and decoder must have the same max size, got [$encoderMaxSize] and [$decoderMaxSize].\",\n    [SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH]: \"Encoder and decoder must either both be fixed-size or variable-size.\",\n    [SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE]: \"Enum discriminator out of range. Expected a number in [$formattedValidDiscriminators], got $discriminator.\",\n    [SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH]: \"Expected a fixed-size codec, got a variable-size one.\",\n    [SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH]: \"Codec [$codecDescription] expected a positive byte length, got $bytesLength.\",\n    [SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH]: \"Expected a variable-size codec, got a fixed-size one.\",\n    [SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE]: \"Codec [$codecDescription] expected zero-value [$hexZeroValue] to have the same size as the provided fixed-size item [$expectedSize bytes].\",\n    [SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH]: \"Codec [$codecDescription] expected $expected bytes, got $bytesLength.\",\n    [SOLANA_ERROR__CODECS__INVALID_CONSTANT]: \"Expected byte array constant [$hexConstant] to be present in data [$hexData] at offset [$offset].\",\n    [SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT]: \"Invalid discriminated union variant. Expected one of [$variants], got $value.\",\n    [SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT]: \"Invalid enum variant. Expected one of [$stringValues] or a number in [$formattedNumericalValues], got $variant.\",\n    [SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT]: \"Invalid literal union variant. Expected one of [$variants], got $value.\",\n    [SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS]: \"Expected [$codecDescription] to have $expected items, got $actual.\",\n    [SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE]: \"Invalid value $value for base $base with alphabet $alphabet.\",\n    [SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE]: \"Literal union discriminator out of range. Expected a number between $minRange and $maxRange, got $discriminator.\",\n    [SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE]: \"Codec [$codecDescription] expected number to be in the range [$min, $max], got $value.\",\n    [SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE]: \"Codec [$codecDescription] expected offset to be in the range [0, $bytesLength], got $offset.\",\n    [SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES]: \"Expected sentinel [$hexSentinel] to be present in decoded bytes [$hexDecodedBytes].\",\n    [SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE]: \"Union variant out of range. Expected an index between $minRange and $maxRange, got $variant.\",\n    [SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED]: \"No random values implementation could be found.\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED]: \"instruction requires an uninitialized account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED]: \"instruction tries to borrow reference for an account which is already borrowed\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]: \"instruction left account with an outstanding borrowed reference\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED]: \"program other than the account's owner changed the size of the account data\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL]: \"account data too small for instruction\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE]: \"instruction expected an executable account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT]: \"An account does not have enough lamports to be rent-exempt\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW]: \"Program arithmetic overflowed\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR]: \"Failed to serialize or deserialize account data: $encodedData\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS]: \"Builtin programs must consume compute units\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH]: \"Cross-program invocation call depth too deep\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED]: \"Computational budget exceeded\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM]: \"custom program error: #$code\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX]: \"instruction contains duplicate accounts\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC]: \"instruction modifications of multiply-passed account differ\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT]: \"executable accounts must be rent exempt\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED]: \"instruction changed executable accounts data\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE]: \"instruction changed the balance of an executable account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED]: \"instruction changed executable bit of an account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED]: \"instruction modified data of an account it does not own\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND]: \"instruction spent from the balance of an account it does not own\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR]: \"generic instruction error\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER]: \"Provided owner is not allowed\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE]: \"Account is immutable\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY]: \"Incorrect authority provided\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID]: \"incorrect program id for instruction\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS]: \"insufficient funds for instruction\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA]: \"invalid account data for instruction\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER]: \"Invalid account owner\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT]: \"invalid program argument\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR]: \"program returned invalid error code\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA]: \"invalid instruction data\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC]: \"Failed to reallocate account data\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS]: \"Provided seeds do not result in a valid address\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED]: \"Accounts data allocations exceeded the maximum allowed per transaction\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED]: \"Max accounts exceeded\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED]: \"Max instruction trace length exceeded\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED]: \"Length of the seed is too long for address generation\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT]: \"An account required by the instruction is missing\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE]: \"missing required signature for instruction\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID]: \"instruction illegally modified the program id of an account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS]: \"insufficient account keys for instruction\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION]: \"Cross-program invocation with unauthorized signer or writable account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE]: \"Failed to create program execution environment\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE]: \"Program failed to compile\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE]: \"Program failed to complete\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED]: \"instruction modified data of a read-only account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE]: \"instruction changed the balance of a read-only account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED]: \"Cross-program invocation reentrancy not allowed for this instruction\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED]: \"instruction modified rent epoch of an account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION]: \"sum of account balances before and after instruction do not match\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT]: \"instruction requires an initialized account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN]: \"\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID]: \"Unsupported program id\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR]: \"Unsupported sysvar\",\n    [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS]: \"The instruction does not have any accounts.\",\n    [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA]: \"The instruction does not have any data.\",\n    [SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH]: \"Expected instruction to have progress address $expectedProgramAddress, got $actualProgramAddress.\",\n    [SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH]: \"Expected base58 encoded blockhash to decode to a byte array of length 32. Actual length: $actualLength.\",\n    [SOLANA_ERROR__INVALID_NONCE]: \"The nonce `$expectedNonceValue` is no longer valid. It has advanced to `$actualNonceValue`\",\n    [SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING]: \"Invariant violation: Found no abortable iterable cache entry for key `$cacheKey`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant\",\n    [SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED]: \"Invariant violation: This data publisher does not publish to the channel named `$channelName`. Supported channels include $supportedChannelNames.\",\n    [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE]: \"Invariant violation: WebSocket message iterator state is corrupt; iterated without first resolving existing message promise. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant\",\n    [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING]: \"Invariant violation: WebSocket message iterator is missing state storage. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant\",\n    [SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE]: \"Invariant violation: Switch statement non-exhaustive. Received unexpected value `$unexpectedValue`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant\",\n    [SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR]: \"JSON-RPC error: Internal JSON-RPC error ($__serverMessage)\",\n    [SOLANA_ERROR__JSON_RPC__INVALID_PARAMS]: \"JSON-RPC error: Invalid method parameter(s) ($__serverMessage)\",\n    [SOLANA_ERROR__JSON_RPC__INVALID_REQUEST]: \"JSON-RPC error: The JSON sent is not a valid `Request` object ($__serverMessage)\",\n    [SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND]: \"JSON-RPC error: The method does not exist / is not available ($__serverMessage)\",\n    [SOLANA_ERROR__JSON_RPC__PARSE_ERROR]: \"JSON-RPC error: An error occurred on the server while parsing the JSON text ($__serverMessage)\",\n    [SOLANA_ERROR__JSON_RPC__SCAN_ERROR]: \"$__serverMessage\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP]: \"$__serverMessage\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE]: \"$__serverMessage\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET]: \"$__serverMessage\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX]: \"$__serverMessage\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED]: \"$__serverMessage\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED]: \"Minimum context slot has not been reached\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY]: \"Node is unhealthy; behind by $numSlotsBehind slots\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT]: \"No snapshot\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE]: \"Transaction simulation failed\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED]: \"$__serverMessage\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE]: \"Transaction history is not available from this node\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE]: \"$__serverMessage\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH]: \"Transaction signature length mismatch\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE]: \"Transaction signature verification failure\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION]: \"$__serverMessage\",\n    [SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH]: \"Key pair bytes must be of length 64, got $byteLength.\",\n    [SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH]: \"Expected private key bytes with length 32. Actual length: $actualLength.\",\n    [SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH]: \"Expected base58-encoded signature to decode to a byte array of length 64. Actual length: $actualLength.\",\n    [SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY]: \"The provided private key does not match the provided public key.\",\n    [SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE]: \"Expected base58-encoded signature string of length in the range [64, 88]. Actual length: $actualLength.\",\n    [SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE]: \"Lamports value must be in the range [0, 2e64-1]\",\n    [SOLANA_ERROR__MALFORMED_BIGINT_STRING]: \"`$value` cannot be parsed as a `BigInt`\",\n    [SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR]: \"$message\",\n    [SOLANA_ERROR__MALFORMED_NUMBER_STRING]: \"`$value` cannot be parsed as a `Number`\",\n    [SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND]: \"No nonce account could be found at address `$nonceAccountAddress`\",\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN]: \"The notification name must end in 'Notifications' and the API must supply a subscription plan creator function for the notification '$notificationName'.\",\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED]: \"WebSocket was closed before payload could be added to the send buffer\",\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED]: \"WebSocket connection closed\",\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT]: \"WebSocket failed to connect\",\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID]: \"Failed to obtain a subscription id from the server\",\n    [SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD]: \"Could not find an API plan for RPC method: `$method`\",\n    [SOLANA_ERROR__RPC__INTEGER_OVERFLOW]: \"The $argumentLabel argument to the `$methodName` RPC method$optionalPathLabel was `$value`. This number is unsafe for use with the Solana JSON-RPC because it exceeds `Number.MAX_SAFE_INTEGER`.\",\n    [SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR]: \"HTTP error ($statusCode): $message\",\n    [SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN]: \"HTTP header(s) forbidden: $headers. Learn more at https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name.\",\n    [SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS]: \"Multiple distinct signers were identified for address `$address`. Please ensure that you are using the same signer instance for each address.\",\n    [SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER]: \"The provided value does not implement the `KeyPairSigner` interface\",\n    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER]: \"The provided value does not implement the `MessageModifyingSigner` interface\",\n    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER]: \"The provided value does not implement the `MessagePartialSigner` interface\",\n    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER]: \"The provided value does not implement any of the `MessageSigner` interfaces\",\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER]: \"The provided value does not implement the `TransactionModifyingSigner` interface\",\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER]: \"The provided value does not implement the `TransactionPartialSigner` interface\",\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER]: \"The provided value does not implement the `TransactionSendingSigner` interface\",\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER]: \"The provided value does not implement any of the `TransactionSigner` interfaces\",\n    [SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS]: \"More than one `TransactionSendingSigner` was identified.\",\n    [SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING]: \"No `TransactionSendingSigner` was identified. Please provide a valid `TransactionWithSingleSendingSigner` transaction.\",\n    [SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED]: \"Wallet account signers do not support signing multiple messages/transactions in a single operation\",\n    [SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY]: \"Cannot export a non-extractable key.\",\n    [SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED]: \"No digest implementation could be found.\",\n    [SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT]: \"Cryptographic operations are only allowed in secure browser contexts. Read more here: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts.\",\n    [SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED]: \"This runtime does not support the generation of Ed25519 key pairs.\\n\\nInstall @solana/webcrypto-ed25519-polyfill and call its `install` function before generating keys in environments that do not support Ed25519.\\n\\nFor a list of runtimes that currently support Ed25519 operations, visit https://github.com/WICG/webcrypto-secure-curves/issues/20.\",\n    [SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED]: \"No signature verification implementation could be found.\",\n    [SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED]: \"No key generation implementation could be found.\",\n    [SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED]: \"No signing implementation could be found.\",\n    [SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED]: \"No key export implementation could be found.\",\n    [SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE]: \"Timestamp value must be in the range [-(2n ** 63n), (2n ** 63n) - 1]. `$value` given\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]: \"Transaction processing left an account with an outstanding borrowed reference\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE]: \"Account in use\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE]: \"Account loaded twice\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND]: \"Attempt to debit an account but found no record of a prior credit.\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND]: \"Transaction loads an address table account that doesn't exist\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED]: \"This transaction has already been processed\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND]: \"Blockhash not found\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP]: \"Loader call chain is too deep\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE]: \"Transactions are currently disabled due to cluster maintenance\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION]: \"Transaction contains a duplicate instruction ($index) that is not allowed\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE]: \"Insufficient funds for fee\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT]: \"Transaction results in an account ($accountIndex) with insufficient funds for rent\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE]: \"This account may not be used to pay transaction fees\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX]: \"Transaction contains an invalid account reference\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA]: \"Transaction loads an address table account with invalid data\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX]: \"Transaction address table lookup uses an invalid index\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER]: \"Transaction loads an address table account with an invalid owner\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT]: \"LoadedAccountsDataSizeLimit set for transaction must be greater than 0.\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION]: \"This program may not be used for executing instructions\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT]: \"Transaction leaves an account with a lower balance than rent-exempt minimum\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT]: \"Transaction loads a writable account that cannot be written\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED]: \"Transaction exceeded max loaded accounts data size cap\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE]: \"Transaction requires a fee but has no signature present\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND]: \"Attempt to load a program that does not exist\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED]: \"Execution of the program referenced by account at index $accountIndex is temporarily restricted.\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED]: \"ResanitizationNeeded\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE]: \"Transaction failed to sanitize accounts offsets correctly\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE]: \"Transaction did not pass signature verification\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS]: \"Transaction locked too many accounts\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION]: \"Sum of account balances before and after transaction do not match\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN]: \"The transaction failed with the error `$errorName`\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION]: \"Transaction version is unsupported\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT]: \"Transaction would exceed account data limit within the block\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT]: \"Transaction would exceed total account data limit\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT]: \"Transaction would exceed max account limit within the block\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT]: \"Transaction would exceed max Block Cost Limit\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT]: \"Transaction would exceed max Vote Cost Limit\",\n    [SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION]: \"Attempted to sign a transaction with an address that is not a signer for it\",\n    [SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING]: \"Transaction is missing an address at index: $index.\",\n    [SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES]: \"Transaction has no expected signers therefore it cannot be encoded\",\n    [SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT]: \"Transaction size $transactionSize exceeds limit of $transactionSizeLimit bytes\",\n    [SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME]: \"Transaction does not have a blockhash lifetime\",\n    [SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME]: \"Transaction is not a durable nonce transaction\",\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING]: \"Contents of these address lookup tables unknown: $lookupTableAddresses\",\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE]: \"Lookup of address at index $highestRequestedIndex failed for lookup table `$lookupTableAddress`. Highest known index is $highestKnownIndex. The lookup table may have been extended since its contents were retrieved\",\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING]: \"No fee payer set in CompiledTransaction\",\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND]: \"Could not find program address at index $index\",\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT]: \"Failed to estimate the compute unit consumption for this transaction message. This is likely because simulating the transaction failed. Inspect the `cause` property of this error to learn more\",\n    [SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT]: \"Transaction failed when it was simulated in order to estimate the compute unit consumption. The compute unit estimate provided is for a transaction that failed when simulated and may not be representative of the compute units this transaction would consume if successful. Inspect the `cause` property of this error to learn more\",\n    [SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING]: \"Transaction is missing a fee payer.\",\n    [SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING]: \"Could not determine this transaction's signature. Make sure that the transaction has been signed by its fee payer.\",\n    [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE]: \"Transaction first instruction is not advance nonce account instruction.\",\n    [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING]: \"Transaction with no instructions cannot be durable nonce transaction.\",\n    [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES]: \"This transaction includes an address (`$programAddress`) which is both invoked and set as the fee payer. Program addresses may not pay fees\",\n    [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE]: \"This transaction includes an address (`$programAddress`) which is both invoked and marked writable. Program addresses may not be writable\",\n    [SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH]: \"The transaction message expected the transaction to have $signerAddressesLength signatures, got $signaturesLength.\",\n    [SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING]: \"Transaction is missing signatures for addresses: $addresses.\",\n    [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE]: \"Transaction version must be in the range [0, 127]. `$actualVersion` given\"\n};\n// src/message-formatter.ts\nvar START_INDEX = \"i\";\nvar TYPE = \"t\";\nfunction getHumanReadableErrorMessage(code, context = {}) {\n    const messageFormatString = SolanaErrorMessages[code];\n    if (messageFormatString.length === 0) {\n        return \"\";\n    }\n    let state;\n    function commitStateUpTo(endIndex) {\n        if (state[TYPE] === 2 /* Variable */ ) {\n            const variableName = messageFormatString.slice(state[START_INDEX] + 1, endIndex);\n            fragments.push(variableName in context ? // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n            `${context[variableName]}` : `$${variableName}`);\n        } else if (state[TYPE] === 1 /* Text */ ) {\n            fragments.push(messageFormatString.slice(state[START_INDEX], endIndex));\n        }\n    }\n    const fragments = [];\n    messageFormatString.split(\"\").forEach((char, ii)=>{\n        if (ii === 0) {\n            state = {\n                [START_INDEX]: 0,\n                [TYPE]: messageFormatString[0] === \"\\\\\" ? 0 /* EscapeSequence */  : messageFormatString[0] === \"$\" ? 2 /* Variable */  : 1 /* Text */ \n            };\n            return;\n        }\n        let nextState;\n        switch(state[TYPE]){\n            case 0 /* EscapeSequence */ :\n                nextState = {\n                    [START_INDEX]: ii,\n                    [TYPE]: 1 /* Text */ \n                };\n                break;\n            case 1 /* Text */ :\n                if (char === \"\\\\\") {\n                    nextState = {\n                        [START_INDEX]: ii,\n                        [TYPE]: 0 /* EscapeSequence */ \n                    };\n                } else if (char === \"$\") {\n                    nextState = {\n                        [START_INDEX]: ii,\n                        [TYPE]: 2 /* Variable */ \n                    };\n                }\n                break;\n            case 2 /* Variable */ :\n                if (char === \"\\\\\") {\n                    nextState = {\n                        [START_INDEX]: ii,\n                        [TYPE]: 0 /* EscapeSequence */ \n                    };\n                } else if (char === \"$\") {\n                    nextState = {\n                        [START_INDEX]: ii,\n                        [TYPE]: 2 /* Variable */ \n                    };\n                } else if (!char.match(/\\w/)) {\n                    nextState = {\n                        [START_INDEX]: ii,\n                        [TYPE]: 1 /* Text */ \n                    };\n                }\n                break;\n        }\n        if (nextState) {\n            if (state !== nextState) {\n                commitStateUpTo(ii);\n            }\n            state = nextState;\n        }\n    });\n    commitStateUpTo();\n    return fragments.join(\"\");\n}\nfunction getErrorMessage(code, context = {}) {\n    if (true) {\n        return getHumanReadableErrorMessage(code, context);\n    } else {}\n}\n// src/error.ts\nfunction isSolanaError(e, code) {\n    const isSolanaError2 = e instanceof Error && e.name === \"SolanaError\";\n    if (isSolanaError2) {\n        if (code !== void 0) {\n            return e.context.__code === code;\n        }\n        return true;\n    }\n    return false;\n}\nvar SolanaError = class extends Error {\n    constructor(...[code, contextAndErrorOptions]){\n        let context;\n        let errorOptions;\n        if (contextAndErrorOptions) {\n            const { cause, ...contextRest } = contextAndErrorOptions;\n            if (cause) {\n                errorOptions = {\n                    cause\n                };\n            }\n            if (Object.keys(contextRest).length > 0) {\n                context = contextRest;\n            }\n        }\n        const message = getErrorMessage(code, context);\n        super(message, errorOptions);\n        /**\n   * Indicates the root cause of this {@link SolanaError}, if any.\n   *\n   * For example, a transaction error might have an instruction error as its root cause. In this\n   * case, you will be able to access the instruction error on the transaction error as `cause`.\n   */ this.cause = this.cause;\n        this.context = {\n            __code: code,\n            ...context\n        };\n        this.name = \"SolanaError\";\n    }\n};\n// src/stack-trace.ts\nfunction safeCaptureStackTrace(...args) {\n    if (\"captureStackTrace\" in Error && typeof Error.captureStackTrace === \"function\") {\n        Error.captureStackTrace(...args);\n    }\n}\n// src/rpc-enum-errors.ts\nfunction getSolanaErrorFromRpcError({ errorCodeBaseOffset, getErrorContext, orderedErrorNames, rpcEnumError }, constructorOpt) {\n    let rpcErrorName;\n    let rpcErrorContext;\n    if (typeof rpcEnumError === \"string\") {\n        rpcErrorName = rpcEnumError;\n    } else {\n        rpcErrorName = Object.keys(rpcEnumError)[0];\n        rpcErrorContext = rpcEnumError[rpcErrorName];\n    }\n    const codeOffset = orderedErrorNames.indexOf(rpcErrorName);\n    const errorCode = errorCodeBaseOffset + codeOffset;\n    const errorContext = getErrorContext(errorCode, rpcErrorName, rpcErrorContext);\n    const err = new SolanaError(errorCode, errorContext);\n    safeCaptureStackTrace(err, constructorOpt);\n    return err;\n}\n// src/instruction-error.ts\nvar ORDERED_ERROR_NAMES = [\n    // Keep synced with RPC source: https://github.com/anza-xyz/agave/blob/master/sdk/program/src/instruction.rs\n    // If this list ever gets too large, consider implementing a compression strategy like this:\n    // https://gist.github.com/steveluscher/aaa7cbbb5433b1197983908a40860c47\n    \"GenericError\",\n    \"InvalidArgument\",\n    \"InvalidInstructionData\",\n    \"InvalidAccountData\",\n    \"AccountDataTooSmall\",\n    \"InsufficientFunds\",\n    \"IncorrectProgramId\",\n    \"MissingRequiredSignature\",\n    \"AccountAlreadyInitialized\",\n    \"UninitializedAccount\",\n    \"UnbalancedInstruction\",\n    \"ModifiedProgramId\",\n    \"ExternalAccountLamportSpend\",\n    \"ExternalAccountDataModified\",\n    \"ReadonlyLamportChange\",\n    \"ReadonlyDataModified\",\n    \"DuplicateAccountIndex\",\n    \"ExecutableModified\",\n    \"RentEpochModified\",\n    \"NotEnoughAccountKeys\",\n    \"AccountDataSizeChanged\",\n    \"AccountNotExecutable\",\n    \"AccountBorrowFailed\",\n    \"AccountBorrowOutstanding\",\n    \"DuplicateAccountOutOfSync\",\n    \"Custom\",\n    \"InvalidError\",\n    \"ExecutableDataModified\",\n    \"ExecutableLamportChange\",\n    \"ExecutableAccountNotRentExempt\",\n    \"UnsupportedProgramId\",\n    \"CallDepth\",\n    \"MissingAccount\",\n    \"ReentrancyNotAllowed\",\n    \"MaxSeedLengthExceeded\",\n    \"InvalidSeeds\",\n    \"InvalidRealloc\",\n    \"ComputationalBudgetExceeded\",\n    \"PrivilegeEscalation\",\n    \"ProgramEnvironmentSetupFailure\",\n    \"ProgramFailedToComplete\",\n    \"ProgramFailedToCompile\",\n    \"Immutable\",\n    \"IncorrectAuthority\",\n    \"BorshIoError\",\n    \"AccountNotRentExempt\",\n    \"InvalidAccountOwner\",\n    \"ArithmeticOverflow\",\n    \"UnsupportedSysvar\",\n    \"IllegalOwner\",\n    \"MaxAccountsDataAllocationsExceeded\",\n    \"MaxAccountsExceeded\",\n    \"MaxInstructionTraceLengthExceeded\",\n    \"BuiltinProgramsMustConsumeComputeUnits\"\n];\nfunction getSolanaErrorFromInstructionError(index, instructionError) {\n    const numberIndex = Number(index);\n    return getSolanaErrorFromRpcError({\n        errorCodeBaseOffset: 4615001,\n        getErrorContext (errorCode, rpcErrorName, rpcErrorContext) {\n            if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN) {\n                return {\n                    errorName: rpcErrorName,\n                    index: numberIndex,\n                    ...rpcErrorContext !== void 0 ? {\n                        instructionErrorContext: rpcErrorContext\n                    } : null\n                };\n            } else if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM) {\n                return {\n                    code: Number(rpcErrorContext),\n                    index: numberIndex\n                };\n            } else if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR) {\n                return {\n                    encodedData: rpcErrorContext,\n                    index: numberIndex\n                };\n            }\n            return {\n                index: numberIndex\n            };\n        },\n        orderedErrorNames: ORDERED_ERROR_NAMES,\n        rpcEnumError: instructionError\n    }, getSolanaErrorFromInstructionError);\n}\n// src/transaction-error.ts\nvar ORDERED_ERROR_NAMES2 = [\n    // Keep synced with RPC source: https://github.com/anza-xyz/agave/blob/master/sdk/src/transaction/error.rs\n    // If this list ever gets too large, consider implementing a compression strategy like this:\n    // https://gist.github.com/steveluscher/aaa7cbbb5433b1197983908a40860c47\n    \"AccountInUse\",\n    \"AccountLoadedTwice\",\n    \"AccountNotFound\",\n    \"ProgramAccountNotFound\",\n    \"InsufficientFundsForFee\",\n    \"InvalidAccountForFee\",\n    \"AlreadyProcessed\",\n    \"BlockhashNotFound\",\n    // `InstructionError` intentionally omitted; delegated to `getSolanaErrorFromInstructionError`\n    \"CallChainTooDeep\",\n    \"MissingSignatureForFee\",\n    \"InvalidAccountIndex\",\n    \"SignatureFailure\",\n    \"InvalidProgramForExecution\",\n    \"SanitizeFailure\",\n    \"ClusterMaintenance\",\n    \"AccountBorrowOutstanding\",\n    \"WouldExceedMaxBlockCostLimit\",\n    \"UnsupportedVersion\",\n    \"InvalidWritableAccount\",\n    \"WouldExceedMaxAccountCostLimit\",\n    \"WouldExceedAccountDataBlockLimit\",\n    \"TooManyAccountLocks\",\n    \"AddressLookupTableNotFound\",\n    \"InvalidAddressLookupTableOwner\",\n    \"InvalidAddressLookupTableData\",\n    \"InvalidAddressLookupTableIndex\",\n    \"InvalidRentPayingAccount\",\n    \"WouldExceedMaxVoteCostLimit\",\n    \"WouldExceedAccountDataTotalLimit\",\n    \"DuplicateInstruction\",\n    \"InsufficientFundsForRent\",\n    \"MaxLoadedAccountsDataSizeExceeded\",\n    \"InvalidLoadedAccountsDataSizeLimit\",\n    \"ResanitizationNeeded\",\n    \"ProgramExecutionTemporarilyRestricted\",\n    \"UnbalancedTransaction\"\n];\nfunction getSolanaErrorFromTransactionError(transactionError) {\n    if (typeof transactionError === \"object\" && \"InstructionError\" in transactionError) {\n        return getSolanaErrorFromInstructionError(...transactionError.InstructionError);\n    }\n    return getSolanaErrorFromRpcError({\n        errorCodeBaseOffset: 7050001,\n        getErrorContext (errorCode, rpcErrorName, rpcErrorContext) {\n            if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN) {\n                return {\n                    errorName: rpcErrorName,\n                    ...rpcErrorContext !== void 0 ? {\n                        transactionErrorContext: rpcErrorContext\n                    } : null\n                };\n            } else if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION) {\n                return {\n                    index: Number(rpcErrorContext)\n                };\n            } else if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT || errorCode === SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED) {\n                return {\n                    accountIndex: Number(rpcErrorContext.account_index)\n                };\n            }\n        },\n        orderedErrorNames: ORDERED_ERROR_NAMES2,\n        rpcEnumError: transactionError\n    }, getSolanaErrorFromTransactionError);\n}\n// src/json-rpc-error.ts\nfunction getSolanaErrorFromJsonRpcError(putativeErrorResponse) {\n    let out;\n    if (isRpcErrorResponse(putativeErrorResponse)) {\n        const { code: rawCode, data, message } = putativeErrorResponse;\n        const code = Number(rawCode);\n        if (code === SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE) {\n            const { err, ...preflightErrorContext } = data;\n            const causeObject = err ? {\n                cause: getSolanaErrorFromTransactionError(err)\n            } : null;\n            out = new SolanaError(SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE, {\n                ...preflightErrorContext,\n                ...causeObject\n            });\n        } else {\n            let errorContext;\n            switch(code){\n                case SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR:\n                case SOLANA_ERROR__JSON_RPC__INVALID_PARAMS:\n                case SOLANA_ERROR__JSON_RPC__INVALID_REQUEST:\n                case SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND:\n                case SOLANA_ERROR__JSON_RPC__PARSE_ERROR:\n                case SOLANA_ERROR__JSON_RPC__SCAN_ERROR:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION:\n                    errorContext = {\n                        __serverMessage: message\n                    };\n                    break;\n                default:\n                    if (typeof data === \"object\" && !Array.isArray(data)) {\n                        errorContext = data;\n                    }\n            }\n            out = new SolanaError(code, errorContext);\n        }\n    } else {\n        const message = typeof putativeErrorResponse === \"object\" && putativeErrorResponse !== null && \"message\" in putativeErrorResponse && typeof putativeErrorResponse.message === \"string\" ? putativeErrorResponse.message : \"Malformed JSON-RPC error with no message attribute\";\n        out = new SolanaError(SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR, {\n            error: putativeErrorResponse,\n            message\n        });\n    }\n    safeCaptureStackTrace(out, getSolanaErrorFromJsonRpcError);\n    return out;\n}\nfunction isRpcErrorResponse(value) {\n    return typeof value === \"object\" && value !== null && \"code\" in value && \"message\" in value && (typeof value.code === \"number\" || typeof value.code === \"bigint\") && typeof value.message === \"string\";\n}\n //# sourceMappingURL=index.node.mjs.map\n //# sourceMappingURL=index.node.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS9lcnJvcnMvZGlzdC9pbmRleC5ub2RlLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLGVBQWU7QUFDZixJQUFJQSxzQ0FBc0M7QUFDMUMsSUFBSUMsOEJBQThCO0FBQ2xDLElBQUlDLHdDQUF3QztBQUM1QyxJQUFJQyxxREFBcUQ7QUFDekQsSUFBSUMsOENBQThDO0FBQ2xELElBQUlDLHNDQUFzQztBQUMxQyxJQUFJQyx3Q0FBd0M7QUFDNUMsSUFBSUMsd0NBQXdDO0FBQzVDLElBQUlDLHVDQUF1QztBQUMzQyxJQUFJQyx5Q0FBeUM7QUFDN0MsSUFBSUMsc0NBQXNDLENBQUM7QUFDM0MsSUFBSUMseUNBQXlDLENBQUM7QUFDOUMsSUFBSUMseUNBQXlDLENBQUM7QUFDOUMsSUFBSUMsMkNBQTJDLENBQUM7QUFDaEQsSUFBSUMsMENBQTBDLENBQUM7QUFDL0MsSUFBSUMsb0VBQW9FLENBQUM7QUFDekUsSUFBSUMsdUVBQXVFLENBQUM7QUFDNUUsSUFBSUMsc0VBQXNFLENBQUM7QUFDM0UsSUFBSUMsMEVBQTBFLENBQUM7QUFDL0UsSUFBSUMscUNBQXFDLENBQUM7QUFDMUMsSUFBSUMseUVBQXlFLENBQUM7QUFDOUUsSUFBSUMseUVBQXlFLENBQUM7QUFDOUUsSUFBSUMsc0VBQXNFLENBQUM7QUFDM0UsSUFBSUMsbURBQW1ELENBQUM7QUFDeEQsSUFBSUMsb0RBQW9ELENBQUM7QUFDekQsSUFBSUMsbUZB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QUtFO2dCQUNMLEtBQUtDO2dCQUNMLEtBQUtUO29CQUNIMFIsZUFBZTt3QkFBRTBCLGlCQUFpQnpDO29CQUFRO29CQUMxQztnQkFDRjtvQkFDRSxJQUFJLE9BQU9zQyxTQUFTLFlBQVksQ0FBQzVGLE1BQU1DLE9BQU8sQ0FBQzJGLE9BQU87d0JBQ3BEdkIsZUFBZXVCO29CQUNqQjtZQUNKO1lBQ0FILE1BQU0sSUFBSXpDLFlBQVkxQixNQUFNK0M7UUFDOUI7SUFDRixPQUFPO1FBQ0wsTUFBTWYsVUFBVSxPQUFPa0MsMEJBQTBCLFlBQVlBLDBCQUEwQixRQUFRLGFBQWFBLHlCQUF5QixPQUFPQSxzQkFBc0JsQyxPQUFPLEtBQUssV0FBV2tDLHNCQUFzQmxDLE9BQU8sR0FBRztRQUN6Tm1DLE1BQU0sSUFBSXpDLFlBQVk1USx3Q0FBd0M7WUFBRTRULE9BQU9SO1lBQXVCbEM7UUFBUTtJQUN4RztJQUNBQyxzQkFBc0JrQyxLQUFLRjtJQUMzQixPQUFPRTtBQUNUO0FBQ0EsU0FBU0MsbUJBQW1CM0YsS0FBSztJQUMvQixPQUFPLE9BQU9BLFVBQVUsWUFBWUEsVUFBVSxRQUFRLFVBQVVBLFNBQVMsYUFBYUEsU0FBVSxRQUFPQSxNQUFNdUIsSUFBSSxLQUFLLFlBQVksT0FBT3ZCLE1BQU11QixJQUFJLEtBQUssUUFBTyxLQUFNLE9BQU92QixNQUFNdUQsT0FBTyxLQUFLO0FBQ2hNO0FBRXUzWixDQUN2M1osdUNBQXVDO0NBQ3ZDLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL3Nrci1kb21haW4td2F0Y2hlci8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL2Vycm9ycy9kaXN0L2luZGV4Lm5vZGUubWpzPzkwMzAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2NvZGVzLnRzXG52YXIgU09MQU5BX0VSUk9SX19CTE9DS19IRUlHSFRfRVhDRUVERUQgPSAxO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5WQUxJRF9OT05DRSA9IDI7XG52YXIgU09MQU5BX0VSUk9SX19OT05DRV9BQ0NPVU5UX05PVF9GT1VORCA9IDM7XG52YXIgU09MQU5BX0VSUk9SX19CTE9DS0hBU0hfU1RSSU5HX0xFTkdUSF9PVVRfT0ZfUkFOR0UgPSA0O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5WQUxJRF9CTE9DS0hBU0hfQllURV9MRU5HVEggPSA1O1xudmFyIFNPTEFOQV9FUlJPUl9fTEFNUE9SVFNfT1VUX09GX1JBTkdFID0gNjtcbnZhciBTT0xBTkFfRVJST1JfX01BTEZPUk1FRF9CSUdJTlRfU1RSSU5HID0gNztcbnZhciBTT0xBTkFfRVJST1JfX01BTEZPUk1FRF9OVU1CRVJfU1RSSU5HID0gODtcbnZhciBTT0xBTkFfRVJST1JfX1RJTUVTVEFNUF9PVVRfT0ZfUkFOR0UgPSA5O1xudmFyIFNPTEFOQV9FUlJPUl9fTUFMRk9STUVEX0pTT05fUlBDX0VSUk9SID0gMTA7XG52YXIgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fUEFSU0VfRVJST1IgPSAtMzI3MDA7XG52YXIgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fSU5URVJOQUxfRVJST1IgPSAtMzI2MDM7XG52YXIgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fSU5WQUxJRF9QQVJBTVMgPSAtMzI2MDI7XG52YXIgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fTUVUSE9EX05PVF9GT1VORCA9IC0zMjYwMTtcbnZhciBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19JTlZBTElEX1JFUVVFU1QgPSAtMzI2MDA7XG52YXIgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX01JTl9DT05URVhUX1NMT1RfTk9UX1JFQUNIRUQgPSAtMzIwMTY7XG52YXIgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1VOU1VQUE9SVEVEX1RSQU5TQUNUSU9OX1ZFUlNJT04gPSAtMzIwMTU7XG52YXIgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0JMT0NLX1NUQVRVU19OT1RfQVZBSUxBQkxFX1lFVCA9IC0zMjAxNDtcbnZhciBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fU0lHTkFUVVJFX0xFTl9NSVNNQVRDSCA9IC0zMjAxMztcbnZhciBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TQ0FOX0VSUk9SID0gLTMyMDEyO1xudmFyIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9ISVNUT1JZX05PVF9BVkFJTEFCTEUgPSAtMzIwMTE7XG52YXIgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0tFWV9FWENMVURFRF9GUk9NX1NFQ09OREFSWV9JTkRFWCA9IC0zMjAxMDtcbnZhciBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfTE9OR19URVJNX1NUT1JBR0VfU0xPVF9TS0lQUEVEID0gLTMyMDA5O1xudmFyIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9OT19TTkFQU0hPVCA9IC0zMjAwODtcbnZhciBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfU0xPVF9TS0lQUEVEID0gLTMyMDA3O1xudmFyIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9QUkVDT01QSUxFX1ZFUklGSUNBVElPTl9GQUlMVVJFID0gLTMyMDA2O1xudmFyIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9OT0RFX1VOSEVBTFRIWSA9IC0zMjAwNTtcbnZhciBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfQkxPQ0tfTk9UX0FWQUlMQUJMRSA9IC0zMjAwNDtcbnZhciBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fU0lHTkFUVVJFX1ZFUklGSUNBVElPTl9GQUlMVVJFID0gLTMyMDAzO1xudmFyIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9TRU5EX1RSQU5TQUNUSU9OX1BSRUZMSUdIVF9GQUlMVVJFID0gLTMyMDAyO1xudmFyIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9CTE9DS19DTEVBTkVEX1VQID0gLTMyMDAxO1xudmFyIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19JTlZBTElEX0JZVEVfTEVOR1RIID0gMjhlNTtcbnZhciBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fU1RSSU5HX0xFTkdUSF9PVVRfT0ZfUkFOR0UgPSAyODAwMDAxO1xudmFyIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19JTlZBTElEX0JBU0U1OF9FTkNPREVEX0FERFJFU1MgPSAyODAwMDAyO1xudmFyIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19JTlZBTElEX0VEMjU1MTlfUFVCTElDX0tFWSA9IDI4MDAwMDM7XG52YXIgU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX01BTEZPUk1FRF9QREEgPSAyODAwMDA0O1xudmFyIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19QREFfQlVNUF9TRUVEX09VVF9PRl9SQU5HRSA9IDI4MDAwMDU7XG52YXIgU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX01BWF9OVU1CRVJfT0ZfUERBX1NFRURTX0VYQ0VFREVEID0gMjgwMDAwNjtcbnZhciBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fTUFYX1BEQV9TRUVEX0xFTkdUSF9FWENFRURFRCA9IDI4MDAwMDc7XG52YXIgU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX0lOVkFMSURfU0VFRFNfUE9JTlRfT05fQ1VSVkUgPSAyODAwMDA4O1xudmFyIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19GQUlMRURfVE9fRklORF9WSUFCTEVfUERBX0JVTVBfU0VFRCA9IDI4MDAwMDk7XG52YXIgU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX1BEQV9FTkRTX1dJVEhfUERBX01BUktFUiA9IDI4MDAwMTA7XG52YXIgU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX0lOVkFMSURfT0ZGX0NVUlZFX0FERFJFU1MgPSAyODAwMDExO1xudmFyIFNPTEFOQV9FUlJPUl9fQUNDT1VOVFNfX0FDQ09VTlRfTk9UX0ZPVU5EID0gMzIzZTQ7XG52YXIgU09MQU5BX0VSUk9SX19BQ0NPVU5UU19fT05FX09SX01PUkVfQUNDT1VOVFNfTk9UX0ZPVU5EID0gMzIzMDAwMDE7XG52YXIgU09MQU5BX0VSUk9SX19BQ0NPVU5UU19fRkFJTEVEX1RPX0RFQ09ERV9BQ0NPVU5UID0gMzIzMDAwMjtcbnZhciBTT0xBTkFfRVJST1JfX0FDQ09VTlRTX19FWFBFQ1RFRF9ERUNPREVEX0FDQ09VTlQgPSAzMjMwMDAzO1xudmFyIFNPTEFOQV9FUlJPUl9fQUNDT1VOVFNfX0VYUEVDVEVEX0FMTF9BQ0NPVU5UU19UT19CRV9ERUNPREVEID0gMzIzMDAwNDtcbnZhciBTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0RJU0FMTE9XRURfSU5fSU5TRUNVUkVfQ09OVEVYVCA9IDM2MWU0O1xudmFyIFNPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fRElHRVNUX1VOSU1QTEVNRU5URUQgPSAzNjEwMDAxO1xudmFyIFNPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fRUQyNTUxOV9BTEdPUklUSE1fVU5JTVBMRU1FTlRFRCA9IDM2MTAwMDI7XG52YXIgU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19FWFBPUlRfRlVOQ1RJT05fVU5JTVBMRU1FTlRFRCA9IDM2MTAwMDM7XG52YXIgU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19HRU5FUkFURV9GVU5DVElPTl9VTklNUExFTUVOVEVEID0gMzYxMDAwNDtcbnZhciBTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX1NJR05fRlVOQ1RJT05fVU5JTVBMRU1FTlRFRCA9IDM2MTAwMDU7XG52YXIgU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19WRVJJRllfRlVOQ1RJT05fVU5JTVBMRU1FTlRFRCA9IDM2MTAwMDY7XG52YXIgU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19DQU5OT1RfRVhQT1JUX05PTl9FWFRSQUNUQUJMRV9LRVkgPSAzNjEwMDA3O1xudmFyIFNPTEFOQV9FUlJPUl9fQ1JZUFRPX19SQU5ET01fVkFMVUVTX0ZVTkNUSU9OX1VOSU1QTEVNRU5URUQgPSAzNjExZTM7XG52YXIgU09MQU5BX0VSUk9SX19LRVlTX19JTlZBTElEX0tFWV9QQUlSX0JZVEVfTEVOR1RIID0gMzcwNGUzO1xudmFyIFNPTEFOQV9FUlJPUl9fS0VZU19fSU5WQUxJRF9QUklWQVRFX0tFWV9CWVRFX0xFTkdUSCA9IDM3MDQwMDE7XG52YXIgU09MQU5BX0VSUk9SX19LRVlTX19JTlZBTElEX1NJR05BVFVSRV9CWVRFX0xFTkdUSCA9IDM3MDQwMDI7XG52YXIgU09MQU5BX0VSUk9SX19LRVlTX19TSUdOQVRVUkVfU1RSSU5HX0xFTkdUSF9PVVRfT0ZfUkFOR0UgPSAzNzA0MDAzO1xudmFyIFNPTEFOQV9FUlJPUl9fS0VZU19fUFVCTElDX0tFWV9NVVNUX01BVENIX1BSSVZBVEVfS0VZID0gMzcwNDAwNDtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX19FWFBFQ1RFRF9UT19IQVZFX0FDQ09VTlRTID0gNDEyOGUzO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fX0VYUEVDVEVEX1RPX0hBVkVfREFUQSA9IDQxMjgwMDE7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9fUFJPR1JBTV9JRF9NSVNNQVRDSCA9IDQxMjgwMDI7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fVU5LTk9XTiA9IDQ2MTVlMztcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19HRU5FUklDX0VSUk9SID0gNDYxNTAwMTtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX0FSR1VNRU5UID0gNDYxNTAwMjtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX0lOU1RSVUNUSU9OX0RBVEEgPSA0NjE1MDAzO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfQUNDT1VOVF9EQVRBID0gNDYxNTAwNDtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX0RBVEFfVE9PX1NNQUxMID0gNDYxNTAwNTtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlNVRkZJQ0lFTlRfRlVORFMgPSA0NjE1MDA2O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOQ09SUkVDVF9QUk9HUkFNX0lEID0gNDYxNTAwNztcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NSVNTSU5HX1JFUVVJUkVEX1NJR05BVFVSRSA9IDQ2MTUwMDg7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9BTFJFQURZX0lOSVRJQUxJWkVEID0gNDYxNTAwOTtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19VTklOSVRJQUxJWkVEX0FDQ09VTlQgPSA0NjE1MDEwO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1VOQkFMQU5DRURfSU5TVFJVQ1RJT04gPSA0NjE1MDExO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01PRElGSUVEX1BST0dSQU1fSUQgPSA0NjE1MDEyO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0VYVEVSTkFMX0FDQ09VTlRfTEFNUE9SVF9TUEVORCA9IDQ2MTUwMTM7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRVhURVJOQUxfQUNDT1VOVF9EQVRBX01PRElGSUVEID0gNDYxNTAxNDtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19SRUFET05MWV9MQU1QT1JUX0NIQU5HRSA9IDQ2MTUwMTU7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUkVBRE9OTFlfREFUQV9NT0RJRklFRCA9IDQ2MTUwMTY7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRFVQTElDQVRFX0FDQ09VTlRfSU5ERVggPSA0NjE1MDE3O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0VYRUNVVEFCTEVfTU9ESUZJRUQgPSA0NjE1MDE4O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1JFTlRfRVBPQ0hfTU9ESUZJRUQgPSA0NjE1MDE5O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX05PVF9FTk9VR0hfQUNDT1VOVF9LRVlTID0gNDYxNTAyMDtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX0RBVEFfU0laRV9DSEFOR0VEID0gNDYxNTAyMTtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX05PVF9FWEVDVVRBQkxFID0gNDYxNTAyMjtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX0JPUlJPV19GQUlMRUQgPSA0NjE1MDIzO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfQk9SUk9XX09VVFNUQU5ESU5HID0gNDYxNTAyNDtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19EVVBMSUNBVEVfQUNDT1VOVF9PVVRfT0ZfU1lOQyA9IDQ2MTUwMjU7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQ1VTVE9NID0gNDYxNTAyNjtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX0VSUk9SID0gNDYxNTAyNztcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19FWEVDVVRBQkxFX0RBVEFfTU9ESUZJRUQgPSA0NjE1MDI4O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0VYRUNVVEFCTEVfTEFNUE9SVF9DSEFOR0UgPSA0NjE1MDI5O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0VYRUNVVEFCTEVfQUNDT1VOVF9OT1RfUkVOVF9FWEVNUFQgPSA0NjE1MDMwO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1VOU1VQUE9SVEVEX1BST0dSQU1fSUQgPSA0NjE1MDMxO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0NBTExfREVQVEggPSA0NjE1MDMyO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01JU1NJTkdfQUNDT1VOVCA9IDQ2MTUwMzM7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUkVFTlRSQU5DWV9OT1RfQUxMT1dFRCA9IDQ2MTUwMzQ7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUFYX1NFRURfTEVOR1RIX0VYQ0VFREVEID0gNDYxNTAzNTtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX1NFRURTID0gNDYxNTAzNjtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX1JFQUxMT0MgPSA0NjE1MDM3O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0NPTVBVVEFUSU9OQUxfQlVER0VUX0VYQ0VFREVEID0gNDYxNTAzODtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19QUklWSUxFR0VfRVNDQUxBVElPTiA9IDQ2MTUwMzk7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUFJPR1JBTV9FTlZJUk9OTUVOVF9TRVRVUF9GQUlMVVJFID0gNDYxNTA0MDtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19QUk9HUkFNX0ZBSUxFRF9UT19DT01QTEVURSA9IDQ2MTUwNDE7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUFJPR1JBTV9GQUlMRURfVE9fQ09NUElMRSA9IDQ2MTUwNDI7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU1NVVRBQkxFID0gNDYxNTA0MztcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTkNPUlJFQ1RfQVVUSE9SSVRZID0gNDYxNTA0NDtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19CT1JTSF9JT19FUlJPUiA9IDQ2MTUwNDU7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9OT1RfUkVOVF9FWEVNUFQgPSA0NjE1MDQ2O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfQUNDT1VOVF9PV05FUiA9IDQ2MTUwNDc7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQVJJVEhNRVRJQ19PVkVSRkxPVyA9IDQ2MTUwNDg7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fVU5TVVBQT1JURURfU1lTVkFSID0gNDYxNTA0OTtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTExFR0FMX09XTkVSID0gNDYxNTA1MDtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NQVhfQUNDT1VOVFNfREFUQV9BTExPQ0FUSU9OU19FWENFRURFRCA9IDQ2MTUwNTE7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUFYX0FDQ09VTlRTX0VYQ0VFREVEID0gNDYxNTA1MjtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NQVhfSU5TVFJVQ1RJT05fVFJBQ0VfTEVOR1RIX0VYQ0VFREVEID0gNDYxNTA1MztcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19CVUlMVElOX1BST0dSQU1TX01VU1RfQ09OU1VNRV9DT01QVVRFX1VOSVRTID0gNDYxNTA1NDtcbnZhciBTT0xBTkFfRVJST1JfX1NJR05FUl9fQUREUkVTU19DQU5OT1RfSEFWRV9NVUxUSVBMRV9TSUdORVJTID0gNTUwOGUzO1xudmFyIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9LRVlfUEFJUl9TSUdORVIgPSA1NTA4MDAxO1xudmFyIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9NRVNTQUdFX1NJR05FUiA9IDU1MDgwMDI7XG52YXIgU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX01FU1NBR0VfTU9ESUZZSU5HX1NJR05FUiA9IDU1MDgwMDM7XG52YXIgU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX01FU1NBR0VfUEFSVElBTF9TSUdORVIgPSA1NTA4MDA0O1xudmFyIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9UUkFOU0FDVElPTl9TSUdORVIgPSA1NTA4MDA1O1xudmFyIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9UUkFOU0FDVElPTl9NT0RJRllJTkdfU0lHTkVSID0gNTUwODAwNjtcbnZhciBTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfVFJBTlNBQ1RJT05fUEFSVElBTF9TSUdORVIgPSA1NTA4MDA3O1xudmFyIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9UUkFOU0FDVElPTl9TRU5ESU5HX1NJR05FUiA9IDU1MDgwMDg7XG52YXIgU09MQU5BX0VSUk9SX19TSUdORVJfX1RSQU5TQUNUSU9OX0NBTk5PVF9IQVZFX01VTFRJUExFX1NFTkRJTkdfU0lHTkVSUyA9IDU1MDgwMDk7XG52YXIgU09MQU5BX0VSUk9SX19TSUdORVJfX1RSQU5TQUNUSU9OX1NFTkRJTkdfU0lHTkVSX01JU1NJTkcgPSA1NTA4MDEwO1xudmFyIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19XQUxMRVRfTVVMVElTSUdOX1VOSU1QTEVNRU5URUQgPSA1NTA4MDExO1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0lOVk9LRURfUFJPR1JBTVNfQ0FOTk9UX1BBWV9GRUVTID0gNTY2M2UzO1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0lOVk9LRURfUFJPR1JBTVNfTVVTVF9OT1RfQkVfV1JJVEFCTEUgPSA1NjYzMDAxO1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0VYUEVDVEVEX0JMT0NLSEFTSF9MSUZFVElNRSA9IDU2NjMwMDI7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRVhQRUNURURfTk9OQ0VfTElGRVRJTUUgPSA1NjYzMDAzO1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX1ZFUlNJT05fTlVNQkVSX09VVF9PRl9SQU5HRSA9IDU2NjMwMDQ7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkFJTEVEX1RPX0RFQ09NUElMRV9BRERSRVNTX0xPT0tVUF9UQUJMRV9DT05URU5UU19NSVNTSU5HID0gNTY2MzAwNTtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GQUlMRURfVE9fREVDT01QSUxFX0FERFJFU1NfTE9PS1VQX1RBQkxFX0lOREVYX09VVF9PRl9SQU5HRSA9IDU2NjMwMDY7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkFJTEVEX1RPX0RFQ09NUElMRV9JTlNUUlVDVElPTl9QUk9HUkFNX0FERFJFU1NfTk9UX0ZPVU5EID0gNTY2MzAwNztcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GQUlMRURfVE9fREVDT01QSUxFX0ZFRV9QQVlFUl9NSVNTSU5HID0gNTY2MzAwODtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19TSUdOQVRVUkVTX01JU1NJTkcgPSA1NjYzMDA5O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0FERFJFU1NfTUlTU0lORyA9IDU2NjMwMTA7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkVFX1BBWUVSX01JU1NJTkcgPSA1NjYzMDExO1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZFRV9QQVlFUl9TSUdOQVRVUkVfTUlTU0lORyA9IDU2NjMwMTI7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fSU5WQUxJRF9OT05DRV9UUkFOU0FDVElPTl9JTlNUUlVDVElPTlNfTUlTU0lORyA9IDU2NjMwMTM7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fSU5WQUxJRF9OT05DRV9UUkFOU0FDVElPTl9GSVJTVF9JTlNUUlVDVElPTl9NVVNUX0JFX0FEVkFOQ0VfTk9OQ0UgPSA1NjYzMDE0O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0FERFJFU1NFU19DQU5OT1RfU0lHTl9UUkFOU0FDVElPTiA9IDU2NjMwMTU7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fQ0FOTk9UX0VOQ09ERV9XSVRIX0VNUFRZX1NJR05BVFVSRVMgPSA1NjYzMDE2O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX01FU1NBR0VfU0lHTkFUVVJFU19NSVNNQVRDSCA9IDU2NjMwMTc7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkFJTEVEX1RPX0VTVElNQVRFX0NPTVBVVEVfTElNSVQgPSA1NjYzMDE4O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9XSEVOX1NJTVVMQVRJTkdfVE9fRVNUSU1BVEVfQ09NUFVURV9MSU1JVCA9IDU2NjMwMTk7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRVhDRUVEU19TSVpFX0xJTUlUID0gNTY2MzAyMDtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19VTktOT1dOID0gNzA1ZTQ7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQUNDT1VOVF9JTl9VU0UgPSA3MDUwMDAxO1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0FDQ09VTlRfTE9BREVEX1RXSUNFID0gNzA1MDAwMjtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19BQ0NPVU5UX05PVF9GT1VORCA9IDcwNTAwMDM7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fUFJPR1JBTV9BQ0NPVU5UX05PVF9GT1VORCA9IDcwNTAwMDQ7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5TVUZGSUNJRU5UX0ZVTkRTX0ZPUl9GRUUgPSA3MDUwMDA1O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfQUNDT1VOVF9GT1JfRkVFID0gNzA1MDAwNjtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19BTFJFQURZX1BST0NFU1NFRCA9IDcwNTAwMDc7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQkxPQ0tIQVNIX05PVF9GT1VORCA9IDcwNTAwMDg7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQ0FMTF9DSEFJTl9UT09fREVFUCA9IDcwNTAwMDk7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fTUlTU0lOR19TSUdOQVRVUkVfRk9SX0ZFRSA9IDcwNTAwMTA7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9BQ0NPVU5UX0lOREVYID0gNzA1MDAxMTtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19TSUdOQVRVUkVfRkFJTFVSRSA9IDcwNTAwMTI7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9QUk9HUkFNX0ZPUl9FWEVDVVRJT04gPSA3MDUwMDEzO1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1NBTklUSVpFX0ZBSUxVUkUgPSA3MDUwMDE0O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0NMVVNURVJfTUFJTlRFTkFOQ0UgPSA3MDUwMDE1O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0FDQ09VTlRfQk9SUk9XX09VVFNUQU5ESU5HID0gNzA1MDAxNjtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19XT1VMRF9FWENFRURfTUFYX0JMT0NLX0NPU1RfTElNSVQgPSA3MDUwMDE3O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1VOU1VQUE9SVEVEX1ZFUlNJT04gPSA3MDUwMDE4O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfV1JJVEFCTEVfQUNDT1VOVCA9IDcwNTAwMTk7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fV09VTERfRVhDRUVEX01BWF9BQ0NPVU5UX0NPU1RfTElNSVQgPSA3MDUwMDIwO1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1dPVUxEX0VYQ0VFRF9BQ0NPVU5UX0RBVEFfQkxPQ0tfTElNSVQgPSA3MDUwMDIxO1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1RPT19NQU5ZX0FDQ09VTlRfTE9DS1MgPSA3MDUwMDIyO1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0FERFJFU1NfTE9PS1VQX1RBQkxFX05PVF9GT1VORCA9IDcwNTAwMjM7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9BRERSRVNTX0xPT0tVUF9UQUJMRV9PV05FUiA9IDcwNTAwMjQ7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9BRERSRVNTX0xPT0tVUF9UQUJMRV9EQVRBID0gNzA1MDAyNTtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX0FERFJFU1NfTE9PS1VQX1RBQkxFX0lOREVYID0gNzA1MDAyNjtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX1JFTlRfUEFZSU5HX0FDQ09VTlQgPSA3MDUwMDI3O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1dPVUxEX0VYQ0VFRF9NQVhfVk9URV9DT1NUX0xJTUlUID0gNzA1MDAyODtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19XT1VMRF9FWENFRURfQUNDT1VOVF9EQVRBX1RPVEFMX0xJTUlUID0gNzA1MDAyOTtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19EVVBMSUNBVEVfSU5TVFJVQ1RJT04gPSA3MDUwMDMwO1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOU1VGRklDSUVOVF9GVU5EU19GT1JfUkVOVCA9IDcwNTAwMzE7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fTUFYX0xPQURFRF9BQ0NPVU5UU19EQVRBX1NJWkVfRVhDRUVERUQgPSA3MDUwMDMyO1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfTE9BREVEX0FDQ09VTlRTX0RBVEFfU0laRV9MSU1JVCA9IDcwNTAwMzM7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fUkVTQU5JVElaQVRJT05fTkVFREVEID0gNzA1MDAzNDtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19QUk9HUkFNX0VYRUNVVElPTl9URU1QT1JBUklMWV9SRVNUUklDVEVEID0gNzA1MDAzNTtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19VTkJBTEFOQ0VEX1RSQU5TQUNUSU9OID0gNzA1MDAzNjtcbnZhciBTT0xBTkFfRVJST1JfX0NPREVDU19fQ0FOTk9UX0RFQ09ERV9FTVBUWV9CWVRFX0FSUkFZID0gODA3OGUzO1xudmFyIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0JZVEVfTEVOR1RIID0gODA3ODAwMTtcbnZhciBTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfRklYRURfTEVOR1RIID0gODA3ODAwMjtcbnZhciBTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfVkFSSUFCTEVfTEVOR1RIID0gODA3ODAwMztcbnZhciBTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX1NJWkVfQ09NUEFUSUJJTElUWV9NSVNNQVRDSCA9IDgwNzgwMDQ7XG52YXIgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9GSVhFRF9TSVpFX01JU01BVENIID0gODA3ODAwNTtcbnZhciBTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX01BWF9TSVpFX01JU01BVENIID0gODA3ODAwNjtcbnZhciBTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9OVU1CRVJfT0ZfSVRFTVMgPSA4MDc4MDA3O1xudmFyIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTlVNX0RJU0NSSU1JTkFUT1JfT1VUX09GX1JBTkdFID0gODA3ODAwODtcbnZhciBTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9ESVNDUklNSU5BVEVEX1VOSU9OX1ZBUklBTlQgPSA4MDc4MDA5O1xudmFyIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0VOVU1fVkFSSUFOVCA9IDgwNzgwMTA7XG52YXIgU09MQU5BX0VSUk9SX19DT0RFQ1NfX05VTUJFUl9PVVRfT0ZfUkFOR0UgPSA4MDc4MDExO1xudmFyIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX1NUUklOR19GT1JfQkFTRSA9IDgwNzgwMTI7XG52YXIgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1BPU0lUSVZFX0JZVEVfTEVOR1RIID0gODA3ODAxMztcbnZhciBTT0xBTkFfRVJST1JfX0NPREVDU19fT0ZGU0VUX09VVF9PRl9SQU5HRSA9IDgwNzgwMTQ7XG52YXIgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfTElURVJBTF9VTklPTl9WQVJJQU5UID0gODA3ODAxNTtcbnZhciBTT0xBTkFfRVJST1JfX0NPREVDU19fTElURVJBTF9VTklPTl9ESVNDUklNSU5BVE9SX09VVF9PRl9SQU5HRSA9IDgwNzgwMTY7XG52YXIgU09MQU5BX0VSUk9SX19DT0RFQ1NfX1VOSU9OX1ZBUklBTlRfT1VUX09GX1JBTkdFID0gODA3ODAxNztcbnZhciBTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9DT05TVEFOVCA9IDgwNzgwMTg7XG52YXIgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1pFUk9fVkFMVUVfVE9fTUFUQ0hfSVRFTV9GSVhFRF9TSVpFID0gODA3ODAxOTtcbnZhciBTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFRF9CWVRFU19NVVNUX05PVF9JTkNMVURFX1NFTlRJTkVMID0gODA3ODAyMDtcbnZhciBTT0xBTkFfRVJST1JfX0NPREVDU19fU0VOVElORUxfTUlTU0lOR19JTl9ERUNPREVEX0JZVEVTID0gODA3ODAyMTtcbnZhciBTT0xBTkFfRVJST1JfX0NPREVDU19fQ0FOTk9UX1VTRV9MRVhJQ0FMX1ZBTFVFU19BU19FTlVNX0RJU0NSSU1JTkFUT1JTID0gODA3ODAyMjtcbnZhciBTT0xBTkFfRVJST1JfX1JQQ19fSU5URUdFUl9PVkVSRkxPVyA9IDgxZTU7XG52YXIgU09MQU5BX0VSUk9SX19SUENfX1RSQU5TUE9SVF9IVFRQX0hFQURFUl9GT1JCSURERU4gPSA4MTAwMDAxO1xudmFyIFNPTEFOQV9FUlJPUl9fUlBDX19UUkFOU1BPUlRfSFRUUF9FUlJPUiA9IDgxMDAwMDI7XG52YXIgU09MQU5BX0VSUk9SX19SUENfX0FQSV9QTEFOX01JU1NJTkdfRk9SX1JQQ19NRVRIT0QgPSA4MTAwMDAzO1xudmFyIFNPTEFOQV9FUlJPUl9fUlBDX1NVQlNDUklQVElPTlNfX0NBTk5PVF9DUkVBVEVfU1VCU0NSSVBUSU9OX1BMQU4gPSA4MTllNDtcbnZhciBTT0xBTkFfRVJST1JfX1JQQ19TVUJTQ1JJUFRJT05TX19FWFBFQ1RFRF9TRVJWRVJfU1VCU0NSSVBUSU9OX0lEID0gODE5MDAwMTtcbnZhciBTT0xBTkFfRVJST1JfX1JQQ19TVUJTQ1JJUFRJT05TX19DSEFOTkVMX0NMT1NFRF9CRUZPUkVfTUVTU0FHRV9CVUZGRVJFRCA9IDgxOTAwMDI7XG52YXIgU09MQU5BX0VSUk9SX19SUENfU1VCU0NSSVBUSU9OU19fQ0hBTk5FTF9DT05ORUNUSU9OX0NMT1NFRCA9IDgxOTAwMDM7XG52YXIgU09MQU5BX0VSUk9SX19SUENfU1VCU0NSSVBUSU9OU19fQ0hBTk5FTF9GQUlMRURfVE9fQ09OTkVDVCA9IDgxOTAwMDQ7XG52YXIgU09MQU5BX0VSUk9SX19JTlZBUklBTlRfVklPTEFUSU9OX19TVUJTQ1JJUFRJT05fSVRFUkFUT1JfU1RBVEVfTUlTU0lORyA9IDk5ZTU7XG52YXIgU09MQU5BX0VSUk9SX19JTlZBUklBTlRfVklPTEFUSU9OX19TVUJTQ1JJUFRJT05fSVRFUkFUT1JfTVVTVF9OT1RfUE9MTF9CRUZPUkVfUkVTT0xWSU5HX0VYSVNUSU5HX01FU1NBR0VfUFJPTUlTRSA9IDk5MDAwMDE7XG52YXIgU09MQU5BX0VSUk9SX19JTlZBUklBTlRfVklPTEFUSU9OX19DQUNIRURfQUJPUlRBQkxFX0lURVJBQkxFX0NBQ0hFX0VOVFJZX01JU1NJTkcgPSA5OTAwMDAyO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5WQVJJQU5UX1ZJT0xBVElPTl9fU1dJVENIX01VU1RfQkVfRVhIQVVTVElWRSA9IDk5MDAwMDM7XG52YXIgU09MQU5BX0VSUk9SX19JTlZBUklBTlRfVklPTEFUSU9OX19EQVRBX1BVQkxJU0hFUl9DSEFOTkVMX1VOSU1QTEVNRU5URUQgPSA5OTAwMDA0O1xuXG4vLyBzcmMvY29udGV4dC50c1xuZnVuY3Rpb24gZW5jb2RlVmFsdWUodmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgY29uc3QgY29tbWFTZXBhcmF0ZWRWYWx1ZXMgPSB2YWx1ZS5tYXAoZW5jb2RlVmFsdWUpLmpvaW4oXG4gICAgICBcIiUyQyUyMFwiXG4gICAgICAvKiBcIiwgXCIgKi9cbiAgICApO1xuICAgIHJldHVybiBcIiU1QlwiICsgY29tbWFTZXBhcmF0ZWRWYWx1ZXMgKyAvKiBcIl1cIiAqL1xuICAgIFwiJTVEXCI7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiKSB7XG4gICAgcmV0dXJuIGAke3ZhbHVlfW5gO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoXG4gICAgICBTdHJpbmcoXG4gICAgICAgIHZhbHVlICE9IG51bGwgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSA9PT0gbnVsbCA/IChcbiAgICAgICAgICAvLyBQbGFpbiBvYmplY3RzIHdpdGggbm8gcHJvdG90eXBlIGRvbid0IGhhdmUgYSBgdG9TdHJpbmdgIG1ldGhvZC5cbiAgICAgICAgICAvLyBDb252ZXJ0IHRoZW0gYmVmb3JlIHN0cmluZ2lmeWluZyB0aGVtLlxuICAgICAgICAgIHsgLi4udmFsdWUgfVxuICAgICAgICApIDogdmFsdWVcbiAgICAgIClcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBlbmNvZGVPYmplY3RDb250ZXh0RW50cnkoW2tleSwgdmFsdWVdKSB7XG4gIHJldHVybiBgJHtrZXl9PSR7ZW5jb2RlVmFsdWUodmFsdWUpfWA7XG59XG5mdW5jdGlvbiBlbmNvZGVDb250ZXh0T2JqZWN0KGNvbnRleHQpIHtcbiAgY29uc3Qgc2VhcmNoUGFyYW1zU3RyaW5nID0gT2JqZWN0LmVudHJpZXMoY29udGV4dCkubWFwKGVuY29kZU9iamVjdENvbnRleHRFbnRyeSkuam9pbihcIiZcIik7XG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWFyY2hQYXJhbXNTdHJpbmcsIFwidXRmOFwiKS50b1N0cmluZyhcImJhc2U2NFwiKSA7XG59XG5cbi8vIHNyYy9tZXNzYWdlcy50c1xudmFyIFNvbGFuYUVycm9yTWVzc2FnZXMgPSB7XG4gIFtTT0xBTkFfRVJST1JfX0FDQ09VTlRTX19BQ0NPVU5UX05PVF9GT1VORF06IFwiQWNjb3VudCBub3QgZm91bmQgYXQgYWRkcmVzczogJGFkZHJlc3NcIixcbiAgW1NPTEFOQV9FUlJPUl9fQUNDT1VOVFNfX0VYUEVDVEVEX0FMTF9BQ0NPVU5UU19UT19CRV9ERUNPREVEXTogXCJOb3QgYWxsIGFjY291bnRzIHdlcmUgZGVjb2RlZC4gRW5jb2RlZCBhY2NvdW50cyBmb3VuZCBhdCBhZGRyZXNzZXM6ICRhZGRyZXNzZXMuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0FDQ09VTlRTX19FWFBFQ1RFRF9ERUNPREVEX0FDQ09VTlRdOiBcIkV4cGVjdGVkIGRlY29kZWQgYWNjb3VudCBhdCBhZGRyZXNzOiAkYWRkcmVzc1wiLFxuICBbU09MQU5BX0VSUk9SX19BQ0NPVU5UU19fRkFJTEVEX1RPX0RFQ09ERV9BQ0NPVU5UXTogXCJGYWlsZWQgdG8gZGVjb2RlIGFjY291bnQgZGF0YSBhdCBhZGRyZXNzOiAkYWRkcmVzc1wiLFxuICBbU09MQU5BX0VSUk9SX19BQ0NPVU5UU19fT05FX09SX01PUkVfQUNDT1VOVFNfTk9UX0ZPVU5EXTogXCJBY2NvdW50cyBub3QgZm91bmQgYXQgYWRkcmVzc2VzOiAkYWRkcmVzc2VzXCIsXG4gIFtTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fRkFJTEVEX1RPX0ZJTkRfVklBQkxFX1BEQV9CVU1QX1NFRURdOiBcIlVuYWJsZSB0byBmaW5kIGEgdmlhYmxlIHByb2dyYW0gYWRkcmVzcyBidW1wIHNlZWQuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9CQVNFNThfRU5DT0RFRF9BRERSRVNTXTogXCIkcHV0YXRpdmVBZGRyZXNzIGlzIG5vdCBhIGJhc2U1OC1lbmNvZGVkIGFkZHJlc3MuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9CWVRFX0xFTkdUSF06IFwiRXhwZWN0ZWQgYmFzZTU4IGVuY29kZWQgYWRkcmVzcyB0byBkZWNvZGUgdG8gYSBieXRlIGFycmF5IG9mIGxlbmd0aCAzMi4gQWN0dWFsIGxlbmd0aDogJGFjdHVhbExlbmd0aC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19JTlZBTElEX0VEMjU1MTlfUFVCTElDX0tFWV06IFwiVGhlIGBDcnlwdG9LZXlgIG11c3QgYmUgYW4gYEVkMjU1MTlgIHB1YmxpYyBrZXkuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9PRkZfQ1VSVkVfQUREUkVTU106IFwiJHB1dGF0aXZlT2ZmQ3VydmVBZGRyZXNzIGlzIG5vdCBhIGJhc2U1OC1lbmNvZGVkIG9mZi1jdXJ2ZSBhZGRyZXNzLlwiLFxuICBbU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX0lOVkFMSURfU0VFRFNfUE9JTlRfT05fQ1VSVkVdOiBcIkludmFsaWQgc2VlZHM7IHBvaW50IG11c3QgZmFsbCBvZmYgdGhlIEVkMjU1MTkgY3VydmUuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fTUFMRk9STUVEX1BEQV06IFwiRXhwZWN0ZWQgZ2l2ZW4gcHJvZ3JhbSBkZXJpdmVkIGFkZHJlc3MgdG8gaGF2ZSB0aGUgZm9sbG93aW5nIGZvcm1hdDogW0FkZHJlc3MsIFByb2dyYW1EZXJpdmVkQWRkcmVzc0J1bXBdLlwiLFxuICBbU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX01BWF9OVU1CRVJfT0ZfUERBX1NFRURTX0VYQ0VFREVEXTogXCJBIG1heGltdW0gb2YgJG1heFNlZWRzIHNlZWRzLCBpbmNsdWRpbmcgdGhlIGJ1bXAgc2VlZCwgbWF5IGJlIHN1cHBsaWVkIHdoZW4gY3JlYXRpbmcgYW4gYWRkcmVzcy4gUmVjZWl2ZWQ6ICRhY3R1YWwuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fTUFYX1BEQV9TRUVEX0xFTkdUSF9FWENFRURFRF06IFwiVGhlIHNlZWQgYXQgaW5kZXggJGluZGV4IHdpdGggbGVuZ3RoICRhY3R1YWwgZXhjZWVkcyB0aGUgbWF4aW11bSBsZW5ndGggb2YgJG1heFNlZWRMZW5ndGggYnl0ZXMuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fUERBX0JVTVBfU0VFRF9PVVRfT0ZfUkFOR0VdOiBcIkV4cGVjdGVkIHByb2dyYW0gZGVyaXZlZCBhZGRyZXNzIGJ1bXAgdG8gYmUgaW4gdGhlIHJhbmdlIFswLCAyNTVdLCBnb3Q6ICRidW1wLlwiLFxuICBbU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX1BEQV9FTkRTX1dJVEhfUERBX01BUktFUl06IFwiUHJvZ3JhbSBhZGRyZXNzIGNhbm5vdCBlbmQgd2l0aCBQREEgbWFya2VyLlwiLFxuICBbU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX1NUUklOR19MRU5HVEhfT1VUX09GX1JBTkdFXTogXCJFeHBlY3RlZCBiYXNlNTgtZW5jb2RlZCBhZGRyZXNzIHN0cmluZyBvZiBsZW5ndGggaW4gdGhlIHJhbmdlIFszMiwgNDRdLiBBY3R1YWwgbGVuZ3RoOiAkYWN0dWFsTGVuZ3RoLlwiLFxuICBbU09MQU5BX0VSUk9SX19CTE9DS0hBU0hfU1RSSU5HX0xFTkdUSF9PVVRfT0ZfUkFOR0VdOiBcIkV4cGVjdGVkIGJhc2U1OC1lbmNvZGVkIGJsb2NrYXNoIHN0cmluZyBvZiBsZW5ndGggaW4gdGhlIHJhbmdlIFszMiwgNDRdLiBBY3R1YWwgbGVuZ3RoOiAkYWN0dWFsTGVuZ3RoLlwiLFxuICBbU09MQU5BX0VSUk9SX19CTE9DS19IRUlHSFRfRVhDRUVERURdOiBcIlRoZSBuZXR3b3JrIGhhcyBwcm9ncmVzc2VkIHBhc3QgdGhlIGxhc3QgYmxvY2sgZm9yIHdoaWNoIHRoaXMgdHJhbnNhY3Rpb24gY291bGQgaGF2ZSBiZWVuIGNvbW1pdHRlZC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19DQU5OT1RfREVDT0RFX0VNUFRZX0JZVEVfQVJSQVldOiBcIkNvZGVjIFskY29kZWNEZXNjcmlwdGlvbl0gY2Fubm90IGRlY29kZSBlbXB0eSBieXRlIGFycmF5cy5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19DQU5OT1RfVVNFX0xFWElDQUxfVkFMVUVTX0FTX0VOVU1fRElTQ1JJTUlOQVRPUlNdOiBcIkVudW0gY29kZWMgY2Fubm90IHVzZSBsZXhpY2FsIHZhbHVlcyBbJHN0cmluZ1ZhbHVlc10gYXMgZGlzY3JpbWluYXRvcnMuIEVpdGhlciByZW1vdmUgYWxsIGxleGljYWwgdmFsdWVzIG9yIHNldCBgdXNlVmFsdWVzQXNEaXNjcmltaW5hdG9yc2AgdG8gYGZhbHNlYC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVEX0JZVEVTX01VU1RfTk9UX0lOQ0xVREVfU0VOVElORUxdOiBcIlNlbnRpbmVsIFskaGV4U2VudGluZWxdIG11c3Qgbm90IGJlIHByZXNlbnQgaW4gZW5jb2RlZCBieXRlcyBbJGhleEVuY29kZWRCeXRlc10uXCIsXG4gIFtTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX0ZJWEVEX1NJWkVfTUlTTUFUQ0hdOiBcIkVuY29kZXIgYW5kIGRlY29kZXIgbXVzdCBoYXZlIHRoZSBzYW1lIGZpeGVkIHNpemUsIGdvdCBbJGVuY29kZXJGaXhlZFNpemVdIGFuZCBbJGRlY29kZXJGaXhlZFNpemVdLlwiLFxuICBbU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9NQVhfU0laRV9NSVNNQVRDSF06IFwiRW5jb2RlciBhbmQgZGVjb2RlciBtdXN0IGhhdmUgdGhlIHNhbWUgbWF4IHNpemUsIGdvdCBbJGVuY29kZXJNYXhTaXplXSBhbmQgWyRkZWNvZGVyTWF4U2l6ZV0uXCIsXG4gIFtTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX1NJWkVfQ09NUEFUSUJJTElUWV9NSVNNQVRDSF06IFwiRW5jb2RlciBhbmQgZGVjb2RlciBtdXN0IGVpdGhlciBib3RoIGJlIGZpeGVkLXNpemUgb3IgdmFyaWFibGUtc2l6ZS5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19FTlVNX0RJU0NSSU1JTkFUT1JfT1VUX09GX1JBTkdFXTogXCJFbnVtIGRpc2NyaW1pbmF0b3Igb3V0IG9mIHJhbmdlLiBFeHBlY3RlZCBhIG51bWJlciBpbiBbJGZvcm1hdHRlZFZhbGlkRGlzY3JpbWluYXRvcnNdLCBnb3QgJGRpc2NyaW1pbmF0b3IuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfRklYRURfTEVOR1RIXTogXCJFeHBlY3RlZCBhIGZpeGVkLXNpemUgY29kZWMsIGdvdCBhIHZhcmlhYmxlLXNpemUgb25lLlwiLFxuICBbU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1BPU0lUSVZFX0JZVEVfTEVOR1RIXTogXCJDb2RlYyBbJGNvZGVjRGVzY3JpcHRpb25dIGV4cGVjdGVkIGEgcG9zaXRpdmUgYnl0ZSBsZW5ndGgsIGdvdCAkYnl0ZXNMZW5ndGguXCIsXG4gIFtTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfVkFSSUFCTEVfTEVOR1RIXTogXCJFeHBlY3RlZCBhIHZhcmlhYmxlLXNpemUgY29kZWMsIGdvdCBhIGZpeGVkLXNpemUgb25lLlwiLFxuICBbU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1pFUk9fVkFMVUVfVE9fTUFUQ0hfSVRFTV9GSVhFRF9TSVpFXTogXCJDb2RlYyBbJGNvZGVjRGVzY3JpcHRpb25dIGV4cGVjdGVkIHplcm8tdmFsdWUgWyRoZXhaZXJvVmFsdWVdIHRvIGhhdmUgdGhlIHNhbWUgc2l6ZSBhcyB0aGUgcHJvdmlkZWQgZml4ZWQtc2l6ZSBpdGVtIFskZXhwZWN0ZWRTaXplIGJ5dGVzXS5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0JZVEVfTEVOR1RIXTogXCJDb2RlYyBbJGNvZGVjRGVzY3JpcHRpb25dIGV4cGVjdGVkICRleHBlY3RlZCBieXRlcywgZ290ICRieXRlc0xlbmd0aC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0NPTlNUQU5UXTogXCJFeHBlY3RlZCBieXRlIGFycmF5IGNvbnN0YW50IFskaGV4Q29uc3RhbnRdIHRvIGJlIHByZXNlbnQgaW4gZGF0YSBbJGhleERhdGFdIGF0IG9mZnNldCBbJG9mZnNldF0uXCIsXG4gIFtTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9ESVNDUklNSU5BVEVEX1VOSU9OX1ZBUklBTlRdOiBcIkludmFsaWQgZGlzY3JpbWluYXRlZCB1bmlvbiB2YXJpYW50LiBFeHBlY3RlZCBvbmUgb2YgWyR2YXJpYW50c10sIGdvdCAkdmFsdWUuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9FTlVNX1ZBUklBTlRdOiBcIkludmFsaWQgZW51bSB2YXJpYW50LiBFeHBlY3RlZCBvbmUgb2YgWyRzdHJpbmdWYWx1ZXNdIG9yIGEgbnVtYmVyIGluIFskZm9ybWF0dGVkTnVtZXJpY2FsVmFsdWVzXSwgZ290ICR2YXJpYW50LlwiLFxuICBbU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfTElURVJBTF9VTklPTl9WQVJJQU5UXTogXCJJbnZhbGlkIGxpdGVyYWwgdW5pb24gdmFyaWFudC4gRXhwZWN0ZWQgb25lIG9mIFskdmFyaWFudHNdLCBnb3QgJHZhbHVlLlwiLFxuICBbU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfTlVNQkVSX09GX0lURU1TXTogXCJFeHBlY3RlZCBbJGNvZGVjRGVzY3JpcHRpb25dIHRvIGhhdmUgJGV4cGVjdGVkIGl0ZW1zLCBnb3QgJGFjdHVhbC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX1NUUklOR19GT1JfQkFTRV06IFwiSW52YWxpZCB2YWx1ZSAkdmFsdWUgZm9yIGJhc2UgJGJhc2Ugd2l0aCBhbHBoYWJldCAkYWxwaGFiZXQuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0NPREVDU19fTElURVJBTF9VTklPTl9ESVNDUklNSU5BVE9SX09VVF9PRl9SQU5HRV06IFwiTGl0ZXJhbCB1bmlvbiBkaXNjcmltaW5hdG9yIG91dCBvZiByYW5nZS4gRXhwZWN0ZWQgYSBudW1iZXIgYmV0d2VlbiAkbWluUmFuZ2UgYW5kICRtYXhSYW5nZSwgZ290ICRkaXNjcmltaW5hdG9yLlwiLFxuICBbU09MQU5BX0VSUk9SX19DT0RFQ1NfX05VTUJFUl9PVVRfT0ZfUkFOR0VdOiBcIkNvZGVjIFskY29kZWNEZXNjcmlwdGlvbl0gZXhwZWN0ZWQgbnVtYmVyIHRvIGJlIGluIHRoZSByYW5nZSBbJG1pbiwgJG1heF0sIGdvdCAkdmFsdWUuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0NPREVDU19fT0ZGU0VUX09VVF9PRl9SQU5HRV06IFwiQ29kZWMgWyRjb2RlY0Rlc2NyaXB0aW9uXSBleHBlY3RlZCBvZmZzZXQgdG8gYmUgaW4gdGhlIHJhbmdlIFswLCAkYnl0ZXNMZW5ndGhdLCBnb3QgJG9mZnNldC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19TRU5USU5FTF9NSVNTSU5HX0lOX0RFQ09ERURfQllURVNdOiBcIkV4cGVjdGVkIHNlbnRpbmVsIFskaGV4U2VudGluZWxdIHRvIGJlIHByZXNlbnQgaW4gZGVjb2RlZCBieXRlcyBbJGhleERlY29kZWRCeXRlc10uXCIsXG4gIFtTT0xBTkFfRVJST1JfX0NPREVDU19fVU5JT05fVkFSSUFOVF9PVVRfT0ZfUkFOR0VdOiBcIlVuaW9uIHZhcmlhbnQgb3V0IG9mIHJhbmdlLiBFeHBlY3RlZCBhbiBpbmRleCBiZXR3ZWVuICRtaW5SYW5nZSBhbmQgJG1heFJhbmdlLCBnb3QgJHZhcmlhbnQuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0NSWVBUT19fUkFORE9NX1ZBTFVFU19GVU5DVElPTl9VTklNUExFTUVOVEVEXTogXCJObyByYW5kb20gdmFsdWVzIGltcGxlbWVudGF0aW9uIGNvdWxkIGJlIGZvdW5kLlwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9BTFJFQURZX0lOSVRJQUxJWkVEXTogXCJpbnN0cnVjdGlvbiByZXF1aXJlcyBhbiB1bmluaXRpYWxpemVkIGFjY291bnRcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfQk9SUk9XX0ZBSUxFRF06IFwiaW5zdHJ1Y3Rpb24gdHJpZXMgdG8gYm9ycm93IHJlZmVyZW5jZSBmb3IgYW4gYWNjb3VudCB3aGljaCBpcyBhbHJlYWR5IGJvcnJvd2VkXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX0JPUlJPV19PVVRTVEFORElOR106IFwiaW5zdHJ1Y3Rpb24gbGVmdCBhY2NvdW50IHdpdGggYW4gb3V0c3RhbmRpbmcgYm9ycm93ZWQgcmVmZXJlbmNlXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX0RBVEFfU0laRV9DSEFOR0VEXTogXCJwcm9ncmFtIG90aGVyIHRoYW4gdGhlIGFjY291bnQncyBvd25lciBjaGFuZ2VkIHRoZSBzaXplIG9mIHRoZSBhY2NvdW50IGRhdGFcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfREFUQV9UT09fU01BTExdOiBcImFjY291bnQgZGF0YSB0b28gc21hbGwgZm9yIGluc3RydWN0aW9uXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX05PVF9FWEVDVVRBQkxFXTogXCJpbnN0cnVjdGlvbiBleHBlY3RlZCBhbiBleGVjdXRhYmxlIGFjY291bnRcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfTk9UX1JFTlRfRVhFTVBUXTogXCJBbiBhY2NvdW50IGRvZXMgbm90IGhhdmUgZW5vdWdoIGxhbXBvcnRzIHRvIGJlIHJlbnQtZXhlbXB0XCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BUklUSE1FVElDX09WRVJGTE9XXTogXCJQcm9ncmFtIGFyaXRobWV0aWMgb3ZlcmZsb3dlZFwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQk9SU0hfSU9fRVJST1JdOiBcIkZhaWxlZCB0byBzZXJpYWxpemUgb3IgZGVzZXJpYWxpemUgYWNjb3VudCBkYXRhOiAkZW5jb2RlZERhdGFcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0JVSUxUSU5fUFJPR1JBTVNfTVVTVF9DT05TVU1FX0NPTVBVVEVfVU5JVFNdOiBcIkJ1aWx0aW4gcHJvZ3JhbXMgbXVzdCBjb25zdW1lIGNvbXB1dGUgdW5pdHNcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0NBTExfREVQVEhdOiBcIkNyb3NzLXByb2dyYW0gaW52b2NhdGlvbiBjYWxsIGRlcHRoIHRvbyBkZWVwXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19DT01QVVRBVElPTkFMX0JVREdFVF9FWENFRURFRF06IFwiQ29tcHV0YXRpb25hbCBidWRnZXQgZXhjZWVkZWRcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0NVU1RPTV06IFwiY3VzdG9tIHByb2dyYW0gZXJyb3I6ICMkY29kZVwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRFVQTElDQVRFX0FDQ09VTlRfSU5ERVhdOiBcImluc3RydWN0aW9uIGNvbnRhaW5zIGR1cGxpY2F0ZSBhY2NvdW50c1wiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRFVQTElDQVRFX0FDQ09VTlRfT1VUX09GX1NZTkNdOiBcImluc3RydWN0aW9uIG1vZGlmaWNhdGlvbnMgb2YgbXVsdGlwbHktcGFzc2VkIGFjY291bnQgZGlmZmVyXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19FWEVDVVRBQkxFX0FDQ09VTlRfTk9UX1JFTlRfRVhFTVBUXTogXCJleGVjdXRhYmxlIGFjY291bnRzIG11c3QgYmUgcmVudCBleGVtcHRcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0VYRUNVVEFCTEVfREFUQV9NT0RJRklFRF06IFwiaW5zdHJ1Y3Rpb24gY2hhbmdlZCBleGVjdXRhYmxlIGFjY291bnRzIGRhdGFcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0VYRUNVVEFCTEVfTEFNUE9SVF9DSEFOR0VdOiBcImluc3RydWN0aW9uIGNoYW5nZWQgdGhlIGJhbGFuY2Ugb2YgYW4gZXhlY3V0YWJsZSBhY2NvdW50XCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19FWEVDVVRBQkxFX01PRElGSUVEXTogXCJpbnN0cnVjdGlvbiBjaGFuZ2VkIGV4ZWN1dGFibGUgYml0IG9mIGFuIGFjY291bnRcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0VYVEVSTkFMX0FDQ09VTlRfREFUQV9NT0RJRklFRF06IFwiaW5zdHJ1Y3Rpb24gbW9kaWZpZWQgZGF0YSBvZiBhbiBhY2NvdW50IGl0IGRvZXMgbm90IG93blwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRVhURVJOQUxfQUNDT1VOVF9MQU1QT1JUX1NQRU5EXTogXCJpbnN0cnVjdGlvbiBzcGVudCBmcm9tIHRoZSBiYWxhbmNlIG9mIGFuIGFjY291bnQgaXQgZG9lcyBub3Qgb3duXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19HRU5FUklDX0VSUk9SXTogXCJnZW5lcmljIGluc3RydWN0aW9uIGVycm9yXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTExFR0FMX09XTkVSXTogXCJQcm92aWRlZCBvd25lciBpcyBub3QgYWxsb3dlZFwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU1NVVRBQkxFXTogXCJBY2NvdW50IGlzIGltbXV0YWJsZVwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5DT1JSRUNUX0FVVEhPUklUWV06IFwiSW5jb3JyZWN0IGF1dGhvcml0eSBwcm92aWRlZFwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5DT1JSRUNUX1BST0dSQU1fSURdOiBcImluY29ycmVjdCBwcm9ncmFtIGlkIGZvciBpbnN0cnVjdGlvblwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5TVUZGSUNJRU5UX0ZVTkRTXTogXCJpbnN1ZmZpY2llbnQgZnVuZHMgZm9yIGluc3RydWN0aW9uXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX0FDQ09VTlRfREFUQV06IFwiaW52YWxpZCBhY2NvdW50IGRhdGEgZm9yIGluc3RydWN0aW9uXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX0FDQ09VTlRfT1dORVJdOiBcIkludmFsaWQgYWNjb3VudCBvd25lclwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9BUkdVTUVOVF06IFwiaW52YWxpZCBwcm9ncmFtIGFyZ3VtZW50XCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX0VSUk9SXTogXCJwcm9ncmFtIHJldHVybmVkIGludmFsaWQgZXJyb3IgY29kZVwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9JTlNUUlVDVElPTl9EQVRBXTogXCJpbnZhbGlkIGluc3RydWN0aW9uIGRhdGFcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfUkVBTExPQ106IFwiRmFpbGVkIHRvIHJlYWxsb2NhdGUgYWNjb3VudCBkYXRhXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX1NFRURTXTogXCJQcm92aWRlZCBzZWVkcyBkbyBub3QgcmVzdWx0IGluIGEgdmFsaWQgYWRkcmVzc1wiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUFYX0FDQ09VTlRTX0RBVEFfQUxMT0NBVElPTlNfRVhDRUVERURdOiBcIkFjY291bnRzIGRhdGEgYWxsb2NhdGlvbnMgZXhjZWVkZWQgdGhlIG1heGltdW0gYWxsb3dlZCBwZXIgdHJhbnNhY3Rpb25cIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01BWF9BQ0NPVU5UU19FWENFRURFRF06IFwiTWF4IGFjY291bnRzIGV4Y2VlZGVkXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NQVhfSU5TVFJVQ1RJT05fVFJBQ0VfTEVOR1RIX0VYQ0VFREVEXTogXCJNYXggaW5zdHJ1Y3Rpb24gdHJhY2UgbGVuZ3RoIGV4Y2VlZGVkXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NQVhfU0VFRF9MRU5HVEhfRVhDRUVERURdOiBcIkxlbmd0aCBvZiB0aGUgc2VlZCBpcyB0b28gbG9uZyBmb3IgYWRkcmVzcyBnZW5lcmF0aW9uXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NSVNTSU5HX0FDQ09VTlRdOiBcIkFuIGFjY291bnQgcmVxdWlyZWQgYnkgdGhlIGluc3RydWN0aW9uIGlzIG1pc3NpbmdcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01JU1NJTkdfUkVRVUlSRURfU0lHTkFUVVJFXTogXCJtaXNzaW5nIHJlcXVpcmVkIHNpZ25hdHVyZSBmb3IgaW5zdHJ1Y3Rpb25cIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01PRElGSUVEX1BST0dSQU1fSURdOiBcImluc3RydWN0aW9uIGlsbGVnYWxseSBtb2RpZmllZCB0aGUgcHJvZ3JhbSBpZCBvZiBhbiBhY2NvdW50XCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19OT1RfRU5PVUdIX0FDQ09VTlRfS0VZU106IFwiaW5zdWZmaWNpZW50IGFjY291bnQga2V5cyBmb3IgaW5zdHJ1Y3Rpb25cIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1BSSVZJTEVHRV9FU0NBTEFUSU9OXTogXCJDcm9zcy1wcm9ncmFtIGludm9jYXRpb24gd2l0aCB1bmF1dGhvcml6ZWQgc2lnbmVyIG9yIHdyaXRhYmxlIGFjY291bnRcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1BST0dSQU1fRU5WSVJPTk1FTlRfU0VUVVBfRkFJTFVSRV06IFwiRmFpbGVkIHRvIGNyZWF0ZSBwcm9ncmFtIGV4ZWN1dGlvbiBlbnZpcm9ubWVudFwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUFJPR1JBTV9GQUlMRURfVE9fQ09NUElMRV06IFwiUHJvZ3JhbSBmYWlsZWQgdG8gY29tcGlsZVwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUFJPR1JBTV9GQUlMRURfVE9fQ09NUExFVEVdOiBcIlByb2dyYW0gZmFpbGVkIHRvIGNvbXBsZXRlXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19SRUFET05MWV9EQVRBX01PRElGSUVEXTogXCJpbnN0cnVjdGlvbiBtb2RpZmllZCBkYXRhIG9mIGEgcmVhZC1vbmx5IGFjY291bnRcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1JFQURPTkxZX0xBTVBPUlRfQ0hBTkdFXTogXCJpbnN0cnVjdGlvbiBjaGFuZ2VkIHRoZSBiYWxhbmNlIG9mIGEgcmVhZC1vbmx5IGFjY291bnRcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1JFRU5UUkFOQ1lfTk9UX0FMTE9XRURdOiBcIkNyb3NzLXByb2dyYW0gaW52b2NhdGlvbiByZWVudHJhbmN5IG5vdCBhbGxvd2VkIGZvciB0aGlzIGluc3RydWN0aW9uXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19SRU5UX0VQT0NIX01PRElGSUVEXTogXCJpbnN0cnVjdGlvbiBtb2RpZmllZCByZW50IGVwb2NoIG9mIGFuIGFjY291bnRcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1VOQkFMQU5DRURfSU5TVFJVQ1RJT05dOiBcInN1bSBvZiBhY2NvdW50IGJhbGFuY2VzIGJlZm9yZSBhbmQgYWZ0ZXIgaW5zdHJ1Y3Rpb24gZG8gbm90IG1hdGNoXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19VTklOSVRJQUxJWkVEX0FDQ09VTlRdOiBcImluc3RydWN0aW9uIHJlcXVpcmVzIGFuIGluaXRpYWxpemVkIGFjY291bnRcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1VOS05PV05dOiBcIlwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fVU5TVVBQT1JURURfUFJPR1JBTV9JRF06IFwiVW5zdXBwb3J0ZWQgcHJvZ3JhbSBpZFwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fVU5TVVBQT1JURURfU1lTVkFSXTogXCJVbnN1cHBvcnRlZCBzeXN2YXJcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fX0VYUEVDVEVEX1RPX0hBVkVfQUNDT1VOVFNdOiBcIlRoZSBpbnN0cnVjdGlvbiBkb2VzIG5vdCBoYXZlIGFueSBhY2NvdW50cy5cIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fX0VYUEVDVEVEX1RPX0hBVkVfREFUQV06IFwiVGhlIGluc3RydWN0aW9uIGRvZXMgbm90IGhhdmUgYW55IGRhdGEuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX19QUk9HUkFNX0lEX01JU01BVENIXTogXCJFeHBlY3RlZCBpbnN0cnVjdGlvbiB0byBoYXZlIHByb2dyZXNzIGFkZHJlc3MgJGV4cGVjdGVkUHJvZ3JhbUFkZHJlc3MsIGdvdCAkYWN0dWFsUHJvZ3JhbUFkZHJlc3MuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOVkFMSURfQkxPQ0tIQVNIX0JZVEVfTEVOR1RIXTogXCJFeHBlY3RlZCBiYXNlNTggZW5jb2RlZCBibG9ja2hhc2ggdG8gZGVjb2RlIHRvIGEgYnl0ZSBhcnJheSBvZiBsZW5ndGggMzIuIEFjdHVhbCBsZW5ndGg6ICRhY3R1YWxMZW5ndGguXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOVkFMSURfTk9OQ0VdOiBcIlRoZSBub25jZSBgJGV4cGVjdGVkTm9uY2VWYWx1ZWAgaXMgbm8gbG9uZ2VyIHZhbGlkLiBJdCBoYXMgYWR2YW5jZWQgdG8gYCRhY3R1YWxOb25jZVZhbHVlYFwiLFxuICBbU09MQU5BX0VSUk9SX19JTlZBUklBTlRfVklPTEFUSU9OX19DQUNIRURfQUJPUlRBQkxFX0lURVJBQkxFX0NBQ0hFX0VOVFJZX01JU1NJTkddOiBcIkludmFyaWFudCB2aW9sYXRpb246IEZvdW5kIG5vIGFib3J0YWJsZSBpdGVyYWJsZSBjYWNoZSBlbnRyeSBmb3Iga2V5IGAkY2FjaGVLZXlgLiBJdCBzaG91bGQgYmUgaW1wb3NzaWJsZSB0byBoaXQgdGhpcyBlcnJvcjsgcGxlYXNlIGZpbGUgYW4gaXNzdWUgYXQgaHR0cHM6Ly9zb2xhLm5hL3dlYjNpbnZhcmlhbnRcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5WQVJJQU5UX1ZJT0xBVElPTl9fREFUQV9QVUJMSVNIRVJfQ0hBTk5FTF9VTklNUExFTUVOVEVEXTogXCJJbnZhcmlhbnQgdmlvbGF0aW9uOiBUaGlzIGRhdGEgcHVibGlzaGVyIGRvZXMgbm90IHB1Ymxpc2ggdG8gdGhlIGNoYW5uZWwgbmFtZWQgYCRjaGFubmVsTmFtZWAuIFN1cHBvcnRlZCBjaGFubmVscyBpbmNsdWRlICRzdXBwb3J0ZWRDaGFubmVsTmFtZXMuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX1NVQlNDUklQVElPTl9JVEVSQVRPUl9NVVNUX05PVF9QT0xMX0JFRk9SRV9SRVNPTFZJTkdfRVhJU1RJTkdfTUVTU0FHRV9QUk9NSVNFXTogXCJJbnZhcmlhbnQgdmlvbGF0aW9uOiBXZWJTb2NrZXQgbWVzc2FnZSBpdGVyYXRvciBzdGF0ZSBpcyBjb3JydXB0OyBpdGVyYXRlZCB3aXRob3V0IGZpcnN0IHJlc29sdmluZyBleGlzdGluZyBtZXNzYWdlIHByb21pc2UuIEl0IHNob3VsZCBiZSBpbXBvc3NpYmxlIHRvIGhpdCB0aGlzIGVycm9yOyBwbGVhc2UgZmlsZSBhbiBpc3N1ZSBhdCBodHRwczovL3NvbGEubmEvd2ViM2ludmFyaWFudFwiLFxuICBbU09MQU5BX0VSUk9SX19JTlZBUklBTlRfVklPTEFUSU9OX19TVUJTQ1JJUFRJT05fSVRFUkFUT1JfU1RBVEVfTUlTU0lOR106IFwiSW52YXJpYW50IHZpb2xhdGlvbjogV2ViU29ja2V0IG1lc3NhZ2UgaXRlcmF0b3IgaXMgbWlzc2luZyBzdGF0ZSBzdG9yYWdlLiBJdCBzaG91bGQgYmUgaW1wb3NzaWJsZSB0byBoaXQgdGhpcyBlcnJvcjsgcGxlYXNlIGZpbGUgYW4gaXNzdWUgYXQgaHR0cHM6Ly9zb2xhLm5hL3dlYjNpbnZhcmlhbnRcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5WQVJJQU5UX1ZJT0xBVElPTl9fU1dJVENIX01VU1RfQkVfRVhIQVVTVElWRV06IFwiSW52YXJpYW50IHZpb2xhdGlvbjogU3dpdGNoIHN0YXRlbWVudCBub24tZXhoYXVzdGl2ZS4gUmVjZWl2ZWQgdW5leHBlY3RlZCB2YWx1ZSBgJHVuZXhwZWN0ZWRWYWx1ZWAuIEl0IHNob3VsZCBiZSBpbXBvc3NpYmxlIHRvIGhpdCB0aGlzIGVycm9yOyBwbGVhc2UgZmlsZSBhbiBpc3N1ZSBhdCBodHRwczovL3NvbGEubmEvd2ViM2ludmFyaWFudFwiLFxuICBbU09MQU5BX0VSUk9SX19KU09OX1JQQ19fSU5URVJOQUxfRVJST1JdOiBcIkpTT04tUlBDIGVycm9yOiBJbnRlcm5hbCBKU09OLVJQQyBlcnJvciAoJF9fc2VydmVyTWVzc2FnZSlcIixcbiAgW1NPTEFOQV9FUlJPUl9fSlNPTl9SUENfX0lOVkFMSURfUEFSQU1TXTogXCJKU09OLVJQQyBlcnJvcjogSW52YWxpZCBtZXRob2QgcGFyYW1ldGVyKHMpICgkX19zZXJ2ZXJNZXNzYWdlKVwiLFxuICBbU09MQU5BX0VSUk9SX19KU09OX1JQQ19fSU5WQUxJRF9SRVFVRVNUXTogXCJKU09OLVJQQyBlcnJvcjogVGhlIEpTT04gc2VudCBpcyBub3QgYSB2YWxpZCBgUmVxdWVzdGAgb2JqZWN0ICgkX19zZXJ2ZXJNZXNzYWdlKVwiLFxuICBbU09MQU5BX0VSUk9SX19KU09OX1JQQ19fTUVUSE9EX05PVF9GT1VORF06IFwiSlNPTi1SUEMgZXJyb3I6IFRoZSBtZXRob2QgZG9lcyBub3QgZXhpc3QgLyBpcyBub3QgYXZhaWxhYmxlICgkX19zZXJ2ZXJNZXNzYWdlKVwiLFxuICBbU09MQU5BX0VSUk9SX19KU09OX1JQQ19fUEFSU0VfRVJST1JdOiBcIkpTT04tUlBDIGVycm9yOiBBbiBlcnJvciBvY2N1cnJlZCBvbiB0aGUgc2VydmVyIHdoaWxlIHBhcnNpbmcgdGhlIEpTT04gdGV4dCAoJF9fc2VydmVyTWVzc2FnZSlcIixcbiAgW1NPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NDQU5fRVJST1JdOiBcIiRfX3NlcnZlck1lc3NhZ2VcIixcbiAgW1NPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9CTE9DS19DTEVBTkVEX1VQXTogXCIkX19zZXJ2ZXJNZXNzYWdlXCIsXG4gIFtTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfQkxPQ0tfTk9UX0FWQUlMQUJMRV06IFwiJF9fc2VydmVyTWVzc2FnZVwiLFxuICBbU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0JMT0NLX1NUQVRVU19OT1RfQVZBSUxBQkxFX1lFVF06IFwiJF9fc2VydmVyTWVzc2FnZVwiLFxuICBbU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0tFWV9FWENMVURFRF9GUk9NX1NFQ09OREFSWV9JTkRFWF06IFwiJF9fc2VydmVyTWVzc2FnZVwiLFxuICBbU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0xPTkdfVEVSTV9TVE9SQUdFX1NMT1RfU0tJUFBFRF06IFwiJF9fc2VydmVyTWVzc2FnZVwiLFxuICBbU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX01JTl9DT05URVhUX1NMT1RfTk9UX1JFQUNIRURdOiBcIk1pbmltdW0gY29udGV4dCBzbG90IGhhcyBub3QgYmVlbiByZWFjaGVkXCIsXG4gIFtTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfTk9ERV9VTkhFQUxUSFldOiBcIk5vZGUgaXMgdW5oZWFsdGh5OyBiZWhpbmQgYnkgJG51bVNsb3RzQmVoaW5kIHNsb3RzXCIsXG4gIFtTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfTk9fU05BUFNIT1RdOiBcIk5vIHNuYXBzaG90XCIsXG4gIFtTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfU0VORF9UUkFOU0FDVElPTl9QUkVGTElHSFRfRkFJTFVSRV06IFwiVHJhbnNhY3Rpb24gc2ltdWxhdGlvbiBmYWlsZWRcIixcbiAgW1NPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9TTE9UX1NLSVBQRURdOiBcIiRfX3NlcnZlck1lc3NhZ2VcIixcbiAgW1NPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9ISVNUT1JZX05PVF9BVkFJTEFCTEVdOiBcIlRyYW5zYWN0aW9uIGhpc3RvcnkgaXMgbm90IGF2YWlsYWJsZSBmcm9tIHRoaXMgbm9kZVwiLFxuICBbU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX1BSRUNPTVBJTEVfVkVSSUZJQ0FUSU9OX0ZBSUxVUkVdOiBcIiRfX3NlcnZlck1lc3NhZ2VcIixcbiAgW1NPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9TSUdOQVRVUkVfTEVOX01JU01BVENIXTogXCJUcmFuc2FjdGlvbiBzaWduYXR1cmUgbGVuZ3RoIG1pc21hdGNoXCIsXG4gIFtTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fU0lHTkFUVVJFX1ZFUklGSUNBVElPTl9GQUlMVVJFXTogXCJUcmFuc2FjdGlvbiBzaWduYXR1cmUgdmVyaWZpY2F0aW9uIGZhaWx1cmVcIixcbiAgW1NPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9VTlNVUFBPUlRFRF9UUkFOU0FDVElPTl9WRVJTSU9OXTogXCIkX19zZXJ2ZXJNZXNzYWdlXCIsXG4gIFtTT0xBTkFfRVJST1JfX0tFWVNfX0lOVkFMSURfS0VZX1BBSVJfQllURV9MRU5HVEhdOiBcIktleSBwYWlyIGJ5dGVzIG11c3QgYmUgb2YgbGVuZ3RoIDY0LCBnb3QgJGJ5dGVMZW5ndGguXCIsXG4gIFtTT0xBTkFfRVJST1JfX0tFWVNfX0lOVkFMSURfUFJJVkFURV9LRVlfQllURV9MRU5HVEhdOiBcIkV4cGVjdGVkIHByaXZhdGUga2V5IGJ5dGVzIHdpdGggbGVuZ3RoIDMyLiBBY3R1YWwgbGVuZ3RoOiAkYWN0dWFsTGVuZ3RoLlwiLFxuICBbU09MQU5BX0VSUk9SX19LRVlTX19JTlZBTElEX1NJR05BVFVSRV9CWVRFX0xFTkdUSF06IFwiRXhwZWN0ZWQgYmFzZTU4LWVuY29kZWQgc2lnbmF0dXJlIHRvIGRlY29kZSB0byBhIGJ5dGUgYXJyYXkgb2YgbGVuZ3RoIDY0LiBBY3R1YWwgbGVuZ3RoOiAkYWN0dWFsTGVuZ3RoLlwiLFxuICBbU09MQU5BX0VSUk9SX19LRVlTX19QVUJMSUNfS0VZX01VU1RfTUFUQ0hfUFJJVkFURV9LRVldOiBcIlRoZSBwcm92aWRlZCBwcml2YXRlIGtleSBkb2VzIG5vdCBtYXRjaCB0aGUgcHJvdmlkZWQgcHVibGljIGtleS5cIixcbiAgW1NPTEFOQV9FUlJPUl9fS0VZU19fU0lHTkFUVVJFX1NUUklOR19MRU5HVEhfT1VUX09GX1JBTkdFXTogXCJFeHBlY3RlZCBiYXNlNTgtZW5jb2RlZCBzaWduYXR1cmUgc3RyaW5nIG9mIGxlbmd0aCBpbiB0aGUgcmFuZ2UgWzY0LCA4OF0uIEFjdHVhbCBsZW5ndGg6ICRhY3R1YWxMZW5ndGguXCIsXG4gIFtTT0xBTkFfRVJST1JfX0xBTVBPUlRTX09VVF9PRl9SQU5HRV06IFwiTGFtcG9ydHMgdmFsdWUgbXVzdCBiZSBpbiB0aGUgcmFuZ2UgWzAsIDJlNjQtMV1cIixcbiAgW1NPTEFOQV9FUlJPUl9fTUFMRk9STUVEX0JJR0lOVF9TVFJJTkddOiBcImAkdmFsdWVgIGNhbm5vdCBiZSBwYXJzZWQgYXMgYSBgQmlnSW50YFwiLFxuICBbU09MQU5BX0VSUk9SX19NQUxGT1JNRURfSlNPTl9SUENfRVJST1JdOiBcIiRtZXNzYWdlXCIsXG4gIFtTT0xBTkFfRVJST1JfX01BTEZPUk1FRF9OVU1CRVJfU1RSSU5HXTogXCJgJHZhbHVlYCBjYW5ub3QgYmUgcGFyc2VkIGFzIGEgYE51bWJlcmBcIixcbiAgW1NPTEFOQV9FUlJPUl9fTk9OQ0VfQUNDT1VOVF9OT1RfRk9VTkRdOiBcIk5vIG5vbmNlIGFjY291bnQgY291bGQgYmUgZm91bmQgYXQgYWRkcmVzcyBgJG5vbmNlQWNjb3VudEFkZHJlc3NgXCIsXG4gIFtTT0xBTkFfRVJST1JfX1JQQ19TVUJTQ1JJUFRJT05TX19DQU5OT1RfQ1JFQVRFX1NVQlNDUklQVElPTl9QTEFOXTogXCJUaGUgbm90aWZpY2F0aW9uIG5hbWUgbXVzdCBlbmQgaW4gJ05vdGlmaWNhdGlvbnMnIGFuZCB0aGUgQVBJIG11c3Qgc3VwcGx5IGEgc3Vic2NyaXB0aW9uIHBsYW4gY3JlYXRvciBmdW5jdGlvbiBmb3IgdGhlIG5vdGlmaWNhdGlvbiAnJG5vdGlmaWNhdGlvbk5hbWUnLlwiLFxuICBbU09MQU5BX0VSUk9SX19SUENfU1VCU0NSSVBUSU9OU19fQ0hBTk5FTF9DTE9TRURfQkVGT1JFX01FU1NBR0VfQlVGRkVSRURdOiBcIldlYlNvY2tldCB3YXMgY2xvc2VkIGJlZm9yZSBwYXlsb2FkIGNvdWxkIGJlIGFkZGVkIHRvIHRoZSBzZW5kIGJ1ZmZlclwiLFxuICBbU09MQU5BX0VSUk9SX19SUENfU1VCU0NSSVBUSU9OU19fQ0hBTk5FTF9DT05ORUNUSU9OX0NMT1NFRF06IFwiV2ViU29ja2V0IGNvbm5lY3Rpb24gY2xvc2VkXCIsXG4gIFtTT0xBTkFfRVJST1JfX1JQQ19TVUJTQ1JJUFRJT05TX19DSEFOTkVMX0ZBSUxFRF9UT19DT05ORUNUXTogXCJXZWJTb2NrZXQgZmFpbGVkIHRvIGNvbm5lY3RcIixcbiAgW1NPTEFOQV9FUlJPUl9fUlBDX1NVQlNDUklQVElPTlNfX0VYUEVDVEVEX1NFUlZFUl9TVUJTQ1JJUFRJT05fSURdOiBcIkZhaWxlZCB0byBvYnRhaW4gYSBzdWJzY3JpcHRpb24gaWQgZnJvbSB0aGUgc2VydmVyXCIsXG4gIFtTT0xBTkFfRVJST1JfX1JQQ19fQVBJX1BMQU5fTUlTU0lOR19GT1JfUlBDX01FVEhPRF06IFwiQ291bGQgbm90IGZpbmQgYW4gQVBJIHBsYW4gZm9yIFJQQyBtZXRob2Q6IGAkbWV0aG9kYFwiLFxuICBbU09MQU5BX0VSUk9SX19SUENfX0lOVEVHRVJfT1ZFUkZMT1ddOiBcIlRoZSAkYXJndW1lbnRMYWJlbCBhcmd1bWVudCB0byB0aGUgYCRtZXRob2ROYW1lYCBSUEMgbWV0aG9kJG9wdGlvbmFsUGF0aExhYmVsIHdhcyBgJHZhbHVlYC4gVGhpcyBudW1iZXIgaXMgdW5zYWZlIGZvciB1c2Ugd2l0aCB0aGUgU29sYW5hIEpTT04tUlBDIGJlY2F1c2UgaXQgZXhjZWVkcyBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlwiLFxuICBbU09MQU5BX0VSUk9SX19SUENfX1RSQU5TUE9SVF9IVFRQX0VSUk9SXTogXCJIVFRQIGVycm9yICgkc3RhdHVzQ29kZSk6ICRtZXNzYWdlXCIsXG4gIFtTT0xBTkFfRVJST1JfX1JQQ19fVFJBTlNQT1JUX0hUVFBfSEVBREVSX0ZPUkJJRERFTl06IFwiSFRUUCBoZWFkZXIocykgZm9yYmlkZGVuOiAkaGVhZGVycy4gTGVhcm4gbW9yZSBhdCBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0dsb3NzYXJ5L0ZvcmJpZGRlbl9oZWFkZXJfbmFtZS5cIixcbiAgW1NPTEFOQV9FUlJPUl9fU0lHTkVSX19BRERSRVNTX0NBTk5PVF9IQVZFX01VTFRJUExFX1NJR05FUlNdOiBcIk11bHRpcGxlIGRpc3RpbmN0IHNpZ25lcnMgd2VyZSBpZGVudGlmaWVkIGZvciBhZGRyZXNzIGAkYWRkcmVzc2AuIFBsZWFzZSBlbnN1cmUgdGhhdCB5b3UgYXJlIHVzaW5nIHRoZSBzYW1lIHNpZ25lciBpbnN0YW5jZSBmb3IgZWFjaCBhZGRyZXNzLlwiLFxuICBbU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX0tFWV9QQUlSX1NJR05FUl06IFwiVGhlIHByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IGltcGxlbWVudCB0aGUgYEtleVBhaXJTaWduZXJgIGludGVyZmFjZVwiLFxuICBbU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX01FU1NBR0VfTU9ESUZZSU5HX1NJR05FUl06IFwiVGhlIHByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IGltcGxlbWVudCB0aGUgYE1lc3NhZ2VNb2RpZnlpbmdTaWduZXJgIGludGVyZmFjZVwiLFxuICBbU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX01FU1NBR0VfUEFSVElBTF9TSUdORVJdOiBcIlRoZSBwcm92aWRlZCB2YWx1ZSBkb2VzIG5vdCBpbXBsZW1lbnQgdGhlIGBNZXNzYWdlUGFydGlhbFNpZ25lcmAgaW50ZXJmYWNlXCIsXG4gIFtTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfTUVTU0FHRV9TSUdORVJdOiBcIlRoZSBwcm92aWRlZCB2YWx1ZSBkb2VzIG5vdCBpbXBsZW1lbnQgYW55IG9mIHRoZSBgTWVzc2FnZVNpZ25lcmAgaW50ZXJmYWNlc1wiLFxuICBbU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX1RSQU5TQUNUSU9OX01PRElGWUlOR19TSUdORVJdOiBcIlRoZSBwcm92aWRlZCB2YWx1ZSBkb2VzIG5vdCBpbXBsZW1lbnQgdGhlIGBUcmFuc2FjdGlvbk1vZGlmeWluZ1NpZ25lcmAgaW50ZXJmYWNlXCIsXG4gIFtTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfVFJBTlNBQ1RJT05fUEFSVElBTF9TSUdORVJdOiBcIlRoZSBwcm92aWRlZCB2YWx1ZSBkb2VzIG5vdCBpbXBsZW1lbnQgdGhlIGBUcmFuc2FjdGlvblBhcnRpYWxTaWduZXJgIGludGVyZmFjZVwiLFxuICBbU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX1RSQU5TQUNUSU9OX1NFTkRJTkdfU0lHTkVSXTogXCJUaGUgcHJvdmlkZWQgdmFsdWUgZG9lcyBub3QgaW1wbGVtZW50IHRoZSBgVHJhbnNhY3Rpb25TZW5kaW5nU2lnbmVyYCBpbnRlcmZhY2VcIixcbiAgW1NPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9UUkFOU0FDVElPTl9TSUdORVJdOiBcIlRoZSBwcm92aWRlZCB2YWx1ZSBkb2VzIG5vdCBpbXBsZW1lbnQgYW55IG9mIHRoZSBgVHJhbnNhY3Rpb25TaWduZXJgIGludGVyZmFjZXNcIixcbiAgW1NPTEFOQV9FUlJPUl9fU0lHTkVSX19UUkFOU0FDVElPTl9DQU5OT1RfSEFWRV9NVUxUSVBMRV9TRU5ESU5HX1NJR05FUlNdOiBcIk1vcmUgdGhhbiBvbmUgYFRyYW5zYWN0aW9uU2VuZGluZ1NpZ25lcmAgd2FzIGlkZW50aWZpZWQuXCIsXG4gIFtTT0xBTkFfRVJST1JfX1NJR05FUl9fVFJBTlNBQ1RJT05fU0VORElOR19TSUdORVJfTUlTU0lOR106IFwiTm8gYFRyYW5zYWN0aW9uU2VuZGluZ1NpZ25lcmAgd2FzIGlkZW50aWZpZWQuIFBsZWFzZSBwcm92aWRlIGEgdmFsaWQgYFRyYW5zYWN0aW9uV2l0aFNpbmdsZVNlbmRpbmdTaWduZXJgIHRyYW5zYWN0aW9uLlwiLFxuICBbU09MQU5BX0VSUk9SX19TSUdORVJfX1dBTExFVF9NVUxUSVNJR05fVU5JTVBMRU1FTlRFRF06IFwiV2FsbGV0IGFjY291bnQgc2lnbmVycyBkbyBub3Qgc3VwcG9ydCBzaWduaW5nIG11bHRpcGxlIG1lc3NhZ2VzL3RyYW5zYWN0aW9ucyBpbiBhIHNpbmdsZSBvcGVyYXRpb25cIixcbiAgW1NPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fQ0FOTk9UX0VYUE9SVF9OT05fRVhUUkFDVEFCTEVfS0VZXTogXCJDYW5ub3QgZXhwb3J0IGEgbm9uLWV4dHJhY3RhYmxlIGtleS5cIixcbiAgW1NPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fRElHRVNUX1VOSU1QTEVNRU5URURdOiBcIk5vIGRpZ2VzdCBpbXBsZW1lbnRhdGlvbiBjb3VsZCBiZSBmb3VuZC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fRElTQUxMT1dFRF9JTl9JTlNFQ1VSRV9DT05URVhUXTogXCJDcnlwdG9ncmFwaGljIG9wZXJhdGlvbnMgYXJlIG9ubHkgYWxsb3dlZCBpbiBzZWN1cmUgYnJvd3NlciBjb250ZXh0cy4gUmVhZCBtb3JlIGhlcmU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NlY3VyaXR5L1NlY3VyZV9Db250ZXh0cy5cIixcbiAgW1NPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fRUQyNTUxOV9BTEdPUklUSE1fVU5JTVBMRU1FTlRFRF06IFwiVGhpcyBydW50aW1lIGRvZXMgbm90IHN1cHBvcnQgdGhlIGdlbmVyYXRpb24gb2YgRWQyNTUxOSBrZXkgcGFpcnMuXFxuXFxuSW5zdGFsbCBAc29sYW5hL3dlYmNyeXB0by1lZDI1NTE5LXBvbHlmaWxsIGFuZCBjYWxsIGl0cyBgaW5zdGFsbGAgZnVuY3Rpb24gYmVmb3JlIGdlbmVyYXRpbmcga2V5cyBpbiBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3Qgc3VwcG9ydCBFZDI1NTE5LlxcblxcbkZvciBhIGxpc3Qgb2YgcnVudGltZXMgdGhhdCBjdXJyZW50bHkgc3VwcG9ydCBFZDI1NTE5IG9wZXJhdGlvbnMsIHZpc2l0IGh0dHBzOi8vZ2l0aHViLmNvbS9XSUNHL3dlYmNyeXB0by1zZWN1cmUtY3VydmVzL2lzc3Vlcy8yMC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fRVhQT1JUX0ZVTkNUSU9OX1VOSU1QTEVNRU5URURdOiBcIk5vIHNpZ25hdHVyZSB2ZXJpZmljYXRpb24gaW1wbGVtZW50YXRpb24gY291bGQgYmUgZm91bmQuXCIsXG4gIFtTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0dFTkVSQVRFX0ZVTkNUSU9OX1VOSU1QTEVNRU5URURdOiBcIk5vIGtleSBnZW5lcmF0aW9uIGltcGxlbWVudGF0aW9uIGNvdWxkIGJlIGZvdW5kLlwiLFxuICBbU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19TSUdOX0ZVTkNUSU9OX1VOSU1QTEVNRU5URURdOiBcIk5vIHNpZ25pbmcgaW1wbGVtZW50YXRpb24gY291bGQgYmUgZm91bmQuXCIsXG4gIFtTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX1ZFUklGWV9GVU5DVElPTl9VTklNUExFTUVOVEVEXTogXCJObyBrZXkgZXhwb3J0IGltcGxlbWVudGF0aW9uIGNvdWxkIGJlIGZvdW5kLlwiLFxuICBbU09MQU5BX0VSUk9SX19USU1FU1RBTVBfT1VUX09GX1JBTkdFXTogXCJUaW1lc3RhbXAgdmFsdWUgbXVzdCBiZSBpbiB0aGUgcmFuZ2UgWy0oMm4gKiogNjNuKSwgKDJuICoqIDYzbikgLSAxXS4gYCR2YWx1ZWAgZ2l2ZW5cIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0FDQ09VTlRfQk9SUk9XX09VVFNUQU5ESU5HXTogXCJUcmFuc2FjdGlvbiBwcm9jZXNzaW5nIGxlZnQgYW4gYWNjb3VudCB3aXRoIGFuIG91dHN0YW5kaW5nIGJvcnJvd2VkIHJlZmVyZW5jZVwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQUNDT1VOVF9JTl9VU0VdOiBcIkFjY291bnQgaW4gdXNlXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19BQ0NPVU5UX0xPQURFRF9UV0lDRV06IFwiQWNjb3VudCBsb2FkZWQgdHdpY2VcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0FDQ09VTlRfTk9UX0ZPVU5EXTogXCJBdHRlbXB0IHRvIGRlYml0IGFuIGFjY291bnQgYnV0IGZvdW5kIG5vIHJlY29yZCBvZiBhIHByaW9yIGNyZWRpdC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0FERFJFU1NfTE9PS1VQX1RBQkxFX05PVF9GT1VORF06IFwiVHJhbnNhY3Rpb24gbG9hZHMgYW4gYWRkcmVzcyB0YWJsZSBhY2NvdW50IHRoYXQgZG9lc24ndCBleGlzdFwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQUxSRUFEWV9QUk9DRVNTRURdOiBcIlRoaXMgdHJhbnNhY3Rpb24gaGFzIGFscmVhZHkgYmVlbiBwcm9jZXNzZWRcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0JMT0NLSEFTSF9OT1RfRk9VTkRdOiBcIkJsb2NraGFzaCBub3QgZm91bmRcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0NBTExfQ0hBSU5fVE9PX0RFRVBdOiBcIkxvYWRlciBjYWxsIGNoYWluIGlzIHRvbyBkZWVwXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19DTFVTVEVSX01BSU5URU5BTkNFXTogXCJUcmFuc2FjdGlvbnMgYXJlIGN1cnJlbnRseSBkaXNhYmxlZCBkdWUgdG8gY2x1c3RlciBtYWludGVuYW5jZVwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fRFVQTElDQVRFX0lOU1RSVUNUSU9OXTogXCJUcmFuc2FjdGlvbiBjb250YWlucyBhIGR1cGxpY2F0ZSBpbnN0cnVjdGlvbiAoJGluZGV4KSB0aGF0IGlzIG5vdCBhbGxvd2VkXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlNVRkZJQ0lFTlRfRlVORFNfRk9SX0ZFRV06IFwiSW5zdWZmaWNpZW50IGZ1bmRzIGZvciBmZWVcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOU1VGRklDSUVOVF9GVU5EU19GT1JfUkVOVF06IFwiVHJhbnNhY3Rpb24gcmVzdWx0cyBpbiBhbiBhY2NvdW50ICgkYWNjb3VudEluZGV4KSB3aXRoIGluc3VmZmljaWVudCBmdW5kcyBmb3IgcmVudFwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9BQ0NPVU5UX0ZPUl9GRUVdOiBcIlRoaXMgYWNjb3VudCBtYXkgbm90IGJlIHVzZWQgdG8gcGF5IHRyYW5zYWN0aW9uIGZlZXNcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfQUNDT1VOVF9JTkRFWF06IFwiVHJhbnNhY3Rpb24gY29udGFpbnMgYW4gaW52YWxpZCBhY2NvdW50IHJlZmVyZW5jZVwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9BRERSRVNTX0xPT0tVUF9UQUJMRV9EQVRBXTogXCJUcmFuc2FjdGlvbiBsb2FkcyBhbiBhZGRyZXNzIHRhYmxlIGFjY291bnQgd2l0aCBpbnZhbGlkIGRhdGFcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfQUREUkVTU19MT09LVVBfVEFCTEVfSU5ERVhdOiBcIlRyYW5zYWN0aW9uIGFkZHJlc3MgdGFibGUgbG9va3VwIHVzZXMgYW4gaW52YWxpZCBpbmRleFwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9BRERSRVNTX0xPT0tVUF9UQUJMRV9PV05FUl06IFwiVHJhbnNhY3Rpb24gbG9hZHMgYW4gYWRkcmVzcyB0YWJsZSBhY2NvdW50IHdpdGggYW4gaW52YWxpZCBvd25lclwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9MT0FERURfQUNDT1VOVFNfREFUQV9TSVpFX0xJTUlUXTogXCJMb2FkZWRBY2NvdW50c0RhdGFTaXplTGltaXQgc2V0IGZvciB0cmFuc2FjdGlvbiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwLlwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9QUk9HUkFNX0ZPUl9FWEVDVVRJT05dOiBcIlRoaXMgcHJvZ3JhbSBtYXkgbm90IGJlIHVzZWQgZm9yIGV4ZWN1dGluZyBpbnN0cnVjdGlvbnNcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfUkVOVF9QQVlJTkdfQUNDT1VOVF06IFwiVHJhbnNhY3Rpb24gbGVhdmVzIGFuIGFjY291bnQgd2l0aCBhIGxvd2VyIGJhbGFuY2UgdGhhbiByZW50LWV4ZW1wdCBtaW5pbXVtXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX1dSSVRBQkxFX0FDQ09VTlRdOiBcIlRyYW5zYWN0aW9uIGxvYWRzIGEgd3JpdGFibGUgYWNjb3VudCB0aGF0IGNhbm5vdCBiZSB3cml0dGVuXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19NQVhfTE9BREVEX0FDQ09VTlRTX0RBVEFfU0laRV9FWENFRURFRF06IFwiVHJhbnNhY3Rpb24gZXhjZWVkZWQgbWF4IGxvYWRlZCBhY2NvdW50cyBkYXRhIHNpemUgY2FwXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19NSVNTSU5HX1NJR05BVFVSRV9GT1JfRkVFXTogXCJUcmFuc2FjdGlvbiByZXF1aXJlcyBhIGZlZSBidXQgaGFzIG5vIHNpZ25hdHVyZSBwcmVzZW50XCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19QUk9HUkFNX0FDQ09VTlRfTk9UX0ZPVU5EXTogXCJBdHRlbXB0IHRvIGxvYWQgYSBwcm9ncmFtIHRoYXQgZG9lcyBub3QgZXhpc3RcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1BST0dSQU1fRVhFQ1VUSU9OX1RFTVBPUkFSSUxZX1JFU1RSSUNURURdOiBcIkV4ZWN1dGlvbiBvZiB0aGUgcHJvZ3JhbSByZWZlcmVuY2VkIGJ5IGFjY291bnQgYXQgaW5kZXggJGFjY291bnRJbmRleCBpcyB0ZW1wb3JhcmlseSByZXN0cmljdGVkLlwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fUkVTQU5JVElaQVRJT05fTkVFREVEXTogXCJSZXNhbml0aXphdGlvbk5lZWRlZFwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fU0FOSVRJWkVfRkFJTFVSRV06IFwiVHJhbnNhY3Rpb24gZmFpbGVkIHRvIHNhbml0aXplIGFjY291bnRzIG9mZnNldHMgY29ycmVjdGx5XCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19TSUdOQVRVUkVfRkFJTFVSRV06IFwiVHJhbnNhY3Rpb24gZGlkIG5vdCBwYXNzIHNpZ25hdHVyZSB2ZXJpZmljYXRpb25cIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1RPT19NQU5ZX0FDQ09VTlRfTE9DS1NdOiBcIlRyYW5zYWN0aW9uIGxvY2tlZCB0b28gbWFueSBhY2NvdW50c1wiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fVU5CQUxBTkNFRF9UUkFOU0FDVElPTl06IFwiU3VtIG9mIGFjY291bnQgYmFsYW5jZXMgYmVmb3JlIGFuZCBhZnRlciB0cmFuc2FjdGlvbiBkbyBub3QgbWF0Y2hcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1VOS05PV05dOiBcIlRoZSB0cmFuc2FjdGlvbiBmYWlsZWQgd2l0aCB0aGUgZXJyb3IgYCRlcnJvck5hbWVgXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19VTlNVUFBPUlRFRF9WRVJTSU9OXTogXCJUcmFuc2FjdGlvbiB2ZXJzaW9uIGlzIHVuc3VwcG9ydGVkXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19XT1VMRF9FWENFRURfQUNDT1VOVF9EQVRBX0JMT0NLX0xJTUlUXTogXCJUcmFuc2FjdGlvbiB3b3VsZCBleGNlZWQgYWNjb3VudCBkYXRhIGxpbWl0IHdpdGhpbiB0aGUgYmxvY2tcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1dPVUxEX0VYQ0VFRF9BQ0NPVU5UX0RBVEFfVE9UQUxfTElNSVRdOiBcIlRyYW5zYWN0aW9uIHdvdWxkIGV4Y2VlZCB0b3RhbCBhY2NvdW50IGRhdGEgbGltaXRcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1dPVUxEX0VYQ0VFRF9NQVhfQUNDT1VOVF9DT1NUX0xJTUlUXTogXCJUcmFuc2FjdGlvbiB3b3VsZCBleGNlZWQgbWF4IGFjY291bnQgbGltaXQgd2l0aGluIHRoZSBibG9ja1wiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fV09VTERfRVhDRUVEX01BWF9CTE9DS19DT1NUX0xJTUlUXTogXCJUcmFuc2FjdGlvbiB3b3VsZCBleGNlZWQgbWF4IEJsb2NrIENvc3QgTGltaXRcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1dPVUxEX0VYQ0VFRF9NQVhfVk9URV9DT1NUX0xJTUlUXTogXCJUcmFuc2FjdGlvbiB3b3VsZCBleGNlZWQgbWF4IFZvdGUgQ29zdCBMaW1pdFwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fQUREUkVTU0VTX0NBTk5PVF9TSUdOX1RSQU5TQUNUSU9OXTogXCJBdHRlbXB0ZWQgdG8gc2lnbiBhIHRyYW5zYWN0aW9uIHdpdGggYW4gYWRkcmVzcyB0aGF0IGlzIG5vdCBhIHNpZ25lciBmb3IgaXRcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0FERFJFU1NfTUlTU0lOR106IFwiVHJhbnNhY3Rpb24gaXMgbWlzc2luZyBhbiBhZGRyZXNzIGF0IGluZGV4OiAkaW5kZXguXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19DQU5OT1RfRU5DT0RFX1dJVEhfRU1QVFlfU0lHTkFUVVJFU106IFwiVHJhbnNhY3Rpb24gaGFzIG5vIGV4cGVjdGVkIHNpZ25lcnMgdGhlcmVmb3JlIGl0IGNhbm5vdCBiZSBlbmNvZGVkXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19FWENFRURTX1NJWkVfTElNSVRdOiBcIlRyYW5zYWN0aW9uIHNpemUgJHRyYW5zYWN0aW9uU2l6ZSBleGNlZWRzIGxpbWl0IG9mICR0cmFuc2FjdGlvblNpemVMaW1pdCBieXRlc1wiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRVhQRUNURURfQkxPQ0tIQVNIX0xJRkVUSU1FXTogXCJUcmFuc2FjdGlvbiBkb2VzIG5vdCBoYXZlIGEgYmxvY2toYXNoIGxpZmV0aW1lXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19FWFBFQ1RFRF9OT05DRV9MSUZFVElNRV06IFwiVHJhbnNhY3Rpb24gaXMgbm90IGEgZHVyYWJsZSBub25jZSB0cmFuc2FjdGlvblwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkFJTEVEX1RPX0RFQ09NUElMRV9BRERSRVNTX0xPT0tVUF9UQUJMRV9DT05URU5UU19NSVNTSU5HXTogXCJDb250ZW50cyBvZiB0aGVzZSBhZGRyZXNzIGxvb2t1cCB0YWJsZXMgdW5rbm93bjogJGxvb2t1cFRhYmxlQWRkcmVzc2VzXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GQUlMRURfVE9fREVDT01QSUxFX0FERFJFU1NfTE9PS1VQX1RBQkxFX0lOREVYX09VVF9PRl9SQU5HRV06IFwiTG9va3VwIG9mIGFkZHJlc3MgYXQgaW5kZXggJGhpZ2hlc3RSZXF1ZXN0ZWRJbmRleCBmYWlsZWQgZm9yIGxvb2t1cCB0YWJsZSBgJGxvb2t1cFRhYmxlQWRkcmVzc2AuIEhpZ2hlc3Qga25vd24gaW5kZXggaXMgJGhpZ2hlc3RLbm93bkluZGV4LiBUaGUgbG9va3VwIHRhYmxlIG1heSBoYXZlIGJlZW4gZXh0ZW5kZWQgc2luY2UgaXRzIGNvbnRlbnRzIHdlcmUgcmV0cmlldmVkXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GQUlMRURfVE9fREVDT01QSUxFX0ZFRV9QQVlFUl9NSVNTSU5HXTogXCJObyBmZWUgcGF5ZXIgc2V0IGluIENvbXBpbGVkVHJhbnNhY3Rpb25cIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9UT19ERUNPTVBJTEVfSU5TVFJVQ1RJT05fUFJPR1JBTV9BRERSRVNTX05PVF9GT1VORF06IFwiQ291bGQgbm90IGZpbmQgcHJvZ3JhbSBhZGRyZXNzIGF0IGluZGV4ICRpbmRleFwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkFJTEVEX1RPX0VTVElNQVRFX0NPTVBVVEVfTElNSVRdOiBcIkZhaWxlZCB0byBlc3RpbWF0ZSB0aGUgY29tcHV0ZSB1bml0IGNvbnN1bXB0aW9uIGZvciB0aGlzIHRyYW5zYWN0aW9uIG1lc3NhZ2UuIFRoaXMgaXMgbGlrZWx5IGJlY2F1c2Ugc2ltdWxhdGluZyB0aGUgdHJhbnNhY3Rpb24gZmFpbGVkLiBJbnNwZWN0IHRoZSBgY2F1c2VgIHByb3BlcnR5IG9mIHRoaXMgZXJyb3IgdG8gbGVhcm4gbW9yZVwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkFJTEVEX1dIRU5fU0lNVUxBVElOR19UT19FU1RJTUFURV9DT01QVVRFX0xJTUlUXTogXCJUcmFuc2FjdGlvbiBmYWlsZWQgd2hlbiBpdCB3YXMgc2ltdWxhdGVkIGluIG9yZGVyIHRvIGVzdGltYXRlIHRoZSBjb21wdXRlIHVuaXQgY29uc3VtcHRpb24uIFRoZSBjb21wdXRlIHVuaXQgZXN0aW1hdGUgcHJvdmlkZWQgaXMgZm9yIGEgdHJhbnNhY3Rpb24gdGhhdCBmYWlsZWQgd2hlbiBzaW11bGF0ZWQgYW5kIG1heSBub3QgYmUgcmVwcmVzZW50YXRpdmUgb2YgdGhlIGNvbXB1dGUgdW5pdHMgdGhpcyB0cmFuc2FjdGlvbiB3b3VsZCBjb25zdW1lIGlmIHN1Y2Nlc3NmdWwuIEluc3BlY3QgdGhlIGBjYXVzZWAgcHJvcGVydHkgb2YgdGhpcyBlcnJvciB0byBsZWFybiBtb3JlXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GRUVfUEFZRVJfTUlTU0lOR106IFwiVHJhbnNhY3Rpb24gaXMgbWlzc2luZyBhIGZlZSBwYXllci5cIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZFRV9QQVlFUl9TSUdOQVRVUkVfTUlTU0lOR106IFwiQ291bGQgbm90IGRldGVybWluZSB0aGlzIHRyYW5zYWN0aW9uJ3Mgc2lnbmF0dXJlLiBNYWtlIHN1cmUgdGhhdCB0aGUgdHJhbnNhY3Rpb24gaGFzIGJlZW4gc2lnbmVkIGJ5IGl0cyBmZWUgcGF5ZXIuXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19JTlZBTElEX05PTkNFX1RSQU5TQUNUSU9OX0ZJUlNUX0lOU1RSVUNUSU9OX01VU1RfQkVfQURWQU5DRV9OT05DRV06IFwiVHJhbnNhY3Rpb24gZmlyc3QgaW5zdHJ1Y3Rpb24gaXMgbm90IGFkdmFuY2Ugbm9uY2UgYWNjb3VudCBpbnN0cnVjdGlvbi5cIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0lOVkFMSURfTk9OQ0VfVFJBTlNBQ1RJT05fSU5TVFJVQ1RJT05TX01JU1NJTkddOiBcIlRyYW5zYWN0aW9uIHdpdGggbm8gaW5zdHJ1Y3Rpb25zIGNhbm5vdCBiZSBkdXJhYmxlIG5vbmNlIHRyYW5zYWN0aW9uLlwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fSU5WT0tFRF9QUk9HUkFNU19DQU5OT1RfUEFZX0ZFRVNdOiBcIlRoaXMgdHJhbnNhY3Rpb24gaW5jbHVkZXMgYW4gYWRkcmVzcyAoYCRwcm9ncmFtQWRkcmVzc2ApIHdoaWNoIGlzIGJvdGggaW52b2tlZCBhbmQgc2V0IGFzIHRoZSBmZWUgcGF5ZXIuIFByb2dyYW0gYWRkcmVzc2VzIG1heSBub3QgcGF5IGZlZXNcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0lOVk9LRURfUFJPR1JBTVNfTVVTVF9OT1RfQkVfV1JJVEFCTEVdOiBcIlRoaXMgdHJhbnNhY3Rpb24gaW5jbHVkZXMgYW4gYWRkcmVzcyAoYCRwcm9ncmFtQWRkcmVzc2ApIHdoaWNoIGlzIGJvdGggaW52b2tlZCBhbmQgbWFya2VkIHdyaXRhYmxlLiBQcm9ncmFtIGFkZHJlc3NlcyBtYXkgbm90IGJlIHdyaXRhYmxlXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19NRVNTQUdFX1NJR05BVFVSRVNfTUlTTUFUQ0hdOiBcIlRoZSB0cmFuc2FjdGlvbiBtZXNzYWdlIGV4cGVjdGVkIHRoZSB0cmFuc2FjdGlvbiB0byBoYXZlICRzaWduZXJBZGRyZXNzZXNMZW5ndGggc2lnbmF0dXJlcywgZ290ICRzaWduYXR1cmVzTGVuZ3RoLlwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fU0lHTkFUVVJFU19NSVNTSU5HXTogXCJUcmFuc2FjdGlvbiBpcyBtaXNzaW5nIHNpZ25hdHVyZXMgZm9yIGFkZHJlc3NlczogJGFkZHJlc3Nlcy5cIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX1ZFUlNJT05fTlVNQkVSX09VVF9PRl9SQU5HRV06IFwiVHJhbnNhY3Rpb24gdmVyc2lvbiBtdXN0IGJlIGluIHRoZSByYW5nZSBbMCwgMTI3XS4gYCRhY3R1YWxWZXJzaW9uYCBnaXZlblwiXG59O1xuXG4vLyBzcmMvbWVzc2FnZS1mb3JtYXR0ZXIudHNcbnZhciBTVEFSVF9JTkRFWCA9IFwiaVwiO1xudmFyIFRZUEUgPSBcInRcIjtcbmZ1bmN0aW9uIGdldEh1bWFuUmVhZGFibGVFcnJvck1lc3NhZ2UoY29kZSwgY29udGV4dCA9IHt9KSB7XG4gIGNvbnN0IG1lc3NhZ2VGb3JtYXRTdHJpbmcgPSBTb2xhbmFFcnJvck1lc3NhZ2VzW2NvZGVdO1xuICBpZiAobWVzc2FnZUZvcm1hdFN0cmluZy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICBsZXQgc3RhdGU7XG4gIGZ1bmN0aW9uIGNvbW1pdFN0YXRlVXBUbyhlbmRJbmRleCkge1xuICAgIGlmIChzdGF0ZVtUWVBFXSA9PT0gMiAvKiBWYXJpYWJsZSAqLykge1xuICAgICAgY29uc3QgdmFyaWFibGVOYW1lID0gbWVzc2FnZUZvcm1hdFN0cmluZy5zbGljZShzdGF0ZVtTVEFSVF9JTkRFWF0gKyAxLCBlbmRJbmRleCk7XG4gICAgICBmcmFnbWVudHMucHVzaChcbiAgICAgICAgdmFyaWFibGVOYW1lIGluIGNvbnRleHQgPyAoXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC10ZW1wbGF0ZS1leHByZXNzaW9uc1xuICAgICAgICAgIGAke2NvbnRleHRbdmFyaWFibGVOYW1lXX1gXG4gICAgICAgICkgOiBgJCR7dmFyaWFibGVOYW1lfWBcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZVtUWVBFXSA9PT0gMSAvKiBUZXh0ICovKSB7XG4gICAgICBmcmFnbWVudHMucHVzaChtZXNzYWdlRm9ybWF0U3RyaW5nLnNsaWNlKHN0YXRlW1NUQVJUX0lOREVYXSwgZW5kSW5kZXgpKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZnJhZ21lbnRzID0gW107XG4gIG1lc3NhZ2VGb3JtYXRTdHJpbmcuc3BsaXQoXCJcIikuZm9yRWFjaCgoY2hhciwgaWkpID0+IHtcbiAgICBpZiAoaWkgPT09IDApIHtcbiAgICAgIHN0YXRlID0ge1xuICAgICAgICBbU1RBUlRfSU5ERVhdOiAwLFxuICAgICAgICBbVFlQRV06IG1lc3NhZ2VGb3JtYXRTdHJpbmdbMF0gPT09IFwiXFxcXFwiID8gMCAvKiBFc2NhcGVTZXF1ZW5jZSAqLyA6IG1lc3NhZ2VGb3JtYXRTdHJpbmdbMF0gPT09IFwiJFwiID8gMiAvKiBWYXJpYWJsZSAqLyA6IDEgLyogVGV4dCAqL1xuICAgICAgfTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IG5leHRTdGF0ZTtcbiAgICBzd2l0Y2ggKHN0YXRlW1RZUEVdKSB7XG4gICAgICBjYXNlIDAgLyogRXNjYXBlU2VxdWVuY2UgKi86XG4gICAgICAgIG5leHRTdGF0ZSA9IHsgW1NUQVJUX0lOREVYXTogaWksIFtUWVBFXTogMSAvKiBUZXh0ICovIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxIC8qIFRleHQgKi86XG4gICAgICAgIGlmIChjaGFyID09PSBcIlxcXFxcIikge1xuICAgICAgICAgIG5leHRTdGF0ZSA9IHsgW1NUQVJUX0lOREVYXTogaWksIFtUWVBFXTogMCAvKiBFc2NhcGVTZXF1ZW5jZSAqLyB9O1xuICAgICAgICB9IGVsc2UgaWYgKGNoYXIgPT09IFwiJFwiKSB7XG4gICAgICAgICAgbmV4dFN0YXRlID0geyBbU1RBUlRfSU5ERVhdOiBpaSwgW1RZUEVdOiAyIC8qIFZhcmlhYmxlICovIH07XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDIgLyogVmFyaWFibGUgKi86XG4gICAgICAgIGlmIChjaGFyID09PSBcIlxcXFxcIikge1xuICAgICAgICAgIG5leHRTdGF0ZSA9IHsgW1NUQVJUX0lOREVYXTogaWksIFtUWVBFXTogMCAvKiBFc2NhcGVTZXF1ZW5jZSAqLyB9O1xuICAgICAgICB9IGVsc2UgaWYgKGNoYXIgPT09IFwiJFwiKSB7XG4gICAgICAgICAgbmV4dFN0YXRlID0geyBbU1RBUlRfSU5ERVhdOiBpaSwgW1RZUEVdOiAyIC8qIFZhcmlhYmxlICovIH07XG4gICAgICAgIH0gZWxzZSBpZiAoIWNoYXIubWF0Y2goL1xcdy8pKSB7XG4gICAgICAgICAgbmV4dFN0YXRlID0geyBbU1RBUlRfSU5ERVhdOiBpaSwgW1RZUEVdOiAxIC8qIFRleHQgKi8gfTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKG5leHRTdGF0ZSkge1xuICAgICAgaWYgKHN0YXRlICE9PSBuZXh0U3RhdGUpIHtcbiAgICAgICAgY29tbWl0U3RhdGVVcFRvKGlpKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlID0gbmV4dFN0YXRlO1xuICAgIH1cbiAgfSk7XG4gIGNvbW1pdFN0YXRlVXBUbygpO1xuICByZXR1cm4gZnJhZ21lbnRzLmpvaW4oXCJcIik7XG59XG5mdW5jdGlvbiBnZXRFcnJvck1lc3NhZ2UoY29kZSwgY29udGV4dCA9IHt9KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICByZXR1cm4gZ2V0SHVtYW5SZWFkYWJsZUVycm9yTWVzc2FnZShjb2RlLCBjb250ZXh0KTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgZGVjb2RpbmdBZHZpY2VNZXNzYWdlID0gYFNvbGFuYSBlcnJvciAjJHtjb2RlfTsgRGVjb2RlIHRoaXMgZXJyb3IgYnkgcnVubmluZyBcXGBucHggQHNvbGFuYS9lcnJvcnMgZGVjb2RlIC0tICR7Y29kZX1gO1xuICAgIGlmIChPYmplY3Qua2V5cyhjb250ZXh0KS5sZW5ndGgpIHtcbiAgICAgIGRlY29kaW5nQWR2aWNlTWVzc2FnZSArPSBgICcke2VuY29kZUNvbnRleHRPYmplY3QoY29udGV4dCl9J2A7XG4gICAgfVxuICAgIHJldHVybiBgJHtkZWNvZGluZ0FkdmljZU1lc3NhZ2V9XFxgYDtcbiAgfVxufVxuXG4vLyBzcmMvZXJyb3IudHNcbmZ1bmN0aW9uIGlzU29sYW5hRXJyb3IoZSwgY29kZSkge1xuICBjb25zdCBpc1NvbGFuYUVycm9yMiA9IGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm5hbWUgPT09IFwiU29sYW5hRXJyb3JcIjtcbiAgaWYgKGlzU29sYW5hRXJyb3IyKSB7XG4gICAgaWYgKGNvZGUgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIGUuY29udGV4dC5fX2NvZGUgPT09IGNvZGU7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbnZhciBTb2xhbmFFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICAvKipcbiAgICogSW5kaWNhdGVzIHRoZSByb290IGNhdXNlIG9mIHRoaXMge0BsaW5rIFNvbGFuYUVycm9yfSwgaWYgYW55LlxuICAgKlxuICAgKiBGb3IgZXhhbXBsZSwgYSB0cmFuc2FjdGlvbiBlcnJvciBtaWdodCBoYXZlIGFuIGluc3RydWN0aW9uIGVycm9yIGFzIGl0cyByb290IGNhdXNlLiBJbiB0aGlzXG4gICAqIGNhc2UsIHlvdSB3aWxsIGJlIGFibGUgdG8gYWNjZXNzIHRoZSBpbnN0cnVjdGlvbiBlcnJvciBvbiB0aGUgdHJhbnNhY3Rpb24gZXJyb3IgYXMgYGNhdXNlYC5cbiAgICovXG4gIGNhdXNlID0gdGhpcy5jYXVzZTtcbiAgLyoqXG4gICAqIENvbnRhaW5zIGNvbnRleHQgdGhhdCBjYW4gYXNzaXN0IGluIHVuZGVyc3RhbmRpbmcgb3IgcmVjb3ZlcmluZyBmcm9tIGEge0BsaW5rIFNvbGFuYUVycm9yfS5cbiAgICovXG4gIGNvbnRleHQ7XG4gIGNvbnN0cnVjdG9yKC4uLltjb2RlLCBjb250ZXh0QW5kRXJyb3JPcHRpb25zXSkge1xuICAgIGxldCBjb250ZXh0O1xuICAgIGxldCBlcnJvck9wdGlvbnM7XG4gICAgaWYgKGNvbnRleHRBbmRFcnJvck9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IHsgY2F1c2UsIC4uLmNvbnRleHRSZXN0IH0gPSBjb250ZXh0QW5kRXJyb3JPcHRpb25zO1xuICAgICAgaWYgKGNhdXNlKSB7XG4gICAgICAgIGVycm9yT3B0aW9ucyA9IHsgY2F1c2UgfTtcbiAgICAgIH1cbiAgICAgIGlmIChPYmplY3Qua2V5cyhjb250ZXh0UmVzdCkubGVuZ3RoID4gMCkge1xuICAgICAgICBjb250ZXh0ID0gY29udGV4dFJlc3Q7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2UgPSBnZXRFcnJvck1lc3NhZ2UoY29kZSwgY29udGV4dCk7XG4gICAgc3VwZXIobWVzc2FnZSwgZXJyb3JPcHRpb25zKTtcbiAgICB0aGlzLmNvbnRleHQgPSB7XG4gICAgICBfX2NvZGU6IGNvZGUsXG4gICAgICAuLi5jb250ZXh0XG4gICAgfTtcbiAgICB0aGlzLm5hbWUgPSBcIlNvbGFuYUVycm9yXCI7XG4gIH1cbn07XG5cbi8vIHNyYy9zdGFjay10cmFjZS50c1xuZnVuY3Rpb24gc2FmZUNhcHR1cmVTdGFja1RyYWNlKC4uLmFyZ3MpIHtcbiAgaWYgKFwiY2FwdHVyZVN0YWNrVHJhY2VcIiBpbiBFcnJvciAmJiB0eXBlb2YgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKC4uLmFyZ3MpO1xuICB9XG59XG5cbi8vIHNyYy9ycGMtZW51bS1lcnJvcnMudHNcbmZ1bmN0aW9uIGdldFNvbGFuYUVycm9yRnJvbVJwY0Vycm9yKHsgZXJyb3JDb2RlQmFzZU9mZnNldCwgZ2V0RXJyb3JDb250ZXh0LCBvcmRlcmVkRXJyb3JOYW1lcywgcnBjRW51bUVycm9yIH0sIGNvbnN0cnVjdG9yT3B0KSB7XG4gIGxldCBycGNFcnJvck5hbWU7XG4gIGxldCBycGNFcnJvckNvbnRleHQ7XG4gIGlmICh0eXBlb2YgcnBjRW51bUVycm9yID09PSBcInN0cmluZ1wiKSB7XG4gICAgcnBjRXJyb3JOYW1lID0gcnBjRW51bUVycm9yO1xuICB9IGVsc2Uge1xuICAgIHJwY0Vycm9yTmFtZSA9IE9iamVjdC5rZXlzKHJwY0VudW1FcnJvcilbMF07XG4gICAgcnBjRXJyb3JDb250ZXh0ID0gcnBjRW51bUVycm9yW3JwY0Vycm9yTmFtZV07XG4gIH1cbiAgY29uc3QgY29kZU9mZnNldCA9IG9yZGVyZWRFcnJvck5hbWVzLmluZGV4T2YocnBjRXJyb3JOYW1lKTtcbiAgY29uc3QgZXJyb3JDb2RlID0gZXJyb3JDb2RlQmFzZU9mZnNldCArIGNvZGVPZmZzZXQ7XG4gIGNvbnN0IGVycm9yQ29udGV4dCA9IGdldEVycm9yQ29udGV4dChlcnJvckNvZGUsIHJwY0Vycm9yTmFtZSwgcnBjRXJyb3JDb250ZXh0KTtcbiAgY29uc3QgZXJyID0gbmV3IFNvbGFuYUVycm9yKGVycm9yQ29kZSwgZXJyb3JDb250ZXh0KTtcbiAgc2FmZUNhcHR1cmVTdGFja1RyYWNlKGVyciwgY29uc3RydWN0b3JPcHQpO1xuICByZXR1cm4gZXJyO1xufVxuXG4vLyBzcmMvaW5zdHJ1Y3Rpb24tZXJyb3IudHNcbnZhciBPUkRFUkVEX0VSUk9SX05BTUVTID0gW1xuICAvLyBLZWVwIHN5bmNlZCB3aXRoIFJQQyBzb3VyY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9hbnphLXh5ei9hZ2F2ZS9ibG9iL21hc3Rlci9zZGsvcHJvZ3JhbS9zcmMvaW5zdHJ1Y3Rpb24ucnNcbiAgLy8gSWYgdGhpcyBsaXN0IGV2ZXIgZ2V0cyB0b28gbGFyZ2UsIGNvbnNpZGVyIGltcGxlbWVudGluZyBhIGNvbXByZXNzaW9uIHN0cmF0ZWd5IGxpa2UgdGhpczpcbiAgLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vc3RldmVsdXNjaGVyL2FhYTdjYmJiNTQzM2IxMTk3OTgzOTA4YTQwODYwYzQ3XG4gIFwiR2VuZXJpY0Vycm9yXCIsXG4gIFwiSW52YWxpZEFyZ3VtZW50XCIsXG4gIFwiSW52YWxpZEluc3RydWN0aW9uRGF0YVwiLFxuICBcIkludmFsaWRBY2NvdW50RGF0YVwiLFxuICBcIkFjY291bnREYXRhVG9vU21hbGxcIixcbiAgXCJJbnN1ZmZpY2llbnRGdW5kc1wiLFxuICBcIkluY29ycmVjdFByb2dyYW1JZFwiLFxuICBcIk1pc3NpbmdSZXF1aXJlZFNpZ25hdHVyZVwiLFxuICBcIkFjY291bnRBbHJlYWR5SW5pdGlhbGl6ZWRcIixcbiAgXCJVbmluaXRpYWxpemVkQWNjb3VudFwiLFxuICBcIlVuYmFsYW5jZWRJbnN0cnVjdGlvblwiLFxuICBcIk1vZGlmaWVkUHJvZ3JhbUlkXCIsXG4gIFwiRXh0ZXJuYWxBY2NvdW50TGFtcG9ydFNwZW5kXCIsXG4gIFwiRXh0ZXJuYWxBY2NvdW50RGF0YU1vZGlmaWVkXCIsXG4gIFwiUmVhZG9ubHlMYW1wb3J0Q2hhbmdlXCIsXG4gIFwiUmVhZG9ubHlEYXRhTW9kaWZpZWRcIixcbiAgXCJEdXBsaWNhdGVBY2NvdW50SW5kZXhcIixcbiAgXCJFeGVjdXRhYmxlTW9kaWZpZWRcIixcbiAgXCJSZW50RXBvY2hNb2RpZmllZFwiLFxuICBcIk5vdEVub3VnaEFjY291bnRLZXlzXCIsXG4gIFwiQWNjb3VudERhdGFTaXplQ2hhbmdlZFwiLFxuICBcIkFjY291bnROb3RFeGVjdXRhYmxlXCIsXG4gIFwiQWNjb3VudEJvcnJvd0ZhaWxlZFwiLFxuICBcIkFjY291bnRCb3Jyb3dPdXRzdGFuZGluZ1wiLFxuICBcIkR1cGxpY2F0ZUFjY291bnRPdXRPZlN5bmNcIixcbiAgXCJDdXN0b21cIixcbiAgXCJJbnZhbGlkRXJyb3JcIixcbiAgXCJFeGVjdXRhYmxlRGF0YU1vZGlmaWVkXCIsXG4gIFwiRXhlY3V0YWJsZUxhbXBvcnRDaGFuZ2VcIixcbiAgXCJFeGVjdXRhYmxlQWNjb3VudE5vdFJlbnRFeGVtcHRcIixcbiAgXCJVbnN1cHBvcnRlZFByb2dyYW1JZFwiLFxuICBcIkNhbGxEZXB0aFwiLFxuICBcIk1pc3NpbmdBY2NvdW50XCIsXG4gIFwiUmVlbnRyYW5jeU5vdEFsbG93ZWRcIixcbiAgXCJNYXhTZWVkTGVuZ3RoRXhjZWVkZWRcIixcbiAgXCJJbnZhbGlkU2VlZHNcIixcbiAgXCJJbnZhbGlkUmVhbGxvY1wiLFxuICBcIkNvbXB1dGF0aW9uYWxCdWRnZXRFeGNlZWRlZFwiLFxuICBcIlByaXZpbGVnZUVzY2FsYXRpb25cIixcbiAgXCJQcm9ncmFtRW52aXJvbm1lbnRTZXR1cEZhaWx1cmVcIixcbiAgXCJQcm9ncmFtRmFpbGVkVG9Db21wbGV0ZVwiLFxuICBcIlByb2dyYW1GYWlsZWRUb0NvbXBpbGVcIixcbiAgXCJJbW11dGFibGVcIixcbiAgXCJJbmNvcnJlY3RBdXRob3JpdHlcIixcbiAgXCJCb3JzaElvRXJyb3JcIixcbiAgXCJBY2NvdW50Tm90UmVudEV4ZW1wdFwiLFxuICBcIkludmFsaWRBY2NvdW50T3duZXJcIixcbiAgXCJBcml0aG1ldGljT3ZlcmZsb3dcIixcbiAgXCJVbnN1cHBvcnRlZFN5c3ZhclwiLFxuICBcIklsbGVnYWxPd25lclwiLFxuICBcIk1heEFjY291bnRzRGF0YUFsbG9jYXRpb25zRXhjZWVkZWRcIixcbiAgXCJNYXhBY2NvdW50c0V4Y2VlZGVkXCIsXG4gIFwiTWF4SW5zdHJ1Y3Rpb25UcmFjZUxlbmd0aEV4Y2VlZGVkXCIsXG4gIFwiQnVpbHRpblByb2dyYW1zTXVzdENvbnN1bWVDb21wdXRlVW5pdHNcIlxuXTtcbmZ1bmN0aW9uIGdldFNvbGFuYUVycm9yRnJvbUluc3RydWN0aW9uRXJyb3IoaW5kZXgsIGluc3RydWN0aW9uRXJyb3IpIHtcbiAgY29uc3QgbnVtYmVySW5kZXggPSBOdW1iZXIoaW5kZXgpO1xuICByZXR1cm4gZ2V0U29sYW5hRXJyb3JGcm9tUnBjRXJyb3IoXG4gICAge1xuICAgICAgZXJyb3JDb2RlQmFzZU9mZnNldDogNDYxNTAwMSxcbiAgICAgIGdldEVycm9yQ29udGV4dChlcnJvckNvZGUsIHJwY0Vycm9yTmFtZSwgcnBjRXJyb3JDb250ZXh0KSB7XG4gICAgICAgIGlmIChlcnJvckNvZGUgPT09IFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1VOS05PV04pIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXJyb3JOYW1lOiBycGNFcnJvck5hbWUsXG4gICAgICAgICAgICBpbmRleDogbnVtYmVySW5kZXgsXG4gICAgICAgICAgICAuLi5ycGNFcnJvckNvbnRleHQgIT09IHZvaWQgMCA/IHsgaW5zdHJ1Y3Rpb25FcnJvckNvbnRleHQ6IHJwY0Vycm9yQ29udGV4dCB9IDogbnVsbFxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoZXJyb3JDb2RlID09PSBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19DVVNUT00pIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29kZTogTnVtYmVyKHJwY0Vycm9yQ29udGV4dCksXG4gICAgICAgICAgICBpbmRleDogbnVtYmVySW5kZXhcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGVycm9yQ29kZSA9PT0gU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQk9SU0hfSU9fRVJST1IpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZW5jb2RlZERhdGE6IHJwY0Vycm9yQ29udGV4dCxcbiAgICAgICAgICAgIGluZGV4OiBudW1iZXJJbmRleFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgaW5kZXg6IG51bWJlckluZGV4IH07XG4gICAgICB9LFxuICAgICAgb3JkZXJlZEVycm9yTmFtZXM6IE9SREVSRURfRVJST1JfTkFNRVMsXG4gICAgICBycGNFbnVtRXJyb3I6IGluc3RydWN0aW9uRXJyb3JcbiAgICB9LFxuICAgIGdldFNvbGFuYUVycm9yRnJvbUluc3RydWN0aW9uRXJyb3JcbiAgKTtcbn1cblxuLy8gc3JjL3RyYW5zYWN0aW9uLWVycm9yLnRzXG52YXIgT1JERVJFRF9FUlJPUl9OQU1FUzIgPSBbXG4gIC8vIEtlZXAgc3luY2VkIHdpdGggUlBDIHNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL2FuemEteHl6L2FnYXZlL2Jsb2IvbWFzdGVyL3Nkay9zcmMvdHJhbnNhY3Rpb24vZXJyb3IucnNcbiAgLy8gSWYgdGhpcyBsaXN0IGV2ZXIgZ2V0cyB0b28gbGFyZ2UsIGNvbnNpZGVyIGltcGxlbWVudGluZyBhIGNvbXByZXNzaW9uIHN0cmF0ZWd5IGxpa2UgdGhpczpcbiAgLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vc3RldmVsdXNjaGVyL2FhYTdjYmJiNTQzM2IxMTk3OTgzOTA4YTQwODYwYzQ3XG4gIFwiQWNjb3VudEluVXNlXCIsXG4gIFwiQWNjb3VudExvYWRlZFR3aWNlXCIsXG4gIFwiQWNjb3VudE5vdEZvdW5kXCIsXG4gIFwiUHJvZ3JhbUFjY291bnROb3RGb3VuZFwiLFxuICBcIkluc3VmZmljaWVudEZ1bmRzRm9yRmVlXCIsXG4gIFwiSW52YWxpZEFjY291bnRGb3JGZWVcIixcbiAgXCJBbHJlYWR5UHJvY2Vzc2VkXCIsXG4gIFwiQmxvY2toYXNoTm90Rm91bmRcIixcbiAgLy8gYEluc3RydWN0aW9uRXJyb3JgIGludGVudGlvbmFsbHkgb21pdHRlZDsgZGVsZWdhdGVkIHRvIGBnZXRTb2xhbmFFcnJvckZyb21JbnN0cnVjdGlvbkVycm9yYFxuICBcIkNhbGxDaGFpblRvb0RlZXBcIixcbiAgXCJNaXNzaW5nU2lnbmF0dXJlRm9yRmVlXCIsXG4gIFwiSW52YWxpZEFjY291bnRJbmRleFwiLFxuICBcIlNpZ25hdHVyZUZhaWx1cmVcIixcbiAgXCJJbnZhbGlkUHJvZ3JhbUZvckV4ZWN1dGlvblwiLFxuICBcIlNhbml0aXplRmFpbHVyZVwiLFxuICBcIkNsdXN0ZXJNYWludGVuYW5jZVwiLFxuICBcIkFjY291bnRCb3Jyb3dPdXRzdGFuZGluZ1wiLFxuICBcIldvdWxkRXhjZWVkTWF4QmxvY2tDb3N0TGltaXRcIixcbiAgXCJVbnN1cHBvcnRlZFZlcnNpb25cIixcbiAgXCJJbnZhbGlkV3JpdGFibGVBY2NvdW50XCIsXG4gIFwiV291bGRFeGNlZWRNYXhBY2NvdW50Q29zdExpbWl0XCIsXG4gIFwiV291bGRFeGNlZWRBY2NvdW50RGF0YUJsb2NrTGltaXRcIixcbiAgXCJUb29NYW55QWNjb3VudExvY2tzXCIsXG4gIFwiQWRkcmVzc0xvb2t1cFRhYmxlTm90Rm91bmRcIixcbiAgXCJJbnZhbGlkQWRkcmVzc0xvb2t1cFRhYmxlT3duZXJcIixcbiAgXCJJbnZhbGlkQWRkcmVzc0xvb2t1cFRhYmxlRGF0YVwiLFxuICBcIkludmFsaWRBZGRyZXNzTG9va3VwVGFibGVJbmRleFwiLFxuICBcIkludmFsaWRSZW50UGF5aW5nQWNjb3VudFwiLFxuICBcIldvdWxkRXhjZWVkTWF4Vm90ZUNvc3RMaW1pdFwiLFxuICBcIldvdWxkRXhjZWVkQWNjb3VudERhdGFUb3RhbExpbWl0XCIsXG4gIFwiRHVwbGljYXRlSW5zdHJ1Y3Rpb25cIixcbiAgXCJJbnN1ZmZpY2llbnRGdW5kc0ZvclJlbnRcIixcbiAgXCJNYXhMb2FkZWRBY2NvdW50c0RhdGFTaXplRXhjZWVkZWRcIixcbiAgXCJJbnZhbGlkTG9hZGVkQWNjb3VudHNEYXRhU2l6ZUxpbWl0XCIsXG4gIFwiUmVzYW5pdGl6YXRpb25OZWVkZWRcIixcbiAgXCJQcm9ncmFtRXhlY3V0aW9uVGVtcG9yYXJpbHlSZXN0cmljdGVkXCIsXG4gIFwiVW5iYWxhbmNlZFRyYW5zYWN0aW9uXCJcbl07XG5mdW5jdGlvbiBnZXRTb2xhbmFFcnJvckZyb21UcmFuc2FjdGlvbkVycm9yKHRyYW5zYWN0aW9uRXJyb3IpIHtcbiAgaWYgKHR5cGVvZiB0cmFuc2FjdGlvbkVycm9yID09PSBcIm9iamVjdFwiICYmIFwiSW5zdHJ1Y3Rpb25FcnJvclwiIGluIHRyYW5zYWN0aW9uRXJyb3IpIHtcbiAgICByZXR1cm4gZ2V0U29sYW5hRXJyb3JGcm9tSW5zdHJ1Y3Rpb25FcnJvcihcbiAgICAgIC4uLnRyYW5zYWN0aW9uRXJyb3IuSW5zdHJ1Y3Rpb25FcnJvclxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGdldFNvbGFuYUVycm9yRnJvbVJwY0Vycm9yKFxuICAgIHtcbiAgICAgIGVycm9yQ29kZUJhc2VPZmZzZXQ6IDcwNTAwMDEsXG4gICAgICBnZXRFcnJvckNvbnRleHQoZXJyb3JDb2RlLCBycGNFcnJvck5hbWUsIHJwY0Vycm9yQ29udGV4dCkge1xuICAgICAgICBpZiAoZXJyb3JDb2RlID09PSBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19VTktOT1dOKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVycm9yTmFtZTogcnBjRXJyb3JOYW1lLFxuICAgICAgICAgICAgLi4ucnBjRXJyb3JDb250ZXh0ICE9PSB2b2lkIDAgPyB7IHRyYW5zYWN0aW9uRXJyb3JDb250ZXh0OiBycGNFcnJvckNvbnRleHQgfSA6IG51bGxcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGVycm9yQ29kZSA9PT0gU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fRFVQTElDQVRFX0lOU1RSVUNUSU9OKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGluZGV4OiBOdW1iZXIocnBjRXJyb3JDb250ZXh0KVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoZXJyb3JDb2RlID09PSBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlNVRkZJQ0lFTlRfRlVORFNfRk9SX1JFTlQgfHwgZXJyb3JDb2RlID09PSBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19QUk9HUkFNX0VYRUNVVElPTl9URU1QT1JBUklMWV9SRVNUUklDVEVEKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFjY291bnRJbmRleDogTnVtYmVyKHJwY0Vycm9yQ29udGV4dC5hY2NvdW50X2luZGV4KVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvcmRlcmVkRXJyb3JOYW1lczogT1JERVJFRF9FUlJPUl9OQU1FUzIsXG4gICAgICBycGNFbnVtRXJyb3I6IHRyYW5zYWN0aW9uRXJyb3JcbiAgICB9LFxuICAgIGdldFNvbGFuYUVycm9yRnJvbVRyYW5zYWN0aW9uRXJyb3JcbiAgKTtcbn1cblxuLy8gc3JjL2pzb24tcnBjLWVycm9yLnRzXG5mdW5jdGlvbiBnZXRTb2xhbmFFcnJvckZyb21Kc29uUnBjRXJyb3IocHV0YXRpdmVFcnJvclJlc3BvbnNlKSB7XG4gIGxldCBvdXQ7XG4gIGlmIChpc1JwY0Vycm9yUmVzcG9uc2UocHV0YXRpdmVFcnJvclJlc3BvbnNlKSkge1xuICAgIGNvbnN0IHsgY29kZTogcmF3Q29kZSwgZGF0YSwgbWVzc2FnZSB9ID0gcHV0YXRpdmVFcnJvclJlc3BvbnNlO1xuICAgIGNvbnN0IGNvZGUgPSBOdW1iZXIocmF3Q29kZSk7XG4gICAgaWYgKGNvZGUgPT09IFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9TRU5EX1RSQU5TQUNUSU9OX1BSRUZMSUdIVF9GQUlMVVJFKSB7XG4gICAgICBjb25zdCB7IGVyciwgLi4ucHJlZmxpZ2h0RXJyb3JDb250ZXh0IH0gPSBkYXRhO1xuICAgICAgY29uc3QgY2F1c2VPYmplY3QgPSBlcnIgPyB7IGNhdXNlOiBnZXRTb2xhbmFFcnJvckZyb21UcmFuc2FjdGlvbkVycm9yKGVycikgfSA6IG51bGw7XG4gICAgICBvdXQgPSBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1NFTkRfVFJBTlNBQ1RJT05fUFJFRkxJR0hUX0ZBSUxVUkUsIHtcbiAgICAgICAgLi4ucHJlZmxpZ2h0RXJyb3JDb250ZXh0LFxuICAgICAgICAuLi5jYXVzZU9iamVjdFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBlcnJvckNvbnRleHQ7XG4gICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgY2FzZSBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19JTlRFUk5BTF9FUlJPUjpcbiAgICAgICAgY2FzZSBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19JTlZBTElEX1BBUkFNUzpcbiAgICAgICAgY2FzZSBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19JTlZBTElEX1JFUVVFU1Q6XG4gICAgICAgIGNhc2UgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fTUVUSE9EX05PVF9GT1VORDpcbiAgICAgICAgY2FzZSBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19QQVJTRV9FUlJPUjpcbiAgICAgICAgY2FzZSBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TQ0FOX0VSUk9SOlxuICAgICAgICBjYXNlIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9CTE9DS19DTEVBTkVEX1VQOlxuICAgICAgICBjYXNlIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9CTE9DS19OT1RfQVZBSUxBQkxFOlxuICAgICAgICBjYXNlIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9CTE9DS19TVEFUVVNfTk9UX0FWQUlMQUJMRV9ZRVQ6XG4gICAgICAgIGNhc2UgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0tFWV9FWENMVURFRF9GUk9NX1NFQ09OREFSWV9JTkRFWDpcbiAgICAgICAgY2FzZSBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfTE9OR19URVJNX1NUT1JBR0VfU0xPVF9TS0lQUEVEOlxuICAgICAgICBjYXNlIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9TTE9UX1NLSVBQRUQ6XG4gICAgICAgIGNhc2UgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX1BSRUNPTVBJTEVfVkVSSUZJQ0FUSU9OX0ZBSUxVUkU6XG4gICAgICAgIGNhc2UgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1VOU1VQUE9SVEVEX1RSQU5TQUNUSU9OX1ZFUlNJT046XG4gICAgICAgICAgZXJyb3JDb250ZXh0ID0geyBfX3NlcnZlck1lc3NhZ2U6IG1lc3NhZ2UgfTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgIGVycm9yQ29udGV4dCA9IGRhdGE7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgb3V0ID0gbmV3IFNvbGFuYUVycm9yKGNvZGUsIGVycm9yQ29udGV4dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSB0eXBlb2YgcHV0YXRpdmVFcnJvclJlc3BvbnNlID09PSBcIm9iamVjdFwiICYmIHB1dGF0aXZlRXJyb3JSZXNwb25zZSAhPT0gbnVsbCAmJiBcIm1lc3NhZ2VcIiBpbiBwdXRhdGl2ZUVycm9yUmVzcG9uc2UgJiYgdHlwZW9mIHB1dGF0aXZlRXJyb3JSZXNwb25zZS5tZXNzYWdlID09PSBcInN0cmluZ1wiID8gcHV0YXRpdmVFcnJvclJlc3BvbnNlLm1lc3NhZ2UgOiBcIk1hbGZvcm1lZCBKU09OLVJQQyBlcnJvciB3aXRoIG5vIG1lc3NhZ2UgYXR0cmlidXRlXCI7XG4gICAgb3V0ID0gbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fTUFMRk9STUVEX0pTT05fUlBDX0VSUk9SLCB7IGVycm9yOiBwdXRhdGl2ZUVycm9yUmVzcG9uc2UsIG1lc3NhZ2UgfSk7XG4gIH1cbiAgc2FmZUNhcHR1cmVTdGFja1RyYWNlKG91dCwgZ2V0U29sYW5hRXJyb3JGcm9tSnNvblJwY0Vycm9yKTtcbiAgcmV0dXJuIG91dDtcbn1cbmZ1bmN0aW9uIGlzUnBjRXJyb3JSZXNwb25zZSh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsICYmIFwiY29kZVwiIGluIHZhbHVlICYmIFwibWVzc2FnZVwiIGluIHZhbHVlICYmICh0eXBlb2YgdmFsdWUuY29kZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgdmFsdWUuY29kZSA9PT0gXCJiaWdpbnRcIikgJiYgdHlwZW9mIHZhbHVlLm1lc3NhZ2UgPT09IFwic3RyaW5nXCI7XG59XG5cbmV4cG9ydCB7IFNPTEFOQV9FUlJPUl9fQUNDT1VOVFNfX0FDQ09VTlRfTk9UX0ZPVU5ELCBTT0xBTkFfRVJST1JfX0FDQ09VTlRTX19FWFBFQ1RFRF9BTExfQUNDT1VOVFNfVE9fQkVfREVDT0RFRCwgU09MQU5BX0VSUk9SX19BQ0NPVU5UU19fRVhQRUNURURfREVDT0RFRF9BQ0NPVU5ULCBTT0xBTkFfRVJST1JfX0FDQ09VTlRTX19GQUlMRURfVE9fREVDT0RFX0FDQ09VTlQsIFNPTEFOQV9FUlJPUl9fQUNDT1VOVFNfX09ORV9PUl9NT1JFX0FDQ09VTlRTX05PVF9GT1VORCwgU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX0ZBSUxFRF9UT19GSU5EX1ZJQUJMRV9QREFfQlVNUF9TRUVELCBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9CQVNFNThfRU5DT0RFRF9BRERSRVNTLCBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9CWVRFX0xFTkdUSCwgU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX0lOVkFMSURfRUQyNTUxOV9QVUJMSUNfS0VZLCBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9PRkZfQ1VSVkVfQUREUkVTUywgU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX0lOVkFMSURfU0VFRFNfUE9JTlRfT05fQ1VSVkUsIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19NQUxGT1JNRURfUERBLCBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fTUFYX05VTUJFUl9PRl9QREFfU0VFRFNfRVhDRUVERUQsIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19NQVhfUERBX1NFRURfTEVOR1RIX0VYQ0VFREVELCBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fUERBX0JVTVBfU0VFRF9PVVRfT0ZfUkFOR0UsIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19QREFfRU5EU19XSVRIX1BEQV9NQVJLRVIsIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19TVFJJTkdfTEVOR1RIX09VVF9PRl9SQU5HRSwgU09MQU5BX0VSUk9SX19CTE9DS0hBU0hfU1RSSU5HX0xFTkdUSF9PVVRfT0ZfUkFOR0UsIFNPTEFOQV9FUlJPUl9fQkxPQ0tfSEVJR0hUX0VYQ0VFREVELCBTT0xBTkFfRVJST1JfX0NPREVDU19fQ0FOTk9UX0RFQ09ERV9FTVBUWV9CWVRFX0FSUkFZLCBTT0xBTkFfRVJST1JfX0NPREVDU19fQ0FOTk9UX1VTRV9MRVhJQ0FMX1ZBTFVFU19BU19FTlVNX0RJU0NSSU1JTkFUT1JTLCBTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFRF9CWVRFU19NVVNUX05PVF9JTkNMVURFX1NFTlRJTkVMLCBTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX0ZJWEVEX1NJWkVfTUlTTUFUQ0gsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfTUFYX1NJWkVfTUlTTUFUQ0gsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfU0laRV9DT01QQVRJQklMSVRZX01JU01BVENILCBTT0xBTkFfRVJST1JfX0NPREVDU19fRU5VTV9ESVNDUklNSU5BVE9SX09VVF9PRl9SQU5HRSwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX0ZJWEVEX0xFTkdUSCwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1BPU0lUSVZFX0JZVEVfTEVOR1RILCBTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfVkFSSUFCTEVfTEVOR1RILCBTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfWkVST19WQUxVRV9UT19NQVRDSF9JVEVNX0ZJWEVEX1NJWkUsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0JZVEVfTEVOR1RILCBTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9DT05TVEFOVCwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfRElTQ1JJTUlOQVRFRF9VTklPTl9WQVJJQU5ULCBTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9FTlVNX1ZBUklBTlQsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0xJVEVSQUxfVU5JT05fVkFSSUFOVCwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfTlVNQkVSX09GX0lURU1TLCBTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9TVFJJTkdfRk9SX0JBU0UsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19MSVRFUkFMX1VOSU9OX0RJU0NSSU1JTkFUT1JfT1VUX09GX1JBTkdFLCBTT0xBTkFfRVJST1JfX0NPREVDU19fTlVNQkVSX09VVF9PRl9SQU5HRSwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX09GRlNFVF9PVVRfT0ZfUkFOR0UsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19TRU5USU5FTF9NSVNTSU5HX0lOX0RFQ09ERURfQllURVMsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19VTklPTl9WQVJJQU5UX09VVF9PRl9SQU5HRSwgU09MQU5BX0VSUk9SX19DUllQVE9fX1JBTkRPTV9WQUxVRVNfRlVOQ1RJT05fVU5JTVBMRU1FTlRFRCwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9BTFJFQURZX0lOSVRJQUxJWkVELCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX0JPUlJPV19GQUlMRUQsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfQk9SUk9XX09VVFNUQU5ESU5HLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX0RBVEFfU0laRV9DSEFOR0VELCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX0RBVEFfVE9PX1NNQUxMLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX05PVF9FWEVDVVRBQkxFLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX05PVF9SRU5UX0VYRU1QVCwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQVJJVEhNRVRJQ19PVkVSRkxPVywgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQk9SU0hfSU9fRVJST1IsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0JVSUxUSU5fUFJPR1JBTVNfTVVTVF9DT05TVU1FX0NPTVBVVEVfVU5JVFMsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0NBTExfREVQVEgsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0NPTVBVVEFUSU9OQUxfQlVER0VUX0VYQ0VFREVELCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19DVVNUT00sIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0RVUExJQ0FURV9BQ0NPVU5UX0lOREVYLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19EVVBMSUNBVEVfQUNDT1VOVF9PVVRfT0ZfU1lOQywgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRVhFQ1VUQUJMRV9BQ0NPVU5UX05PVF9SRU5UX0VYRU1QVCwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRVhFQ1VUQUJMRV9EQVRBX01PRElGSUVELCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19FWEVDVVRBQkxFX0xBTVBPUlRfQ0hBTkdFLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19FWEVDVVRBQkxFX01PRElGSUVELCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19FWFRFUk5BTF9BQ0NPVU5UX0RBVEFfTU9ESUZJRUQsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0VYVEVSTkFMX0FDQ09VTlRfTEFNUE9SVF9TUEVORCwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fR0VORVJJQ19FUlJPUiwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSUxMRUdBTF9PV05FUiwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU1NVVRBQkxFLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTkNPUlJFQ1RfQVVUSE9SSVRZLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTkNPUlJFQ1RfUFJPR1JBTV9JRCwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5TVUZGSUNJRU5UX0ZVTkRTLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX0FDQ09VTlRfREFUQSwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9BQ0NPVU5UX09XTkVSLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX0FSR1VNRU5ULCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX0VSUk9SLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX0lOU1RSVUNUSU9OX0RBVEEsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfUkVBTExPQywgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9TRUVEUywgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUFYX0FDQ09VTlRTX0RBVEFfQUxMT0NBVElPTlNfRVhDRUVERUQsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01BWF9BQ0NPVU5UU19FWENFRURFRCwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUFYX0lOU1RSVUNUSU9OX1RSQUNFX0xFTkdUSF9FWENFRURFRCwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUFYX1NFRURfTEVOR1RIX0VYQ0VFREVELCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NSVNTSU5HX0FDQ09VTlQsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01JU1NJTkdfUkVRVUlSRURfU0lHTkFUVVJFLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NT0RJRklFRF9QUk9HUkFNX0lELCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19OT1RfRU5PVUdIX0FDQ09VTlRfS0VZUywgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUFJJVklMRUdFX0VTQ0FMQVRJT04sIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1BST0dSQU1fRU5WSVJPTk1FTlRfU0VUVVBfRkFJTFVSRSwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUFJPR1JBTV9GQUlMRURfVE9fQ09NUElMRSwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUFJPR1JBTV9GQUlMRURfVE9fQ09NUExFVEUsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1JFQURPTkxZX0RBVEFfTU9ESUZJRUQsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1JFQURPTkxZX0xBTVBPUlRfQ0hBTkdFLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19SRUVOVFJBTkNZX05PVF9BTExPV0VELCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19SRU5UX0VQT0NIX01PRElGSUVELCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19VTkJBTEFOQ0VEX0lOU1RSVUNUSU9OLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19VTklOSVRJQUxJWkVEX0FDQ09VTlQsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1VOS05PV04sIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1VOU1VQUE9SVEVEX1BST0dSQU1fSUQsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1VOU1VQUE9SVEVEX1NZU1ZBUiwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9fRVhQRUNURURfVE9fSEFWRV9BQ0NPVU5UUywgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9fRVhQRUNURURfVE9fSEFWRV9EQVRBLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX19QUk9HUkFNX0lEX01JU01BVENILCBTT0xBTkFfRVJST1JfX0lOVkFMSURfQkxPQ0tIQVNIX0JZVEVfTEVOR1RILCBTT0xBTkFfRVJST1JfX0lOVkFMSURfTk9OQ0UsIFNPTEFOQV9FUlJPUl9fSU5WQVJJQU5UX1ZJT0xBVElPTl9fQ0FDSEVEX0FCT1JUQUJMRV9JVEVSQUJMRV9DQUNIRV9FTlRSWV9NSVNTSU5HLCBTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX0RBVEFfUFVCTElTSEVSX0NIQU5ORUxfVU5JTVBMRU1FTlRFRCwgU09MQU5BX0VSUk9SX19JTlZBUklBTlRfVklPTEFUSU9OX19TVUJTQ1JJUFRJT05fSVRFUkFUT1JfTVVTVF9OT1RfUE9MTF9CRUZPUkVfUkVTT0xWSU5HX0VYSVNUSU5HX01FU1NBR0VfUFJPTUlTRSwgU09MQU5BX0VSUk9SX19JTlZBUklBTlRfVklPTEFUSU9OX19TVUJTQ1JJUFRJT05fSVRFUkFUT1JfU1RBVEVfTUlTU0lORywgU09MQU5BX0VSUk9SX19JTlZBUklBTlRfVklPTEFUSU9OX19TV0lUQ0hfTVVTVF9CRV9FWEhBVVNUSVZFLCBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19JTlRFUk5BTF9FUlJPUiwgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fSU5WQUxJRF9QQVJBTVMsIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX0lOVkFMSURfUkVRVUVTVCwgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fTUVUSE9EX05PVF9GT1VORCwgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fUEFSU0VfRVJST1IsIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NDQU5fRVJST1IsIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9CTE9DS19DTEVBTkVEX1VQLCBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfQkxPQ0tfTk9UX0FWQUlMQUJMRSwgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0JMT0NLX1NUQVRVU19OT1RfQVZBSUxBQkxFX1lFVCwgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0tFWV9FWENMVURFRF9GUk9NX1NFQ09OREFSWV9JTkRFWCwgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0xPTkdfVEVSTV9TVE9SQUdFX1NMT1RfU0tJUFBFRCwgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX01JTl9DT05URVhUX1NMT1RfTk9UX1JFQUNIRUQsIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9OT0RFX1VOSEVBTFRIWSwgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX05PX1NOQVBTSE9ULCBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfU0VORF9UUkFOU0FDVElPTl9QUkVGTElHSFRfRkFJTFVSRSwgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1NMT1RfU0tJUFBFRCwgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX0hJU1RPUllfTk9UX0FWQUlMQUJMRSwgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX1BSRUNPTVBJTEVfVkVSSUZJQ0FUSU9OX0ZBSUxVUkUsIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9TSUdOQVRVUkVfTEVOX01JU01BVENILCBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fU0lHTkFUVVJFX1ZFUklGSUNBVElPTl9GQUlMVVJFLCBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfVU5TVVBQT1JURURfVFJBTlNBQ1RJT05fVkVSU0lPTiwgU09MQU5BX0VSUk9SX19LRVlTX19JTlZBTElEX0tFWV9QQUlSX0JZVEVfTEVOR1RILCBTT0xBTkFfRVJST1JfX0tFWVNfX0lOVkFMSURfUFJJVkFURV9LRVlfQllURV9MRU5HVEgsIFNPTEFOQV9FUlJPUl9fS0VZU19fSU5WQUxJRF9TSUdOQVRVUkVfQllURV9MRU5HVEgsIFNPTEFOQV9FUlJPUl9fS0VZU19fUFVCTElDX0tFWV9NVVNUX01BVENIX1BSSVZBVEVfS0VZLCBTT0xBTkFfRVJST1JfX0tFWVNfX1NJR05BVFVSRV9TVFJJTkdfTEVOR1RIX09VVF9PRl9SQU5HRSwgU09MQU5BX0VSUk9SX19MQU1QT1JUU19PVVRfT0ZfUkFOR0UsIFNPTEFOQV9FUlJPUl9fTUFMRk9STUVEX0JJR0lOVF9TVFJJTkcsIFNPTEFOQV9FUlJPUl9fTUFMRk9STUVEX0pTT05fUlBDX0VSUk9SLCBTT0xBTkFfRVJST1JfX01BTEZPUk1FRF9OVU1CRVJfU1RSSU5HLCBTT0xBTkFfRVJST1JfX05PTkNFX0FDQ09VTlRfTk9UX0ZPVU5ELCBTT0xBTkFfRVJST1JfX1JQQ19TVUJTQ1JJUFRJT05TX19DQU5OT1RfQ1JFQVRFX1NVQlNDUklQVElPTl9QTEFOLCBTT0xBTkFfRVJST1JfX1JQQ19TVUJTQ1JJUFRJT05TX19DSEFOTkVMX0NMT1NFRF9CRUZPUkVfTUVTU0FHRV9CVUZGRVJFRCwgU09MQU5BX0VSUk9SX19SUENfU1VCU0NSSVBUSU9OU19fQ0hBTk5FTF9DT05ORUNUSU9OX0NMT1NFRCwgU09MQU5BX0VSUk9SX19SUENfU1VCU0NSSVBUSU9OU19fQ0hBTk5FTF9GQUlMRURfVE9fQ09OTkVDVCwgU09MQU5BX0VSUk9SX19SUENfU1VCU0NSSVBUSU9OU19fRVhQRUNURURfU0VSVkVSX1NVQlNDUklQVElPTl9JRCwgU09MQU5BX0VSUk9SX19SUENfX0FQSV9QTEFOX01JU1NJTkdfRk9SX1JQQ19NRVRIT0QsIFNPTEFOQV9FUlJPUl9fUlBDX19JTlRFR0VSX09WRVJGTE9XLCBTT0xBTkFfRVJST1JfX1JQQ19fVFJBTlNQT1JUX0hUVFBfRVJST1IsIFNPTEFOQV9FUlJPUl9fUlBDX19UUkFOU1BPUlRfSFRUUF9IRUFERVJfRk9SQklEREVOLCBTT0xBTkFfRVJST1JfX1NJR05FUl9fQUREUkVTU19DQU5OT1RfSEFWRV9NVUxUSVBMRV9TSUdORVJTLCBTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfS0VZX1BBSVJfU0lHTkVSLCBTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfTUVTU0FHRV9NT0RJRllJTkdfU0lHTkVSLCBTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfTUVTU0FHRV9QQVJUSUFMX1NJR05FUiwgU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX01FU1NBR0VfU0lHTkVSLCBTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfVFJBTlNBQ1RJT05fTU9ESUZZSU5HX1NJR05FUiwgU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX1RSQU5TQUNUSU9OX1BBUlRJQUxfU0lHTkVSLCBTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfVFJBTlNBQ1RJT05fU0VORElOR19TSUdORVIsIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9UUkFOU0FDVElPTl9TSUdORVIsIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19UUkFOU0FDVElPTl9DQU5OT1RfSEFWRV9NVUxUSVBMRV9TRU5ESU5HX1NJR05FUlMsIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19UUkFOU0FDVElPTl9TRU5ESU5HX1NJR05FUl9NSVNTSU5HLCBTT0xBTkFfRVJST1JfX1NJR05FUl9fV0FMTEVUX01VTFRJU0lHTl9VTklNUExFTUVOVEVELCBTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0NBTk5PVF9FWFBPUlRfTk9OX0VYVFJBQ1RBQkxFX0tFWSwgU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19ESUdFU1RfVU5JTVBMRU1FTlRFRCwgU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19ESVNBTExPV0VEX0lOX0lOU0VDVVJFX0NPTlRFWFQsIFNPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fRUQyNTUxOV9BTEdPUklUSE1fVU5JTVBMRU1FTlRFRCwgU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19FWFBPUlRfRlVOQ1RJT05fVU5JTVBMRU1FTlRFRCwgU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19HRU5FUkFURV9GVU5DVElPTl9VTklNUExFTUVOVEVELCBTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX1NJR05fRlVOQ1RJT05fVU5JTVBMRU1FTlRFRCwgU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19WRVJJRllfRlVOQ1RJT05fVU5JTVBMRU1FTlRFRCwgU09MQU5BX0VSUk9SX19USU1FU1RBTVBfT1VUX09GX1JBTkdFLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19BQ0NPVU5UX0JPUlJPV19PVVRTVEFORElORywgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQUNDT1VOVF9JTl9VU0UsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0FDQ09VTlRfTE9BREVEX1RXSUNFLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19BQ0NPVU5UX05PVF9GT1VORCwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQUREUkVTU19MT09LVVBfVEFCTEVfTk9UX0ZPVU5ELCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19BTFJFQURZX1BST0NFU1NFRCwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQkxPQ0tIQVNIX05PVF9GT1VORCwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQ0FMTF9DSEFJTl9UT09fREVFUCwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQ0xVU1RFUl9NQUlOVEVOQU5DRSwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fRFVQTElDQVRFX0lOU1RSVUNUSU9OLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlNVRkZJQ0lFTlRfRlVORFNfRk9SX0ZFRSwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5TVUZGSUNJRU5UX0ZVTkRTX0ZPUl9SRU5ULCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX0FDQ09VTlRfRk9SX0ZFRSwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9BQ0NPVU5UX0lOREVYLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX0FERFJFU1NfTE9PS1VQX1RBQkxFX0RBVEEsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfQUREUkVTU19MT09LVVBfVEFCTEVfSU5ERVgsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfQUREUkVTU19MT09LVVBfVEFCTEVfT1dORVIsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfTE9BREVEX0FDQ09VTlRTX0RBVEFfU0laRV9MSU1JVCwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9QUk9HUkFNX0ZPUl9FWEVDVVRJT04sIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfUkVOVF9QQVlJTkdfQUNDT1VOVCwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9XUklUQUJMRV9BQ0NPVU5ULCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19NQVhfTE9BREVEX0FDQ09VTlRTX0RBVEFfU0laRV9FWENFRURFRCwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fTUlTU0lOR19TSUdOQVRVUkVfRk9SX0ZFRSwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fUFJPR1JBTV9BQ0NPVU5UX05PVF9GT1VORCwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fUFJPR1JBTV9FWEVDVVRJT05fVEVNUE9SQVJJTFlfUkVTVFJJQ1RFRCwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fUkVTQU5JVElaQVRJT05fTkVFREVELCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19TQU5JVElaRV9GQUlMVVJFLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19TSUdOQVRVUkVfRkFJTFVSRSwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fVE9PX01BTllfQUNDT1VOVF9MT0NLUywgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fVU5CQUxBTkNFRF9UUkFOU0FDVElPTiwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fVU5LTk9XTiwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fVU5TVVBQT1JURURfVkVSU0lPTiwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fV09VTERfRVhDRUVEX0FDQ09VTlRfREFUQV9CTE9DS19MSU1JVCwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fV09VTERfRVhDRUVEX0FDQ09VTlRfREFUQV9UT1RBTF9MSU1JVCwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fV09VTERfRVhDRUVEX01BWF9BQ0NPVU5UX0NPU1RfTElNSVQsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1dPVUxEX0VYQ0VFRF9NQVhfQkxPQ0tfQ09TVF9MSU1JVCwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fV09VTERfRVhDRUVEX01BWF9WT1RFX0NPU1RfTElNSVQsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0FERFJFU1NFU19DQU5OT1RfU0lHTl9UUkFOU0FDVElPTiwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fQUREUkVTU19NSVNTSU5HLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19DQU5OT1RfRU5DT0RFX1dJVEhfRU1QVFlfU0lHTkFUVVJFUywgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRVhDRUVEU19TSVpFX0xJTUlULCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19FWFBFQ1RFRF9CTE9DS0hBU0hfTElGRVRJTUUsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0VYUEVDVEVEX05PTkNFX0xJRkVUSU1FLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GQUlMRURfVE9fREVDT01QSUxFX0FERFJFU1NfTE9PS1VQX1RBQkxFX0NPTlRFTlRTX01JU1NJTkcsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9UT19ERUNPTVBJTEVfQUREUkVTU19MT09LVVBfVEFCTEVfSU5ERVhfT1VUX09GX1JBTkdFLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GQUlMRURfVE9fREVDT01QSUxFX0ZFRV9QQVlFUl9NSVNTSU5HLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GQUlMRURfVE9fREVDT01QSUxFX0lOU1RSVUNUSU9OX1BST0dSQU1fQUREUkVTU19OT1RfRk9VTkQsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9UT19FU1RJTUFURV9DT01QVVRFX0xJTUlULCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GQUlMRURfV0hFTl9TSU1VTEFUSU5HX1RPX0VTVElNQVRFX0NPTVBVVEVfTElNSVQsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZFRV9QQVlFUl9NSVNTSU5HLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GRUVfUEFZRVJfU0lHTkFUVVJFX01JU1NJTkcsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0lOVkFMSURfTk9OQ0VfVFJBTlNBQ1RJT05fRklSU1RfSU5TVFJVQ1RJT05fTVVTVF9CRV9BRFZBTkNFX05PTkNFLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19JTlZBTElEX05PTkNFX1RSQU5TQUNUSU9OX0lOU1RSVUNUSU9OU19NSVNTSU5HLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19JTlZPS0VEX1BST0dSQU1TX0NBTk5PVF9QQVlfRkVFUywgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fSU5WT0tFRF9QUk9HUkFNU19NVVNUX05PVF9CRV9XUklUQUJMRSwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fTUVTU0FHRV9TSUdOQVRVUkVTX01JU01BVENILCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19TSUdOQVRVUkVTX01JU1NJTkcsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX1ZFUlNJT05fTlVNQkVSX09VVF9PRl9SQU5HRSwgU29sYW5hRXJyb3IsIGdldFNvbGFuYUVycm9yRnJvbUluc3RydWN0aW9uRXJyb3IsIGdldFNvbGFuYUVycm9yRnJvbUpzb25ScGNFcnJvciwgZ2V0U29sYW5hRXJyb3JGcm9tVHJhbnNhY3Rpb25FcnJvciwgaXNTb2xhbmFFcnJvciwgc2FmZUNhcHR1cmVTdGFja1RyYWNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5ub2RlLm1qcy5tYXBcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm5vZGUubWpzLm1hcCJdLCJuYW1lcyI6WyJTT0xBTkFfRVJST1JfX0JMT0NLX0hFSUdIVF9FWENFRURFRCIsIlNPTEFOQV9FUlJPUl9fSU5WQUxJRF9OT05DRSIsIlNPTEFOQV9FUlJPUl9fTk9OQ0VfQUNDT1VOVF9OT1RfRk9VTkQiLCJTT0xBTkFfRVJST1JfX0JMT0NLSEFTSF9TVFJJTkdfTEVOR1RIX09VVF9PRl9SQU5HRSIsIlNPTEFOQV9FUlJPUl9fSU5WQUxJRF9CTE9DS0hBU0hfQllURV9MRU5HVEgiLCJTT0xBTkFfRVJST1JfX0xBTVBPUlRTX09VVF9PRl9SQU5HRSIsIlNPTEFOQV9FUlJPUl9fTUFMRk9STUVEX0JJR0lOVF9TVFJJTkciLCJTT0xBTkFfRVJST1JfX01BTEZPUk1FRF9OVU1CRVJfU1RSSU5HIiwiU09MQU5BX0VSUk9SX19USU1FU1RBTVBfT1VUX09GX1JBTkdFIiwiU09MQU5BX0VSUk9SX19NQUxGT1JNRURfSlNPTl9SUENfRVJST1IiLCJTT0xBTkFfRVJST1JfX0pTT05fUlBDX19QQVJTRV9FUlJPUiIsIlNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX0lOVEVSTkFMX0VSUk9SIiwiU09MQU5BX0VSUk9SX19KU09OX1JQQ19fSU5WQUxJRF9QQVJBTVMiLCJTT0xBTkFfRVJST1JfX0pTT05fUlBDX19NRVRIT0RfTk9UX0ZPVU5EIiwiU09MQU5BX0VSUk9SX19KU09OX1JQQ19fSU5WQUxJRF9SRVFVRVNUIiwiU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX01JTl9DT05URVhUX1NMT1RfTk9UX1JFQUNIRUQiLCJTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfVU5TVVBQT1JURURfVFJBTlNBQ1RJT05fVkVSU0lPTiIsIlNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9CTE9DS19TVEFUVVNfTk9UX0FWQUlMQUJMRV9ZRVQiLCJTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fU0lHTkFUVVJFX0xFTl9NSVNNQVRDSCIsIlNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NDQU5fRVJST1IiLCJTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fSElTVE9SWV9OT1RfQVZBSUxBQkxFIiwiU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0tFWV9FWENMVURFRF9GUk9NX1NFQ09OREFSWV9JTkRFWCIsIlNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9MT05HX1RFUk1fU1RPUkFHRV9TTE9UX1NLSVBQRUQiLCJTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfTk9fU05BUFNIT1QiLCJTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfU0xPVF9TS0lQUEVEIiwiU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX1BSRUNPTVBJTEVfVkVSSUZJQ0FUSU9OX0ZBSUxVUkUiLCJTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfTk9ERV9VTkhFQUxUSFkiLCJTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfQkxPQ0tfTk9UX0FWQUlMQUJMRSIsIlNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9TSUdOQVRVUkVfVkVSSUZJQ0FUSU9OX0ZBSUxVUkUiLCJTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfU0VORF9UUkFOU0FDVElPTl9QUkVGTElHSFRfRkFJTFVSRSIsIlNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9CTE9DS19DTEVBTkVEX1VQIiwiU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX0lOVkFMSURfQllURV9MRU5HVEgiLCJTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fU1RSSU5HX0xFTkdUSF9PVVRfT0ZfUkFOR0UiLCJTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9CQVNFNThfRU5DT0RFRF9BRERSRVNTIiwiU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX0lOVkFMSURfRUQyNTUxOV9QVUJMSUNfS0VZIiwiU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX01BTEZPUk1FRF9QREEiLCJTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fUERBX0JVTVBfU0VFRF9PVVRfT0ZfUkFOR0UiLCJTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fTUFYX05VTUJFUl9PRl9QREFfU0VFRFNfRVhDRUVERUQiLCJTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fTUFYX1BEQV9TRUVEX0xFTkdUSF9FWENFRURFRCIsIlNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19JTlZBTElEX1NFRURTX1BPSU5UX09OX0NVUlZFIiwiU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX0ZBSUxFRF9UT19GSU5EX1ZJQUJMRV9QREFfQlVNUF9TRUVEIiwiU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX1BEQV9FTkRTX1dJVEhfUERBX01BUktFUiIsIlNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19JTlZBTElEX09GRl9DVVJWRV9BRERSRVNTIiwiU09MQU5BX0VSUk9SX19BQ0NPVU5UU19fQUNDT1VOVF9OT1RfRk9VTkQiLCJTT0xBTkFfRVJST1JfX0FDQ09VTlRTX19PTkVfT1JfTU9SRV9BQ0NPVU5UU19OT1RfRk9VTkQiLCJTT0xBTkFfRVJST1JfX0FDQ09VTlRTX19GQUlMRURfVE9fREVDT0RFX0FDQ09VTlQiLCJTT0xBTkFfRVJST1JfX0FDQ09VTlRTX19FWFBFQ1RFRF9ERUNPREVEX0FDQ09VTlQiLCJTT0xBTkFfRVJST1JfX0FDQ09VTlRTX19FWFBFQ1RFRF9BTExfQUNDT1VOVFNfVE9fQkVfREVDT0RFRCIsIlNPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fRElTQUxMT1dFRF9JTl9JTlNFQ1VSRV9DT05URVhUIiwiU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19ESUdFU1RfVU5JTVBMRU1FTlRFRCIsIlNPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fRUQyNTUxOV9BTEdPUklUSE1fVU5JTVBMRU1FTlRFRCIsIlNPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fRVhQT1JUX0ZVTkNUSU9OX1VOSU1QTEVNRU5URUQiLCJTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0dFTkVSQVRFX0ZVTkNUSU9OX1VOSU1QTEVNRU5URUQiLCJTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX1NJR05fRlVOQ1RJT05fVU5JTVBMRU1FTlRFRCIsIlNPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fVkVSSUZZX0ZVTkNUSU9OX1VOSU1QTEVNRU5URUQiLCJTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0NBTk5PVF9FWFBPUlRfTk9OX0VYVFJBQ1RBQkxFX0tFWSIsIlNPTEFOQV9FUlJPUl9fQ1JZUFRPX19SQU5ET01fVkFMVUVTX0ZVTkNUSU9OX1VOSU1QTEVNRU5URUQiLCJTT0xBTkFfRVJST1JfX0tFWVNfX0lOVkFMSURfS0VZX1BBSVJfQllURV9MRU5HVEgiLCJTT0xBTkFfRVJST1JfX0tFWVNfX0lOVkFMSURfUFJJVkFURV9LRVlfQllURV9MRU5HVEgiLCJTT0xBTkFfRVJST1JfX0tFWVNfX0lOVkFMSURfU0lHTkFUVVJFX0JZVEVfTEVOR1RIIiwiU09MQU5BX0VSUk9SX19LRVlTX19TSUdOQVRVUkVfU1RSSU5HX0xFTkdUSF9PVVRfT0ZfUkFOR0UiLCJTT0xBTkFfRVJST1JfX0tFWVNfX1BVQkxJQ19LRVlfTVVTVF9NQVRDSF9QUklWQVRFX0tFWSIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fX0VYUEVDVEVEX1RPX0hBVkVfQUNDT1VOVFMiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX19FWFBFQ1RFRF9UT19IQVZFX0RBVEEiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX19QUk9HUkFNX0lEX01JU01BVENIIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fVU5LTk9XTiIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0dFTkVSSUNfRVJST1IiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX0FSR1VNRU5UIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9JTlNUUlVDVElPTl9EQVRBIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9BQ0NPVU5UX0RBVEEiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX0RBVEFfVE9PX1NNQUxMIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5TVUZGSUNJRU5UX0ZVTkRTIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5DT1JSRUNUX1BST0dSQU1fSUQiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NSVNTSU5HX1JFUVVJUkVEX1NJR05BVFVSRSIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfQUxSRUFEWV9JTklUSUFMSVpFRCIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1VOSU5JVElBTElaRURfQUNDT1VOVCIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1VOQkFMQU5DRURfSU5TVFJVQ1RJT04iLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NT0RJRklFRF9QUk9HUkFNX0lEIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRVhURVJOQUxfQUNDT1VOVF9MQU1QT1JUX1NQRU5EIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRVhURVJOQUxfQUNDT1VOVF9EQVRBX01PRElGSUVEIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUkVBRE9OTFlfTEFNUE9SVF9DSEFOR0UiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19SRUFET05MWV9EQVRBX01PRElGSUVEIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRFVQTElDQVRFX0FDQ09VTlRfSU5ERVgiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19FWEVDVVRBQkxFX01PRElGSUVEIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUkVOVF9FUE9DSF9NT0RJRklFRCIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX05PVF9FTk9VR0hfQUNDT1VOVF9LRVlTIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9EQVRBX1NJWkVfQ0hBTkdFRCIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfTk9UX0VYRUNVVEFCTEUiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX0JPUlJPV19GQUlMRUQiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX0JPUlJPV19PVVRTVEFORElORyIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0RVUExJQ0FURV9BQ0NPVU5UX09VVF9PRl9TWU5DIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQ1VTVE9NIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9FUlJPUiIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0VYRUNVVEFCTEVfREFUQV9NT0RJRklFRCIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0VYRUNVVEFCTEVfTEFNUE9SVF9DSEFOR0UiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19FWEVDVVRBQkxFX0FDQ09VTlRfTk9UX1JFTlRfRVhFTVBUIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fVU5TVVBQT1JURURfUFJPR1JBTV9JRCIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0NBTExfREVQVEgiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NSVNTSU5HX0FDQ09VTlQiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19SRUVOVFJBTkNZX05PVF9BTExPV0VEIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUFYX1NFRURfTEVOR1RIX0VYQ0VFREVEIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9TRUVEUyIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfUkVBTExPQyIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0NPTVBVVEFUSU9OQUxfQlVER0VUX0VYQ0VFREVEIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUFJJVklMRUdFX0VTQ0FMQVRJT04iLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19QUk9HUkFNX0VOVklST05NRU5UX1NFVFVQX0ZBSUxVUkUiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19QUk9HUkFNX0ZBSUxFRF9UT19DT01QTEVURSIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1BST0dSQU1fRkFJTEVEX1RPX0NPTVBJTEUiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTU1VVEFCTEUiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTkNPUlJFQ1RfQVVUSE9SSVRZIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQk9SU0hfSU9fRVJST1IiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX05PVF9SRU5UX0VYRU1QVCIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfQUNDT1VOVF9PV05FUiIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FSSVRITUVUSUNfT1ZFUkZMT1ciLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19VTlNVUFBPUlRFRF9TWVNWQVIiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTExFR0FMX09XTkVSIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUFYX0FDQ09VTlRTX0RBVEFfQUxMT0NBVElPTlNfRVhDRUVERUQiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NQVhfQUNDT1VOVFNfRVhDRUVERUQiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NQVhfSU5TVFJVQ1RJT05fVFJBQ0VfTEVOR1RIX0VYQ0VFREVEIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQlVJTFRJTl9QUk9HUkFNU19NVVNUX0NPTlNVTUVfQ09NUFVURV9VTklUUyIsIlNPTEFOQV9FUlJPUl9fU0lHTkVSX19BRERSRVNTX0NBTk5PVF9IQVZFX01VTFRJUExFX1NJR05FUlMiLCJTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfS0VZX1BBSVJfU0lHTkVSIiwiU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX01FU1NBR0VfU0lHTkVSIiwiU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX01FU1NBR0VfTU9ESUZZSU5HX1NJR05FUiIsIlNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9NRVNTQUdFX1BBUlRJQUxfU0lHTkVSIiwiU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX1RSQU5TQUNUSU9OX1NJR05FUiIsIlNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9UUkFOU0FDVElPTl9NT0RJRllJTkdfU0lHTkVSIiwiU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX1RSQU5TQUNUSU9OX1BBUlRJQUxfU0lHTkVSIiwiU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX1RSQU5TQUNUSU9OX1NFTkRJTkdfU0lHTkVSIiwiU09MQU5BX0VSUk9SX19TSUdORVJfX1RSQU5TQUNUSU9OX0NBTk5PVF9IQVZFX01VTFRJUExFX1NFTkRJTkdfU0lHTkVSUyIsIlNPTEFOQV9FUlJPUl9fU0lHTkVSX19UUkFOU0FDVElPTl9TRU5ESU5HX1NJR05FUl9NSVNTSU5HIiwiU09MQU5BX0VSUk9SX19TSUdORVJfX1dBTExFVF9NVUxUSVNJR05fVU5JTVBMRU1FTlRFRCIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0lOVk9LRURfUFJPR1JBTVNfQ0FOTk9UX1BBWV9GRUVTIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fSU5WT0tFRF9QUk9HUkFNU19NVVNUX05PVF9CRV9XUklUQUJMRSIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0VYUEVDVEVEX0JMT0NLSEFTSF9MSUZFVElNRSIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0VYUEVDVEVEX05PTkNFX0xJRkVUSU1FIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fVkVSU0lPTl9OVU1CRVJfT1VUX09GX1JBTkdFIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkFJTEVEX1RPX0RFQ09NUElMRV9BRERSRVNTX0xPT0tVUF9UQUJMRV9DT05URU5UU19NSVNTSU5HIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkFJTEVEX1RPX0RFQ09NUElMRV9BRERSRVNTX0xPT0tVUF9UQUJMRV9JTkRFWF9PVVRfT0ZfUkFOR0UiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GQUlMRURfVE9fREVDT01QSUxFX0lOU1RSVUNUSU9OX1BST0dSQU1fQUREUkVTU19OT1RfRk9VTkQiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GQUlMRURfVE9fREVDT01QSUxFX0ZFRV9QQVlFUl9NSVNTSU5HIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fU0lHTkFUVVJFU19NSVNTSU5HIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fQUREUkVTU19NSVNTSU5HIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkVFX1BBWUVSX01JU1NJTkciLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GRUVfUEFZRVJfU0lHTkFUVVJFX01JU1NJTkciLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19JTlZBTElEX05PTkNFX1RSQU5TQUNUSU9OX0lOU1RSVUNUSU9OU19NSVNTSU5HIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fSU5WQUxJRF9OT05DRV9UUkFOU0FDVElPTl9GSVJTVF9JTlNUUlVDVElPTl9NVVNUX0JFX0FEVkFOQ0VfTk9OQ0UiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19BRERSRVNTRVNfQ0FOTk9UX1NJR05fVFJBTlNBQ1RJT04iLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19DQU5OT1RfRU5DT0RFX1dJVEhfRU1QVFlfU0lHTkFUVVJFUyIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX01FU1NBR0VfU0lHTkFUVVJFU19NSVNNQVRDSCIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9UT19FU1RJTUFURV9DT01QVVRFX0xJTUlUIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkFJTEVEX1dIRU5fU0lNVUxBVElOR19UT19FU1RJTUFURV9DT01QVVRFX0xJTUlUIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRVhDRUVEU19TSVpFX0xJTUlUIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fVU5LTk9XTiIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0FDQ09VTlRfSU5fVVNFIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQUNDT1VOVF9MT0FERURfVFdJQ0UiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19BQ0NPVU5UX05PVF9GT1VORCIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1BST0dSQU1fQUNDT1VOVF9OT1RfRk9VTkQiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlNVRkZJQ0lFTlRfRlVORFNfRk9SX0ZFRSIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfQUNDT1VOVF9GT1JfRkVFIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQUxSRUFEWV9QUk9DRVNTRUQiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19CTE9DS0hBU0hfTk9UX0ZPVU5EIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQ0FMTF9DSEFJTl9UT09fREVFUCIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX01JU1NJTkdfU0lHTkFUVVJFX0ZPUl9GRUUiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX0FDQ09VTlRfSU5ERVgiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19TSUdOQVRVUkVfRkFJTFVSRSIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfUFJPR1JBTV9GT1JfRVhFQ1VUSU9OIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fU0FOSVRJWkVfRkFJTFVSRSIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0NMVVNURVJfTUFJTlRFTkFOQ0UiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19BQ0NPVU5UX0JPUlJPV19PVVRTVEFORElORyIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1dPVUxEX0VYQ0VFRF9NQVhfQkxPQ0tfQ09TVF9MSU1JVCIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1VOU1VQUE9SVEVEX1ZFUlNJT04iLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX1dSSVRBQkxFX0FDQ09VTlQiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19XT1VMRF9FWENFRURfTUFYX0FDQ09VTlRfQ09TVF9MSU1JVCIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1dPVUxEX0VYQ0VFRF9BQ0NPVU5UX0RBVEFfQkxPQ0tfTElNSVQiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19UT09fTUFOWV9BQ0NPVU5UX0xPQ0tTIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQUREUkVTU19MT09LVVBfVEFCTEVfTk9UX0ZPVU5EIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9BRERSRVNTX0xPT0tVUF9UQUJMRV9PV05FUiIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfQUREUkVTU19MT09LVVBfVEFCTEVfREFUQSIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfQUREUkVTU19MT09LVVBfVEFCTEVfSU5ERVgiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX1JFTlRfUEFZSU5HX0FDQ09VTlQiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19XT1VMRF9FWENFRURfTUFYX1ZPVEVfQ09TVF9MSU1JVCIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1dPVUxEX0VYQ0VFRF9BQ0NPVU5UX0RBVEFfVE9UQUxfTElNSVQiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19EVVBMSUNBVEVfSU5TVFJVQ1RJT04iLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlNVRkZJQ0lFTlRfRlVORFNfRk9SX1JFTlQiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19NQVhfTE9BREVEX0FDQ09VTlRTX0RBVEFfU0laRV9FWENFRURFRCIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfTE9BREVEX0FDQ09VTlRTX0RBVEFfU0laRV9MSU1JVCIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1JFU0FOSVRJWkFUSU9OX05FRURFRCIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1BST0dSQU1fRVhFQ1VUSU9OX1RFTVBPUkFSSUxZX1JFU1RSSUNURUQiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19VTkJBTEFOQ0VEX1RSQU5TQUNUSU9OIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0NBTk5PVF9ERUNPREVfRU1QVFlfQllURV9BUlJBWSIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0JZVEVfTEVOR1RIIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX0ZJWEVEX0xFTkdUSCIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9WQVJJQUJMRV9MRU5HVEgiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX1NJWkVfQ09NUEFUSUJJTElUWV9NSVNNQVRDSCIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfRklYRURfU0laRV9NSVNNQVRDSCIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfTUFYX1NJWkVfTUlTTUFUQ0giLCJTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9OVU1CRVJfT0ZfSVRFTVMiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fRU5VTV9ESVNDUklNSU5BVE9SX09VVF9PRl9SQU5HRSIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0RJU0NSSU1JTkFURURfVU5JT05fVkFSSUFOVCIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0VOVU1fVkFSSUFOVCIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19OVU1CRVJfT1VUX09GX1JBTkdFIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfU1RSSU5HX0ZPUl9CQVNFIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1BPU0lUSVZFX0JZVEVfTEVOR1RIIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX09GRlNFVF9PVVRfT0ZfUkFOR0UiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9MSVRFUkFMX1VOSU9OX1ZBUklBTlQiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fTElURVJBTF9VTklPTl9ESVNDUklNSU5BVE9SX09VVF9PRl9SQU5HRSIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19VTklPTl9WQVJJQU5UX09VVF9PRl9SQU5HRSIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0NPTlNUQU5UIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1pFUk9fVkFMVUVfVE9fTUFUQ0hfSVRFTV9GSVhFRF9TSVpFIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERURfQllURVNfTVVTVF9OT1RfSU5DTFVERV9TRU5USU5FTCIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19TRU5USU5FTF9NSVNTSU5HX0lOX0RFQ09ERURfQllURVMiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fQ0FOTk9UX1VTRV9MRVhJQ0FMX1ZBTFVFU19BU19FTlVNX0RJU0NSSU1JTkFUT1JTIiwiU09MQU5BX0VSUk9SX19SUENfX0lOVEVHRVJfT1ZFUkZMT1ciLCJTT0xBTkFfRVJST1JfX1JQQ19fVFJBTlNQT1JUX0hUVFBfSEVBREVSX0ZPUkJJRERFTiIsIlNPTEFOQV9FUlJPUl9fUlBDX19UUkFOU1BPUlRfSFRUUF9FUlJPUiIsIlNPTEFOQV9FUlJPUl9fUlBDX19BUElfUExBTl9NSVNTSU5HX0ZPUl9SUENfTUVUSE9EIiwiU09MQU5BX0VSUk9SX19SUENfU1VCU0NSSVBUSU9OU19fQ0FOTk9UX0NSRUFURV9TVUJTQ1JJUFRJT05fUExBTiIsIlNPTEFOQV9FUlJPUl9fUlBDX1NVQlNDUklQVElPTlNfX0VYUEVDVEVEX1NFUlZFUl9TVUJTQ1JJUFRJT05fSUQiLCJTT0xBTkFfRVJST1JfX1JQQ19TVUJTQ1JJUFRJT05TX19DSEFOTkVMX0NMT1NFRF9CRUZPUkVfTUVTU0FHRV9CVUZGRVJFRCIsIlNPTEFOQV9FUlJPUl9fUlBDX1NVQlNDUklQVElPTlNfX0NIQU5ORUxfQ09OTkVDVElPTl9DTE9TRUQiLCJTT0xBTkFfRVJST1JfX1JQQ19TVUJTQ1JJUFRJT05TX19DSEFOTkVMX0ZBSUxFRF9UT19DT05ORUNUIiwiU09MQU5BX0VSUk9SX19JTlZBUklBTlRfVklPTEFUSU9OX19TVUJTQ1JJUFRJT05fSVRFUkFUT1JfU1RBVEVfTUlTU0lORyIsIlNPTEFOQV9FUlJPUl9fSU5WQVJJQU5UX1ZJT0xBVElPTl9fU1VCU0NSSVBUSU9OX0lURVJBVE9SX01VU1RfTk9UX1BPTExfQkVGT1JFX1JFU09MVklOR19FWElTVElOR19NRVNTQUdFX1BST01JU0UiLCJTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX0NBQ0hFRF9BQk9SVEFCTEVfSVRFUkFCTEVfQ0FDSEVfRU5UUllfTUlTU0lORyIsIlNPTEFOQV9FUlJPUl9fSU5WQVJJQU5UX1ZJT0xBVElPTl9fU1dJVENIX01VU1RfQkVfRVhIQVVTVElWRSIsIlNPTEFOQV9FUlJPUl9fSU5WQVJJQU5UX1ZJT0xBVElPTl9fREFUQV9QVUJMSVNIRVJfQ0hBTk5FTF9VTklNUExFTUVOVEVEIiwiZW5jb2RlVmFsdWUiLCJ2YWx1ZSIsIkFycmF5IiwiaXNBcnJheSIsImNvbW1hU2VwYXJhdGVkVmFsdWVzIiwibWFwIiwiam9pbiIsImVuY29kZVVSSUNvbXBvbmVudCIsIlN0cmluZyIsIk9iamVjdCIsImdldFByb3RvdHlwZU9mIiwiZW5jb2RlT2JqZWN0Q29udGV4dEVudHJ5Iiwia2V5IiwiZW5jb2RlQ29udGV4dE9iamVjdCIsImNvbnRleHQiLCJzZWFyY2hQYXJhbXNTdHJpbmciLCJlbnRyaWVzIiwiQnVmZmVyIiwiZnJvbSIsInRvU3RyaW5nIiwiU29sYW5hRXJyb3JNZXNzYWdlcyIsIlNUQVJUX0lOREVYIiwiVFlQRSIsImdldEh1bWFuUmVhZGFibGVFcnJvck1lc3NhZ2UiLCJjb2RlIiwibWVzc2FnZUZvcm1hdFN0cmluZyIsImxlbmd0aCIsInN0YXRlIiwiY29tbWl0U3RhdGVVcFRvIiwiZW5kSW5kZXgiLCJ2YXJpYWJsZU5hbWUiLCJzbGljZSIsImZyYWdtZW50cyIsInB1c2giLCJzcGxpdCIsImZvckVhY2giLCJjaGFyIiwiaWkiLCJuZXh0U3RhdGUiLCJtYXRjaCIsImdldEVycm9yTWVzc2FnZSIsInByb2Nlc3MiLCJkZWNvZGluZ0FkdmljZU1lc3NhZ2UiLCJrZXlzIiwiaXNTb2xhbmFFcnJvciIsImUiLCJpc1NvbGFuYUVycm9yMiIsIkVycm9yIiwibmFtZSIsIl9fY29kZSIsIlNvbGFuYUVycm9yIiwiY29uc3RydWN0b3IiLCJjb250ZXh0QW5kRXJyb3JPcHRpb25zIiwiZXJyb3JPcHRpb25zIiwiY2F1c2UiLCJjb250ZXh0UmVzdCIsIm1lc3NhZ2UiLCJzYWZlQ2FwdHVyZVN0YWNrVHJhY2UiLCJhcmdzIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJnZXRTb2xhbmFFcnJvckZyb21ScGNFcnJvciIsImVycm9yQ29kZUJhc2VPZmZzZXQiLCJnZXRFcnJvckNvbnRleHQiLCJvcmRlcmVkRXJyb3JOYW1lcyIsInJwY0VudW1FcnJvciIsImNvbnN0cnVjdG9yT3B0IiwicnBjRXJyb3JOYW1lIiwicnBjRXJyb3JDb250ZXh0IiwiY29kZU9mZnNldCIsImluZGV4T2YiLCJlcnJvckNvZGUiLCJlcnJvckNvbnRleHQiLCJlcnIiLCJPUkRFUkVEX0VSUk9SX05BTUVTIiwiZ2V0U29sYW5hRXJyb3JGcm9tSW5zdHJ1Y3Rpb25FcnJvciIsImluZGV4IiwiaW5zdHJ1Y3Rpb25FcnJvciIsIm51bWJlckluZGV4IiwiTnVtYmVyIiwiZXJyb3JOYW1lIiwiaW5zdHJ1Y3Rpb25FcnJvckNvbnRleHQiLCJlbmNvZGVkRGF0YSIsIk9SREVSRURfRVJST1JfTkFNRVMyIiwiZ2V0U29sYW5hRXJyb3JGcm9tVHJhbnNhY3Rpb25FcnJvciIsInRyYW5zYWN0aW9uRXJyb3IiLCJJbnN0cnVjdGlvbkVycm9yIiwidHJhbnNhY3Rpb25FcnJvckNvbnRleHQiLCJhY2NvdW50SW5kZXgiLCJhY2NvdW50X2luZGV4IiwiZ2V0U29sYW5hRXJyb3JGcm9tSnNvblJwY0Vycm9yIiwicHV0YXRpdmVFcnJvclJlc3BvbnNlIiwib3V0IiwiaXNScGNFcnJvclJlc3BvbnNlIiwicmF3Q29kZSIsImRhdGEiLCJwcmVmbGlnaHRFcnJvckNvbnRleHQiLCJjYXVzZU9iamVjdCIsIl9fc2VydmVyTWVzc2FnZSIsImVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@solana/errors/dist/index.node.mjs\n");

/***/ })

};
;